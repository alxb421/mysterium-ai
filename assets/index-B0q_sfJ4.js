var UH = Object.defineProperty;
var PH = (n, e, t) => e in n ? UH(n, e, {
   enumerable: !0,
   configurable: !0,
   writable: !0,
   value: t
}) : n[e] = t;
var Ut = (n, e, t) => PH(n, typeof e != "symbol" ? e + "" : e, t);
(function () {
   const e = document.createElement("link").relList;
   if (e && e.supports && e.supports("modulepreload")) return;
   for (const s of document.querySelectorAll('link[rel="modulepreload"]')) i(s);
   new MutationObserver(s => {
      for (const r of s)
         if (r.type === "childList")
            for (const a of r.addedNodes) a.tagName === "LINK" && a.rel === "modulepreload" && i(a)
   }).observe(document, {
      childList: !0,
      subtree: !0
   });

   function t(s) {
      const r = {};
      return s.integrity && (r.integrity = s.integrity), s.referrerPolicy && (r.referrerPolicy = s.referrerPolicy), s.crossOrigin === "use-credentials" ? r.credentials = "include" : s.crossOrigin === "anonymous" ? r.credentials = "omit" : r.credentials = "same-origin", r
   }

   function i(s) {
      if (s.ep) return;
      s.ep = !0;
      const r = t(s);
      fetch(s.href, r)
   }
})();

function lx(n) {
   return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n
}
var FE = {
      exports: {}
   },
   i0 = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aD;

function LH() {
   if (aD) return i0;
   aD = 1;
   var n = Symbol.for("react.transitional.element"),
      e = Symbol.for("react.fragment");

   function t(i, s, r) {
      var a = null;
      if (r !== void 0 && (a = "" + r), s.key !== void 0 && (a = "" + s.key), "key" in s) {
         r = {};
         for (var l in s) l !== "key" && (r[l] = s[l])
      } else r = s;
      return s = r.ref, {
         $$typeof: n,
         type: i,
         key: a,
         ref: s !== void 0 ? s : null,
         props: r
      }
   }
   return i0.Fragment = e, i0.jsx = t, i0.jsxs = t, i0
}
var oD;

function BH() {
   return oD || (oD = 1, FE.exports = LH()), FE.exports
}
var H = BH(),
   HE = {
      exports: {}
   },
   vn = {};
/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var lD;

function zH() {
   if (lD) return vn;
   lD = 1;
   var n = Symbol.for("react.transitional.element"),
      e = Symbol.for("react.portal"),
      t = Symbol.for("react.fragment"),
      i = Symbol.for("react.strict_mode"),
      s = Symbol.for("react.profiler"),
      r = Symbol.for("react.consumer"),
      a = Symbol.for("react.context"),
      l = Symbol.for("react.forward_ref"),
      c = Symbol.for("react.suspense"),
      h = Symbol.for("react.memo"),
      m = Symbol.for("react.lazy"),
      g = Symbol.iterator;

   function v(F) {
      return F === null || typeof F != "object" ? null : (F = g && F[g] || F["@@iterator"], typeof F == "function" ? F : null)
   }
   var x = {
         isMounted: function () {
            return !1
         },
         enqueueForceUpdate: function () {},
         enqueueReplaceState: function () {},
         enqueueSetState: function () {}
      },
      S = Object.assign,
      E = {};

   function T(F, ie, ye) {
      this.props = F, this.context = ie, this.refs = E, this.updater = ye || x
   }
   T.prototype.isReactComponent = {}, T.prototype.setState = function (F, ie) {
      if (typeof F != "object" && typeof F != "function" && F != null) throw Error("takes an object of state variables to update or a function which returns an object of state variables.");
      this.updater.enqueueSetState(this, F, ie, "setState")
   }, T.prototype.forceUpdate = function (F) {
      this.updater.enqueueForceUpdate(this, F, "forceUpdate")
   };

   function b() {}
   b.prototype = T.prototype;

   function w(F, ie, ye) {
      this.props = F, this.context = ie, this.refs = E, this.updater = ye || x
   }
   var C = w.prototype = new b;
   C.constructor = w, S(C, T.prototype), C.isPureReactComponent = !0;
   var N = Array.isArray,
      U = {
         H: null,
         A: null,
         T: null,
         S: null,
         V: null
      },
      z = Object.prototype.hasOwnProperty;

   function B(F, ie, ye, we, oe, be) {
      return ye = be.ref, {
         $$typeof: n,
         type: F,
         key: ie,
         ref: ye !== void 0 ? ye : null,
         props: be
      }
   }

   function I(F, ie) {
      return B(F.type, ie, void 0, void 0, void 0, F.props)
   }

   function O(F) {
      return typeof F == "object" && F !== null && F.$$typeof === n
   }

   function P(F) {
      var ie = {
         "=": "=0",
         ":": "=2"
      };
      return "$" + F.replace(/[=:]/g, function (ye) {
         return ie[ye]
      })
   }
   var q = /\/+/g;

   function Q(F, ie) {
      return typeof F == "object" && F !== null && F.key != null ? P("" + F.key) : ie.toString(36)
   }

   function $() {}

   function ae(F) {
      switch (F.status) {
         case "fulfilled":
            return F.value;
         case "rejected":
            throw F.reason;
         default:
            switch (typeof F.status == "string" ? F.then($, $) : (F.status = "pending", F.then(function (ie) {
                  F.status === "pending" && (F.status = "fulfilled", F.value = ie)
               }, function (ie) {
                  F.status === "pending" && (F.status = "rejected", F.reason = ie)
               })), F.status) {
               case "fulfilled":
                  return F.value;
               case "rejected":
                  throw F.reason
            }
      }
      throw F
   }

   function fe(F, ie, ye, we, oe) {
      var be = typeof F;
      (be === "undefined" || be === "boolean") && (F = null);
      var Pe = !1;
      if (F === null) Pe = !0;
      else switch (be) {
         case "bigint":
         case "string":
         case "number":
            Pe = !0;
            break;
         case "object":
            switch (F.$$typeof) {
               case n:
               case e:
                  Pe = !0;
                  break;
               case m:
                  return Pe = F._init, fe(Pe(F._payload), ie, ye, we, oe)
            }
      }
      if (Pe) return oe = oe(F), Pe = we === "" ? "." + Q(F, 0) : we, N(oe) ? (ye = "", Pe != null && (ye = Pe.replace(q, "$&/") + "/"), fe(oe, ie, ye, "", function (yt) {
         return yt
      })) : oe != null && (O(oe) && (oe = I(oe, ye + (oe.key == null || F && F.key === oe.key ? "" : ("" + oe.key).replace(q, "$&/") + "/") + Pe)), ie.push(oe)), 1;
      Pe = 0;
      var Ge = we === "" ? "." : we + ":";
      if (N(F))
         for (var Xe = 0; Xe < F.length; Xe++) we = F[Xe], be = Ge + Q(we, Xe), Pe += fe(we, ie, ye, be, oe);
      else if (Xe = v(F), typeof Xe == "function")
         for (F = Xe.call(F), Xe = 0; !(we = F.next()).done;) we = we.value, be = Ge + Q(we, Xe++), Pe += fe(we, ie, ye, be, oe);
      else if (be === "object") {
         if (typeof F.then == "function") return fe(ae(F), ie, ye, we, oe);
         throw ie = String(F), Error("Objects are not valid as a React child (found: " + (ie === "[object Object]" ? "object with keys {" + Object.keys(F).join(", ") + "}" : ie) + "). If you meant to render a collection of children, use an array instead.")
      }
      return Pe
   }

   function k(F, ie, ye) {
      if (F == null) return F;
      var we = [],
         oe = 0;
      return fe(F, we, "", "", function (be) {
         return ie.call(ye, be, oe++)
      }), we
   }

   function Z(F) {
      if (F._status === -1) {
         var ie = F._result;
         ie = ie(), ie.then(function (ye) {
            (F._status === 0 || F._status === -1) && (F._status = 1, F._result = ye)
         }, function (ye) {
            (F._status === 0 || F._status === -1) && (F._status = 2, F._result = ye)
         }), F._status === -1 && (F._status = 0, F._result = ie)
      }
      if (F._status === 1) return F._result.default;
      throw F._result
   }
   var J = typeof reportError == "function" ? reportError : function (F) {
      if (typeof window == "object" && typeof window.ErrorEvent == "function") {
         var ie = new window.ErrorEvent("error", {
            bubbles: !0,
            cancelable: !0,
            message: typeof F == "object" && F !== null && typeof F.message == "string" ? String(F.message) : String(F),
            error: F
         });
         if (!window.dispatchEvent(ie)) return
      } else if (typeof process == "object" && typeof process.emit == "function") {
         process.emit("uncaughtException", F);
         return
      }
      console.error(F)
   };

   function pe() {}
   return vn.Children = {
      map: k,
      forEach: function (F, ie, ye) {
         k(F, function () {
            ie.apply(this, arguments)
         }, ye)
      },
      count: function (F) {
         var ie = 0;
         return k(F, function () {
            ie++
         }), ie
      },
      toArray: function (F) {
         return k(F, function (ie) {
            return ie
         }) || []
      },
      only: function (F) {
         if (!O(F)) throw Error("React.Children.only expected to receive a single React element child.");
         return F
      }
   }, vn.Component = T, vn.Fragment = t, vn.Profiler = s, vn.PureComponent = w, vn.StrictMode = i, vn.Suspense = c, vn.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = U, vn.__COMPILER_RUNTIME = {
      __proto__: null,
      c: function (F) {
         return U.H.useMemoCache(F)
      }
   }, vn.cache = function (F) {
      return function () {
         return F.apply(null, arguments)
      }
   }, vn.cloneElement = function (F, ie, ye) {
      if (F == null) throw Error("The argument must be a React element, but you passed " + F + ".");
      var we = S({}, F.props),
         oe = F.key,
         be = void 0;
      if (ie != null)
         for (Pe in ie.ref !== void 0 && (be = void 0), ie.key !== void 0 && (oe = "" + ie.key), ie) !z.call(ie, Pe) || Pe === "key" || Pe === "__self" || Pe === "__source" || Pe === "ref" && ie.ref === void 0 || (we[Pe] = ie[Pe]);
      var Pe = arguments.length - 2;
      if (Pe === 1) we.children = ye;
      else if (1 < Pe) {
         for (var Ge = Array(Pe), Xe = 0; Xe < Pe; Xe++) Ge[Xe] = arguments[Xe + 2];
         we.children = Ge
      }
      return B(F.type, oe, void 0, void 0, be, we)
   }, vn.createContext = function (F) {
      return F = {
         $$typeof: a,
         _currentValue: F,
         _currentValue2: F,
         _threadCount: 0,
         Provider: null,
         Consumer: null
      }, F.Provider = F, F.Consumer = {
         $$typeof: r,
         _context: F
      }, F
   }, vn.createElement = function (F, ie, ye) {
      var we, oe = {},
         be = null;
      if (ie != null)
         for (we in ie.key !== void 0 && (be = "" + ie.key), ie) z.call(ie, we) && we !== "key" && we !== "__self" && we !== "__source" && (oe[we] = ie[we]);
      var Pe = arguments.length - 2;
      if (Pe === 1) oe.children = ye;
      else if (1 < Pe) {
         for (var Ge = Array(Pe), Xe = 0; Xe < Pe; Xe++) Ge[Xe] = arguments[Xe + 2];
         oe.children = Ge
      }
      if (F && F.defaultProps)
         for (we in Pe = F.defaultProps, Pe) oe[we] === void 0 && (oe[we] = Pe[we]);
      return B(F, be, void 0, void 0, null, oe)
   }, vn.createRef = function () {
      return {
         current: null
      }
   }, vn.forwardRef = function (F) {
      return {
         $$typeof: l,
         render: F
      }
   }, vn.isValidElement = O, vn.lazy = function (F) {
      return {
         $$typeof: m,
         _payload: {
            _status: -1,
            _result: F
         },
         _init: Z
      }
   }, vn.memo = function (F, ie) {
      return {
         $$typeof: h,
         type: F,
         compare: ie === void 0 ? null : ie
      }
   }, vn.startTransition = function (F) {
      var ie = U.T,
         ye = {};
      U.T = ye;
      try {
         var we = F(),
            oe = U.S;
         oe !== null && oe(ye, we), typeof we == "object" && we !== null && typeof we.then == "function" && we.then(pe, J)
      } catch (be) {
         J(be)
      } finally {
         U.T = ie
      }
   }, vn.unstable_useCacheRefresh = function () {
      return U.H.useCacheRefresh()
   }, vn.use = function (F) {
      return U.H.use(F)
   }, vn.useActionState = function (F, ie, ye) {
      return U.H.useActionState(F, ie, ye)
   }, vn.useCallback = function (F, ie) {
      return U.H.useCallback(F, ie)
   }, vn.useContext = function (F) {
      return U.H.useContext(F)
   }, vn.useDebugValue = function () {}, vn.useDeferredValue = function (F, ie) {
      return U.H.useDeferredValue(F, ie)
   }, vn.useEffect = function (F, ie, ye) {
      var we = U.H;
      if (typeof ye == "function") throw Error("useEffect CRUD overload is not enabled in this build of React.");
      return we.useEffect(F, ie)
   }, vn.useId = function () {
      return U.H.useId()
   }, vn.useImperativeHandle = function (F, ie, ye) {
      return U.H.useImperativeHandle(F, ie, ye)
   }, vn.useInsertionEffect = function (F, ie) {
      return U.H.useInsertionEffect(F, ie)
   }, vn.useLayoutEffect = function (F, ie) {
      return U.H.useLayoutEffect(F, ie)
   }, vn.useMemo = function (F, ie) {
      return U.H.useMemo(F, ie)
   }, vn.useOptimistic = function (F, ie) {
      return U.H.useOptimistic(F, ie)
   }, vn.useReducer = function (F, ie, ye) {
      return U.H.useReducer(F, ie, ye)
   }, vn.useRef = function (F) {
      return U.H.useRef(F)
   }, vn.useState = function (F) {
      return U.H.useState(F)
   }, vn.useSyncExternalStore = function (F, ie, ye) {
      return U.H.useSyncExternalStore(F, ie, ye)
   }, vn.useTransition = function () {
      return U.H.useTransition()
   }, vn.version = "19.1.0", vn
}
var uD;

function Rg() {
   return uD || (uD = 1, HE.exports = zH()), HE.exports
}
var j = Rg();
const $o = lx(j);
var VE = {
      exports: {}
   },
   s0 = {},
   GE = {
      exports: {}
   },
   kE = {};
/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var cD;

function IH() {
   return cD || (cD = 1, function (n) {
      function e(k, Z) {
         var J = k.length;
         k.push(Z);
         e: for (; 0 < J;) {
            var pe = J - 1 >>> 1,
               F = k[pe];
            if (0 < s(F, Z)) k[pe] = Z, k[J] = F, J = pe;
            else break e
         }
      }

      function t(k) {
         return k.length === 0 ? null : k[0]
      }

      function i(k) {
         if (k.length === 0) return null;
         var Z = k[0],
            J = k.pop();
         if (J !== Z) {
            k[0] = J;
            e: for (var pe = 0, F = k.length, ie = F >>> 1; pe < ie;) {
               var ye = 2 * (pe + 1) - 1,
                  we = k[ye],
                  oe = ye + 1,
                  be = k[oe];
               if (0 > s(we, J)) oe < F && 0 > s(be, we) ? (k[pe] = be, k[oe] = J, pe = oe) : (k[pe] = we, k[ye] = J, pe = ye);
               else if (oe < F && 0 > s(be, J)) k[pe] = be, k[oe] = J, pe = oe;
               else break e
            }
         }
         return Z
      }

      function s(k, Z) {
         var J = k.sortIndex - Z.sortIndex;
         return J !== 0 ? J : k.id - Z.id
      }
      if (n.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
         var r = performance;
         n.unstable_now = function () {
            return r.now()
         }
      } else {
         var a = Date,
            l = a.now();
         n.unstable_now = function () {
            return a.now() - l
         }
      }
      var c = [],
         h = [],
         m = 1,
         g = null,
         v = 3,
         x = !1,
         S = !1,
         E = !1,
         T = !1,
         b = typeof setTimeout == "function" ? setTimeout : null,
         w = typeof clearTimeout == "function" ? clearTimeout : null,
         C = typeof setImmediate < "u" ? setImmediate : null;

      function N(k) {
         for (var Z = t(h); Z !== null;) {
            if (Z.callback === null) i(h);
            else if (Z.startTime <= k) i(h), Z.sortIndex = Z.expirationTime, e(c, Z);
            else break;
            Z = t(h)
         }
      }

      function U(k) {
         if (E = !1, N(k), !S)
            if (t(c) !== null) S = !0, z || (z = !0, Q());
            else {
               var Z = t(h);
               Z !== null && fe(U, Z.startTime - k)
            }
      }
      var z = !1,
         B = -1,
         I = 5,
         O = -1;

      function P() {
         return T ? !0 : !(n.unstable_now() - O < I)
      }

      function q() {
         if (T = !1, z) {
            var k = n.unstable_now();
            O = k;
            var Z = !0;
            try {
               e: {
                  S = !1,
                  E && (E = !1, w(B), B = -1),
                  x = !0;
                  var J = v;
                  try {
                     t: {
                        for (N(k), g = t(c); g !== null && !(g.expirationTime > k && P());) {
                           var pe = g.callback;
                           if (typeof pe == "function") {
                              g.callback = null, v = g.priorityLevel;
                              var F = pe(g.expirationTime <= k);
                              if (k = n.unstable_now(), typeof F == "function") {
                                 g.callback = F, N(k), Z = !0;
                                 break t
                              }
                              g === t(c) && i(c), N(k)
                           } else i(c);
                           g = t(c)
                        }
                        if (g !== null) Z = !0;
                        else {
                           var ie = t(h);
                           ie !== null && fe(U, ie.startTime - k), Z = !1
                        }
                     }
                     break e
                  }
                  finally {
                     g = null, v = J, x = !1
                  }
                  Z = void 0
               }
            }
            finally {
               Z ? Q() : z = !1
            }
         }
      }
      var Q;
      if (typeof C == "function") Q = function () {
         C(q)
      };
      else if (typeof MessageChannel < "u") {
         var $ = new MessageChannel,
            ae = $.port2;
         $.port1.onmessage = q, Q = function () {
            ae.postMessage(null)
         }
      } else Q = function () {
         b(q, 0)
      };

      function fe(k, Z) {
         B = b(function () {
            k(n.unstable_now())
         }, Z)
      }
      n.unstable_IdlePriority = 5, n.unstable_ImmediatePriority = 1, n.unstable_LowPriority = 4, n.unstable_NormalPriority = 3, n.unstable_Profiling = null, n.unstable_UserBlockingPriority = 2, n.unstable_cancelCallback = function (k) {
         k.callback = null
      }, n.unstable_forceFrameRate = function (k) {
         0 > k || 125 < k ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : I = 0 < k ? Math.floor(1e3 / k) : 5
      }, n.unstable_getCurrentPriorityLevel = function () {
         return v
      }, n.unstable_next = function (k) {
         switch (v) {
            case 1:
            case 2:
            case 3:
               var Z = 3;
               break;
            default:
               Z = v
         }
         var J = v;
         v = Z;
         try {
            return k()
         } finally {
            v = J
         }
      }, n.unstable_requestPaint = function () {
         T = !0
      }, n.unstable_runWithPriority = function (k, Z) {
         switch (k) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
               break;
            default:
               k = 3
         }
         var J = v;
         v = k;
         try {
            return Z()
         } finally {
            v = J
         }
      }, n.unstable_scheduleCallback = function (k, Z, J) {
         var pe = n.unstable_now();
         switch (typeof J == "object" && J !== null ? (J = J.delay, J = typeof J == "number" && 0 < J ? pe + J : pe) : J = pe, k) {
            case 1:
               var F = -1;
               break;
            case 2:
               F = 250;
               break;
            case 5:
               F = 1073741823;
               break;
            case 4:
               F = 1e4;
               break;
            default:
               F = 5e3
         }
         return F = J + F, k = {
            id: m++,
            callback: Z,
            priorityLevel: k,
            startTime: J,
            expirationTime: F,
            sortIndex: -1
         }, J > pe ? (k.sortIndex = J, e(h, k), t(c) === null && k === t(h) && (E ? (w(B), B = -1) : E = !0, fe(U, J - pe))) : (k.sortIndex = F, e(c, k), S || x || (S = !0, z || (z = !0, Q()))), k
      }, n.unstable_shouldYield = P, n.unstable_wrapCallback = function (k) {
         var Z = v;
         return function () {
            var J = v;
            v = Z;
            try {
               return k.apply(this, arguments)
            } finally {
               v = J
            }
         }
      }
   }(kE)), kE
}
var fD;

function FH() {
   return fD || (fD = 1, GE.exports = IH()), GE.exports
}
var jE = {
      exports: {}
   },
   Ar = {};
/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hD;

function HH() {
   if (hD) return Ar;
   hD = 1;
   var n = Rg();

   function e(c) {
      var h = "https://react.dev/errors/" + c;
      if (1 < arguments.length) {
         h += "?args[]=" + encodeURIComponent(arguments[1]);
         for (var m = 2; m < arguments.length; m++) h += "&args[]=" + encodeURIComponent(arguments[m])
      }
      return "Minified React error #" + c + "; visit " + h + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
   }

   function t() {}
   var i = {
         d: {
            f: t,
            r: function () {
               throw Error(e(522))
            },
            D: t,
            C: t,
            L: t,
            m: t,
            X: t,
            S: t,
            M: t
         },
         p: 0,
         findDOMNode: null
      },
      s = Symbol.for("react.portal");

   function r(c, h, m) {
      var g = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
      return {
         $$typeof: s,
         key: g == null ? null : "" + g,
         children: c,
         containerInfo: h,
         implementation: m
      }
   }
   var a = n.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;

   function l(c, h) {
      if (c === "font") return "";
      if (typeof h == "string") return h === "use-credentials" ? h : ""
   }
   return Ar.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = i, Ar.createPortal = function (c, h) {
      var m = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
      if (!h || h.nodeType !== 1 && h.nodeType !== 9 && h.nodeType !== 11) throw Error(e(299));
      return r(c, h, null, m)
   }, Ar.flushSync = function (c) {
      var h = a.T,
         m = i.p;
      try {
         if (a.T = null, i.p = 2, c) return c()
      } finally {
         a.T = h, i.p = m, i.d.f()
      }
   }, Ar.preconnect = function (c, h) {
      typeof c == "string" && (h ? (h = h.crossOrigin, h = typeof h == "string" ? h === "use-credentials" ? h : "" : void 0) : h = null, i.d.C(c, h))
   }, Ar.prefetchDNS = function (c) {
      typeof c == "string" && i.d.D(c)
   }, Ar.preinit = function (c, h) {
      if (typeof c == "string" && h && typeof h.as == "string") {
         var m = h.as,
            g = l(m, h.crossOrigin),
            v = typeof h.integrity == "string" ? h.integrity : void 0,
            x = typeof h.fetchPriority == "string" ? h.fetchPriority : void 0;
         m === "style" ? i.d.S(c, typeof h.precedence == "string" ? h.precedence : void 0, {
            crossOrigin: g,
            integrity: v,
            fetchPriority: x
         }) : m === "script" && i.d.X(c, {
            crossOrigin: g,
            integrity: v,
            fetchPriority: x,
            nonce: typeof h.nonce == "string" ? h.nonce : void 0
         })
      }
   }, Ar.preinitModule = function (c, h) {
      if (typeof c == "string")
         if (typeof h == "object" && h !== null) {
            if (h.as == null || h.as === "script") {
               var m = l(h.as, h.crossOrigin);
               i.d.M(c, {
                  crossOrigin: m,
                  integrity: typeof h.integrity == "string" ? h.integrity : void 0,
                  nonce: typeof h.nonce == "string" ? h.nonce : void 0
               })
            }
         } else h == null && i.d.M(c)
   }, Ar.preload = function (c, h) {
      if (typeof c == "string" && typeof h == "object" && h !== null && typeof h.as == "string") {
         var m = h.as,
            g = l(m, h.crossOrigin);
         i.d.L(c, m, {
            crossOrigin: g,
            integrity: typeof h.integrity == "string" ? h.integrity : void 0,
            nonce: typeof h.nonce == "string" ? h.nonce : void 0,
            type: typeof h.type == "string" ? h.type : void 0,
            fetchPriority: typeof h.fetchPriority == "string" ? h.fetchPriority : void 0,
            referrerPolicy: typeof h.referrerPolicy == "string" ? h.referrerPolicy : void 0,
            imageSrcSet: typeof h.imageSrcSet == "string" ? h.imageSrcSet : void 0,
            imageSizes: typeof h.imageSizes == "string" ? h.imageSizes : void 0,
            media: typeof h.media == "string" ? h.media : void 0
         })
      }
   }, Ar.preloadModule = function (c, h) {
      if (typeof c == "string")
         if (h) {
            var m = l(h.as, h.crossOrigin);
            i.d.m(c, {
               as: typeof h.as == "string" && h.as !== "script" ? h.as : void 0,
               crossOrigin: m,
               integrity: typeof h.integrity == "string" ? h.integrity : void 0
            })
         } else i.d.m(c)
   }, Ar.requestFormReset = function (c) {
      i.d.r(c)
   }, Ar.unstable_batchedUpdates = function (c, h) {
      return c(h)
   }, Ar.useFormState = function (c, h, m) {
      return a.H.useFormState(c, h, m)
   }, Ar.useFormStatus = function () {
      return a.H.useHostTransitionStatus()
   }, Ar.version = "19.1.0", Ar
}
var dD;

function pP() {
   if (dD) return jE.exports;
   dD = 1;

   function n() {
      if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try {
         __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)
      } catch (e) {
         console.error(e)
      }
   }
   return n(), jE.exports = HH(), jE.exports
}
/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var pD;

function VH() {
   if (pD) return s0;
   pD = 1;
   var n = FH(),
      e = Rg(),
      t = pP();

   function i(o) {
      var u = "https://react.dev/errors/" + o;
      if (1 < arguments.length) {
         u += "?args[]=" + encodeURIComponent(arguments[1]);
         for (var p = 2; p < arguments.length; p++) u += "&args[]=" + encodeURIComponent(arguments[p])
      }
      return "Minified React error #" + o + "; visit " + u + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
   }

   function s(o) {
      return !(!o || o.nodeType !== 1 && o.nodeType !== 9 && o.nodeType !== 11)
   }

   function r(o) {
      var u = o,
         p = o;
      if (o.alternate)
         for (; u.return;) u = u.return;
      else {
         o = u;
         do u = o, (u.flags & 4098) !== 0 && (p = u.return), o = u.return; while (o)
      }
      return u.tag === 3 ? p : null
   }

   function a(o) {
      if (o.tag === 13) {
         var u = o.memoizedState;
         if (u === null && (o = o.alternate, o !== null && (u = o.memoizedState)), u !== null) return u.dehydrated
      }
      return null
   }

   function l(o) {
      if (r(o) !== o) throw Error(i(188))
   }

   function c(o) {
      var u = o.alternate;
      if (!u) {
         if (u = r(o), u === null) throw Error(i(188));
         return u !== o ? null : o
      }
      for (var p = o, y = u;;) {
         var M = p.return;
         if (M === null) break;
         var R = M.alternate;
         if (R === null) {
            if (y = M.return, y !== null) {
               p = y;
               continue
            }
            break
         }
         if (M.child === R.child) {
            for (R = M.child; R;) {
               if (R === p) return l(M), o;
               if (R === y) return l(M), u;
               R = R.sibling
            }
            throw Error(i(188))
         }
         if (p.return !== y.return) p = M, y = R;
         else {
            for (var V = !1, W = M.child; W;) {
               if (W === p) {
                  V = !0, p = M, y = R;
                  break
               }
               if (W === y) {
                  V = !0, y = M, p = R;
                  break
               }
               W = W.sibling
            }
            if (!V) {
               for (W = R.child; W;) {
                  if (W === p) {
                     V = !0, p = R, y = M;
                     break
                  }
                  if (W === y) {
                     V = !0, y = R, p = M;
                     break
                  }
                  W = W.sibling
               }
               if (!V) throw Error(i(189))
            }
         }
         if (p.alternate !== y) throw Error(i(190))
      }
      if (p.tag !== 3) throw Error(i(188));
      return p.stateNode.current === p ? o : u
   }

   function h(o) {
      var u = o.tag;
      if (u === 5 || u === 26 || u === 27 || u === 6) return o;
      for (o = o.child; o !== null;) {
         if (u = h(o), u !== null) return u;
         o = o.sibling
      }
      return null
   }
   var m = Object.assign,
      g = Symbol.for("react.element"),
      v = Symbol.for("react.transitional.element"),
      x = Symbol.for("react.portal"),
      S = Symbol.for("react.fragment"),
      E = Symbol.for("react.strict_mode"),
      T = Symbol.for("react.profiler"),
      b = Symbol.for("react.provider"),
      w = Symbol.for("react.consumer"),
      C = Symbol.for("react.context"),
      N = Symbol.for("react.forward_ref"),
      U = Symbol.for("react.suspense"),
      z = Symbol.for("react.suspense_list"),
      B = Symbol.for("react.memo"),
      I = Symbol.for("react.lazy"),
      O = Symbol.for("react.activity"),
      P = Symbol.for("react.memo_cache_sentinel"),
      q = Symbol.iterator;

   function Q(o) {
      return o === null || typeof o != "object" ? null : (o = q && o[q] || o["@@iterator"], typeof o == "function" ? o : null)
   }
   var $ = Symbol.for("react.client.reference");

   function ae(o) {
      if (o == null) return null;
      if (typeof o == "function") return o.$$typeof === $ ? null : o.displayName || o.name || null;
      if (typeof o == "string") return o;
      switch (o) {
         case S:
            return "Fragment";
         case T:
            return "Profiler";
         case E:
            return "StrictMode";
         case U:
            return "Suspense";
         case z:
            return "SuspenseList";
         case O:
            return "Activity"
      }
      if (typeof o == "object") switch (o.$$typeof) {
         case x:
            return "Portal";
         case C:
            return (o.displayName || "Context") + ".Provider";
         case w:
            return (o._context.displayName || "Context") + ".Consumer";
         case N:
            var u = o.render;
            return o = o.displayName, o || (o = u.displayName || u.name || "", o = o !== "" ? "ForwardRef(" + o + ")" : "ForwardRef"), o;
         case B:
            return u = o.displayName || null, u !== null ? u : ae(o.type) || "Memo";
         case I:
            u = o._payload, o = o._init;
            try {
               return ae(o(u))
            } catch {}
      }
      return null
   }
   var fe = Array.isArray,
      k = e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
      Z = t.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
      J = {
         pending: !1,
         data: null,
         method: null,
         action: null
      },
      pe = [],
      F = -1;

   function ie(o) {
      return {
         current: o
      }
   }

   function ye(o) {
      0 > F || (o.current = pe[F], pe[F] = null, F--)
   }

   function we(o, u) {
      F++, pe[F] = o.current, o.current = u
   }
   var oe = ie(null),
      be = ie(null),
      Pe = ie(null),
      Ge = ie(null);

   function Xe(o, u) {
      switch (we(Pe, u), we(be, o), we(oe, null), u.nodeType) {
         case 9:
         case 11:
            o = (o = u.documentElement) && (o = o.namespaceURI) ? PC(o) : 0;
            break;
         default:
            if (o = u.tagName, u = u.namespaceURI) u = PC(u), o = LC(u, o);
            else switch (o) {
               case "svg":
                  o = 1;
                  break;
               case "math":
                  o = 2;
                  break;
               default:
                  o = 0
            }
      }
      ye(oe), we(oe, o)
   }

   function yt() {
      ye(oe), ye(be), ye(Pe)
   }

   function vt(o) {
      o.memoizedState !== null && we(Ge, o);
      var u = oe.current,
         p = LC(u, o.type);
      u !== p && (we(be, o), we(oe, p))
   }

   function Mt(o) {
      be.current === o && (ye(oe), ye(be)), Ge.current === o && (ye(Ge), Jv._currentValue = J)
   }
   var zt = Object.prototype.hasOwnProperty,
      lt = n.unstable_scheduleCallback,
      ne = n.unstable_cancelCallback,
      sn = n.unstable_shouldYield,
      ze = n.unstable_requestPaint,
      te = n.unstable_now,
      Be = n.unstable_getCurrentPriorityLevel,
      Je = n.unstable_ImmediatePriority,
      Ue = n.unstable_UserBlockingPriority,
      K = n.unstable_NormalPriority,
      G = n.unstable_LowPriority,
      me = n.unstable_IdlePriority,
      Ne = n.log,
      Oe = n.unstable_setDisableYieldValue,
      De = null,
      Ye = null;

   function We(o) {
      if (typeof Ne == "function" && Oe(o), Ye && typeof Ye.setStrictMode == "function") try {
         Ye.setStrictMode(De, o)
      } catch {}
   }
   var Ze = Math.clz32 ? Math.clz32 : et,
      kt = Math.log,
      Ke = Math.LN2;

   function et(o) {
      return o >>>= 0, o === 0 ? 32 : 31 - (kt(o) / Ke | 0) | 0
   }
   var xt = 256,
      mt = 4194304;

   function it(o) {
      var u = o & 42;
      if (u !== 0) return u;
      switch (o & -o) {
         case 1:
            return 1;
         case 2:
            return 2;
         case 4:
            return 4;
         case 8:
            return 8;
         case 16:
            return 16;
         case 32:
            return 32;
         case 64:
            return 64;
         case 128:
            return 128;
         case 256:
         case 512:
         case 1024:
         case 2048:
         case 4096:
         case 8192:
         case 16384:
         case 32768:
         case 65536:
         case 131072:
         case 262144:
         case 524288:
         case 1048576:
         case 2097152:
            return o & 4194048;
         case 4194304:
         case 8388608:
         case 16777216:
         case 33554432:
            return o & 62914560;
         case 67108864:
            return 67108864;
         case 134217728:
            return 134217728;
         case 268435456:
            return 268435456;
         case 536870912:
            return 536870912;
         case 1073741824:
            return 0;
         default:
            return o
      }
   }

   function jt(o, u, p) {
      var y = o.pendingLanes;
      if (y === 0) return 0;
      var M = 0,
         R = o.suspendedLanes,
         V = o.pingedLanes;
      o = o.warmLanes;
      var W = y & 134217727;
      return W !== 0 ? (y = W & ~R, y !== 0 ? M = it(y) : (V &= W, V !== 0 ? M = it(V) : p || (p = W & ~o, p !== 0 && (M = it(p))))) : (W = y & ~R, W !== 0 ? M = it(W) : V !== 0 ? M = it(V) : p || (p = y & ~o, p !== 0 && (M = it(p)))), M === 0 ? 0 : u !== 0 && u !== M && (u & R) === 0 && (R = M & -M, p = u & -u, R >= p || R === 32 && (p & 4194048) !== 0) ? u : M
   }

   function Rt(o, u) {
      return (o.pendingLanes & ~(o.suspendedLanes & ~o.pingedLanes) & u) === 0
   }

   function cn(o, u) {
      switch (o) {
         case 1:
         case 2:
         case 4:
         case 8:
         case 64:
            return u + 250;
         case 16:
         case 32:
         case 128:
         case 256:
         case 512:
         case 1024:
         case 2048:
         case 4096:
         case 8192:
         case 16384:
         case 32768:
         case 65536:
         case 131072:
         case 262144:
         case 524288:
         case 1048576:
         case 2097152:
            return u + 5e3;
         case 4194304:
         case 8388608:
         case 16777216:
         case 33554432:
            return -1;
         case 67108864:
         case 134217728:
         case 268435456:
         case 536870912:
         case 1073741824:
            return -1;
         default:
            return -1
      }
   }

   function le() {
      var o = xt;
      return xt <<= 1, (xt & 4194048) === 0 && (xt = 256), o
   }

   function rt() {
      var o = mt;
      return mt <<= 1, (mt & 62914560) === 0 && (mt = 4194304), o
   }

   function Re(o) {
      for (var u = [], p = 0; 31 > p; p++) u.push(o);
      return u
   }

   function Ie(o, u) {
      o.pendingLanes |= u, u !== 268435456 && (o.suspendedLanes = 0, o.pingedLanes = 0, o.warmLanes = 0)
   }

   function nt(o, u, p, y, M, R) {
      var V = o.pendingLanes;
      o.pendingLanes = p, o.suspendedLanes = 0, o.pingedLanes = 0, o.warmLanes = 0, o.expiredLanes &= p, o.entangledLanes &= p, o.errorRecoveryDisabledLanes &= p, o.shellSuspendCounter = 0;
      var W = o.entanglements,
         se = o.expirationTimes,
         Se = o.hiddenUpdates;
      for (p = V & ~p; 0 < p;) {
         var Ve = 31 - Ze(p),
            qe = 1 << Ve;
         W[Ve] = 0, se[Ve] = -1;
         var Me = Se[Ve];
         if (Me !== null)
            for (Se[Ve] = null, Ve = 0; Ve < Me.length; Ve++) {
               var Ae = Me[Ve];
               Ae !== null && (Ae.lane &= -536870913)
            }
         p &= ~qe
      }
      y !== 0 && at(o, y, 0), R !== 0 && M === 0 && o.tag !== 0 && (o.suspendedLanes |= R & ~(V & ~u))
   }

   function at(o, u, p) {
      o.pendingLanes |= u, o.suspendedLanes &= ~u;
      var y = 31 - Ze(u);
      o.entangledLanes |= u, o.entanglements[y] = o.entanglements[y] | 1073741824 | p & 4194090
   }

   function Bt(o, u) {
      var p = o.entangledLanes |= u;
      for (o = o.entanglements; p;) {
         var y = 31 - Ze(p),
            M = 1 << y;
         M & u | o[y] & u && (o[y] |= u), p &= ~M
      }
   }

   function mn(o) {
      switch (o) {
         case 2:
            o = 1;
            break;
         case 8:
            o = 4;
            break;
         case 32:
            o = 16;
            break;
         case 256:
         case 512:
         case 1024:
         case 2048:
         case 4096:
         case 8192:
         case 16384:
         case 32768:
         case 65536:
         case 131072:
         case 262144:
         case 524288:
         case 1048576:
         case 2097152:
         case 4194304:
         case 8388608:
         case 16777216:
         case 33554432:
            o = 128;
            break;
         case 268435456:
            o = 134217728;
            break;
         default:
            o = 0
      }
      return o
   }

   function Yn(o) {
      return o &= -o, 2 < o ? 8 < o ? (o & 134217727) !== 0 ? 32 : 268435456 : 8 : 2
   }

   function ut() {
      var o = Z.p;
      return o !== 0 ? o : (o = window.event, o === void 0 ? 32 : eD(o.type))
   }

   function _t(o, u) {
      var p = Z.p;
      try {
         return Z.p = o, u()
      } finally {
         Z.p = p
      }
   }
   var It = Math.random().toString(36).slice(2),
      Qe = "__reactFiber$" + It,
      St = "__reactProps$" + It,
      gt = "__reactContainer$" + It,
      Dt = "__reactEvents$" + It,
      Ti = "__reactListeners$" + It,
      Xt = "__reactHandles$" + It,
      _n = "__reactResources$" + It,
      ii = "__reactMarker$" + It;

   function Ft(o) {
      delete o[Qe], delete o[St], delete o[Dt], delete o[Ti], delete o[Xt]
   }

   function Mn(o) {
      var u = o[Qe];
      if (u) return u;
      for (var p = o.parentNode; p;) {
         if (u = p[gt] || p[Qe]) {
            if (p = u.alternate, u.child !== null || p !== null && p.child !== null)
               for (o = FC(o); o !== null;) {
                  if (p = o[Qe]) return p;
                  o = FC(o)
               }
            return u
         }
         o = p, p = o.parentNode
      }
      return null
   }

   function gn(o) {
      if (o = o[Qe] || o[gt]) {
         var u = o.tag;
         if (u === 5 || u === 6 || u === 13 || u === 26 || u === 27 || u === 3) return o
      }
      return null
   }

   function Zi(o) {
      var u = o.tag;
      if (u === 5 || u === 26 || u === 27 || u === 6) return o.stateNode;
      throw Error(i(33))
   }

   function zn(o) {
      var u = o[_n];
      return u || (u = o[_n] = {
         hoistableStyles: new Map,
         hoistableScripts: new Map
      }), u
   }

   function Pn(o) {
      o[ii] = !0
   }
   var Ns = new Set,
      Ei = {};

   function ei(o, u) {
      X(o, u), X(o + "Capture", u)
   }

   function X(o, u) {
      for (Ei[o] = u, o = 0; o < u.length; o++) Ns.add(u[o])
   }
   var ue = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"),
      Te = {},
      xe = {};

   function de(o) {
      return zt.call(xe, o) ? !0 : zt.call(Te, o) ? !1 : ue.test(o) ? xe[o] = !0 : (Te[o] = !0, !1)
   }

   function je(o, u, p) {
      if (de(u))
         if (p === null) o.removeAttribute(u);
         else {
            switch (typeof p) {
               case "undefined":
               case "function":
               case "symbol":
                  o.removeAttribute(u);
                  return;
               case "boolean":
                  var y = u.toLowerCase().slice(0, 5);
                  if (y !== "data-" && y !== "aria-") {
                     o.removeAttribute(u);
                     return
                  }
            }
            o.setAttribute(u, "" + p)
         }
   }

   function st(o, u, p) {
      if (p === null) o.removeAttribute(u);
      else {
         switch (typeof p) {
            case "undefined":
            case "function":
            case "symbol":
            case "boolean":
               o.removeAttribute(u);
               return
         }
         o.setAttribute(u, "" + p)
      }
   }

   function ot(o, u, p, y) {
      if (y === null) o.removeAttribute(p);
      else {
         switch (typeof y) {
            case "undefined":
            case "function":
            case "symbol":
            case "boolean":
               o.removeAttribute(p);
               return
         }
         o.setAttributeNS(u, p, "" + y)
      }
   }
   var ct, At;

   function wt(o) {
      if (ct === void 0) try {
         throw Error()
      } catch (p) {
         var u = p.stack.trim().match(/\n( *(at )?)/);
         ct = u && u[1] || "", At = -1 < p.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < p.stack.indexOf("@") ? "@unknown:0:0" : ""
      }
      return `
` + ct + o + At
   }
   var Tt = !1;

   function Wt(o, u) {
      if (!o || Tt) return "";
      Tt = !0;
      var p = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
         var y = {
            DetermineComponentFrameRoot: function () {
               try {
                  if (u) {
                     var qe = function () {
                        throw Error()
                     };
                     if (Object.defineProperty(qe.prototype, "props", {
                           set: function () {
                              throw Error()
                           }
                        }), typeof Reflect == "object" && Reflect.construct) {
                        try {
                           Reflect.construct(qe, [])
                        } catch (Ae) {
                           var Me = Ae
                        }
                        Reflect.construct(o, [], qe)
                     } else {
                        try {
                           qe.call()
                        } catch (Ae) {
                           Me = Ae
                        }
                        o.call(qe.prototype)
                     }
                  } else {
                     try {
                        throw Error()
                     } catch (Ae) {
                        Me = Ae
                     }(qe = o()) && typeof qe.catch == "function" && qe.catch(function () {})
                  }
               } catch (Ae) {
                  if (Ae && Me && typeof Ae.stack == "string") return [Ae.stack, Me.stack]
               }
               return [null, null]
            }
         };
         y.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
         var M = Object.getOwnPropertyDescriptor(y.DetermineComponentFrameRoot, "name");
         M && M.configurable && Object.defineProperty(y.DetermineComponentFrameRoot, "name", {
            value: "DetermineComponentFrameRoot"
         });
         var R = y.DetermineComponentFrameRoot(),
            V = R[0],
            W = R[1];
         if (V && W) {
            var se = V.split(`
`),
               Se = W.split(`
`);
            for (M = y = 0; y < se.length && !se[y].includes("DetermineComponentFrameRoot");) y++;
            for (; M < Se.length && !Se[M].includes("DetermineComponentFrameRoot");) M++;
            if (y === se.length || M === Se.length)
               for (y = se.length - 1, M = Se.length - 1; 1 <= y && 0 <= M && se[y] !== Se[M];) M--;
            for (; 1 <= y && 0 <= M; y--, M--)
               if (se[y] !== Se[M]) {
                  if (y !== 1 || M !== 1)
                     do
                        if (y--, M--, 0 > M || se[y] !== Se[M]) {
                           var Ve = `
` + se[y].replace(" at new ", " at ");
                           return o.displayName && Ve.includes("<anonymous>") && (Ve = Ve.replace("<anonymous>", o.displayName)), Ve
                        } while (1 <= y && 0 <= M);
                  break
               }
         }
      } finally {
         Tt = !1, Error.prepareStackTrace = p
      }
      return (p = o ? o.displayName || o.name : "") ? wt(p) : ""
   }

   function In(o) {
      switch (o.tag) {
         case 26:
         case 27:
         case 5:
            return wt(o.type);
         case 16:
            return wt("Lazy");
         case 13:
            return wt("Suspense");
         case 19:
            return wt("SuspenseList");
         case 0:
         case 15:
            return Wt(o.type, !1);
         case 11:
            return Wt(o.type.render, !1);
         case 1:
            return Wt(o.type, !0);
         case 31:
            return wt("Activity");
         default:
            return ""
      }
   }

   function Mi(o) {
      try {
         var u = "";
         do u += In(o), o = o.return; while (o);
         return u
      } catch (p) {
         return `
Error generating stack: ` + p.message + `
` + p.stack
      }
   }

   function Sn(o) {
      switch (typeof o) {
         case "bigint":
         case "boolean":
         case "number":
         case "string":
         case "undefined":
            return o;
         case "object":
            return o;
         default:
            return ""
      }
   }

   function An(o) {
      var u = o.type;
      return (o = o.nodeName) && o.toLowerCase() === "input" && (u === "checkbox" || u === "radio")
   }

   function Pt(o) {
      var u = An(o) ? "checked" : "value",
         p = Object.getOwnPropertyDescriptor(o.constructor.prototype, u),
         y = "" + o[u];
      if (!o.hasOwnProperty(u) && typeof p < "u" && typeof p.get == "function" && typeof p.set == "function") {
         var M = p.get,
            R = p.set;
         return Object.defineProperty(o, u, {
            configurable: !0,
            get: function () {
               return M.call(this)
            },
            set: function (V) {
               y = "" + V, R.call(this, V)
            }
         }), Object.defineProperty(o, u, {
            enumerable: p.enumerable
         }), {
            getValue: function () {
               return y
            },
            setValue: function (V) {
               y = "" + V
            },
            stopTracking: function () {
               o._valueTracker = null, delete o[u]
            }
         }
      }
   }

   function Ri(o) {
      o._valueTracker || (o._valueTracker = Pt(o))
   }

   function Ln(o) {
      if (!o) return !1;
      var u = o._valueTracker;
      if (!u) return !0;
      var p = u.getValue(),
         y = "";
      return o && (y = An(o) ? o.checked ? "true" : "false" : o.value), o = y, o !== p ? (u.setValue(o), !0) : !1
   }

   function Os(o) {
      if (o = o || (typeof document < "u" ? document : void 0), typeof o > "u") return null;
      try {
         return o.activeElement || o.body
      } catch {
         return o.body
      }
   }
   var _o = /[\n"\\]/g;

   function li(o) {
      return o.replace(_o, function (u) {
         return "\\" + u.charCodeAt(0).toString(16) + " "
      })
   }

   function So(o, u, p, y, M, R, V, W) {
      o.name = "", V != null && typeof V != "function" && typeof V != "symbol" && typeof V != "boolean" ? o.type = V : o.removeAttribute("type"), u != null ? V === "number" ? (u === 0 && o.value === "" || o.value != u) && (o.value = "" + Sn(u)) : o.value !== "" + Sn(u) && (o.value = "" + Sn(u)) : V !== "submit" && V !== "reset" || o.removeAttribute("value"), u != null ? Us(o, V, Sn(u)) : p != null ? Us(o, V, Sn(p)) : y != null && o.removeAttribute("value"), M == null && R != null && (o.defaultChecked = !!R), M != null && (o.checked = M && typeof M != "function" && typeof M != "symbol"), W != null && typeof W != "function" && typeof W != "symbol" && typeof W != "boolean" ? o.name = "" + Sn(W) : o.removeAttribute("name")
   }

   function si(o, u, p, y, M, R, V, W) {
      if (R != null && typeof R != "function" && typeof R != "symbol" && typeof R != "boolean" && (o.type = R), u != null || p != null) {
         if (!(R !== "submit" && R !== "reset" || u != null)) return;
         p = p != null ? "" + Sn(p) : "", u = u != null ? "" + Sn(u) : p, W || u === o.value || (o.value = u), o.defaultValue = u
      }
      y = y ?? M, y = typeof y != "function" && typeof y != "symbol" && !!y, o.checked = W ? o.checked : !!y, o.defaultChecked = !!y, V != null && typeof V != "function" && typeof V != "symbol" && typeof V != "boolean" && (o.name = V)
   }

   function Us(o, u, p) {
      u === "number" && Os(o.ownerDocument) === o || o.defaultValue === "" + p || (o.defaultValue = "" + p)
   }

   function Qi(o, u, p, y) {
      if (o = o.options, u) {
         u = {};
         for (var M = 0; M < p.length; M++) u["$" + p[M]] = !0;
         for (p = 0; p < o.length; p++) M = u.hasOwnProperty("$" + o[p].value), o[p].selected !== M && (o[p].selected = M), M && y && (o[p].defaultSelected = !0)
      } else {
         for (p = "" + Sn(p), u = null, M = 0; M < o.length; M++) {
            if (o[M].value === p) {
               o[M].selected = !0, y && (o[M].defaultSelected = !0);
               return
            }
            u !== null || o[M].disabled || (u = o[M])
         }
         u !== null && (u.selected = !0)
      }
   }

   function vs(o, u, p) {
      if (u != null && (u = "" + Sn(u), u !== o.value && (o.value = u), p == null)) {
         o.defaultValue !== u && (o.defaultValue = u);
         return
      }
      o.defaultValue = p != null ? "" + Sn(p) : ""
   }

   function ys(o, u, p, y) {
      if (u == null) {
         if (y != null) {
            if (p != null) throw Error(i(92));
            if (fe(y)) {
               if (1 < y.length) throw Error(i(93));
               y = y[0]
            }
            p = y
         }
         p == null && (p = ""), u = p
      }
      p = Sn(u), o.defaultValue = p, y = o.textContent, y === p && y !== "" && y !== null && (o.value = y)
   }

   function rr(o, u) {
      if (u) {
         var p = o.firstChild;
         if (p && p === o.lastChild && p.nodeType === 3) {
            p.nodeValue = u;
            return
         }
      }
      o.textContent = u
   }
   var bo = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));

   function gh(o, u, p) {
      var y = u.indexOf("--") === 0;
      p == null || typeof p == "boolean" || p === "" ? y ? o.setProperty(u, "") : u === "float" ? o.cssFloat = "" : o[u] = "" : y ? o.setProperty(u, p) : typeof p != "number" || p === 0 || bo.has(u) ? u === "float" ? o.cssFloat = p : o[u] = ("" + p).trim() : o[u] = p + "px"
   }

   function vh(o, u, p) {
      if (u != null && typeof u != "object") throw Error(i(62));
      if (o = o.style, p != null) {
         for (var y in p) !p.hasOwnProperty(y) || u != null && u.hasOwnProperty(y) || (y.indexOf("--") === 0 ? o.setProperty(y, "") : y === "float" ? o.cssFloat = "" : o[y] = "");
         for (var M in u) y = u[M], u.hasOwnProperty(M) && p[M] !== y && gh(o, M, y)
      } else
         for (var R in u) u.hasOwnProperty(R) && gh(o, R, u[R])
   }

   function pp(o) {
      if (o.indexOf("-") === -1) return !1;
      switch (o) {
         case "annotation-xml":
         case "color-profile":
         case "font-face":
         case "font-face-src":
         case "font-face-uri":
         case "font-face-format":
         case "font-face-name":
         case "missing-glyph":
            return !1;
         default:
            return !0
      }
   }
   var jg = new Map([
         ["acceptCharset", "accept-charset"],
         ["htmlFor", "for"],
         ["httpEquiv", "http-equiv"],
         ["crossOrigin", "crossorigin"],
         ["accentHeight", "accent-height"],
         ["alignmentBaseline", "alignment-baseline"],
         ["arabicForm", "arabic-form"],
         ["baselineShift", "baseline-shift"],
         ["capHeight", "cap-height"],
         ["clipPath", "clip-path"],
         ["clipRule", "clip-rule"],
         ["colorInterpolation", "color-interpolation"],
         ["colorInterpolationFilters", "color-interpolation-filters"],
         ["colorProfile", "color-profile"],
         ["colorRendering", "color-rendering"],
         ["dominantBaseline", "dominant-baseline"],
         ["enableBackground", "enable-background"],
         ["fillOpacity", "fill-opacity"],
         ["fillRule", "fill-rule"],
         ["floodColor", "flood-color"],
         ["floodOpacity", "flood-opacity"],
         ["fontFamily", "font-family"],
         ["fontSize", "font-size"],
         ["fontSizeAdjust", "font-size-adjust"],
         ["fontStretch", "font-stretch"],
         ["fontStyle", "font-style"],
         ["fontVariant", "font-variant"],
         ["fontWeight", "font-weight"],
         ["glyphName", "glyph-name"],
         ["glyphOrientationHorizontal", "glyph-orientation-horizontal"],
         ["glyphOrientationVertical", "glyph-orientation-vertical"],
         ["horizAdvX", "horiz-adv-x"],
         ["horizOriginX", "horiz-origin-x"],
         ["imageRendering", "image-rendering"],
         ["letterSpacing", "letter-spacing"],
         ["lightingColor", "lighting-color"],
         ["markerEnd", "marker-end"],
         ["markerMid", "marker-mid"],
         ["markerStart", "marker-start"],
         ["overlinePosition", "overline-position"],
         ["overlineThickness", "overline-thickness"],
         ["paintOrder", "paint-order"],
         ["panose-1", "panose-1"],
         ["pointerEvents", "pointer-events"],
         ["renderingIntent", "rendering-intent"],
         ["shapeRendering", "shape-rendering"],
         ["stopColor", "stop-color"],
         ["stopOpacity", "stop-opacity"],
         ["strikethroughPosition", "strikethrough-position"],
         ["strikethroughThickness", "strikethrough-thickness"],
         ["strokeDasharray", "stroke-dasharray"],
         ["strokeDashoffset", "stroke-dashoffset"],
         ["strokeLinecap", "stroke-linecap"],
         ["strokeLinejoin", "stroke-linejoin"],
         ["strokeMiterlimit", "stroke-miterlimit"],
         ["strokeOpacity", "stroke-opacity"],
         ["strokeWidth", "stroke-width"],
         ["textAnchor", "text-anchor"],
         ["textDecoration", "text-decoration"],
         ["textRendering", "text-rendering"],
         ["transformOrigin", "transform-origin"],
         ["underlinePosition", "underline-position"],
         ["underlineThickness", "underline-thickness"],
         ["unicodeBidi", "unicode-bidi"],
         ["unicodeRange", "unicode-range"],
         ["unitsPerEm", "units-per-em"],
         ["vAlphabetic", "v-alphabetic"],
         ["vHanging", "v-hanging"],
         ["vIdeographic", "v-ideographic"],
         ["vMathematical", "v-mathematical"],
         ["vectorEffect", "vector-effect"],
         ["vertAdvY", "vert-adv-y"],
         ["vertOriginX", "vert-origin-x"],
         ["vertOriginY", "vert-origin-y"],
         ["wordSpacing", "word-spacing"],
         ["writingMode", "writing-mode"],
         ["xmlnsXlink", "xmlns:xlink"],
         ["xHeight", "x-height"]
      ]),
      Ox = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;

   function yh(o) {
      return Ox.test("" + o) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : o
   }
   var mp = null;

   function gp(o) {
      return o = o.target || o.srcElement || window, o.correspondingUseElement && (o = o.correspondingUseElement), o.nodeType === 3 ? o.parentNode : o
   }
   var Xl = null,
      Xu = null;

   function qg(o) {
      var u = gn(o);
      if (u && (o = u.stateNode)) {
         var p = o[St] || null;
         e: switch (o = u.stateNode, u.type) {
            case "input":
               if (So(o, p.value, p.defaultValue, p.defaultValue, p.checked, p.defaultChecked, p.type, p.name), u = p.name, p.type === "radio" && u != null) {
                  for (p = o; p.parentNode;) p = p.parentNode;
                  for (p = p.querySelectorAll('input[name="' + li("" + u) + '"][type="radio"]'), u = 0; u < p.length; u++) {
                     var y = p[u];
                     if (y !== o && y.form === o.form) {
                        var M = y[St] || null;
                        if (!M) throw Error(i(90));
                        So(y, M.value, M.defaultValue, M.defaultValue, M.checked, M.defaultChecked, M.type, M.name)
                     }
                  }
                  for (u = 0; u < p.length; u++) y = p[u], y.form === o.form && Ln(y)
               }
               break e;
            case "textarea":
               vs(o, p.value, p.defaultValue);
               break e;
            case "select":
               u = p.value, u != null && Qi(o, !!p.multiple, u, !1)
         }
      }
   }
   var xh = !1;

   function Xg(o, u, p) {
      if (xh) return o(u, p);
      xh = !0;
      try {
         var y = o(u);
         return y
      } finally {
         if (xh = !1, (Xl !== null || Xu !== null) && (Io(), Xl && (u = Xl, o = Xu, Xu = Xl = null, qg(u), o)))
            for (u = 0; u < o.length; u++) qg(o[u])
      }
   }

   function Hc(o, u) {
      var p = o.stateNode;
      if (p === null) return null;
      var y = p[St] || null;
      if (y === null) return null;
      p = y[u];
      e: switch (u) {
         case "onClick":
         case "onClickCapture":
         case "onDoubleClick":
         case "onDoubleClickCapture":
         case "onMouseDown":
         case "onMouseDownCapture":
         case "onMouseMove":
         case "onMouseMoveCapture":
         case "onMouseUp":
         case "onMouseUpCapture":
         case "onMouseEnter":
            (y = !y.disabled) || (o = o.type, y = !(o === "button" || o === "input" || o === "select" || o === "textarea")), o = !y;
            break e;
         default:
            o = !1
      }
      if (o) return null;
      if (p && typeof p != "function") throw Error(i(231, u, typeof p));
      return p
   }
   var To = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"),
      _h = !1;
   if (To) try {
      var Vc = {};
      Object.defineProperty(Vc, "passive", {
         get: function () {
            _h = !0
         }
      }), window.addEventListener("test", Vc, Vc), window.removeEventListener("test", Vc, Vc)
   } catch {
      _h = !1
   }
   var rl = null,
      Wg = null,
      vp = null;

   function Yg() {
      if (vp) return vp;
      var o, u = Wg,
         p = u.length,
         y, M = "value" in rl ? rl.value : rl.textContent,
         R = M.length;
      for (o = 0; o < p && u[o] === M[o]; o++);
      var V = p - o;
      for (y = 1; y <= V && u[p - y] === M[R - y]; y++);
      return vp = M.slice(o, 1 < y ? 1 - y : void 0)
   }

   function Wl(o) {
      var u = o.keyCode;
      return "charCode" in o ? (o = o.charCode, o === 0 && u === 13 && (o = 13)) : o = u, o === 10 && (o = 13), 32 <= o || o === 13 ? o : 0
   }

   function Gc() {
      return !0
   }

   function Sh() {
      return !1
   }

   function ar(o) {
      function u(p, y, M, R, V) {
         this._reactName = p, this._targetInst = M, this.type = y, this.nativeEvent = R, this.target = V, this.currentTarget = null;
         for (var W in o) o.hasOwnProperty(W) && (p = o[W], this[W] = p ? p(R) : R[W]);
         return this.isDefaultPrevented = (R.defaultPrevented != null ? R.defaultPrevented : R.returnValue === !1) ? Gc : Sh, this.isPropagationStopped = Sh, this
      }
      return m(u.prototype, {
         preventDefault: function () {
            this.defaultPrevented = !0;
            var p = this.nativeEvent;
            p && (p.preventDefault ? p.preventDefault() : typeof p.returnValue != "unknown" && (p.returnValue = !1), this.isDefaultPrevented = Gc)
         },
         stopPropagation: function () {
            var p = this.nativeEvent;
            p && (p.stopPropagation ? p.stopPropagation() : typeof p.cancelBubble != "unknown" && (p.cancelBubble = !0), this.isPropagationStopped = Gc)
         },
         persist: function () {},
         isPersistent: Gc
      }), u
   }
   var Yl = {
         eventPhase: 0,
         bubbles: 0,
         cancelable: 0,
         timeStamp: function (o) {
            return o.timeStamp || Date.now()
         },
         defaultPrevented: 0,
         isTrusted: 0
      },
      kc = ar(Yl),
      jc = m({}, Yl, {
         view: 0,
         detail: 0
      }),
      Ux = ar(jc),
      al, qc, Xc, Wc = m({}, jc, {
         screenX: 0,
         screenY: 0,
         clientX: 0,
         clientY: 0,
         pageX: 0,
         pageY: 0,
         ctrlKey: 0,
         shiftKey: 0,
         altKey: 0,
         metaKey: 0,
         getModifierState: Th,
         button: 0,
         buttons: 0,
         relatedTarget: function (o) {
            return o.relatedTarget === void 0 ? o.fromElement === o.srcElement ? o.toElement : o.fromElement : o.relatedTarget
         },
         movementX: function (o) {
            return "movementX" in o ? o.movementX : (o !== Xc && (Xc && o.type === "mousemove" ? (al = o.screenX - Xc.screenX, qc = o.screenY - Xc.screenY) : qc = al = 0, Xc = o), al)
         },
         movementY: function (o) {
            return "movementY" in o ? o.movementY : qc
         }
      }),
      Kg = ar(Wc),
      Px = m({}, Wc, {
         dataTransfer: 0
      }),
      iE = ar(Px),
      Ps = m({}, jc, {
         relatedTarget: 0
      }),
      yp = ar(Ps),
      Lx = m({}, Yl, {
         animationName: 0,
         elapsedTime: 0,
         pseudoElement: 0
      }),
      Bx = ar(Lx),
      zx = m({}, Yl, {
         clipboardData: function (o) {
            return "clipboardData" in o ? o.clipboardData : window.clipboardData
         }
      }),
      Ix = ar(zx),
      bh = m({}, Yl, {
         data: 0
      }),
      xp = ar(bh),
      Fx = {
         Esc: "Escape",
         Spacebar: " ",
         Left: "ArrowLeft",
         Up: "ArrowUp",
         Right: "ArrowRight",
         Down: "ArrowDown",
         Del: "Delete",
         Win: "OS",
         Menu: "ContextMenu",
         Apps: "ContextMenu",
         Scroll: "ScrollLock",
         MozPrintableKey: "Unidentified"
      },
      Hx = {
         8: "Backspace",
         9: "Tab",
         12: "Clear",
         13: "Enter",
         16: "Shift",
         17: "Control",
         18: "Alt",
         19: "Pause",
         20: "CapsLock",
         27: "Escape",
         32: " ",
         33: "PageUp",
         34: "PageDown",
         35: "End",
         36: "Home",
         37: "ArrowLeft",
         38: "ArrowUp",
         39: "ArrowRight",
         40: "ArrowDown",
         45: "Insert",
         46: "Delete",
         112: "F1",
         113: "F2",
         114: "F3",
         115: "F4",
         116: "F5",
         117: "F6",
         118: "F7",
         119: "F8",
         120: "F9",
         121: "F10",
         122: "F11",
         123: "F12",
         144: "NumLock",
         145: "ScrollLock",
         224: "Meta"
      },
      Vx = {
         Alt: "altKey",
         Control: "ctrlKey",
         Meta: "metaKey",
         Shift: "shiftKey"
      };

   function Zg(o) {
      var u = this.nativeEvent;
      return u.getModifierState ? u.getModifierState(o) : (o = Vx[o]) ? !!u[o] : !1
   }

   function Th() {
      return Zg
   }
   var Gx = m({}, jc, {
         key: function (o) {
            if (o.key) {
               var u = Fx[o.key] || o.key;
               if (u !== "Unidentified") return u
            }
            return o.type === "keypress" ? (o = Wl(o), o === 13 ? "Enter" : String.fromCharCode(o)) : o.type === "keydown" || o.type === "keyup" ? Hx[o.keyCode] || "Unidentified" : ""
         },
         code: 0,
         location: 0,
         ctrlKey: 0,
         shiftKey: 0,
         altKey: 0,
         metaKey: 0,
         repeat: 0,
         locale: 0,
         getModifierState: Th,
         charCode: function (o) {
            return o.type === "keypress" ? Wl(o) : 0
         },
         keyCode: function (o) {
            return o.type === "keydown" || o.type === "keyup" ? o.keyCode : 0
         },
         which: function (o) {
            return o.type === "keypress" ? Wl(o) : o.type === "keydown" || o.type === "keyup" ? o.keyCode : 0
         }
      }),
      Qg = ar(Gx),
      Jg = m({}, Wc, {
         pointerId: 0,
         width: 0,
         height: 0,
         pressure: 0,
         tangentialPressure: 0,
         tiltX: 0,
         tiltY: 0,
         twist: 0,
         pointerType: 0,
         isPrimary: 0
      }),
      _p = ar(Jg),
      kx = m({}, jc, {
         touches: 0,
         targetTouches: 0,
         changedTouches: 0,
         altKey: 0,
         metaKey: 0,
         ctrlKey: 0,
         shiftKey: 0,
         getModifierState: Th
      }),
      $g = ar(kx),
      jx = m({}, Yl, {
         propertyName: 0,
         elapsedTime: 0,
         pseudoElement: 0
      }),
      ol = ar(jx),
      ev = m({}, Wc, {
         deltaX: function (o) {
            return "deltaX" in o ? o.deltaX : "wheelDeltaX" in o ? -o.wheelDeltaX : 0
         },
         deltaY: function (o) {
            return "deltaY" in o ? o.deltaY : "wheelDeltaY" in o ? -o.wheelDeltaY : "wheelDelta" in o ? -o.wheelDelta : 0
         },
         deltaZ: 0,
         deltaMode: 0
      }),
      sE = ar(ev),
      qx = m({}, Yl, {
         newState: 0,
         oldState: 0
      }),
      Kl = ar(qx),
      ll = [9, 13, 27, 32],
      Eh = To && "CompositionEvent" in window,
      Wu = null;
   To && "documentMode" in document && (Wu = document.documentMode);
   var Mh = To && "TextEvent" in window && !Wu,
      Ah = To && (!Eh || Wu && 8 < Wu && 11 >= Wu),
      Zl = " ",
      Ls = !1;

   function wh(o, u) {
      switch (o) {
         case "keyup":
            return ll.indexOf(u.keyCode) !== -1;
         case "keydown":
            return u.keyCode !== 229;
         case "keypress":
         case "mousedown":
         case "focusout":
            return !0;
         default:
            return !1
      }
   }

   function tv(o) {
      return o = o.detail, typeof o == "object" && "data" in o ? o.data : null
   }
   var Ql = !1;

   function Rh(o, u) {
      switch (o) {
         case "compositionend":
            return tv(u);
         case "keypress":
            return u.which !== 32 ? null : (Ls = !0, Zl);
         case "textInput":
            return o = u.data, o === Zl && Ls ? null : o;
         default:
            return null
      }
   }

   function nv(o, u) {
      if (Ql) return o === "compositionend" || !Eh && wh(o, u) ? (o = Yg(), vp = Wg = rl = null, Ql = !1, o) : null;
      switch (o) {
         case "paste":
            return null;
         case "keypress":
            if (!(u.ctrlKey || u.altKey || u.metaKey) || u.ctrlKey && u.altKey) {
               if (u.char && 1 < u.char.length) return u.char;
               if (u.which) return String.fromCharCode(u.which)
            }
            return null;
         case "compositionend":
            return Ah && u.locale !== "ko" ? null : u.data;
         default:
            return null
      }
   }
   var Sp = {
      color: !0,
      date: !0,
      datetime: !0,
      "datetime-local": !0,
      email: !0,
      month: !0,
      number: !0,
      password: !0,
      range: !0,
      search: !0,
      tel: !0,
      text: !0,
      time: !0,
      url: !0,
      week: !0
   };

   function iv(o) {
      var u = o && o.nodeName && o.nodeName.toLowerCase();
      return u === "input" ? !!Sp[o.type] : u === "textarea"
   }

   function yr(o, u, p, y) {
      Xl ? Xu ? Xu.push(y) : Xu = [y] : Xl = y, u = j_(u, "onChange"), 0 < u.length && (p = new kc("onChange", "change", null, p, y), o.push({
         event: p,
         listeners: u
      }))
   }
   var Yc = null,
      Yu = null;

   function Xx(o) {
      CC(o, 0)
   }

   function Ch(o) {
      var u = Zi(o);
      if (Ln(u)) return o
   }

   function bp(o, u) {
      if (o === "change") return u
   }
   var Tp = !1;
   if (To) {
      var Ep;
      if (To) {
         var Kc = "oninput" in document;
         if (!Kc) {
            var Zc = document.createElement("div");
            Zc.setAttribute("oninput", "return;"), Kc = typeof Zc.oninput == "function"
         }
         Ep = Kc
      } else Ep = !1;
      Tp = Ep && (!document.documentMode || 9 < document.documentMode)
   }

   function Ai() {
      Yc && (Yc.detachEvent("onpropertychange", Wx), Yu = Yc = null)
   }

   function Wx(o) {
      if (o.propertyName === "value" && Ch(Yu)) {
         var u = [];
         yr(u, Yu, o, gp(o)), Xg(Xx, u)
      }
   }

   function rE(o, u, p) {
      o === "focusin" ? (Ai(), Yc = u, Yu = p, Yc.attachEvent("onpropertychange", Wx)) : o === "focusout" && Ai()
   }

   function Yx(o) {
      if (o === "selectionchange" || o === "keyup" || o === "keydown") return Ch(Yu)
   }

   function Dh(o, u) {
      if (o === "click") return Ch(u)
   }

   function Jl(o, u) {
      if (o === "input" || o === "change") return Ch(u)
   }

   function Kx(o, u) {
      return o === u && (o !== 0 || 1 / o === 1 / u) || o !== o && u !== u
   }
   var xr = typeof Object.is == "function" ? Object.is : Kx;

   function qa(o, u) {
      if (xr(o, u)) return !0;
      if (typeof o != "object" || o === null || typeof u != "object" || u === null) return !1;
      var p = Object.keys(o),
         y = Object.keys(u);
      if (p.length !== y.length) return !1;
      for (y = 0; y < p.length; y++) {
         var M = p[y];
         if (!zt.call(u, M) || !xr(o[M], u[M])) return !1
      }
      return !0
   }

   function _r(o) {
      for (; o && o.firstChild;) o = o.firstChild;
      return o
   }

   function sv(o, u) {
      var p = _r(o);
      o = 0;
      for (var y; p;) {
         if (p.nodeType === 3) {
            if (y = o + p.textContent.length, o <= u && y >= u) return {
               node: p,
               offset: u - o
            };
            o = y
         }
         e: {
            for (; p;) {
               if (p.nextSibling) {
                  p = p.nextSibling;
                  break e
               }
               p = p.parentNode
            }
            p = void 0
         }
         p = _r(p)
      }
   }

   function rv(o, u) {
      return o && u ? o === u ? !0 : o && o.nodeType === 3 ? !1 : u && u.nodeType === 3 ? rv(o, u.parentNode) : "contains" in o ? o.contains(u) : o.compareDocumentPosition ? !!(o.compareDocumentPosition(u) & 16) : !1 : !1
   }

   function av(o) {
      o = o != null && o.ownerDocument != null && o.ownerDocument.defaultView != null ? o.ownerDocument.defaultView : window;
      for (var u = Os(o.document); u instanceof o.HTMLIFrameElement;) {
         try {
            var p = typeof u.contentWindow.location.href == "string"
         } catch {
            p = !1
         }
         if (p) o = u.contentWindow;
         else break;
         u = Os(o.document)
      }
      return u
   }

   function Nh(o) {
      var u = o && o.nodeName && o.nodeName.toLowerCase();
      return u && (u === "input" && (o.type === "text" || o.type === "search" || o.type === "tel" || o.type === "url" || o.type === "password") || u === "textarea" || o.contentEditable === "true")
   }
   var ov = To && "documentMode" in document && 11 >= document.documentMode,
      ul = null,
      Mp = null,
      Oh = null,
      Ap = !1;

   function lv(o, u, p) {
      var y = p.window === p ? p.document : p.nodeType === 9 ? p : p.ownerDocument;
      Ap || ul == null || ul !== Os(y) || (y = ul, "selectionStart" in y && Nh(y) ? y = {
         start: y.selectionStart,
         end: y.selectionEnd
      } : (y = (y.ownerDocument && y.ownerDocument.defaultView || window).getSelection(), y = {
         anchorNode: y.anchorNode,
         anchorOffset: y.anchorOffset,
         focusNode: y.focusNode,
         focusOffset: y.focusOffset
      }), Oh && qa(Oh, y) || (Oh = y, y = j_(Mp, "onSelect"), 0 < y.length && (u = new kc("onSelect", "select", null, u, p), o.push({
         event: u,
         listeners: y
      }), u.target = ul)))
   }

   function Bs(o, u) {
      var p = {};
      return p[o.toLowerCase()] = u.toLowerCase(), p["Webkit" + o] = "webkit" + u, p["Moz" + o] = "moz" + u, p
   }
   var $l = {
         animationend: Bs("Animation", "AnimationEnd"),
         animationiteration: Bs("Animation", "AnimationIteration"),
         animationstart: Bs("Animation", "AnimationStart"),
         transitionrun: Bs("Transition", "TransitionRun"),
         transitionstart: Bs("Transition", "TransitionStart"),
         transitioncancel: Bs("Transition", "TransitionCancel"),
         transitionend: Bs("Transition", "TransitionEnd")
      },
      wp = {},
      Zx = {};
   To && (Zx = document.createElement("div").style, "AnimationEvent" in window || (delete $l.animationend.animation, delete $l.animationiteration.animation, delete $l.animationstart.animation), "TransitionEvent" in window || delete $l.transitionend.transition);

   function cl(o) {
      if (wp[o]) return wp[o];
      if (!$l[o]) return o;
      var u = $l[o],
         p;
      for (p in u)
         if (u.hasOwnProperty(p) && p in Zx) return wp[o] = u[p];
      return o
   }
   var or = cl("animationend"),
      uv = cl("animationiteration"),
      Sr = cl("animationstart"),
      Qx = cl("transitionrun"),
      fl = cl("transitionstart"),
      Qc = cl("transitioncancel"),
      hl = cl("transitionend"),
      Rp = new Map,
      Uh = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
   Uh.push("scrollEnd");

   function xs(o, u) {
      Rp.set(o, u), ei(u, [o])
   }
   var cv = new WeakMap;

   function zs(o, u) {
      if (typeof o == "object" && o !== null) {
         var p = cv.get(o);
         return p !== void 0 ? p : (u = {
            value: o,
            source: u,
            stack: Mi(u)
         }, cv.set(o, u), u)
      }
      return {
         value: o,
         source: u,
         stack: Mi(u)
      }
   }
   var Ys = [],
      va = 0,
      Cp = 0;

   function Ph() {
      for (var o = va, u = Cp = va = 0; u < o;) {
         var p = Ys[u];
         Ys[u++] = null;
         var y = Ys[u];
         Ys[u++] = null;
         var M = Ys[u];
         Ys[u++] = null;
         var R = Ys[u];
         if (Ys[u++] = null, y !== null && M !== null) {
            var V = y.pending;
            V === null ? M.next = M : (M.next = V.next, V.next = M), y.pending = M
         }
         R !== 0 && fv(p, M, R)
      }
   }

   function eu(o, u, p, y) {
      Ys[va++] = o, Ys[va++] = u, Ys[va++] = p, Ys[va++] = y, Cp |= y, o.lanes |= y, o = o.alternate, o !== null && (o.lanes |= y)
   }

   function Dp(o, u, p, y) {
      return eu(o, u, p, y), Jc(o)
   }

   function dl(o, u) {
      return eu(o, null, null, u), Jc(o)
   }

   function fv(o, u, p) {
      o.lanes |= p;
      var y = o.alternate;
      y !== null && (y.lanes |= p);
      for (var M = !1, R = o.return; R !== null;) R.childLanes |= p, y = R.alternate, y !== null && (y.childLanes |= p), R.tag === 22 && (o = R.stateNode, o === null || o._visibility & 1 || (M = !0)), o = R, R = R.return;
      return o.tag === 3 ? (R = o.stateNode, M && u !== null && (M = 31 - Ze(p), o = R.hiddenUpdates, y = o[M], y === null ? o[M] = [u] : y.push(u), u.lane = p | 536870912), R) : null
   }

   function Jc(o) {
      if (50 < zo) throw zo = 0, hc = null, Error(i(185));
      for (var u = o.return; u !== null;) o = u, u = o.return;
      return o.tag === 3 ? o.stateNode : null
   }
   var tu = {};

   function hv(o, u, p, y) {
      this.tag = o, this.key = p, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = u, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = y, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null
   }

   function br(o, u, p, y) {
      return new hv(o, u, p, y)
   }

   function Lh(o) {
      return o = o.prototype, !(!o || !o.isReactComponent)
   }

   function Vi(o, u) {
      var p = o.alternate;
      return p === null ? (p = br(o.tag, u, o.key, o.mode), p.elementType = o.elementType, p.type = o.type, p.stateNode = o.stateNode, p.alternate = o, o.alternate = p) : (p.pendingProps = u, p.type = o.type, p.flags = 0, p.subtreeFlags = 0, p.deletions = null), p.flags = o.flags & 65011712, p.childLanes = o.childLanes, p.lanes = o.lanes, p.child = o.child, p.memoizedProps = o.memoizedProps, p.memoizedState = o.memoizedState, p.updateQueue = o.updateQueue, u = o.dependencies, p.dependencies = u === null ? null : {
         lanes: u.lanes,
         firstContext: u.firstContext
      }, p.sibling = o.sibling, p.index = o.index, p.ref = o.ref, p.refCleanup = o.refCleanup, p
   }

   function dv(o, u) {
      o.flags &= 65011714;
      var p = o.alternate;
      return p === null ? (o.childLanes = 0, o.lanes = u, o.child = null, o.subtreeFlags = 0, o.memoizedProps = null, o.memoizedState = null, o.updateQueue = null, o.dependencies = null, o.stateNode = null) : (o.childLanes = p.childLanes, o.lanes = p.lanes, o.child = p.child, o.subtreeFlags = 0, o.deletions = null, o.memoizedProps = p.memoizedProps, o.memoizedState = p.memoizedState, o.updateQueue = p.updateQueue, o.type = p.type, u = p.dependencies, o.dependencies = u === null ? null : {
         lanes: u.lanes,
         firstContext: u.firstContext
      }), o
   }

   function _s(o, u, p, y, M, R) {
      var V = 0;
      if (y = o, typeof o == "function") Lh(o) && (V = 1);
      else if (typeof o == "string") V = _H(o, p, oe.current) ? 26 : o === "html" || o === "head" || o === "body" ? 27 : 5;
      else e: switch (o) {
         case O:
            return o = br(31, p, u, M), o.elementType = O, o.lanes = R, o;
         case S:
            return nu(p.children, M, R, u);
         case E:
            V = 8, M |= 24;
            break;
         case T:
            return o = br(12, p, u, M | 2), o.elementType = T, o.lanes = R, o;
         case U:
            return o = br(13, p, u, M), o.elementType = U, o.lanes = R, o;
         case z:
            return o = br(19, p, u, M), o.elementType = z, o.lanes = R, o;
         default:
            if (typeof o == "object" && o !== null) switch (o.$$typeof) {
               case b:
               case C:
                  V = 10;
                  break e;
               case w:
                  V = 9;
                  break e;
               case N:
                  V = 11;
                  break e;
               case B:
                  V = 14;
                  break e;
               case I:
                  V = 16, y = null;
                  break e
            }
            V = 29, p = Error(i(130, o === null ? "null" : typeof o, "")), y = null
      }
      return u = br(V, p, u, M), u.elementType = o, u.type = y, u.lanes = R, u
   }

   function nu(o, u, p, y) {
      return o = br(7, o, y, u), o.lanes = p, o
   }

   function Bh(o, u, p) {
      return o = br(6, o, null, u), o.lanes = p, o
   }

   function Np(o, u, p) {
      return u = br(4, o.children !== null ? o.children : [], o.key, u), u.lanes = p, u.stateNode = {
         containerInfo: o.containerInfo,
         pendingChildren: null,
         implementation: o.implementation
      }, u
   }
   var $c = [],
      Tr = 0,
      zh = null,
      ef = 0,
      Is = [],
      Hr = 0,
      iu = null,
      Eo = 1,
      Mo = "";

   function pl(o, u) {
      $c[Tr++] = ef, $c[Tr++] = zh, zh = o, ef = u
   }

   function Op(o, u, p) {
      Is[Hr++] = Eo, Is[Hr++] = Mo, Is[Hr++] = iu, iu = o;
      var y = Eo;
      o = Mo;
      var M = 32 - Ze(y) - 1;
      y &= ~(1 << M), p += 1;
      var R = 32 - Ze(u) + M;
      if (30 < R) {
         var V = M - M % 5;
         R = (y & (1 << V) - 1).toString(32), y >>= V, M -= V, Eo = 1 << 32 - Ze(u) + M | p << M | y, Mo = R + o
      } else Eo = 1 << R | p << M | y, Mo = o
   }

   function pv(o) {
      o.return !== null && (pl(o, 1), Op(o, 1, 0))
   }

   function mv(o) {
      for (; o === zh;) zh = $c[--Tr], $c[Tr] = null, ef = $c[--Tr], $c[Tr] = null;
      for (; o === iu;) iu = Is[--Hr], Is[Hr] = null, Mo = Is[--Hr], Is[Hr] = null, Eo = Is[--Hr], Is[Hr] = null
   }
   var lr = null,
      Ci = null,
      jn = !1,
      ya = null,
      Vr = !1,
      Up = Error(i(519));

   function su(o) {
      var u = Error(i(418, ""));
      throw Ku(zs(u, o)), Up
   }

   function Jx(o) {
      var u = o.stateNode,
         p = o.type,
         y = o.memoizedProps;
      switch (u[Qe] = o, u[St] = y, p) {
         case "dialog":
            On("cancel", u), On("close", u);
            break;
         case "iframe":
         case "object":
         case "embed":
            On("load", u);
            break;
         case "video":
         case "audio":
            for (p = 0; p < Xv.length; p++) On(Xv[p], u);
            break;
         case "source":
            On("error", u);
            break;
         case "img":
         case "image":
         case "link":
            On("error", u), On("load", u);
            break;
         case "details":
            On("toggle", u);
            break;
         case "input":
            On("invalid", u), si(u, y.value, y.defaultValue, y.checked, y.defaultChecked, y.type, y.name, !0), Ri(u);
            break;
         case "select":
            On("invalid", u);
            break;
         case "textarea":
            On("invalid", u), ys(u, y.value, y.defaultValue, y.children), Ri(u)
      }
      p = y.children, typeof p != "string" && typeof p != "number" && typeof p != "bigint" || u.textContent === "" + p || y.suppressHydrationWarning === !0 || UC(u.textContent, p) ? (y.popover != null && (On("beforetoggle", u), On("toggle", u)), y.onScroll != null && On("scroll", u), y.onScrollEnd != null && On("scrollend", u), y.onClick != null && (u.onclick = q_), u = !0) : u = !1, u || su(o)
   }

   function gv(o) {
      for (lr = o.return; lr;) switch (lr.tag) {
         case 5:
         case 13:
            Vr = !1;
            return;
         case 27:
         case 3:
            Vr = !0;
            return;
         default:
            lr = lr.return
      }
   }

   function Xa(o) {
      if (o !== lr) return !1;
      if (!jn) return gv(o), jn = !0, !1;
      var u = o.tag,
         p;
      if ((p = u !== 3 && u !== 27) && ((p = u === 5) && (p = o.type, p = !(p !== "form" && p !== "button") || ME(o.type, o.memoizedProps)), p = !p), p && Ci && su(o), gv(o), u === 13) {
         if (o = o.memoizedState, o = o !== null ? o.dehydrated : null, !o) throw Error(i(317));
         e: {
            for (o = o.nextSibling, u = 0; o;) {
               if (o.nodeType === 8)
                  if (p = o.data, p === "/$") {
                     if (u === 0) {
                        Ci = Rl(o.nextSibling);
                        break e
                     }
                     u--
                  } else p !== "$" && p !== "$!" && p !== "$?" || u++;
               o = o.nextSibling
            }
            Ci = null
         }
      } else u === 27 ? (u = Ci, Af(o.type) ? (o = CE, CE = null, Ci = o) : Ci = u) : Ci = lr ? Rl(o.stateNode.nextSibling) : null;
      return !0
   }

   function tf() {
      Ci = lr = null, jn = !1
   }

   function Kn() {
      var o = ya;
      return o !== null && (Vt === null ? Vt = o : Vt.push.apply(Vt, o), ya = null), o
   }

   function Ku(o) {
      ya === null ? ya = [o] : ya.push(o)
   }
   var vv = ie(null),
      ru = null,
      ml = null;

   function au(o, u, p) {
      we(vv, u._currentValue), u._currentValue = p
   }

   function gl(o) {
      o._currentValue = vv.current, ye(vv)
   }

   function yv(o, u, p) {
      for (; o !== null;) {
         var y = o.alternate;
         if ((o.childLanes & u) !== u ? (o.childLanes |= u, y !== null && (y.childLanes |= u)) : y !== null && (y.childLanes & u) !== u && (y.childLanes |= u), o === p) break;
         o = o.return
      }
   }

   function Ih(o, u, p, y) {
      var M = o.child;
      for (M !== null && (M.return = o); M !== null;) {
         var R = M.dependencies;
         if (R !== null) {
            var V = M.child;
            R = R.firstContext;
            e: for (; R !== null;) {
               var W = R;
               R = M;
               for (var se = 0; se < u.length; se++)
                  if (W.context === u[se]) {
                     R.lanes |= p, W = R.alternate, W !== null && (W.lanes |= p), yv(R.return, p, o), y || (V = null);
                     break e
                  } R = W.next
            }
         } else if (M.tag === 18) {
            if (V = M.return, V === null) throw Error(i(341));
            V.lanes |= p, R = V.alternate, R !== null && (R.lanes |= p), yv(V, p, o), V = null
         } else V = M.child;
         if (V !== null) V.return = M;
         else
            for (V = M; V !== null;) {
               if (V === o) {
                  V = null;
                  break
               }
               if (M = V.sibling, M !== null) {
                  M.return = V.return, V = M;
                  break
               }
               V = V.return
            }
         M = V
      }
   }

   function xa(o, u, p, y) {
      o = null;
      for (var M = u, R = !1; M !== null;) {
         if (!R) {
            if ((M.flags & 524288) !== 0) R = !0;
            else if ((M.flags & 262144) !== 0) break
         }
         if (M.tag === 10) {
            var V = M.alternate;
            if (V === null) throw Error(i(387));
            if (V = V.memoizedProps, V !== null) {
               var W = M.type;
               xr(M.pendingProps.value, V.value) || (o !== null ? o.push(W) : o = [W])
            }
         } else if (M === Ge.current) {
            if (V = M.alternate, V === null) throw Error(i(387));
            V.memoizedState.memoizedState !== M.memoizedState.memoizedState && (o !== null ? o.push(Jv) : o = [Jv])
         }
         M = M.return
      }
      o !== null && Ih(u, o, p, y), u.flags |= 262144
   }

   function Fh(o) {
      for (o = o.firstContext; o !== null;) {
         if (!xr(o.context._currentValue, o.memoizedValue)) return !0;
         o = o.next
      }
      return !1
   }

   function Ao(o) {
      ru = o, ml = null, o = o.dependencies, o !== null && (o.firstContext = null)
   }

   function Oi(o) {
      return Pp(ru, o)
   }

   function Hh(o, u) {
      return ru === null && Ao(o), Pp(o, u)
   }

   function Pp(o, u) {
      var p = u._currentValue;
      if (u = {
            context: u,
            memoizedValue: p,
            next: null
         }, ml === null) {
         if (o === null) throw Error(i(308));
         ml = u, o.dependencies = {
            lanes: 0,
            firstContext: u
         }, o.flags |= 524288
      } else ml = ml.next = u;
      return p
   }
   var xv = typeof AbortController < "u" ? AbortController : function () {
         var o = [],
            u = this.signal = {
               aborted: !1,
               addEventListener: function (p, y) {
                  o.push(y)
               }
            };
         this.abort = function () {
            u.aborted = !0, o.forEach(function (p) {
               return p()
            })
         }
      },
      aE = n.unstable_scheduleCallback,
      $x = n.unstable_NormalPriority,
      Ji = {
         $$typeof: C,
         Consumer: null,
         Provider: null,
         _currentValue: null,
         _currentValue2: null,
         _threadCount: 0
      };

   function Lp() {
      return {
         controller: new xv,
         data: new Map,
         refCount: 0
      }
   }

   function nf(o) {
      o.refCount--, o.refCount === 0 && aE($x, function () {
         o.controller.abort()
      })
   }
   var sf = null,
      Vh = 0,
      rn = 0,
      rf = null;

   function Gr(o, u) {
      if (sf === null) {
         var p = sf = [];
         Vh = 0, rn = gE(), rf = {
            status: "pending",
            value: void 0,
            then: function (y) {
               p.push(y)
            }
         }
      }
      return Vh++, u.then(Bp, Bp), u
   }

   function Bp() {
      if (--Vh === 0 && sf !== null) {
         rf !== null && (rf.status = "fulfilled");
         var o = sf;
         sf = null, rn = 0, rf = null;
         for (var u = 0; u < o.length; u++)(0, o[u])()
      }
   }

   function oE(o, u) {
      var p = [],
         y = {
            status: "pending",
            value: null,
            reason: null,
            then: function (M) {
               p.push(M)
            }
         };
      return o.then(function () {
         y.status = "fulfilled", y.value = u;
         for (var M = 0; M < p.length; M++)(0, p[M])(u)
      }, function (M) {
         for (y.status = "rejected", y.reason = M, M = 0; M < p.length; M++)(0, p[M])(void 0)
      }), y
   }
   var Gh = k.S;
   k.S = function (o, u) {
      typeof u == "object" && u !== null && typeof u.then == "function" && Gr(o, u), Gh !== null && Gh(o, u)
   };
   var _a = ie(null);

   function ou() {
      var o = _a.current;
      return o !== null ? o : en.pooledCache
   }

   function kh(o, u) {
      u === null ? we(_a, _a.current) : we(_a, u.pool)
   }

   function zp() {
      var o = ou();
      return o === null ? null : {
         parent: Ji._currentValue,
         pool: o
      }
   }
   var jh = Error(i(460)),
      _v = Error(i(474)),
      Wa = Error(i(542)),
      qh = {
         then: function () {}
      };

   function Ip(o) {
      return o = o.status, o === "fulfilled" || o === "rejected"
   }

   function af() {}

   function Fp(o, u, p) {
      switch (p = o[p], p === void 0 ? o.push(u) : p !== u && (u.then(af, af), u = p), u.status) {
         case "fulfilled":
            return u.value;
         case "rejected":
            throw o = u.reason, e_(o), o;
         default:
            if (typeof u.status == "string") u.then(af, af);
            else {
               if (o = en, o !== null && 100 < o.shellSuspendCounter) throw Error(i(482));
               o = u, o.status = "pending", o.then(function (y) {
                  if (u.status === "pending") {
                     var M = u;
                     M.status = "fulfilled", M.value = y
                  }
               }, function (y) {
                  if (u.status === "pending") {
                     var M = u;
                     M.status = "rejected", M.reason = y
                  }
               })
            }
            switch (u.status) {
               case "fulfilled":
                  return u.value;
               case "rejected":
                  throw o = u.reason, e_(o), o
            }
            throw Sa = u, jh
      }
   }
   var Sa = null;

   function Sv() {
      if (Sa === null) throw Error(i(459));
      var o = Sa;
      return Sa = null, o
   }

   function e_(o) {
      if (o === jh || o === Wa) throw Error(i(483))
   }
   var vl = !1;

   function bv(o) {
      o.updateQueue = {
         baseState: o.memoizedState,
         firstBaseUpdate: null,
         lastBaseUpdate: null,
         shared: {
            pending: null,
            lanes: 0,
            hiddenCallbacks: null
         },
         callbacks: null
      }
   }

   function Yt(o, u) {
      o = o.updateQueue, u.updateQueue === o && (u.updateQueue = {
         baseState: o.baseState,
         firstBaseUpdate: o.firstBaseUpdate,
         lastBaseUpdate: o.lastBaseUpdate,
         shared: o.shared,
         callbacks: null
      })
   }

   function wo(o) {
      return {
         lane: o,
         tag: 0,
         payload: null,
         callback: null,
         next: null
      }
   }

   function yl(o, u, p) {
      var y = o.updateQueue;
      if (y === null) return null;
      if (y = y.shared, (Zn & 2) !== 0) {
         var M = y.pending;
         return M === null ? u.next = u : (u.next = M.next, M.next = u), y.pending = u, u = Jc(o), fv(o, null, p), u
      }
      return eu(o, y, u, p), Jc(o)
   }

   function Zu(o, u, p) {
      if (u = u.updateQueue, u !== null && (u = u.shared, (p & 4194048) !== 0)) {
         var y = u.lanes;
         y &= o.pendingLanes, p |= y, u.lanes = p, Bt(o, p)
      }
   }

   function of (o, u) {
      var p = o.updateQueue,
         y = o.alternate;
      if (y !== null && (y = y.updateQueue, p === y)) {
         var M = null,
            R = null;
         if (p = p.firstBaseUpdate, p !== null) {
            do {
               var V = {
                  lane: p.lane,
                  tag: p.tag,
                  payload: p.payload,
                  callback: null,
                  next: null
               };
               R === null ? M = R = V : R = R.next = V, p = p.next
            } while (p !== null);
            R === null ? M = R = u : R = R.next = u
         } else M = R = u;
         p = {
            baseState: y.baseState,
            firstBaseUpdate: M,
            lastBaseUpdate: R,
            shared: y.shared,
            callbacks: y.callbacks
         }, o.updateQueue = p;
         return
      }
      o = p.lastBaseUpdate, o === null ? p.firstBaseUpdate = u : o.next = u, p.lastBaseUpdate = u
   }
   var Tv = !1;

   function Xh() {
      if (Tv) {
         var o = rf;
         if (o !== null) throw o
      }
   }

   function lf(o, u, p, y) {
      Tv = !1;
      var M = o.updateQueue;
      vl = !1;
      var R = M.firstBaseUpdate,
         V = M.lastBaseUpdate,
         W = M.shared.pending;
      if (W !== null) {
         M.shared.pending = null;
         var se = W,
            Se = se.next;
         se.next = null, V === null ? R = Se : V.next = Se, V = se;
         var Ve = o.alternate;
         Ve !== null && (Ve = Ve.updateQueue, W = Ve.lastBaseUpdate, W !== V && (W === null ? Ve.firstBaseUpdate = Se : W.next = Se, Ve.lastBaseUpdate = se))
      }
      if (R !== null) {
         var qe = M.baseState;
         V = 0, Ve = Se = se = null, W = R;
         do {
            var Me = W.lane & -536870913,
               Ae = Me !== W.lane;
            if (Ae ? (Lt & Me) === Me : (y & Me) === Me) {
               Me !== 0 && Me === rn && (Tv = !0), Ve !== null && (Ve = Ve.next = {
                  lane: 0,
                  tag: W.tag,
                  payload: W.payload,
                  callback: null,
                  next: null
               });
               e: {
                  var Qt = o,
                     Gt = W;Me = u;
                  var yi = p;
                  switch (Gt.tag) {
                     case 1:
                        if (Qt = Gt.payload, typeof Qt == "function") {
                           qe = Qt.call(yi, qe, Me);
                           break e
                        }
                        qe = Qt;
                        break e;
                     case 3:
                        Qt.flags = Qt.flags & -65537 | 128;
                     case 0:
                        if (Qt = Gt.payload, Me = typeof Qt == "function" ? Qt.call(yi, qe, Me) : Qt, Me == null) break e;
                        qe = m({}, qe, Me);
                        break e;
                     case 2:
                        vl = !0
                  }
               }
               Me = W.callback, Me !== null && (o.flags |= 64, Ae && (o.flags |= 8192), Ae = M.callbacks, Ae === null ? M.callbacks = [Me] : Ae.push(Me))
            } else Ae = {
               lane: Me,
               tag: W.tag,
               payload: W.payload,
               callback: W.callback,
               next: null
            }, Ve === null ? (Se = Ve = Ae, se = qe) : Ve = Ve.next = Ae, V |= Me;
            if (W = W.next, W === null) {
               if (W = M.shared.pending, W === null) break;
               Ae = W, W = Ae.next, Ae.next = null, M.lastBaseUpdate = Ae, M.shared.pending = null
            }
         } while (!0);
         Ve === null && (se = qe), M.baseState = se, M.firstBaseUpdate = Se, M.lastBaseUpdate = Ve, R === null && (M.shared.lanes = 0), to |= V, o.lanes = V, o.memoizedState = qe
      }
   }

   function uf(o, u) {
      if (typeof o != "function") throw Error(i(191, o));
      o.call(u)
   }

   function t_(o, u) {
      var p = o.callbacks;
      if (p !== null)
         for (o.callbacks = null, o = 0; o < p.length; o++) uf(p[o], u)
   }
   var cf = ie(null),
      Hp = ie(0);

   function n_(o, u) {
      o = wa, we(Hp, o), we(cf, u), wa = o | u.baseLanes
   }

   function Ev() {
      we(Hp, wa), we(cf, cf.current)
   }

   function Wh() {
      wa = Hp.current, ye(cf), ye(Hp)
   }
   var xl = 0,
      an = null,
      ti = null,
      $i = null,
      Vp = !1,
      lu = !1,
      ur = !1,
      as = 0,
      ba = 0,
      Fs = null,
      i_ = 0;

   function Gi() {
      throw Error(i(321))
   }

   function Ks(o, u) {
      if (u === null) return !1;
      for (var p = 0; p < u.length && p < o.length; p++)
         if (!xr(o[p], u[p])) return !1;
      return !0
   }

   function _l(o, u, p, y, M, R) {
      return xl = R, an = u, u.memoizedState = null, u.updateQueue = null, u.lanes = 0, k.H = o === null || o.memoizedState === null ? Zp : Hv, ur = !1, R = p(y, M), ur = !1, lu && (R = r_(u, p, y, M)), s_(o), R
   }

   function s_(o) {
      k.H = Zh;
      var u = ti !== null && ti.next !== null;
      if (xl = 0, $i = ti = an = null, Vp = !1, ba = 0, Fs = null, u) throw Error(i(300));
      o === null || Ss || (o = o.dependencies, o !== null && Fh(o) && (Ss = !0))
   }

   function r_(o, u, p, y) {
      an = o;
      var M = 0;
      do {
         if (lu && (Fs = null), ba = 0, lu = !1, 25 <= M) throw Error(i(301));
         if (M += 1, $i = ti = null, o.updateQueue != null) {
            var R = o.updateQueue;
            R.lastEffect = null, R.events = null, R.stores = null, R.memoCache != null && (R.memoCache.index = 0)
         }
         k.H = N_, R = u(p, y)
      } while (lu);
      return R
   }

   function lE() {
      var o = k.H,
         u = o.useState()[0];
      return u = typeof u.then == "function" ? Ya(u) : u, o = o.useState()[0], (ti !== null ? ti.memoizedState : null) !== o && (an.flags |= 1024), u
   }

   function Mv() {
      var o = as !== 0;
      return as = 0, o
   }

   function Gp(o, u, p) {
      u.updateQueue = o.updateQueue, u.flags &= -2053, o.lanes &= ~p
   }

   function Av(o) {
      if (Vp) {
         for (o = o.memoizedState; o !== null;) {
            var u = o.queue;
            u !== null && (u.pending = null), o = o.next
         }
         Vp = !1
      }
      xl = 0, $i = ti = an = null, lu = !1, ba = as = 0, Fs = null
   }

   function cr() {
      var o = {
         memoizedState: null,
         baseState: null,
         baseQueue: null,
         queue: null,
         next: null
      };
      return $i === null ? an.memoizedState = $i = o : $i = $i.next = o, $i
   }

   function es() {
      if (ti === null) {
         var o = an.alternate;
         o = o !== null ? o.memoizedState : null
      } else o = ti.next;
      var u = $i === null ? an.memoizedState : $i.next;
      if (u !== null) $i = u, ti = o;
      else {
         if (o === null) throw an.alternate === null ? Error(i(467)) : Error(i(310));
         ti = o, o = {
            memoizedState: ti.memoizedState,
            baseState: ti.baseState,
            baseQueue: ti.baseQueue,
            queue: ti.queue,
            next: null
         }, $i === null ? an.memoizedState = $i = o : $i = $i.next = o
      }
      return $i
   }

   function uu() {
      return {
         lastEffect: null,
         events: null,
         stores: null,
         memoCache: null
      }
   }

   function Ya(o) {
      var u = ba;
      return ba += 1, Fs === null && (Fs = []), o = Fp(Fs, o, u), u = an, ($i === null ? u.memoizedState : $i.next) === null && (u = u.alternate, k.H = u === null || u.memoizedState === null ? Zp : Hv), o
   }

   function kp(o) {
      if (o !== null && typeof o == "object") {
         if (typeof o.then == "function") return Ya(o);
         if (o.$$typeof === C) return Oi(o)
      }
      throw Error(i(438, String(o)))
   }

   function wv(o) {
      var u = null,
         p = an.updateQueue;
      if (p !== null && (u = p.memoCache), u == null) {
         var y = an.alternate;
         y !== null && (y = y.updateQueue, y !== null && (y = y.memoCache, y != null && (u = {
            data: y.data.map(function (M) {
               return M.slice()
            }),
            index: 0
         })))
      }
      if (u == null && (u = {
            data: [],
            index: 0
         }), p === null && (p = uu(), an.updateQueue = p), p.memoCache = u, p = u.data[u.index], p === void 0)
         for (p = u.data[u.index] = Array(o), y = 0; y < o; y++) p[y] = P;
      return u.index++, p
   }

   function Sl(o, u) {
      return typeof u == "function" ? u(o) : u
   }

   function cu(o) {
      var u = es();
      return Rv(u, ti, o)
   }

   function Rv(o, u, p) {
      var y = o.queue;
      if (y === null) throw Error(i(311));
      y.lastRenderedReducer = p;
      var M = o.baseQueue,
         R = y.pending;
      if (R !== null) {
         if (M !== null) {
            var V = M.next;
            M.next = R.next, R.next = V
         }
         u.baseQueue = M = R, y.pending = null
      }
      if (R = o.baseState, M === null) o.memoizedState = R;
      else {
         u = M.next;
         var W = V = null,
            se = null,
            Se = u,
            Ve = !1;
         do {
            var qe = Se.lane & -536870913;
            if (qe !== Se.lane ? (Lt & qe) === qe : (xl & qe) === qe) {
               var Me = Se.revertLane;
               if (Me === 0) se !== null && (se = se.next = {
                  lane: 0,
                  revertLane: 0,
                  action: Se.action,
                  hasEagerState: Se.hasEagerState,
                  eagerState: Se.eagerState,
                  next: null
               }), qe === rn && (Ve = !0);
               else if ((xl & Me) === Me) {
                  Se = Se.next, Me === rn && (Ve = !0);
                  continue
               } else qe = {
                  lane: 0,
                  revertLane: Se.revertLane,
                  action: Se.action,
                  hasEagerState: Se.hasEagerState,
                  eagerState: Se.eagerState,
                  next: null
               }, se === null ? (W = se = qe, V = R) : se = se.next = qe, an.lanes |= Me, to |= Me;
               qe = Se.action, ur && p(R, qe), R = Se.hasEagerState ? Se.eagerState : p(R, qe)
            } else Me = {
               lane: qe,
               revertLane: Se.revertLane,
               action: Se.action,
               hasEagerState: Se.hasEagerState,
               eagerState: Se.eagerState,
               next: null
            }, se === null ? (W = se = Me, V = R) : se = se.next = Me, an.lanes |= qe, to |= qe;
            Se = Se.next
         } while (Se !== null && Se !== u);
         if (se === null ? V = R : se.next = W, !xr(R, o.memoizedState) && (Ss = !0, Ve && (p = rf, p !== null))) throw p;
         o.memoizedState = R, o.baseState = V, o.baseQueue = se, y.lastRenderedState = R
      }
      return M === null && (y.lanes = 0), [o.memoizedState, y.dispatch]
   }

   function Cv(o) {
      var u = es(),
         p = u.queue;
      if (p === null) throw Error(i(311));
      p.lastRenderedReducer = o;
      var y = p.dispatch,
         M = p.pending,
         R = u.memoizedState;
      if (M !== null) {
         p.pending = null;
         var V = M = M.next;
         do R = o(R, V.action), V = V.next; while (V !== M);
         xr(R, u.memoizedState) || (Ss = !0), u.memoizedState = R, u.baseQueue === null && (u.baseState = R), p.lastRenderedState = R
      }
      return [R, y]
   }

   function a_(o, u, p) {
      var y = an,
         M = es(),
         R = jn;
      if (R) {
         if (p === void 0) throw Error(i(407));
         p = p()
      } else p = u();
      var V = !xr((ti || M).memoizedState, p);
      V && (M.memoizedState = p, Ss = !0), M = M.queue;
      var W = l_.bind(null, y, M, o);
      if (df(2048, 8, W, [o]), M.getSnapshot !== u || V || $i !== null && $i.memoizedState.tag & 1) {
         if (y.flags |= 2048, hf(9, Yh(), o_.bind(null, y, M, p, u), null), en === null) throw Error(i(349));
         R || (xl & 124) !== 0 || ff(y, u, p)
      }
      return p
   }

   function ff(o, u, p) {
      o.flags |= 16384, o = {
         getSnapshot: u,
         value: p
      }, u = an.updateQueue, u === null ? (u = uu(), an.updateQueue = u, u.stores = [o]) : (p = u.stores, p === null ? u.stores = [o] : p.push(o))
   }

   function o_(o, u, p, y) {
      u.value = p, u.getSnapshot = y, u_(u) && c_(o)
   }

   function l_(o, u, p) {
      return p(function () {
         u_(u) && c_(o)
      })
   }

   function u_(o) {
      var u = o.getSnapshot;
      o = o.value;
      try {
         var p = u();
         return !xr(o, p)
      } catch {
         return !0
      }
   }

   function c_(o) {
      var u = dl(o, 2);
      u !== null && dr(u, o, 2)
   }

   function Dv(o) {
      var u = cr();
      if (typeof o == "function") {
         var p = o;
         if (o = p(), ur) {
            We(!0);
            try {
               p()
            } finally {
               We(!1)
            }
         }
      }
      return u.memoizedState = u.baseState = o, u.queue = {
         pending: null,
         lanes: 0,
         dispatch: null,
         lastRenderedReducer: Sl,
         lastRenderedState: o
      }, u
   }

   function f_(o, u, p, y) {
      return o.baseState = p, Rv(o, ti, typeof y == "function" ? y : Sl)
   }

   function uE(o, u, p, y, M) {
      if (Kp(o)) throw Error(i(485));
      if (o = u.action, o !== null) {
         var R = {
            payload: M,
            action: o,
            next: null,
            isTransition: !0,
            status: "pending",
            value: null,
            reason: null,
            listeners: [],
            then: function (V) {
               R.listeners.push(V)
            }
         };
         k.T !== null ? p(!0) : R.isTransition = !1, y(R), p = u.pending, p === null ? (R.next = u.pending = R, h_(u, R)) : (R.next = p.next, u.pending = p.next = R)
      }
   }

   function h_(o, u) {
      var p = u.action,
         y = u.payload,
         M = o.state;
      if (u.isTransition) {
         var R = k.T,
            V = {};
         k.T = V;
         try {
            var W = p(M, y),
               se = k.S;
            se !== null && se(V, W), d_(o, u, W)
         } catch (Se) {
            Nv(o, u, Se)
         } finally {
            k.T = R
         }
      } else try {
         R = p(M, y), d_(o, u, R)
      } catch (Se) {
         Nv(o, u, Se)
      }
   }

   function d_(o, u, p) {
      p !== null && typeof p == "object" && typeof p.then == "function" ? p.then(function (y) {
         p_(o, u, y)
      }, function (y) {
         return Nv(o, u, y)
      }) : p_(o, u, p)
   }

   function p_(o, u, p) {
      u.status = "fulfilled", u.value = p, m_(u), o.state = p, u = o.pending, u !== null && (p = u.next, p === u ? o.pending = null : (p = p.next, u.next = p, h_(o, p)))
   }

   function Nv(o, u, p) {
      var y = o.pending;
      if (o.pending = null, y !== null) {
         y = y.next;
         do u.status = "rejected", u.reason = p, m_(u), u = u.next; while (u !== y)
      }
      o.action = null
   }

   function m_(o) {
      o = o.listeners;
      for (var u = 0; u < o.length; u++)(0, o[u])()
   }

   function Ov(o, u) {
      return u
   }

   function g_(o, u) {
      if (jn) {
         var p = en.formState;
         if (p !== null) {
            e: {
               var y = an;
               if (jn) {
                  if (Ci) {
                     t: {
                        for (var M = Ci, R = Vr; M.nodeType !== 8;) {
                           if (!R) {
                              M = null;
                              break t
                           }
                           if (M = Rl(M.nextSibling), M === null) {
                              M = null;
                              break t
                           }
                        }
                        R = M.data,
                        M = R === "F!" || R === "F" ? M : null
                     }
                     if (M) {
                        Ci = Rl(M.nextSibling), y = M.data === "F!";
                        break e
                     }
                  }
                  su(y)
               }
               y = !1
            }
            y && (u = p[0])
         }
      }
      return p = cr(), p.memoizedState = p.baseState = u, y = {
         pending: null,
         lanes: 0,
         dispatch: null,
         lastRenderedReducer: Ov,
         lastRenderedState: u
      }, p.queue = y, p = C_.bind(null, an, y), y.dispatch = p, y = Dv(!1), R = Yp.bind(null, an, !1, y.queue), y = cr(), M = {
         state: u,
         dispatch: null,
         action: o,
         pending: null
      }, y.queue = M, p = uE.bind(null, an, M, R, p), M.dispatch = p, y.memoizedState = o, [u, p, !1]
   }

   function v_(o) {
      var u = es();
      return y_(u, ti, o)
   }

   function y_(o, u, p) {
      if (u = Rv(o, u, Ov)[0], o = cu(Sl)[0], typeof u == "object" && u !== null && typeof u.then == "function") try {
         var y = Ya(u)
      } catch (V) {
         throw V === jh ? Wa : V
      } else y = u;
      u = es();
      var M = u.queue,
         R = M.dispatch;
      return p !== u.memoizedState && (an.flags |= 2048, hf(9, Yh(), cE.bind(null, M, p), null)), [y, R, o]
   }

   function cE(o, u) {
      o.action = u
   }

   function x_(o) {
      var u = es(),
         p = ti;
      if (p !== null) return y_(u, p, o);
      es(), u = u.memoizedState, p = es();
      var y = p.queue.dispatch;
      return p.memoizedState = o, [u, y, !1]
   }

   function hf(o, u, p, y) {
      return o = {
         tag: o,
         create: p,
         deps: y,
         inst: u,
         next: null
      }, u = an.updateQueue, u === null && (u = uu(), an.updateQueue = u), p = u.lastEffect, p === null ? u.lastEffect = o.next = o : (y = p.next, p.next = o, o.next = y, u.lastEffect = o), o
   }

   function Yh() {
      return {
         destroy: void 0,
         resource: void 0
      }
   }

   function Uv() {
      return es().memoizedState
   }

   function jp(o, u, p, y) {
      var M = cr();
      y = y === void 0 ? null : y, an.flags |= o, M.memoizedState = hf(1 | u, Yh(), p, y)
   }

   function df(o, u, p, y) {
      var M = es();
      y = y === void 0 ? null : y;
      var R = M.memoizedState.inst;
      ti !== null && y !== null && Ks(y, ti.memoizedState.deps) ? M.memoizedState = hf(u, R, p, y) : (an.flags |= o, M.memoizedState = hf(1 | u, R, p, y))
   }

   function Pv(o, u) {
      jp(8390656, 8, o, u)
   }

   function Lv(o, u) {
      df(2048, 8, o, u)
   }

   function qp(o, u) {
      return df(4, 2, o, u)
   }

   function Xp(o, u) {
      return df(4, 4, o, u)
   }

   function __(o, u) {
      if (typeof u == "function") {
         o = o();
         var p = u(o);
         return function () {
            typeof p == "function" ? p() : u(null)
         }
      }
      if (u != null) return o = o(), u.current = o,
         function () {
            u.current = null
         }
   }

   function S_(o, u, p) {
      p = p != null ? p.concat([o]) : null, df(4, 4, __.bind(null, u, o), p)
   }

   function Bv() {}

   function b_(o, u) {
      var p = es();
      u = u === void 0 ? null : u;
      var y = p.memoizedState;
      return u !== null && Ks(u, y[1]) ? y[0] : (p.memoizedState = [o, u], o)
   }

   function zv(o, u) {
      var p = es();
      u = u === void 0 ? null : u;
      var y = p.memoizedState;
      if (u !== null && Ks(u, y[1])) return y[0];
      if (y = o(), ur) {
         We(!0);
         try {
            o()
         } finally {
            We(!1)
         }
      }
      return p.memoizedState = [y, u], y
   }

   function Wp(o, u, p) {
      return p === void 0 || (xl & 1073741824) !== 0 ? o.memoizedState = u : (o.memoizedState = p, o = om(), an.lanes |= o, to |= o, p)
   }

   function T_(o, u, p, y) {
      return xr(p, u) ? p : cf.current !== null ? (o = Wp(o, p, y), xr(o, u) || (Ss = !0), o) : (xl & 42) === 0 ? (Ss = !0, o.memoizedState = p) : (o = om(), an.lanes |= o, to |= o, u)
   }

   function E_(o, u, p, y, M) {
      var R = Z.p;
      Z.p = R !== 0 && 8 > R ? R : 8;
      var V = k.T,
         W = {};
      k.T = W, Yp(o, !1, u, p);
      try {
         var se = M(),
            Se = k.S;
         if (Se !== null && Se(W, se), se !== null && typeof se == "object" && typeof se.then == "function") {
            var Ve = oE(se, y);
            Kh(o, u, Ve, Li(o))
         } else Kh(o, u, y, Li(o))
      } catch (qe) {
         Kh(o, u, {
            then: function () {},
            status: "rejected",
            reason: qe
         }, Li())
      } finally {
         Z.p = R, k.T = V
      }
   }

   function fE() {}

   function Iv(o, u, p, y) {
      if (o.tag !== 5) throw Error(i(476));
      var M = M_(o).queue;
      E_(o, M, u, J, p === null ? fE : function () {
         return A_(o), p(y)
      })
   }

   function M_(o) {
      var u = o.memoizedState;
      if (u !== null) return u;
      u = {
         memoizedState: J,
         baseState: J,
         baseQueue: null,
         queue: {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: Sl,
            lastRenderedState: J
         },
         next: null
      };
      var p = {};
      return u.next = {
         memoizedState: p,
         baseState: p,
         baseQueue: null,
         queue: {
            pending: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: Sl,
            lastRenderedState: p
         },
         next: null
      }, o.memoizedState = u, o = o.alternate, o !== null && (o.memoizedState = u), u
   }

   function A_(o) {
      var u = M_(o).next.queue;
      Kh(o, u, {}, Li())
   }

   function Fv() {
      return Oi(Jv)
   }

   function w_() {
      return es().memoizedState
   }

   function R_() {
      return es().memoizedState
   }

   function hE(o) {
      for (var u = o.return; u !== null;) {
         switch (u.tag) {
            case 24:
            case 3:
               var p = Li();
               o = wo(p);
               var y = yl(u, o, p);
               y !== null && (dr(y, u, p), Zu(y, u, p)), u = {
                  cache: Lp()
               }, o.payload = u;
               return
         }
         u = u.return
      }
   }

   function dE(o, u, p) {
      var y = Li();
      p = {
         lane: y,
         revertLane: 0,
         action: p,
         hasEagerState: !1,
         eagerState: null,
         next: null
      }, Kp(o) ? D_(u, p) : (p = Dp(o, u, p, y), p !== null && (dr(p, o, y), kr(p, u, y)))
   }

   function C_(o, u, p) {
      var y = Li();
      Kh(o, u, p, y)
   }

   function Kh(o, u, p, y) {
      var M = {
         lane: y,
         revertLane: 0,
         action: p,
         hasEagerState: !1,
         eagerState: null,
         next: null
      };
      if (Kp(o)) D_(u, M);
      else {
         var R = o.alternate;
         if (o.lanes === 0 && (R === null || R.lanes === 0) && (R = u.lastRenderedReducer, R !== null)) try {
            var V = u.lastRenderedState,
               W = R(V, p);
            if (M.hasEagerState = !0, M.eagerState = W, xr(W, V)) return eu(o, u, M, 0), en === null && Ph(), !1
         } catch {} finally {}
         if (p = Dp(o, u, M, y), p !== null) return dr(p, o, y), kr(p, u, y), !0
      }
      return !1
   }

   function Yp(o, u, p, y) {
      if (y = {
            lane: 2,
            revertLane: gE(),
            action: y,
            hasEagerState: !1,
            eagerState: null,
            next: null
         }, Kp(o)) {
         if (u) throw Error(i(479))
      } else u = Dp(o, p, y, 2), u !== null && dr(u, o, 2)
   }

   function Kp(o) {
      var u = o.alternate;
      return o === an || u !== null && u === an
   }

   function D_(o, u) {
      lu = Vp = !0;
      var p = o.pending;
      p === null ? u.next = u : (u.next = p.next, p.next = u), o.pending = u
   }

   function kr(o, u, p) {
      if ((p & 4194048) !== 0) {
         var y = u.lanes;
         y &= o.pendingLanes, p |= y, u.lanes = p, Bt(o, p)
      }
   }
   var Zh = {
         readContext: Oi,
         use: kp,
         useCallback: Gi,
         useContext: Gi,
         useEffect: Gi,
         useImperativeHandle: Gi,
         useLayoutEffect: Gi,
         useInsertionEffect: Gi,
         useMemo: Gi,
         useReducer: Gi,
         useRef: Gi,
         useState: Gi,
         useDebugValue: Gi,
         useDeferredValue: Gi,
         useTransition: Gi,
         useSyncExternalStore: Gi,
         useId: Gi,
         useHostTransitionStatus: Gi,
         useFormState: Gi,
         useActionState: Gi,
         useOptimistic: Gi,
         useMemoCache: Gi,
         useCacheRefresh: Gi
      },
      Zp = {
         readContext: Oi,
         use: kp,
         useCallback: function (o, u) {
            return cr().memoizedState = [o, u === void 0 ? null : u], o
         },
         useContext: Oi,
         useEffect: Pv,
         useImperativeHandle: function (o, u, p) {
            p = p != null ? p.concat([o]) : null, jp(4194308, 4, __.bind(null, u, o), p)
         },
         useLayoutEffect: function (o, u) {
            return jp(4194308, 4, o, u)
         },
         useInsertionEffect: function (o, u) {
            jp(4, 2, o, u)
         },
         useMemo: function (o, u) {
            var p = cr();
            u = u === void 0 ? null : u;
            var y = o();
            if (ur) {
               We(!0);
               try {
                  o()
               } finally {
                  We(!1)
               }
            }
            return p.memoizedState = [y, u], y
         },
         useReducer: function (o, u, p) {
            var y = cr();
            if (p !== void 0) {
               var M = p(u);
               if (ur) {
                  We(!0);
                  try {
                     p(u)
                  } finally {
                     We(!1)
                  }
               }
            } else M = u;
            return y.memoizedState = y.baseState = M, o = {
               pending: null,
               lanes: 0,
               dispatch: null,
               lastRenderedReducer: o,
               lastRenderedState: M
            }, y.queue = o, o = o.dispatch = dE.bind(null, an, o), [y.memoizedState, o]
         },
         useRef: function (o) {
            var u = cr();
            return o = {
               current: o
            }, u.memoizedState = o
         },
         useState: function (o) {
            o = Dv(o);
            var u = o.queue,
               p = C_.bind(null, an, u);
            return u.dispatch = p, [o.memoizedState, p]
         },
         useDebugValue: Bv,
         useDeferredValue: function (o, u) {
            var p = cr();
            return Wp(p, o, u)
         },
         useTransition: function () {
            var o = Dv(!1);
            return o = E_.bind(null, an, o.queue, !0, !1), cr().memoizedState = o, [!1, o]
         },
         useSyncExternalStore: function (o, u, p) {
            var y = an,
               M = cr();
            if (jn) {
               if (p === void 0) throw Error(i(407));
               p = p()
            } else {
               if (p = u(), en === null) throw Error(i(349));
               (Lt & 124) !== 0 || ff(y, u, p)
            }
            M.memoizedState = p;
            var R = {
               value: p,
               getSnapshot: u
            };
            return M.queue = R, Pv(l_.bind(null, y, R, o), [o]), y.flags |= 2048, hf(9, Yh(), o_.bind(null, y, R, p, u), null), p
         },
         useId: function () {
            var o = cr(),
               u = en.identifierPrefix;
            if (jn) {
               var p = Mo,
                  y = Eo;
               p = (y & ~(1 << 32 - Ze(y) - 1)).toString(32) + p, u = "" + u + "R" + p, p = as++, 0 < p && (u += "H" + p.toString(32)), u += ""
            } else p = i_++, u = "" + u + "r" + p.toString(32) + "";
            return o.memoizedState = u
         },
         useHostTransitionStatus: Fv,
         useFormState: g_,
         useActionState: g_,
         useOptimistic: function (o) {
            var u = cr();
            u.memoizedState = u.baseState = o;
            var p = {
               pending: null,
               lanes: 0,
               dispatch: null,
               lastRenderedReducer: null,
               lastRenderedState: null
            };
            return u.queue = p, u = Yp.bind(null, an, !0, p), p.dispatch = u, [o, u]
         },
         useMemoCache: wv,
         useCacheRefresh: function () {
            return cr().memoizedState = hE.bind(null, an)
         }
      },
      Hv = {
         readContext: Oi,
         use: kp,
         useCallback: b_,
         useContext: Oi,
         useEffect: Lv,
         useImperativeHandle: S_,
         useInsertionEffect: qp,
         useLayoutEffect: Xp,
         useMemo: zv,
         useReducer: cu,
         useRef: Uv,
         useState: function () {
            return cu(Sl)
         },
         useDebugValue: Bv,
         useDeferredValue: function (o, u) {
            var p = es();
            return T_(p, ti.memoizedState, o, u)
         },
         useTransition: function () {
            var o = cu(Sl)[0],
               u = es().memoizedState;
            return [typeof o == "boolean" ? o : Ya(o), u]
         },
         useSyncExternalStore: a_,
         useId: w_,
         useHostTransitionStatus: Fv,
         useFormState: v_,
         useActionState: v_,
         useOptimistic: function (o, u) {
            var p = es();
            return f_(p, ti, o, u)
         },
         useMemoCache: wv,
         useCacheRefresh: R_
      },
      N_ = {
         readContext: Oi,
         use: kp,
         useCallback: b_,
         useContext: Oi,
         useEffect: Lv,
         useImperativeHandle: S_,
         useInsertionEffect: qp,
         useLayoutEffect: Xp,
         useMemo: zv,
         useReducer: Cv,
         useRef: Uv,
         useState: function () {
            return Cv(Sl)
         },
         useDebugValue: Bv,
         useDeferredValue: function (o, u) {
            var p = es();
            return ti === null ? Wp(p, o, u) : T_(p, ti.memoizedState, o, u)
         },
         useTransition: function () {
            var o = Cv(Sl)[0],
               u = es().memoizedState;
            return [typeof o == "boolean" ? o : Ya(o), u]
         },
         useSyncExternalStore: a_,
         useId: w_,
         useHostTransitionStatus: Fv,
         useFormState: x_,
         useActionState: x_,
         useOptimistic: function (o, u) {
            var p = es();
            return ti !== null ? f_(p, ti, o, u) : (p.baseState = o, [o, p.queue.dispatch])
         },
         useMemoCache: wv,
         useCacheRefresh: R_
      },
      Qu = null,
      Qh = 0;

   function Jh(o) {
      var u = Qh;
      return Qh += 1, Qu === null && (Qu = []), Fp(Qu, o, u)
   }

   function pf(o, u) {
      u = u.props.ref, o.ref = u !== void 0 ? u : null
   }

   function Qp(o, u) {
      throw u.$$typeof === g ? Error(i(525)) : (o = Object.prototype.toString.call(u), Error(i(31, o === "[object Object]" ? "object with keys {" + Object.keys(u).join(", ") + "}" : o)))
   }

   function O_(o) {
      var u = o._init;
      return u(o._payload)
   }

   function U_(o) {
      function u(ge, he) {
         if (o) {
            var _e = ge.deletions;
            _e === null ? (ge.deletions = [he], ge.flags |= 16) : _e.push(he)
         }
      }

      function p(ge, he) {
         if (!o) return null;
         for (; he !== null;) u(ge, he), he = he.sibling;
         return null
      }

      function y(ge) {
         for (var he = new Map; ge !== null;) ge.key !== null ? he.set(ge.key, ge) : he.set(ge.index, ge), ge = ge.sibling;
         return he
      }

      function M(ge, he) {
         return ge = Vi(ge, he), ge.index = 0, ge.sibling = null, ge
      }

      function R(ge, he, _e) {
         return ge.index = _e, o ? (_e = ge.alternate, _e !== null ? (_e = _e.index, _e < he ? (ge.flags |= 67108866, he) : _e) : (ge.flags |= 67108866, he)) : (ge.flags |= 1048576, he)
      }

      function V(ge) {
         return o && ge.alternate === null && (ge.flags |= 67108866), ge
      }

      function W(ge, he, _e, ke) {
         return he === null || he.tag !== 6 ? (he = Bh(_e, ge.mode, ke), he.return = ge, he) : (he = M(he, _e), he.return = ge, he)
      }

      function se(ge, he, _e, ke) {
         var Et = _e.type;
         return Et === S ? Ve(ge, he, _e.props.children, ke, _e.key) : he !== null && (he.elementType === Et || typeof Et == "object" && Et !== null && Et.$$typeof === I && O_(Et) === he.type) ? (he = M(he, _e.props), pf(he, _e), he.return = ge, he) : (he = _s(_e.type, _e.key, _e.props, null, ge.mode, ke), pf(he, _e), he.return = ge, he)
      }

      function Se(ge, he, _e, ke) {
         return he === null || he.tag !== 4 || he.stateNode.containerInfo !== _e.containerInfo || he.stateNode.implementation !== _e.implementation ? (he = Np(_e, ge.mode, ke), he.return = ge, he) : (he = M(he, _e.children || []), he.return = ge, he)
      }

      function Ve(ge, he, _e, ke, Et) {
         return he === null || he.tag !== 7 ? (he = nu(_e, ge.mode, ke, Et), he.return = ge, he) : (he = M(he, _e), he.return = ge, he)
      }

      function qe(ge, he, _e) {
         if (typeof he == "string" && he !== "" || typeof he == "number" || typeof he == "bigint") return he = Bh("" + he, ge.mode, _e), he.return = ge, he;
         if (typeof he == "object" && he !== null) {
            switch (he.$$typeof) {
               case v:
                  return _e = _s(he.type, he.key, he.props, null, ge.mode, _e), pf(_e, he), _e.return = ge, _e;
               case x:
                  return he = Np(he, ge.mode, _e), he.return = ge, he;
               case I:
                  var ke = he._init;
                  return he = ke(he._payload), qe(ge, he, _e)
            }
            if (fe(he) || Q(he)) return he = nu(he, ge.mode, _e, null), he.return = ge, he;
            if (typeof he.then == "function") return qe(ge, Jh(he), _e);
            if (he.$$typeof === C) return qe(ge, Hh(ge, he), _e);
            Qp(ge, he)
         }
         return null
      }

      function Me(ge, he, _e, ke) {
         var Et = he !== null ? he.key : null;
         if (typeof _e == "string" && _e !== "" || typeof _e == "number" || typeof _e == "bigint") return Et !== null ? null : W(ge, he, "" + _e, ke);
         if (typeof _e == "object" && _e !== null) {
            switch (_e.$$typeof) {
               case v:
                  return _e.key === Et ? se(ge, he, _e, ke) : null;
               case x:
                  return _e.key === Et ? Se(ge, he, _e, ke) : null;
               case I:
                  return Et = _e._init, _e = Et(_e._payload), Me(ge, he, _e, ke)
            }
            if (fe(_e) || Q(_e)) return Et !== null ? null : Ve(ge, he, _e, ke, null);
            if (typeof _e.then == "function") return Me(ge, he, Jh(_e), ke);
            if (_e.$$typeof === C) return Me(ge, he, Hh(ge, _e), ke);
            Qp(ge, _e)
         }
         return null
      }

      function Ae(ge, he, _e, ke, Et) {
         if (typeof ke == "string" && ke !== "" || typeof ke == "number" || typeof ke == "bigint") return ge = ge.get(_e) || null, W(he, ge, "" + ke, Et);
         if (typeof ke == "object" && ke !== null) {
            switch (ke.$$typeof) {
               case v:
                  return ge = ge.get(ke.key === null ? _e : ke.key) || null, se(he, ge, ke, Et);
               case x:
                  return ge = ge.get(ke.key === null ? _e : ke.key) || null, Se(he, ge, ke, Et);
               case I:
                  var Rn = ke._init;
                  return ke = Rn(ke._payload), Ae(ge, he, _e, ke, Et)
            }
            if (fe(ke) || Q(ke)) return ge = ge.get(_e) || null, Ve(he, ge, ke, Et, null);
            if (typeof ke.then == "function") return Ae(ge, he, _e, Jh(ke), Et);
            if (ke.$$typeof === C) return Ae(ge, he, _e, Hh(he, ke), Et);
            Qp(he, ke)
         }
         return null
      }

      function Qt(ge, he, _e, ke) {
         for (var Et = null, Rn = null, Ot = he, qt = he = 0, Js = null; Ot !== null && qt < _e.length; qt++) {
            Ot.index > qt ? (Js = Ot, Ot = null) : Js = Ot.sibling;
            var Jn = Me(ge, Ot, _e[qt], ke);
            if (Jn === null) {
               Ot === null && (Ot = Js);
               break
            }
            o && Ot && Jn.alternate === null && u(ge, Ot), he = R(Jn, he, qt), Rn === null ? Et = Jn : Rn.sibling = Jn, Rn = Jn, Ot = Js
         }
         if (qt === _e.length) return p(ge, Ot), jn && pl(ge, qt), Et;
         if (Ot === null) {
            for (; qt < _e.length; qt++) Ot = qe(ge, _e[qt], ke), Ot !== null && (he = R(Ot, he, qt), Rn === null ? Et = Ot : Rn.sibling = Ot, Rn = Ot);
            return jn && pl(ge, qt), Et
         }
         for (Ot = y(Ot); qt < _e.length; qt++) Js = Ae(Ot, ge, qt, _e[qt], ke), Js !== null && (o && Js.alternate !== null && Ot.delete(Js.key === null ? qt : Js.key), he = R(Js, he, qt), Rn === null ? Et = Js : Rn.sibling = Js, Rn = Js);
         return o && Ot.forEach(function (Nf) {
            return u(ge, Nf)
         }), jn && pl(ge, qt), Et
      }

      function Gt(ge, he, _e, ke) {
         if (_e == null) throw Error(i(151));
         for (var Et = null, Rn = null, Ot = he, qt = he = 0, Js = null, Jn = _e.next(); Ot !== null && !Jn.done; qt++, Jn = _e.next()) {
            Ot.index > qt ? (Js = Ot, Ot = null) : Js = Ot.sibling;
            var Nf = Me(ge, Ot, Jn.value, ke);
            if (Nf === null) {
               Ot === null && (Ot = Js);
               break
            }
            o && Ot && Nf.alternate === null && u(ge, Ot), he = R(Nf, he, qt), Rn === null ? Et = Nf : Rn.sibling = Nf, Rn = Nf, Ot = Js
         }
         if (Jn.done) return p(ge, Ot), jn && pl(ge, qt), Et;
         if (Ot === null) {
            for (; !Jn.done; qt++, Jn = _e.next()) Jn = qe(ge, Jn.value, ke), Jn !== null && (he = R(Jn, he, qt), Rn === null ? Et = Jn : Rn.sibling = Jn, Rn = Jn);
            return jn && pl(ge, qt), Et
         }
         for (Ot = y(Ot); !Jn.done; qt++, Jn = _e.next()) Jn = Ae(Ot, ge, qt, Jn.value, ke), Jn !== null && (o && Jn.alternate !== null && Ot.delete(Jn.key === null ? qt : Jn.key), he = R(Jn, he, qt), Rn === null ? Et = Jn : Rn.sibling = Jn, Rn = Jn);
         return o && Ot.forEach(function (OH) {
            return u(ge, OH)
         }), jn && pl(ge, qt), Et
      }

      function yi(ge, he, _e, ke) {
         if (typeof _e == "object" && _e !== null && _e.type === S && _e.key === null && (_e = _e.props.children), typeof _e == "object" && _e !== null) {
            switch (_e.$$typeof) {
               case v:
                  e: {
                     for (var Et = _e.key; he !== null;) {
                        if (he.key === Et) {
                           if (Et = _e.type, Et === S) {
                              if (he.tag === 7) {
                                 p(ge, he.sibling), ke = M(he, _e.props.children), ke.return = ge, ge = ke;
                                 break e
                              }
                           } else if (he.elementType === Et || typeof Et == "object" && Et !== null && Et.$$typeof === I && O_(Et) === he.type) {
                              p(ge, he.sibling), ke = M(he, _e.props), pf(ke, _e), ke.return = ge, ge = ke;
                              break e
                           }
                           p(ge, he);
                           break
                        } else u(ge, he);
                        he = he.sibling
                     }
                     _e.type === S ? (ke = nu(_e.props.children, ge.mode, ke, _e.key), ke.return = ge, ge = ke) : (ke = _s(_e.type, _e.key, _e.props, null, ge.mode, ke), pf(ke, _e), ke.return = ge, ge = ke)
                  }
                  return V(ge);
               case x:
                  e: {
                     for (Et = _e.key; he !== null;) {
                        if (he.key === Et)
                           if (he.tag === 4 && he.stateNode.containerInfo === _e.containerInfo && he.stateNode.implementation === _e.implementation) {
                              p(ge, he.sibling), ke = M(he, _e.children || []), ke.return = ge, ge = ke;
                              break e
                           } else {
                              p(ge, he);
                              break
                           }
                        else u(ge, he);
                        he = he.sibling
                     }
                     ke = Np(_e, ge.mode, ke),
                     ke.return = ge,
                     ge = ke
                  }
                  return V(ge);
               case I:
                  return Et = _e._init, _e = Et(_e._payload), yi(ge, he, _e, ke)
            }
            if (fe(_e)) return Qt(ge, he, _e, ke);
            if (Q(_e)) {
               if (Et = Q(_e), typeof Et != "function") throw Error(i(150));
               return _e = Et.call(_e), Gt(ge, he, _e, ke)
            }
            if (typeof _e.then == "function") return yi(ge, he, Jh(_e), ke);
            if (_e.$$typeof === C) return yi(ge, he, Hh(ge, _e), ke);
            Qp(ge, _e)
         }
         return typeof _e == "string" && _e !== "" || typeof _e == "number" || typeof _e == "bigint" ? (_e = "" + _e, he !== null && he.tag === 6 ? (p(ge, he.sibling), ke = M(he, _e), ke.return = ge, ge = ke) : (p(ge, he), ke = Bh(_e, ge.mode, ke), ke.return = ge, ge = ke), V(ge)) : p(ge, he)
      }
      return function (ge, he, _e, ke) {
         try {
            Qh = 0;
            var Et = yi(ge, he, _e, ke);
            return Qu = null, Et
         } catch (Ot) {
            if (Ot === jh || Ot === Wa) throw Ot;
            var Rn = br(29, Ot, null, ge.mode);
            return Rn.lanes = ke, Rn.return = ge, Rn
         } finally {}
      }
   }
   var Ju = U_(!0),
      P_ = U_(!1),
      ui = ie(null),
      Ka = null;

   function fu(o) {
      var u = o.alternate;
      we(ki, ki.current & 1), we(ui, o), Ka === null && (u === null || cf.current !== null || u.memoizedState !== null) && (Ka = o)
   }

   function L_(o) {
      if (o.tag === 22) {
         if (we(ki, ki.current), we(ui, o), Ka === null) {
            var u = o.alternate;
            u !== null && u.memoizedState !== null && (Ka = o)
         }
      } else hu()
   }

   function hu() {
      we(ki, ki.current), we(ui, ui.current)
   }

   function Ro(o) {
      ye(ui), Ka === o && (Ka = null), ye(ki)
   }
   var ki = ie(0);

   function bl(o) {
      for (var u = o; u !== null;) {
         if (u.tag === 13) {
            var p = u.memoizedState;
            if (p !== null && (p = p.dehydrated, p === null || p.data === "$?" || RE(p))) return u
         } else if (u.tag === 19 && u.memoizedProps.revealOrder !== void 0) {
            if ((u.flags & 128) !== 0) return u
         } else if (u.child !== null) {
            u.child.return = u, u = u.child;
            continue
         }
         if (u === o) break;
         for (; u.sibling === null;) {
            if (u.return === null || u.return === o) return null;
            u = u.return
         }
         u.sibling.return = u.return, u = u.sibling
      }
      return null
   }

   function du(o, u, p, y) {
      u = o.memoizedState, p = p(y, u), p = p == null ? u : m({}, u, p), o.memoizedState = p, o.lanes === 0 && (o.updateQueue.baseState = p)
   }
   var fr = {
      enqueueSetState: function (o, u, p) {
         o = o._reactInternals;
         var y = Li(),
            M = wo(y);
         M.payload = u, p != null && (M.callback = p), u = yl(o, M, y), u !== null && (dr(u, o, y), Zu(u, o, y))
      },
      enqueueReplaceState: function (o, u, p) {
         o = o._reactInternals;
         var y = Li(),
            M = wo(y);
         M.tag = 1, M.payload = u, p != null && (M.callback = p), u = yl(o, M, y), u !== null && (dr(u, o, y), Zu(u, o, y))
      },
      enqueueForceUpdate: function (o, u) {
         o = o._reactInternals;
         var p = Li(),
            y = wo(p);
         y.tag = 2, u != null && (y.callback = u), u = yl(o, y, p), u !== null && (dr(u, o, p), Zu(u, o, p))
      }
   };

   function B_(o, u, p, y, M, R, V) {
      return o = o.stateNode, typeof o.shouldComponentUpdate == "function" ? o.shouldComponentUpdate(y, R, V) : u.prototype && u.prototype.isPureReactComponent ? !qa(p, y) || !qa(M, R) : !0
   }

   function z_(o, u, p, y) {
      o = u.state, typeof u.componentWillReceiveProps == "function" && u.componentWillReceiveProps(p, y), typeof u.UNSAFE_componentWillReceiveProps == "function" && u.UNSAFE_componentWillReceiveProps(p, y), u.state !== o && fr.enqueueReplaceState(u, u.state, null)
   }

   function Co(o, u) {
      var p = u;
      if ("ref" in u) {
         p = {};
         for (var y in u) y !== "ref" && (p[y] = u[y])
      }
      if (o = o.defaultProps) {
         p === u && (p = m({}, p));
         for (var M in o) p[M] === void 0 && (p[M] = o[M])
      }
      return p
   }
   var $u = typeof reportError == "function" ? reportError : function (o) {
      if (typeof window == "object" && typeof window.ErrorEvent == "function") {
         var u = new window.ErrorEvent("error", {
            bubbles: !0,
            cancelable: !0,
            message: typeof o == "object" && o !== null && typeof o.message == "string" ? String(o.message) : String(o),
            error: o
         });
         if (!window.dispatchEvent(u)) return
      } else if (typeof process == "object" && typeof process.emit == "function") {
         process.emit("uncaughtException", o);
         return
      }
      console.error(o)
   };

   function $h(o) {
      $u(o)
   }

   function Jp(o) {
      console.error(o)
   }

   function I_(o) {
      $u(o)
   }

   function $p(o, u) {
      try {
         var p = o.onUncaughtError;
         p(u.value, {
            componentStack: u.stack
         })
      } catch (y) {
         setTimeout(function () {
            throw y
         })
      }
   }

   function Ta(o, u, p) {
      try {
         var y = o.onCaughtError;
         y(p.value, {
            componentStack: p.stack,
            errorBoundary: u.tag === 1 ? u.stateNode : null
         })
      } catch (M) {
         setTimeout(function () {
            throw M
         })
      }
   }

   function em(o, u, p) {
      return p = wo(p), p.tag = 3, p.payload = {
         element: null
      }, p.callback = function () {
         $p(o, u)
      }, p
   }

   function F_(o) {
      return o = wo(o), o.tag = 3, o
   }

   function tm(o, u, p, y) {
      var M = p.type.getDerivedStateFromError;
      if (typeof M == "function") {
         var R = y.value;
         o.payload = function () {
            return M(R)
         }, o.callback = function () {
            Ta(u, p, y)
         }
      }
      var V = p.stateNode;
      V !== null && typeof V.componentDidCatch == "function" && (o.callback = function () {
         Ta(u, p, y), typeof M != "function" && (Qr === null ? Qr = new Set([this]) : Qr.add(this));
         var W = y.stack;
         this.componentDidCatch(y.value, {
            componentStack: W !== null ? W : ""
         })
      })
   }

   function pE(o, u, p, y, M) {
      if (p.flags |= 32768, y !== null && typeof y == "object" && typeof y.then == "function") {
         if (u = p.alternate, u !== null && xa(u, p, M, !0), p = ui.current, p !== null) {
            switch (p.tag) {
               case 13:
                  return Ka === null ? f() : p.alternate === null && xi === 0 && (xi = 3), p.flags &= -257, p.flags |= 65536, p.lanes = M, y === qh ? p.flags |= 16384 : (u = p.updateQueue, u === null ? p.updateQueue = new Set([y]) : u.add(y), Ce(o, y, M)), !1;
               case 22:
                  return p.flags |= 65536, y === qh ? p.flags |= 16384 : (u = p.updateQueue, u === null ? (u = {
                     transitions: null,
                     markerInstances: null,
                     retryQueue: new Set([y])
                  }, p.updateQueue = u) : (p = u.retryQueue, p === null ? u.retryQueue = new Set([y]) : p.add(y)), Ce(o, y, M)), !1
            }
            throw Error(i(435, p.tag))
         }
         return Ce(o, y, M), f(), !1
      }
      if (jn) return u = ui.current, u !== null ? ((u.flags & 65536) === 0 && (u.flags |= 256), u.flags |= 65536, u.lanes = M, y !== Up && (o = Error(i(422), {
         cause: y
      }), Ku(zs(o, p)))) : (y !== Up && (u = Error(i(423), {
         cause: y
      }), Ku(zs(u, p))), o = o.current.alternate, o.flags |= 65536, M &= -M, o.lanes |= M, y = zs(y, p), M = em(o.stateNode, y, M), of (o, M), xi !== 4 && (xi = 2)), !1;
      var R = Error(i(520), {
         cause: y
      });
      if (R = zs(R, p), Qn === null ? Qn = [R] : Qn.push(R), xi !== 4 && (xi = 2), u === null) return !0;
      y = zs(y, p), p = u;
      do {
         switch (p.tag) {
            case 3:
               return p.flags |= 65536, o = M & -M, p.lanes |= o, o = em(p.stateNode, y, o), of (p, o), !1;
            case 1:
               if (u = p.type, R = p.stateNode, (p.flags & 128) === 0 && (typeof u.getDerivedStateFromError == "function" || R !== null && typeof R.componentDidCatch == "function" && (Qr === null || !Qr.has(R)))) return p.flags |= 65536, M &= -M, p.lanes |= M, M = F_(M), tm(M, o, p, y), of (p, M), !1
         }
         p = p.return
      } while (p !== null);
      return !1
   }
   var H_ = Error(i(461)),
      Ss = !1;

   function ji(o, u, p, y) {
      u.child = o === null ? P_(u, null, p, y) : Ju(u, o.child, p, y)
   }

   function Er(o, u, p, y, M) {
      p = p.render;
      var R = u.ref;
      if ("ref" in y) {
         var V = {};
         for (var W in y) W !== "ref" && (V[W] = y[W])
      } else V = y;
      return Ao(u), y = _l(o, u, p, V, R, M), W = Mv(), o !== null && !Ss ? (Gp(o, u, M), bs(o, u, M)) : (jn && W && pv(u), u.flags |= 1, ji(o, u, y, M), u.child)
   }

   function Mr(o, u, p, y, M) {
      if (o === null) {
         var R = p.type;
         return typeof R == "function" && !Lh(R) && R.defaultProps === void 0 && p.compare === null ? (u.tag = 15, u.type = R, Vv(o, u, R, y, M)) : (o = _s(p.type, null, y, u, u.mode, M), o.ref = u.ref, o.return = u, u.child = o)
      }
      if (R = o.child, !ed(o, M)) {
         var V = R.memoizedProps;
         if (p = p.compare, p = p !== null ? p : qa, p(V, y) && o.ref === u.ref) return bs(o, u, M)
      }
      return u.flags |= 1, o = Vi(R, y), o.ref = u.ref, o.return = u, u.child = o
   }

   function Vv(o, u, p, y, M) {
      if (o !== null) {
         var R = o.memoizedProps;
         if (qa(R, y) && o.ref === u.ref)
            if (Ss = !1, u.pendingProps = y = R, ed(o, M))(o.flags & 131072) !== 0 && (Ss = !0);
            else return u.lanes = o.lanes, bs(o, u, M)
      }
      return mf(o, u, p, y, M)
   }

   function ec(o, u, p) {
      var y = u.pendingProps,
         M = y.children,
         R = o !== null ? o.memoizedState : null;
      if (y.mode === "hidden") {
         if ((u.flags & 128) !== 0) {
            if (y = R !== null ? R.baseLanes | p : p, o !== null) {
               for (M = u.child = o.child, R = 0; M !== null;) R = R | M.lanes | M.childLanes, M = M.sibling;
               u.childLanes = R & ~y
            } else u.childLanes = 0, u.child = null;
            return tc(o, u, y, p)
         }
         if ((p & 536870912) !== 0) u.memoizedState = {
            baseLanes: 0,
            cachePool: null
         }, o !== null && kh(u, R !== null ? R.cachePool : null), R !== null ? n_(u, R) : Ev(), L_(u);
         else return u.lanes = u.childLanes = 536870912, tc(o, u, R !== null ? R.baseLanes | p : p, p)
      } else R !== null ? (kh(u, R.cachePool), n_(u, R), hu(), u.memoizedState = null) : (o !== null && kh(u, null), Ev(), hu());
      return ji(o, u, M, p), u.child
   }

   function tc(o, u, p, y) {
      var M = ou();
      return M = M === null ? null : {
         parent: Ji._currentValue,
         pool: M
      }, u.memoizedState = {
         baseLanes: p,
         cachePool: M
      }, o !== null && kh(u, null), Ev(), L_(u), o !== null && xa(o, u, y, !0), null
   }

   function nc(o, u) {
      var p = u.ref;
      if (p === null) o !== null && o.ref !== null && (u.flags |= 4194816);
      else {
         if (typeof p != "function" && typeof p != "object") throw Error(i(284));
         (o === null || o.ref !== p) && (u.flags |= 4194816)
      }
   }

   function mf(o, u, p, y, M) {
      return Ao(u), p = _l(o, u, p, y, void 0, M), y = Mv(), o !== null && !Ss ? (Gp(o, u, M), bs(o, u, M)) : (jn && y && pv(u), u.flags |= 1, ji(o, u, p, M), u.child)
   }

   function jr(o, u, p, y, M, R) {
      return Ao(u), u.updateQueue = null, p = r_(u, y, p, M), s_(o), y = Mv(), o !== null && !Ss ? (Gp(o, u, R), bs(o, u, R)) : (jn && y && pv(u), u.flags |= 1, ji(o, u, p, R), u.child)
   }

   function qr(o, u, p, y, M) {
      if (Ao(u), u.stateNode === null) {
         var R = tu,
            V = p.contextType;
         typeof V == "object" && V !== null && (R = Oi(V)), R = new p(y, R), u.memoizedState = R.state !== null && R.state !== void 0 ? R.state : null, R.updater = fr, u.stateNode = R, R._reactInternals = u, R = u.stateNode, R.props = y, R.state = u.memoizedState, R.refs = {}, bv(u), V = p.contextType, R.context = typeof V == "object" && V !== null ? Oi(V) : tu, R.state = u.memoizedState, V = p.getDerivedStateFromProps, typeof V == "function" && (du(u, p, V, y), R.state = u.memoizedState), typeof p.getDerivedStateFromProps == "function" || typeof R.getSnapshotBeforeUpdate == "function" || typeof R.UNSAFE_componentWillMount != "function" && typeof R.componentWillMount != "function" || (V = R.state, typeof R.componentWillMount == "function" && R.componentWillMount(), typeof R.UNSAFE_componentWillMount == "function" && R.UNSAFE_componentWillMount(), V !== R.state && fr.enqueueReplaceState(R, R.state, null), lf(u, y, R, M), Xh(), R.state = u.memoizedState), typeof R.componentDidMount == "function" && (u.flags |= 4194308), y = !0
      } else if (o === null) {
         R = u.stateNode;
         var W = u.memoizedProps,
            se = Co(p, W);
         R.props = se;
         var Se = R.context,
            Ve = p.contextType;
         V = tu, typeof Ve == "object" && Ve !== null && (V = Oi(Ve));
         var qe = p.getDerivedStateFromProps;
         Ve = typeof qe == "function" || typeof R.getSnapshotBeforeUpdate == "function", W = u.pendingProps !== W, Ve || typeof R.UNSAFE_componentWillReceiveProps != "function" && typeof R.componentWillReceiveProps != "function" || (W || Se !== V) && z_(u, R, y, V), vl = !1;
         var Me = u.memoizedState;
         R.state = Me, lf(u, y, R, M), Xh(), Se = u.memoizedState, W || Me !== Se || vl ? (typeof qe == "function" && (du(u, p, qe, y), Se = u.memoizedState), (se = vl || B_(u, p, se, y, Me, Se, V)) ? (Ve || typeof R.UNSAFE_componentWillMount != "function" && typeof R.componentWillMount != "function" || (typeof R.componentWillMount == "function" && R.componentWillMount(), typeof R.UNSAFE_componentWillMount == "function" && R.UNSAFE_componentWillMount()), typeof R.componentDidMount == "function" && (u.flags |= 4194308)) : (typeof R.componentDidMount == "function" && (u.flags |= 4194308), u.memoizedProps = y, u.memoizedState = Se), R.props = y, R.state = Se, R.context = V, y = se) : (typeof R.componentDidMount == "function" && (u.flags |= 4194308), y = !1)
      } else {
         R = u.stateNode, Yt(o, u), V = u.memoizedProps, Ve = Co(p, V), R.props = Ve, qe = u.pendingProps, Me = R.context, Se = p.contextType, se = tu, typeof Se == "object" && Se !== null && (se = Oi(Se)), W = p.getDerivedStateFromProps, (Se = typeof W == "function" || typeof R.getSnapshotBeforeUpdate == "function") || typeof R.UNSAFE_componentWillReceiveProps != "function" && typeof R.componentWillReceiveProps != "function" || (V !== qe || Me !== se) && z_(u, R, y, se), vl = !1, Me = u.memoizedState, R.state = Me, lf(u, y, R, M), Xh();
         var Ae = u.memoizedState;
         V !== qe || Me !== Ae || vl || o !== null && o.dependencies !== null && Fh(o.dependencies) ? (typeof W == "function" && (du(u, p, W, y), Ae = u.memoizedState), (Ve = vl || B_(u, p, Ve, y, Me, Ae, se) || o !== null && o.dependencies !== null && Fh(o.dependencies)) ? (Se || typeof R.UNSAFE_componentWillUpdate != "function" && typeof R.componentWillUpdate != "function" || (typeof R.componentWillUpdate == "function" && R.componentWillUpdate(y, Ae, se), typeof R.UNSAFE_componentWillUpdate == "function" && R.UNSAFE_componentWillUpdate(y, Ae, se)), typeof R.componentDidUpdate == "function" && (u.flags |= 4), typeof R.getSnapshotBeforeUpdate == "function" && (u.flags |= 1024)) : (typeof R.componentDidUpdate != "function" || V === o.memoizedProps && Me === o.memoizedState || (u.flags |= 4), typeof R.getSnapshotBeforeUpdate != "function" || V === o.memoizedProps && Me === o.memoizedState || (u.flags |= 1024), u.memoizedProps = y, u.memoizedState = Ae), R.props = y, R.state = Ae, R.context = se, y = Ve) : (typeof R.componentDidUpdate != "function" || V === o.memoizedProps && Me === o.memoizedState || (u.flags |= 4), typeof R.getSnapshotBeforeUpdate != "function" || V === o.memoizedProps && Me === o.memoizedState || (u.flags |= 1024), y = !1)
      }
      return R = y, nc(o, u), y = (u.flags & 128) !== 0, R || y ? (R = u.stateNode, p = y && typeof p.getDerivedStateFromError != "function" ? null : R.render(), u.flags |= 1, o !== null && y ? (u.child = Ju(u, o.child, null, M), u.child = Ju(u, null, p, M)) : ji(o, u, p, M), u.memoizedState = R.state, o = u.child) : o = bs(o, u, M), o
   }

   function pu(o, u, p, y) {
      return tf(), u.flags |= 256, ji(o, u, p, y), u.child
   }
   var Za = {
      dehydrated: null,
      treeContext: null,
      retryLane: 0,
      hydrationErrors: null
   };

   function Qa(o) {
      return {
         baseLanes: o,
         cachePool: zp()
      }
   }

   function os(o, u, p) {
      return o = o !== null ? o.childLanes & ~p : 0, u && (o |= Ra), o
   }

   function gf(o, u, p) {
      var y = u.pendingProps,
         M = !1,
         R = (u.flags & 128) !== 0,
         V;
      if ((V = R) || (V = o !== null && o.memoizedState === null ? !1 : (ki.current & 2) !== 0), V && (M = !0, u.flags &= -129), V = (u.flags & 32) !== 0, u.flags &= -33, o === null) {
         if (jn) {
            if (M ? fu(u) : hu(), jn) {
               var W = Ci,
                  se;
               if (se = W) {
                  e: {
                     for (se = W, W = Vr; se.nodeType !== 8;) {
                        if (!W) {
                           W = null;
                           break e
                        }
                        if (se = Rl(se.nextSibling), se === null) {
                           W = null;
                           break e
                        }
                     }
                     W = se
                  }
                  W !== null ? (u.memoizedState = {
                     dehydrated: W,
                     treeContext: iu !== null ? {
                        id: Eo,
                        overflow: Mo
                     } : null,
                     retryLane: 536870912,
                     hydrationErrors: null
                  }, se = br(18, null, null, 0), se.stateNode = W, se.return = u, u.child = se, lr = u, Ci = null, se = !0) : se = !1
               }
               se || su(u)
            }
            if (W = u.memoizedState, W !== null && (W = W.dehydrated, W !== null)) return RE(W) ? u.lanes = 32 : u.lanes = 536870912, null;
            Ro(u)
         }
         return W = y.children, y = y.fallback, M ? (hu(), M = u.mode, W = ic({
            mode: "hidden",
            children: W
         }, M), y = nu(y, M, p, null), W.return = u, y.return = u, W.sibling = y, u.child = W, M = u.child, M.memoizedState = Qa(p), M.childLanes = os(o, V, p), u.memoizedState = Za, y) : (fu(u), Do(u, W))
      }
      if (se = o.memoizedState, se !== null && (W = se.dehydrated, W !== null)) {
         if (R) u.flags & 256 ? (fu(u), u.flags &= -257, u = Hs(o, u, p)) : u.memoizedState !== null ? (hu(), u.child = o.child, u.flags |= 128, u = null) : (hu(), M = y.fallback, W = u.mode, y = ic({
            mode: "visible",
            children: y.children
         }, W), M = nu(M, W, p, null), M.flags |= 2, y.return = u, M.return = u, y.sibling = M, u.child = y, Ju(u, o.child, null, p), y = u.child, y.memoizedState = Qa(p), y.childLanes = os(o, V, p), u.memoizedState = Za, u = M);
         else if (fu(u), RE(W)) {
            if (V = W.nextSibling && W.nextSibling.dataset, V) var Se = V.dgst;
            V = Se, y = Error(i(419)), y.stack = "", y.digest = V, Ku({
               value: y,
               source: null,
               stack: null
            }), u = Hs(o, u, p)
         } else if (Ss || xa(o, u, p, !1), V = (p & o.childLanes) !== 0, Ss || V) {
            if (V = en, V !== null && (y = p & -p, y = (y & 42) !== 0 ? 1 : mn(y), y = (y & (V.suspendedLanes | p)) !== 0 ? 0 : y, y !== 0 && y !== se.retryLane)) throw se.retryLane = y, dl(o, y), dr(V, o, y), H_;
            W.data === "$?" || f(), u = Hs(o, u, p)
         } else W.data === "$?" ? (u.flags |= 192, u.child = o.child, u = null) : (o = se.treeContext, Ci = Rl(W.nextSibling), lr = u, jn = !0, ya = null, Vr = !1, o !== null && (Is[Hr++] = Eo, Is[Hr++] = Mo, Is[Hr++] = iu, Eo = o.id, Mo = o.overflow, iu = u), u = Do(u, y.children), u.flags |= 4096);
         return u
      }
      return M ? (hu(), M = y.fallback, W = u.mode, se = o.child, Se = se.sibling, y = Vi(se, {
         mode: "hidden",
         children: y.children
      }), y.subtreeFlags = se.subtreeFlags & 65011712, Se !== null ? M = Vi(Se, M) : (M = nu(M, W, p, null), M.flags |= 2), M.return = u, y.return = u, y.sibling = M, u.child = y, y = M, M = u.child, W = o.child.memoizedState, W === null ? W = Qa(p) : (se = W.cachePool, se !== null ? (Se = Ji._currentValue, se = se.parent !== Se ? {
         parent: Se,
         pool: Se
      } : se) : se = zp(), W = {
         baseLanes: W.baseLanes | p,
         cachePool: se
      }), M.memoizedState = W, M.childLanes = os(o, V, p), u.memoizedState = Za, y) : (fu(u), p = o.child, o = p.sibling, p = Vi(p, {
         mode: "visible",
         children: y.children
      }), p.return = u, p.sibling = null, o !== null && (V = u.deletions, V === null ? (u.deletions = [o], u.flags |= 16) : V.push(o)), u.child = p, u.memoizedState = null, p)
   }

   function Do(o, u) {
      return u = ic({
         mode: "visible",
         children: u
      }, o.mode), u.return = o, o.child = u
   }

   function ic(o, u) {
      return o = br(22, o, null, u), o.lanes = 0, o.stateNode = {
         _visibility: 1,
         _pendingMarkers: null,
         _retryCache: null,
         _transitions: null
      }, o
   }

   function Hs(o, u, p) {
      return Ju(u, o.child, null, p), o = Do(u, u.pendingProps.children), o.flags |= 2, u.memoizedState = null, o
   }

   function Vs(o, u, p) {
      o.lanes |= u;
      var y = o.alternate;
      y !== null && (y.lanes |= u), yv(o.return, u, p)
   }

   function Bn(o, u, p, y, M) {
      var R = o.memoizedState;
      R === null ? o.memoizedState = {
         isBackwards: u,
         rendering: null,
         renderingStartTime: 0,
         last: y,
         tail: p,
         tailMode: M
      } : (R.isBackwards = u, R.rendering = null, R.renderingStartTime = 0, R.last = y, R.tail = p, R.tailMode = M)
   }

   function Ea(o, u, p) {
      var y = u.pendingProps,
         M = y.revealOrder,
         R = y.tail;
      if (ji(o, u, y.children, p), y = ki.current, (y & 2) !== 0) y = y & 1 | 2, u.flags |= 128;
      else {
         if (o !== null && (o.flags & 128) !== 0) e: for (o = u.child; o !== null;) {
            if (o.tag === 13) o.memoizedState !== null && Vs(o, p, u);
            else if (o.tag === 19) Vs(o, p, u);
            else if (o.child !== null) {
               o.child.return = o, o = o.child;
               continue
            }
            if (o === u) break e;
            for (; o.sibling === null;) {
               if (o.return === null || o.return === u) break e;
               o = o.return
            }
            o.sibling.return = o.return, o = o.sibling
         }
         y &= 1
      }
      switch (we(ki, y), M) {
         case "forwards":
            for (p = u.child, M = null; p !== null;) o = p.alternate, o !== null && bl(o) === null && (M = p), p = p.sibling;
            p = M, p === null ? (M = u.child, u.child = null) : (M = p.sibling, p.sibling = null), Bn(u, !1, M, p, R);
            break;
         case "backwards":
            for (p = null, M = u.child, u.child = null; M !== null;) {
               if (o = M.alternate, o !== null && bl(o) === null) {
                  u.child = M;
                  break
               }
               o = M.sibling, M.sibling = p, p = M, M = o
            }
            Bn(u, !0, p, null, R);
            break;
         case "together":
            Bn(u, !1, null, null, void 0);
            break;
         default:
            u.memoizedState = null
      }
      return u.child
   }

   function bs(o, u, p) {
      if (o !== null && (u.dependencies = o.dependencies), to |= u.lanes, (p & u.childLanes) === 0)
         if (o !== null) {
            if (xa(o, u, p, !1), (p & u.childLanes) === 0) return null
         } else return null;
      if (o !== null && u.child !== o.child) throw Error(i(153));
      if (u.child !== null) {
         for (o = u.child, p = Vi(o, o.pendingProps), u.child = p, p.return = u; o.sibling !== null;) o = o.sibling, p = p.sibling = Vi(o, o.pendingProps), p.return = u;
         p.sibling = null
      }
      return u.child
   }

   function ed(o, u) {
      return (o.lanes & u) !== 0 ? !0 : (o = o.dependencies, !!(o !== null && Fh(o)))
   }

   function Ma(o, u, p) {
      switch (u.tag) {
         case 3:
            Xe(u, u.stateNode.containerInfo), au(u, Ji, o.memoizedState.cache), tf();
            break;
         case 27:
         case 5:
            vt(u);
            break;
         case 4:
            Xe(u, u.stateNode.containerInfo);
            break;
         case 10:
            au(u, u.type, u.memoizedProps.value);
            break;
         case 13:
            var y = u.memoizedState;
            if (y !== null) return y.dehydrated !== null ? (fu(u), u.flags |= 128, null) : (p & u.child.childLanes) !== 0 ? gf(o, u, p) : (fu(u), o = bs(o, u, p), o !== null ? o.sibling : null);
            fu(u);
            break;
         case 19:
            var M = (o.flags & 128) !== 0;
            if (y = (p & u.childLanes) !== 0, y || (xa(o, u, p, !1), y = (p & u.childLanes) !== 0), M) {
               if (y) return Ea(o, u, p);
               u.flags |= 128
            }
            if (M = u.memoizedState, M !== null && (M.rendering = null, M.tail = null, M.lastEffect = null), we(ki, ki.current), y) break;
            return null;
         case 22:
         case 23:
            return u.lanes = 0, ec(o, u, p);
         case 24:
            au(u, Ji, o.memoizedState.cache)
      }
      return bs(o, u, p)
   }

   function sc(o, u, p) {
      if (o !== null)
         if (o.memoizedProps !== u.pendingProps) Ss = !0;
         else {
            if (!ed(o, p) && (u.flags & 128) === 0) return Ss = !1, Ma(o, u, p);
            Ss = (o.flags & 131072) !== 0
         }
      else Ss = !1, jn && (u.flags & 1048576) !== 0 && Op(u, ef, u.index);
      switch (u.lanes = 0, u.tag) {
         case 16:
            e: {
               o = u.pendingProps;
               var y = u.elementType,
                  M = y._init;
               if (y = M(y._payload), u.type = y, typeof y == "function") Lh(y) ? (o = Co(y, o), u.tag = 1, u = qr(null, u, y, o, p)) : (u.tag = 0, u = mf(null, u, y, o, p));
               else {
                  if (y != null) {
                     if (M = y.$$typeof, M === N) {
                        u.tag = 11, u = Er(null, u, y, o, p);
                        break e
                     } else if (M === B) {
                        u.tag = 14, u = Mr(null, u, y, o, p);
                        break e
                     }
                  }
                  throw u = ae(y) || y, Error(i(306, u, ""))
               }
            }
            return u;
         case 0:
            return mf(o, u, u.type, u.pendingProps, p);
         case 1:
            return y = u.type, M = Co(y, u.pendingProps), qr(o, u, y, M, p);
         case 3:
            e: {
               if (Xe(u, u.stateNode.containerInfo), o === null) throw Error(i(387));y = u.pendingProps;
               var R = u.memoizedState;M = R.element,
               Yt(o, u),
               lf(u, y, null, p);
               var V = u.memoizedState;
               if (y = V.cache, au(u, Ji, y), y !== R.cache && Ih(u, [Ji], p, !0), Xh(), y = V.element, R.isDehydrated)
                  if (R = {
                        element: y,
                        isDehydrated: !1,
                        cache: V.cache
                     }, u.updateQueue.baseState = R, u.memoizedState = R, u.flags & 256) {
                     u = pu(o, u, y, p);
                     break e
                  } else if (y !== M) {
                  M = zs(Error(i(424)), u), Ku(M), u = pu(o, u, y, p);
                  break e
               } else {
                  switch (o = u.stateNode.containerInfo, o.nodeType) {
                     case 9:
                        o = o.body;
                        break;
                     default:
                        o = o.nodeName === "HTML" ? o.ownerDocument.body : o
                  }
                  for (Ci = Rl(o.firstChild), lr = u, jn = !0, ya = null, Vr = !0, p = P_(u, null, y, p), u.child = p; p;) p.flags = p.flags & -3 | 4096, p = p.sibling
               } else {
                  if (tf(), y === M) {
                     u = bs(o, u, p);
                     break e
                  }
                  ji(o, u, y, p)
               }
               u = u.child
            }
            return u;
         case 26:
            return nc(o, u), o === null ? (p = kC(u.type, null, u.pendingProps, null)) ? u.memoizedState = p : jn || (p = u.type, o = u.pendingProps, y = X_(Pe.current).createElement(p), y[Qe] = u, y[St] = o, pr(y, p, o), Pn(y), u.stateNode = y) : u.memoizedState = kC(u.type, o.memoizedProps, u.pendingProps, o.memoizedState), null;
         case 27:
            return vt(u), o === null && jn && (y = u.stateNode = HC(u.type, u.pendingProps, Pe.current), lr = u, Vr = !0, M = Ci, Af(u.type) ? (CE = M, Ci = Rl(y.firstChild)) : Ci = M), ji(o, u, u.pendingProps.children, p), nc(o, u), o === null && (u.flags |= 4194304), u.child;
         case 5:
            return o === null && jn && ((M = y = Ci) && (y = oH(y, u.type, u.pendingProps, Vr), y !== null ? (u.stateNode = y, lr = u, Ci = Rl(y.firstChild), Vr = !1, M = !0) : M = !1), M || su(u)), vt(u), M = u.type, R = u.pendingProps, V = o !== null ? o.memoizedProps : null, y = R.children, ME(M, R) ? y = null : V !== null && ME(M, V) && (u.flags |= 32), u.memoizedState !== null && (M = _l(o, u, lE, null, null, p), Jv._currentValue = M), nc(o, u), ji(o, u, y, p), u.child;
         case 6:
            return o === null && jn && ((o = p = Ci) && (p = lH(p, u.pendingProps, Vr), p !== null ? (u.stateNode = p, lr = u, Ci = null, o = !0) : o = !1), o || su(u)), null;
         case 13:
            return gf(o, u, p);
         case 4:
            return Xe(u, u.stateNode.containerInfo), y = u.pendingProps, o === null ? u.child = Ju(u, null, y, p) : ji(o, u, y, p), u.child;
         case 11:
            return Er(o, u, u.type, u.pendingProps, p);
         case 7:
            return ji(o, u, u.pendingProps, p), u.child;
         case 8:
            return ji(o, u, u.pendingProps.children, p), u.child;
         case 12:
            return ji(o, u, u.pendingProps.children, p), u.child;
         case 10:
            return y = u.pendingProps, au(u, u.type, y.value), ji(o, u, y.children, p), u.child;
         case 9:
            return M = u.type._context, y = u.pendingProps.children, Ao(u), M = Oi(M), y = y(M), u.flags |= 1, ji(o, u, y, p), u.child;
         case 14:
            return Mr(o, u, u.type, u.pendingProps, p);
         case 15:
            return Vv(o, u, u.type, u.pendingProps, p);
         case 19:
            return Ea(o, u, p);
         case 31:
            return y = u.pendingProps, p = u.mode, y = {
               mode: y.mode,
               children: y.children
            }, o === null ? (p = ic(y, p), p.ref = u.ref, u.child = p, p.return = u, u = p) : (p = Vi(o.child, y), p.ref = u.ref, u.child = p, p.return = u, u = p), u;
         case 22:
            return ec(o, u, p);
         case 24:
            return Ao(u), y = Oi(Ji), o === null ? (M = ou(), M === null && (M = en, R = Lp(), M.pooledCache = R, R.refCount++, R !== null && (M.pooledCacheLanes |= p), M = R), u.memoizedState = {
               parent: y,
               cache: M
            }, bv(u), au(u, Ji, M)) : ((o.lanes & p) !== 0 && (Yt(o, u), lf(u, null, null, p), Xh()), M = o.memoizedState, R = u.memoizedState, M.parent !== y ? (M = {
               parent: y,
               cache: y
            }, u.memoizedState = M, u.lanes === 0 && (u.memoizedState = u.updateQueue.baseState = M), au(u, Ji, y)) : (y = R.cache, au(u, Ji, y), y !== M.cache && Ih(u, [Ji], p, !0))), ji(o, u, u.pendingProps.children, p), u.child;
         case 29:
            throw u.pendingProps
      }
      throw Error(i(156, u.tag))
   }

   function Ja(o) {
      o.flags |= 4
   }

   function td(o, u) {
      if (u.type !== "stylesheet" || (u.state.loading & 4) !== 0) o.flags &= -16777217;
      else if (o.flags |= 16777216, !YC(u)) {
         if (u = ui.current, u !== null && ((Lt & 4194048) === Lt ? Ka !== null : (Lt & 62914560) !== Lt && (Lt & 536870912) === 0 || u !== Ka)) throw Sa = qh, _v;
         o.flags |= 8192
      }
   }

   function Tl(o, u) {
      u !== null && (o.flags |= 4), o.flags & 16384 && (u = o.tag !== 22 ? rt() : 536870912, o.lanes |= u, Hn |= u)
   }

   function rc(o, u) {
      if (!jn) switch (o.tailMode) {
         case "hidden":
            u = o.tail;
            for (var p = null; u !== null;) u.alternate !== null && (p = u), u = u.sibling;
            p === null ? o.tail = null : p.sibling = null;
            break;
         case "collapsed":
            p = o.tail;
            for (var y = null; p !== null;) p.alternate !== null && (y = p), p = p.sibling;
            y === null ? u || o.tail === null ? o.tail = null : o.tail.sibling = null : y.sibling = null
      }
   }

   function pi(o) {
      var u = o.alternate !== null && o.alternate.child === o.child,
         p = 0,
         y = 0;
      if (u)
         for (var M = o.child; M !== null;) p |= M.lanes | M.childLanes, y |= M.subtreeFlags & 65011712, y |= M.flags & 65011712, M.return = o, M = M.sibling;
      else
         for (M = o.child; M !== null;) p |= M.lanes | M.childLanes, y |= M.subtreeFlags, y |= M.flags, M.return = o, M = M.sibling;
      return o.subtreeFlags |= y, o.childLanes = p, u
   }

   function Gv(o, u, p) {
      var y = u.pendingProps;
      switch (mv(u), u.tag) {
         case 31:
         case 16:
         case 15:
         case 0:
         case 11:
         case 7:
         case 8:
         case 12:
         case 9:
         case 14:
            return pi(u), null;
         case 1:
            return pi(u), null;
         case 3:
            return p = u.stateNode, y = null, o !== null && (y = o.memoizedState.cache), u.memoizedState.cache !== y && (u.flags |= 2048), gl(Ji), yt(), p.pendingContext && (p.context = p.pendingContext, p.pendingContext = null), (o === null || o.child === null) && (Xa(u) ? Ja(u) : o === null || o.memoizedState.isDehydrated && (u.flags & 256) === 0 || (u.flags |= 1024, Kn())), pi(u), null;
         case 26:
            return p = u.memoizedState, o === null ? (Ja(u), p !== null ? (pi(u), td(u, p)) : (pi(u), u.flags &= -16777217)) : p ? p !== o.memoizedState ? (Ja(u), pi(u), td(u, p)) : (pi(u), u.flags &= -16777217) : (o.memoizedProps !== y && Ja(u), pi(u), u.flags &= -16777217), null;
         case 27:
            Mt(u), p = Pe.current;
            var M = u.type;
            if (o !== null && u.stateNode != null) o.memoizedProps !== y && Ja(u);
            else {
               if (!y) {
                  if (u.stateNode === null) throw Error(i(166));
                  return pi(u), null
               }
               o = oe.current, Xa(u) ? Jx(u) : (o = HC(M, y, p), u.stateNode = o, Ja(u))
            }
            return pi(u), null;
         case 5:
            if (Mt(u), p = u.type, o !== null && u.stateNode != null) o.memoizedProps !== y && Ja(u);
            else {
               if (!y) {
                  if (u.stateNode === null) throw Error(i(166));
                  return pi(u), null
               }
               if (o = oe.current, Xa(u)) Jx(u);
               else {
                  switch (M = X_(Pe.current), o) {
                     case 1:
                        o = M.createElementNS("http://www.w3.org/2000/svg", p);
                        break;
                     case 2:
                        o = M.createElementNS("http://www.w3.org/1998/Math/MathML", p);
                        break;
                     default:
                        switch (p) {
                           case "svg":
                              o = M.createElementNS("http://www.w3.org/2000/svg", p);
                              break;
                           case "math":
                              o = M.createElementNS("http://www.w3.org/1998/Math/MathML", p);
                              break;
                           case "script":
                              o = M.createElement("div"), o.innerHTML = "<script><\/script>", o = o.removeChild(o.firstChild);
                              break;
                           case "select":
                              o = typeof y.is == "string" ? M.createElement("select", {
                                 is: y.is
                              }) : M.createElement("select"), y.multiple ? o.multiple = !0 : y.size && (o.size = y.size);
                              break;
                           default:
                              o = typeof y.is == "string" ? M.createElement(p, {
                                 is: y.is
                              }) : M.createElement(p)
                        }
                  }
                  o[Qe] = u, o[St] = y;
                  e: for (M = u.child; M !== null;) {
                     if (M.tag === 5 || M.tag === 6) o.appendChild(M.stateNode);
                     else if (M.tag !== 4 && M.tag !== 27 && M.child !== null) {
                        M.child.return = M, M = M.child;
                        continue
                     }
                     if (M === u) break e;
                     for (; M.sibling === null;) {
                        if (M.return === null || M.return === u) break e;
                        M = M.return
                     }
                     M.sibling.return = M.return, M = M.sibling
                  }
                  u.stateNode = o;
                  e: switch (pr(o, p, y), p) {
                     case "button":
                     case "input":
                     case "select":
                     case "textarea":
                        o = !!y.autoFocus;
                        break e;
                     case "img":
                        o = !0;
                        break e;
                     default:
                        o = !1
                  }
                  o && Ja(u)
               }
            }
            return pi(u), u.flags &= -16777217, null;
         case 6:
            if (o && u.stateNode != null) o.memoizedProps !== y && Ja(u);
            else {
               if (typeof y != "string" && u.stateNode === null) throw Error(i(166));
               if (o = Pe.current, Xa(u)) {
                  if (o = u.stateNode, p = u.memoizedProps, y = null, M = lr, M !== null) switch (M.tag) {
                     case 27:
                     case 5:
                        y = M.memoizedProps
                  }
                  o[Qe] = u, o = !!(o.nodeValue === p || y !== null && y.suppressHydrationWarning === !0 || UC(o.nodeValue, p)), o || su(u)
               } else o = X_(o).createTextNode(y), o[Qe] = u, u.stateNode = o
            }
            return pi(u), null;
         case 13:
            if (y = u.memoizedState, o === null || o.memoizedState !== null && o.memoizedState.dehydrated !== null) {
               if (M = Xa(u), y !== null && y.dehydrated !== null) {
                  if (o === null) {
                     if (!M) throw Error(i(318));
                     if (M = u.memoizedState, M = M !== null ? M.dehydrated : null, !M) throw Error(i(317));
                     M[Qe] = u
                  } else tf(), (u.flags & 128) === 0 && (u.memoizedState = null), u.flags |= 4;
                  pi(u), M = !1
               } else M = Kn(), o !== null && o.memoizedState !== null && (o.memoizedState.hydrationErrors = M), M = !0;
               if (!M) return u.flags & 256 ? (Ro(u), u) : (Ro(u), null)
            }
            if (Ro(u), (u.flags & 128) !== 0) return u.lanes = p, u;
            if (p = y !== null, o = o !== null && o.memoizedState !== null, p) {
               y = u.child, M = null, y.alternate !== null && y.alternate.memoizedState !== null && y.alternate.memoizedState.cachePool !== null && (M = y.alternate.memoizedState.cachePool.pool);
               var R = null;
               y.memoizedState !== null && y.memoizedState.cachePool !== null && (R = y.memoizedState.cachePool.pool), R !== M && (y.flags |= 2048)
            }
            return p !== o && p && (u.child.flags |= 8192), Tl(u, u.updateQueue), pi(u), null;
         case 4:
            return yt(), o === null && _E(u.stateNode.containerInfo), pi(u), null;
         case 10:
            return gl(u.type), pi(u), null;
         case 19:
            if (ye(ki), M = u.memoizedState, M === null) return pi(u), null;
            if (y = (u.flags & 128) !== 0, R = M.rendering, R === null)
               if (y) rc(M, !1);
               else {
                  if (xi !== 0 || o !== null && (o.flags & 128) !== 0)
                     for (o = u.child; o !== null;) {
                        if (R = bl(o), R !== null) {
                           for (u.flags |= 128, rc(M, !1), o = R.updateQueue, u.updateQueue = o, Tl(u, o), u.subtreeFlags = 0, o = p, p = u.child; p !== null;) dv(p, o), p = p.sibling;
                           return we(ki, ki.current & 1 | 2), u.child
                        }
                        o = o.sibling
                     }
                  M.tail !== null && te() > Zs && (u.flags |= 128, y = !0, rc(M, !1), u.lanes = 4194304)
               }
            else {
               if (!y)
                  if (o = bl(R), o !== null) {
                     if (u.flags |= 128, y = !0, o = o.updateQueue, u.updateQueue = o, Tl(u, o), rc(M, !0), M.tail === null && M.tailMode === "hidden" && !R.alternate && !jn) return pi(u), null
                  } else 2 * te() - M.renderingStartTime > Zs && p !== 536870912 && (u.flags |= 128, y = !0, rc(M, !1), u.lanes = 4194304);
               M.isBackwards ? (R.sibling = u.child, u.child = R) : (o = M.last, o !== null ? o.sibling = R : u.child = R, M.last = R)
            }
            return M.tail !== null ? (u = M.tail, M.rendering = u, M.tail = u.sibling, M.renderingStartTime = te(), u.sibling = null, o = ki.current, we(ki, y ? o & 1 | 2 : o & 1), u) : (pi(u), null);
         case 22:
         case 23:
            return Ro(u), Wh(), y = u.memoizedState !== null, o !== null ? o.memoizedState !== null !== y && (u.flags |= 8192) : y && (u.flags |= 8192), y ? (p & 536870912) !== 0 && (u.flags & 128) === 0 && (pi(u), u.subtreeFlags & 6 && (u.flags |= 8192)) : pi(u), p = u.updateQueue, p !== null && Tl(u, p.retryQueue), p = null, o !== null && o.memoizedState !== null && o.memoizedState.cachePool !== null && (p = o.memoizedState.cachePool.pool), y = null, u.memoizedState !== null && u.memoizedState.cachePool !== null && (y = u.memoizedState.cachePool.pool), y !== p && (u.flags |= 2048), o !== null && ye(_a), null;
         case 24:
            return p = null, o !== null && (p = o.memoizedState.cache), u.memoizedState.cache !== p && (u.flags |= 2048), gl(Ji), pi(u), null;
         case 25:
            return null;
         case 30:
            return null
      }
      throw Error(i(156, u.tag))
   }

   function vf(o, u) {
      switch (mv(u), u.tag) {
         case 1:
            return o = u.flags, o & 65536 ? (u.flags = o & -65537 | 128, u) : null;
         case 3:
            return gl(Ji), yt(), o = u.flags, (o & 65536) !== 0 && (o & 128) === 0 ? (u.flags = o & -65537 | 128, u) : null;
         case 26:
         case 27:
         case 5:
            return Mt(u), null;
         case 13:
            if (Ro(u), o = u.memoizedState, o !== null && o.dehydrated !== null) {
               if (u.alternate === null) throw Error(i(340));
               tf()
            }
            return o = u.flags, o & 65536 ? (u.flags = o & -65537 | 128, u) : null;
         case 19:
            return ye(ki), null;
         case 4:
            return yt(), null;
         case 10:
            return gl(u.type), null;
         case 22:
         case 23:
            return Ro(u), Wh(), o !== null && ye(_a), o = u.flags, o & 65536 ? (u.flags = o & -65537 | 128, u) : null;
         case 24:
            return gl(Ji), null;
         case 25:
            return null;
         default:
            return null
      }
   }

   function yf(o, u) {
      switch (mv(u), u.tag) {
         case 3:
            gl(Ji), yt();
            break;
         case 26:
         case 27:
         case 5:
            Mt(u);
            break;
         case 4:
            yt();
            break;
         case 13:
            Ro(u);
            break;
         case 19:
            ye(ki);
            break;
         case 10:
            gl(u.type);
            break;
         case 22:
         case 23:
            Ro(u), Wh(), o !== null && ye(_a);
            break;
         case 24:
            gl(Ji)
      }
   }

   function ac(o, u) {
      try {
         var p = u.updateQueue,
            y = p !== null ? p.lastEffect : null;
         if (y !== null) {
            var M = y.next;
            p = M;
            do {
               if ((p.tag & o) === o) {
                  y = void 0;
                  var R = p.create,
                     V = p.inst;
                  y = R(), V.destroy = y
               }
               p = p.next
            } while (p !== M)
         }
      } catch (W) {
         ce(u, u.return, W)
      }
   }

   function Xr(o, u, p) {
      try {
         var y = u.updateQueue,
            M = y !== null ? y.lastEffect : null;
         if (M !== null) {
            var R = M.next;
            y = R;
            do {
               if ((y.tag & o) === o) {
                  var V = y.inst,
                     W = V.destroy;
                  if (W !== void 0) {
                     V.destroy = void 0, M = u;
                     var se = p,
                        Se = W;
                     try {
                        Se()
                     } catch (Ve) {
                        ce(M, se, Ve)
                     }
                  }
               }
               y = y.next
            } while (y !== R)
         }
      } catch (Ve) {
         ce(u, u.return, Ve)
      }
   }

   function oc(o) {
      var u = o.updateQueue;
      if (u !== null) {
         var p = o.stateNode;
         try {
            t_(u, p)
         } catch (y) {
            ce(o, o.return, y)
         }
      }
   }

   function El(o, u, p) {
      p.props = Co(o.type, o.memoizedProps), p.state = o.memoizedState;
      try {
         p.componentWillUnmount()
      } catch (y) {
         ce(o, u, y)
      }
   }

   function lc(o, u) {
      try {
         var p = o.ref;
         if (p !== null) {
            switch (o.tag) {
               case 26:
               case 27:
               case 5:
                  var y = o.stateNode;
                  break;
               case 30:
                  y = o.stateNode;
                  break;
               default:
                  y = o.stateNode
            }
            typeof p == "function" ? o.refCleanup = p(y) : p.current = y
         }
      } catch (M) {
         ce(o, u, M)
      }
   }

   function No(o, u) {
      var p = o.ref,
         y = o.refCleanup;
      if (p !== null)
         if (typeof y == "function") try {
            y()
         } catch (M) {
            ce(o, u, M)
         } finally {
            o.refCleanup = null, o = o.alternate, o != null && (o.refCleanup = null)
         } else if (typeof p == "function") try {
            p(null)
         } catch (M) {
            ce(o, u, M)
         } else p.current = null
   }

   function xf(o) {
      var u = o.type,
         p = o.memoizedProps,
         y = o.stateNode;
      try {
         e: switch (u) {
            case "button":
            case "input":
            case "select":
            case "textarea":
               p.autoFocus && y.focus();
               break e;
            case "img":
               p.src ? y.src = p.src : p.srcSet && (y.srcset = p.srcSet)
         }
      }
      catch (M) {
         ce(o, o.return, M)
      }
   }

   function nd(o, u, p) {
      try {
         var y = o.stateNode;
         nH(y, o.type, p, u), y[St] = u
      } catch (M) {
         ce(o, o.return, M)
      }
   }

   function id(o) {
      return o.tag === 5 || o.tag === 3 || o.tag === 26 || o.tag === 27 && Af(o.type) || o.tag === 4
   }

   function mu(o) {
      e: for (;;) {
         for (; o.sibling === null;) {
            if (o.return === null || id(o.return)) return null;
            o = o.return
         }
         for (o.sibling.return = o.return, o = o.sibling; o.tag !== 5 && o.tag !== 6 && o.tag !== 18;) {
            if (o.tag === 27 && Af(o.type) || o.flags & 2 || o.child === null || o.tag === 4) continue e;
            o.child.return = o, o = o.child
         }
         if (!(o.flags & 2)) return o.stateNode
      }
   }

   function gu(o, u, p) {
      var y = o.tag;
      if (y === 5 || y === 6) o = o.stateNode, u ? (p.nodeType === 9 ? p.body : p.nodeName === "HTML" ? p.ownerDocument.body : p).insertBefore(o, u) : (u = p.nodeType === 9 ? p.body : p.nodeName === "HTML" ? p.ownerDocument.body : p, u.appendChild(o), p = p._reactRootContainer, p != null || u.onclick !== null || (u.onclick = q_));
      else if (y !== 4 && (y === 27 && Af(o.type) && (p = o.stateNode, u = null), o = o.child, o !== null))
         for (gu(o, u, p), o = o.sibling; o !== null;) gu(o, u, p), o = o.sibling
   }

   function vu(o, u, p) {
      var y = o.tag;
      if (y === 5 || y === 6) o = o.stateNode, u ? p.insertBefore(o, u) : p.appendChild(o);
      else if (y !== 4 && (y === 27 && Af(o.type) && (p = o.stateNode), o = o.child, o !== null))
         for (vu(o, u, p), o = o.sibling; o !== null;) vu(o, u, p), o = o.sibling
   }

   function yu(o) {
      var u = o.stateNode,
         p = o.memoizedProps;
      try {
         for (var y = o.type, M = u.attributes; M.length;) u.removeAttributeNode(M[0]);
         pr(u, y, p), u[Qe] = o, u[St] = p
      } catch (R) {
         ce(o, o.return, R)
      }
   }
   var Oo = !1,
      mi = !1,
      _f = !1,
      Wr = typeof WeakSet == "function" ? WeakSet : Set,
      ci = null;

   function ls(o, u) {
      if (o = o.containerInfo, TE = J_, o = av(o), Nh(o)) {
         if ("selectionStart" in o) var p = {
            start: o.selectionStart,
            end: o.selectionEnd
         };
         else e: {
            p = (p = o.ownerDocument) && p.defaultView || window;
            var y = p.getSelection && p.getSelection();
            if (y && y.rangeCount !== 0) {
               p = y.anchorNode;
               var M = y.anchorOffset,
                  R = y.focusNode;
               y = y.focusOffset;
               try {
                  p.nodeType, R.nodeType
               } catch {
                  p = null;
                  break e
               }
               var V = 0,
                  W = -1,
                  se = -1,
                  Se = 0,
                  Ve = 0,
                  qe = o,
                  Me = null;
               t: for (;;) {
                  for (var Ae; qe !== p || M !== 0 && qe.nodeType !== 3 || (W = V + M), qe !== R || y !== 0 && qe.nodeType !== 3 || (se = V + y), qe.nodeType === 3 && (V += qe.nodeValue.length), (Ae = qe.firstChild) !== null;) Me = qe, qe = Ae;
                  for (;;) {
                     if (qe === o) break t;
                     if (Me === p && ++Se === M && (W = V), Me === R && ++Ve === y && (se = V), (Ae = qe.nextSibling) !== null) break;
                     qe = Me, Me = qe.parentNode
                  }
                  qe = Ae
               }
               p = W === -1 || se === -1 ? null : {
                  start: W,
                  end: se
               }
            } else p = null
         }
         p = p || {
            start: 0,
            end: 0
         }
      } else p = null;
      for (EE = {
            focusedElem: o,
            selectionRange: p
         }, J_ = !1, ci = u; ci !== null;)
         if (u = ci, o = u.child, (u.subtreeFlags & 1024) !== 0 && o !== null) o.return = u, ci = o;
         else
            for (; ci !== null;) {
               switch (u = ci, R = u.alternate, o = u.flags, u.tag) {
                  case 0:
                     break;
                  case 11:
                  case 15:
                     break;
                  case 1:
                     if ((o & 1024) !== 0 && R !== null) {
                        o = void 0, p = u, M = R.memoizedProps, R = R.memoizedState, y = p.stateNode;
                        try {
                           var Qt = Co(p.type, M, p.elementType === p.type);
                           o = y.getSnapshotBeforeUpdate(Qt, R), y.__reactInternalSnapshotBeforeUpdate = o
                        } catch (Gt) {
                           ce(p, p.return, Gt)
                        }
                     }
                     break;
                  case 3:
                     if ((o & 1024) !== 0) {
                        if (o = u.stateNode.containerInfo, p = o.nodeType, p === 9) wE(o);
                        else if (p === 1) switch (o.nodeName) {
                           case "HEAD":
                           case "HTML":
                           case "BODY":
                              wE(o);
                              break;
                           default:
                              o.textContent = ""
                        }
                     }
                     break;
                  case 5:
                  case 26:
                  case 27:
                  case 6:
                  case 4:
                  case 17:
                     break;
                  default:
                     if ((o & 1024) !== 0) throw Error(i(163))
               }
               if (o = u.sibling, o !== null) {
                  o.return = u.return, ci = o;
                  break
               }
               ci = u.return
            }
   }

   function Ml(o, u, p) {
      var y = p.flags;
      switch (p.tag) {
         case 0:
         case 11:
         case 15:
            hr(o, p), y & 4 && ac(5, p);
            break;
         case 1:
            if (hr(o, p), y & 4)
               if (o = p.stateNode, u === null) try {
                  o.componentDidMount()
               } catch (V) {
                  ce(p, p.return, V)
               } else {
                  var M = Co(p.type, u.memoizedProps);
                  u = u.memoizedState;
                  try {
                     o.componentDidUpdate(M, u, o.__reactInternalSnapshotBeforeUpdate)
                  } catch (V) {
                     ce(p, p.return, V)
                  }
               }
            y & 64 && oc(p), y & 512 && lc(p, p.return);
            break;
         case 3:
            if (hr(o, p), y & 64 && (o = p.updateQueue, o !== null)) {
               if (u = null, p.child !== null) switch (p.child.tag) {
                  case 27:
                  case 5:
                     u = p.child.stateNode;
                     break;
                  case 1:
                     u = p.child.stateNode
               }
               try {
                  t_(o, u)
               } catch (V) {
                  ce(p, p.return, V)
               }
            }
            break;
         case 27:
            u === null && y & 4 && yu(p);
         case 26:
         case 5:
            hr(o, p), u === null && y & 4 && xf(p), y & 512 && lc(p, p.return);
            break;
         case 12:
            hr(o, p);
            break;
         case 13:
            hr(o, p), y & 4 && xu(o, p), y & 64 && (o = p.memoizedState, o !== null && (o = o.dehydrated, o !== null && (p = _i.bind(null, p), uH(o, p))));
            break;
         case 22:
            if (y = p.memoizedState !== null || Oo, !y) {
               u = u !== null && u.memoizedState !== null || mi, M = Oo;
               var R = mi;
               Oo = y, (mi = u) && !R ? Uo(o, p, (p.subtreeFlags & 8772) !== 0) : hr(o, p), Oo = M, mi = R
            }
            break;
         case 30:
            break;
         default:
            hr(o, p)
      }
   }

   function fn(o) {
      var u = o.alternate;
      u !== null && (o.alternate = null, fn(u)), o.child = null, o.deletions = null, o.sibling = null, o.tag === 5 && (u = o.stateNode, u !== null && Ft(u)), o.stateNode = null, o.return = null, o.dependencies = null, o.memoizedProps = null, o.memoizedState = null, o.pendingProps = null, o.stateNode = null, o.updateQueue = null
   }
   var Ht = null,
      Fn = !1;

   function Aa(o, u, p) {
      for (p = p.child; p !== null;) uc(o, u, p), p = p.sibling
   }

   function uc(o, u, p) {
      if (Ye && typeof Ye.onCommitFiberUnmount == "function") try {
         Ye.onCommitFiberUnmount(De, p)
      } catch {}
      switch (p.tag) {
         case 26:
            mi || No(p, u), Aa(o, u, p), p.memoizedState ? p.memoizedState.count-- : p.stateNode && (p = p.stateNode, p.parentNode.removeChild(p));
            break;
         case 27:
            mi || No(p, u);
            var y = Ht,
               M = Fn;
            Af(p.type) && (Ht = p.stateNode, Fn = !1), Aa(o, u, p), Yv(p.stateNode), Ht = y, Fn = M;
            break;
         case 5:
            mi || No(p, u);
         case 6:
            if (y = Ht, M = Fn, Ht = null, Aa(o, u, p), Ht = y, Fn = M, Ht !== null)
               if (Fn) try {
                  (Ht.nodeType === 9 ? Ht.body : Ht.nodeName === "HTML" ? Ht.ownerDocument.body : Ht).removeChild(p.stateNode)
               } catch (R) {
                  ce(p, u, R)
               } else try {
                  Ht.removeChild(p.stateNode)
               } catch (R) {
                  ce(p, u, R)
               }
            break;
         case 18:
            Ht !== null && (Fn ? (o = Ht, IC(o.nodeType === 9 ? o.body : o.nodeName === "HTML" ? o.ownerDocument.body : o, p.stateNode), n0(o)) : IC(Ht, p.stateNode));
            break;
         case 4:
            y = Ht, M = Fn, Ht = p.stateNode.containerInfo, Fn = !0, Aa(o, u, p), Ht = y, Fn = M;
            break;
         case 0:
         case 11:
         case 14:
         case 15:
            mi || Xr(2, p, u), mi || Xr(4, p, u), Aa(o, u, p);
            break;
         case 1:
            mi || (No(p, u), y = p.stateNode, typeof y.componentWillUnmount == "function" && El(p, u, y)), Aa(o, u, p);
            break;
         case 21:
            Aa(o, u, p);
            break;
         case 22:
            mi = (y = mi) || p.memoizedState !== null, Aa(o, u, p), mi = y;
            break;
         default:
            Aa(o, u, p)
      }
   }

   function xu(o, u) {
      if (u.memoizedState === null && (o = u.alternate, o !== null && (o = o.memoizedState, o !== null && (o = o.dehydrated, o !== null)))) try {
         n0(o)
      } catch (p) {
         ce(u, u.return, p)
      }
   }

   function nm(o) {
      switch (o.tag) {
         case 13:
         case 19:
            var u = o.stateNode;
            return u === null && (u = o.stateNode = new Wr), u;
         case 22:
            return o = o.stateNode, u = o._retryCache, u === null && (u = o._retryCache = new Wr), u;
         default:
            throw Error(i(435, o.tag))
      }
   }

   function cc(o, u) {
      var p = nm(o);
      u.forEach(function (y) {
         var M = Kt.bind(null, o, y);
         p.has(y) || (p.add(y), y.then(M, M))
      })
   }

   function Ts(o, u) {
      var p = u.deletions;
      if (p !== null)
         for (var y = 0; y < p.length; y++) {
            var M = p[y],
               R = o,
               V = u,
               W = V;
            e: for (; W !== null;) {
               switch (W.tag) {
                  case 27:
                     if (Af(W.type)) {
                        Ht = W.stateNode, Fn = !1;
                        break e
                     }
                     break;
                  case 5:
                     Ht = W.stateNode, Fn = !1;
                     break e;
                  case 3:
                  case 4:
                     Ht = W.stateNode.containerInfo, Fn = !0;
                     break e
               }
               W = W.return
            }
            if (Ht === null) throw Error(i(160));
            uc(R, V, M), Ht = null, Fn = !1, R = M.alternate, R !== null && (R.return = null), M.return = null
         }
      if (u.subtreeFlags & 13878)
         for (u = u.child; u !== null;) im(u, o), u = u.sibling
   }
   var $a = null;

   function im(o, u) {
      var p = o.alternate,
         y = o.flags;
      switch (o.tag) {
         case 0:
         case 11:
         case 14:
         case 15:
            Ts(u, o), Ui(o), y & 4 && (Xr(3, o, o.return), ac(3, o), Xr(5, o, o.return));
            break;
         case 1:
            Ts(u, o), Ui(o), y & 512 && (mi || p === null || No(p, p.return)), y & 64 && Oo && (o = o.updateQueue, o !== null && (y = o.callbacks, y !== null && (p = o.shared.hiddenCallbacks, o.shared.hiddenCallbacks = p === null ? y : p.concat(y))));
            break;
         case 26:
            var M = $a;
            if (Ts(u, o), Ui(o), y & 512 && (mi || p === null || No(p, p.return)), y & 4) {
               var R = p !== null ? p.memoizedState : null;
               if (y = o.memoizedState, p === null)
                  if (y === null)
                     if (o.stateNode === null) {
                        e: {
                           y = o.type,
                           p = o.memoizedProps,
                           M = M.ownerDocument || M;t: switch (y) {
                              case "title":
                                 R = M.getElementsByTagName("title")[0], (!R || R[ii] || R[Qe] || R.namespaceURI === "http://www.w3.org/2000/svg" || R.hasAttribute("itemprop")) && (R = M.createElement(y), M.head.insertBefore(R, M.querySelector("head > title"))), pr(R, y, p), R[Qe] = o, Pn(R), y = R;
                                 break e;
                              case "link":
                                 var V = XC("link", "href", M).get(y + (p.href || ""));
                                 if (V) {
                                    for (var W = 0; W < V.length; W++)
                                       if (R = V[W], R.getAttribute("href") === (p.href == null || p.href === "" ? null : p.href) && R.getAttribute("rel") === (p.rel == null ? null : p.rel) && R.getAttribute("title") === (p.title == null ? null : p.title) && R.getAttribute("crossorigin") === (p.crossOrigin == null ? null : p.crossOrigin)) {
                                          V.splice(W, 1);
                                          break t
                                       }
                                 }
                                 R = M.createElement(y), pr(R, y, p), M.head.appendChild(R);
                                 break;
                              case "meta":
                                 if (V = XC("meta", "content", M).get(y + (p.content || ""))) {
                                    for (W = 0; W < V.length; W++)
                                       if (R = V[W], R.getAttribute("content") === (p.content == null ? null : "" + p.content) && R.getAttribute("name") === (p.name == null ? null : p.name) && R.getAttribute("property") === (p.property == null ? null : p.property) && R.getAttribute("http-equiv") === (p.httpEquiv == null ? null : p.httpEquiv) && R.getAttribute("charset") === (p.charSet == null ? null : p.charSet)) {
                                          V.splice(W, 1);
                                          break t
                                       }
                                 }
                                 R = M.createElement(y), pr(R, y, p), M.head.appendChild(R);
                                 break;
                              default:
                                 throw Error(i(468, y))
                           }
                           R[Qe] = o,
                           Pn(R),
                           y = R
                        }
                        o.stateNode = y
                     }
               else WC(M, o.type, o.stateNode);
               else o.stateNode = qC(M, y, o.memoizedProps);
               else R !== y ? (R === null ? p.stateNode !== null && (p = p.stateNode, p.parentNode.removeChild(p)) : R.count--, y === null ? WC(M, o.type, o.stateNode) : qC(M, y, o.memoizedProps)) : y === null && o.stateNode !== null && nd(o, o.memoizedProps, p.memoizedProps)
            }
            break;
         case 27:
            Ts(u, o), Ui(o), y & 512 && (mi || p === null || No(p, p.return)), p !== null && y & 4 && nd(o, o.memoizedProps, p.memoizedProps);
            break;
         case 5:
            if (Ts(u, o), Ui(o), y & 512 && (mi || p === null || No(p, p.return)), o.flags & 32) {
               M = o.stateNode;
               try {
                  rr(M, "")
               } catch (Ae) {
                  ce(o, o.return, Ae)
               }
            }
            y & 4 && o.stateNode != null && (M = o.memoizedProps, nd(o, M, p !== null ? p.memoizedProps : M)), y & 1024 && (_f = !0);
            break;
         case 6:
            if (Ts(u, o), Ui(o), y & 4) {
               if (o.stateNode === null) throw Error(i(162));
               y = o.memoizedProps, p = o.stateNode;
               try {
                  p.nodeValue = y
               } catch (Ae) {
                  ce(o, o.return, Ae)
               }
            }
            break;
         case 3:
            if (K_ = null, M = $a, $a = W_(u.containerInfo), Ts(u, o), $a = M, Ui(o), y & 4 && p !== null && p.memoizedState.isDehydrated) try {
               n0(u.containerInfo)
            } catch (Ae) {
               ce(o, o.return, Ae)
            }
            _f && (_f = !1, _u(o));
            break;
         case 4:
            y = $a, $a = W_(o.stateNode.containerInfo), Ts(u, o), Ui(o), $a = y;
            break;
         case 12:
            Ts(u, o), Ui(o);
            break;
         case 13:
            Ts(u, o), Ui(o), o.child.flags & 8192 && o.memoizedState !== null != (p !== null && p.memoizedState !== null) && (ri = te()), y & 4 && (y = o.updateQueue, y !== null && (o.updateQueue = null, cc(o, y)));
            break;
         case 22:
            M = o.memoizedState !== null;
            var se = p !== null && p.memoizedState !== null,
               Se = Oo,
               Ve = mi;
            if (Oo = Se || M, mi = Ve || se, Ts(u, o), mi = Ve, Oo = Se, Ui(o), y & 8192) e: for (u = o.stateNode, u._visibility = M ? u._visibility & -2 : u._visibility | 1, M && (p === null || se || Oo || mi || Yr(o)), p = null, u = o;;) {
               if (u.tag === 5 || u.tag === 26) {
                  if (p === null) {
                     se = p = u;
                     try {
                        if (R = se.stateNode, M) V = R.style, typeof V.setProperty == "function" ? V.setProperty("display", "none", "important") : V.display = "none";
                        else {
                           W = se.stateNode;
                           var qe = se.memoizedProps.style,
                              Me = qe != null && qe.hasOwnProperty("display") ? qe.display : null;
                           W.style.display = Me == null || typeof Me == "boolean" ? "" : ("" + Me).trim()
                        }
                     } catch (Ae) {
                        ce(se, se.return, Ae)
                     }
                  }
               } else if (u.tag === 6) {
                  if (p === null) {
                     se = u;
                     try {
                        se.stateNode.nodeValue = M ? "" : se.memoizedProps
                     } catch (Ae) {
                        ce(se, se.return, Ae)
                     }
                  }
               } else if ((u.tag !== 22 && u.tag !== 23 || u.memoizedState === null || u === o) && u.child !== null) {
                  u.child.return = u, u = u.child;
                  continue
               }
               if (u === o) break e;
               for (; u.sibling === null;) {
                  if (u.return === null || u.return === o) break e;
                  p === u && (p = null), u = u.return
               }
               p === u && (p = null), u.sibling.return = u.return, u = u.sibling
            }
            y & 4 && (y = o.updateQueue, y !== null && (p = y.retryQueue, p !== null && (y.retryQueue = null, cc(o, p))));
            break;
         case 19:
            Ts(u, o), Ui(o), y & 4 && (y = o.updateQueue, y !== null && (o.updateQueue = null, cc(o, y)));
            break;
         case 30:
            break;
         case 21:
            break;
         default:
            Ts(u, o), Ui(o)
      }
   }

   function Ui(o) {
      var u = o.flags;
      if (u & 2) {
         try {
            for (var p, y = o.return; y !== null;) {
               if (id(y)) {
                  p = y;
                  break
               }
               y = y.return
            }
            if (p == null) throw Error(i(160));
            switch (p.tag) {
               case 27:
                  var M = p.stateNode,
                     R = mu(o);
                  vu(o, R, M);
                  break;
               case 5:
                  var V = p.stateNode;
                  p.flags & 32 && (rr(V, ""), p.flags &= -33);
                  var W = mu(o);
                  vu(o, W, V);
                  break;
               case 3:
               case 4:
                  var se = p.stateNode.containerInfo,
                     Se = mu(o);
                  gu(o, Se, se);
                  break;
               default:
                  throw Error(i(161))
            }
         } catch (Ve) {
            ce(o, o.return, Ve)
         }
         o.flags &= -3
      }
      u & 4096 && (o.flags &= -4097)
   }

   function _u(o) {
      if (o.subtreeFlags & 1024)
         for (o = o.child; o !== null;) {
            var u = o;
            _u(u), u.tag === 5 && u.flags & 1024 && u.stateNode.reset(), o = o.sibling
         }
   }

   function hr(o, u) {
      if (u.subtreeFlags & 8772)
         for (u = u.child; u !== null;) Ml(o, u.alternate, u), u = u.sibling
   }

   function Yr(o) {
      for (o = o.child; o !== null;) {
         var u = o;
         switch (u.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
               Xr(4, u, u.return), Yr(u);
               break;
            case 1:
               No(u, u.return);
               var p = u.stateNode;
               typeof p.componentWillUnmount == "function" && El(u, u.return, p), Yr(u);
               break;
            case 27:
               Yv(u.stateNode);
            case 26:
            case 5:
               No(u, u.return), Yr(u);
               break;
            case 22:
               u.memoizedState === null && Yr(u);
               break;
            case 30:
               Yr(u);
               break;
            default:
               Yr(u)
         }
         o = o.sibling
      }
   }

   function Uo(o, u, p) {
      for (p = p && (u.subtreeFlags & 8772) !== 0, u = u.child; u !== null;) {
         var y = u.alternate,
            M = o,
            R = u,
            V = R.flags;
         switch (R.tag) {
            case 0:
            case 11:
            case 15:
               Uo(M, R, p), ac(4, R);
               break;
            case 1:
               if (Uo(M, R, p), y = R, M = y.stateNode, typeof M.componentDidMount == "function") try {
                  M.componentDidMount()
               } catch (Se) {
                  ce(y, y.return, Se)
               }
               if (y = R, M = y.updateQueue, M !== null) {
                  var W = y.stateNode;
                  try {
                     var se = M.shared.hiddenCallbacks;
                     if (se !== null)
                        for (M.shared.hiddenCallbacks = null, M = 0; M < se.length; M++) uf(se[M], W)
                  } catch (Se) {
                     ce(y, y.return, Se)
                  }
               }
               p && V & 64 && oc(R), lc(R, R.return);
               break;
            case 27:
               yu(R);
            case 26:
            case 5:
               Uo(M, R, p), p && y === null && V & 4 && xf(R), lc(R, R.return);
               break;
            case 12:
               Uo(M, R, p);
               break;
            case 13:
               Uo(M, R, p), p && V & 4 && xu(M, R);
               break;
            case 22:
               R.memoizedState === null && Uo(M, R, p), lc(R, R.return);
               break;
            case 30:
               break;
            default:
               Uo(M, R, p)
         }
         u = u.sibling
      }
   }

   function sm(o, u) {
      var p = null;
      o !== null && o.memoizedState !== null && o.memoizedState.cachePool !== null && (p = o.memoizedState.cachePool.pool), o = null, u.memoizedState !== null && u.memoizedState.cachePool !== null && (o = u.memoizedState.cachePool.pool), o !== p && (o != null && o.refCount++, p != null && nf(p))
   }

   function rm(o, u) {
      o = null, u.alternate !== null && (o = u.alternate.memoizedState.cache), u = u.memoizedState.cache, u !== o && (u.refCount++, o != null && nf(o))
   }

   function fi(o, u, p, y) {
      if (u.subtreeFlags & 10256)
         for (u = u.child; u !== null;) am(o, u, p, y), u = u.sibling
   }

   function am(o, u, p, y) {
      var M = u.flags;
      switch (u.tag) {
         case 0:
         case 11:
         case 15:
            fi(o, u, p, y), M & 2048 && ac(9, u);
            break;
         case 1:
            fi(o, u, p, y);
            break;
         case 3:
            fi(o, u, p, y), M & 2048 && (o = null, u.alternate !== null && (o = u.alternate.memoizedState.cache), u = u.memoizedState.cache, u !== o && (u.refCount++, o != null && nf(o)));
            break;
         case 12:
            if (M & 2048) {
               fi(o, u, p, y), o = u.stateNode;
               try {
                  var R = u.memoizedProps,
                     V = R.id,
                     W = R.onPostCommit;
                  typeof W == "function" && W(V, u.alternate === null ? "mount" : "update", o.passiveEffectDuration, -0)
               } catch (se) {
                  ce(u, u.return, se)
               }
            } else fi(o, u, p, y);
            break;
         case 13:
            fi(o, u, p, y);
            break;
         case 23:
            break;
         case 22:
            R = u.stateNode, V = u.alternate, u.memoizedState !== null ? R._visibility & 2 ? fi(o, u, p, y) : eo(o, u) : R._visibility & 2 ? fi(o, u, p, y) : (R._visibility |= 2, Al(o, u, p, y, (u.subtreeFlags & 10256) !== 0)), M & 2048 && sm(V, u);
            break;
         case 24:
            fi(o, u, p, y), M & 2048 && rm(u.alternate, u);
            break;
         default:
            fi(o, u, p, y)
      }
   }

   function Al(o, u, p, y, M) {
      for (M = M && (u.subtreeFlags & 10256) !== 0, u = u.child; u !== null;) {
         var R = o,
            V = u,
            W = p,
            se = y,
            Se = V.flags;
         switch (V.tag) {
            case 0:
            case 11:
            case 15:
               Al(R, V, W, se, M), ac(8, V);
               break;
            case 23:
               break;
            case 22:
               var Ve = V.stateNode;
               V.memoizedState !== null ? Ve._visibility & 2 ? Al(R, V, W, se, M) : eo(R, V) : (Ve._visibility |= 2, Al(R, V, W, se, M)), M && Se & 2048 && sm(V.alternate, V);
               break;
            case 24:
               Al(R, V, W, se, M), M && Se & 2048 && rm(V.alternate, V);
               break;
            default:
               Al(R, V, W, se, M)
         }
         u = u.sibling
      }
   }

   function eo(o, u) {
      if (u.subtreeFlags & 10256)
         for (u = u.child; u !== null;) {
            var p = o,
               y = u,
               M = y.flags;
            switch (y.tag) {
               case 22:
                  eo(p, y), M & 2048 && sm(y.alternate, y);
                  break;
               case 24:
                  eo(p, y), M & 2048 && rm(y.alternate, y);
                  break;
               default:
                  eo(p, y)
            }
            u = u.sibling
         }
   }
   var Kr = 8192;

   function Sf(o) {
      if (o.subtreeFlags & Kr)
         for (o = o.child; o !== null;) V_(o), o = o.sibling
   }

   function V_(o) {
      switch (o.tag) {
         case 26:
            Sf(o), o.flags & Kr && o.memoizedState !== null && bH($a, o.memoizedState, o.memoizedProps);
            break;
         case 5:
            Sf(o);
            break;
         case 3:
         case 4:
            var u = $a;
            $a = W_(o.stateNode.containerInfo), Sf(o), $a = u;
            break;
         case 22:
            o.memoizedState === null && (u = o.alternate, u !== null && u.memoizedState !== null ? (u = Kr, Kr = 16777216, Sf(o), Kr = u) : Sf(o));
            break;
         default:
            Sf(o)
      }
   }

   function G_(o) {
      var u = o.alternate;
      if (u !== null && (o = u.child, o !== null)) {
         u.child = null;
         do u = o.sibling, o.sibling = null, o = u; while (o !== null)
      }
   }

   function gi(o) {
      var u = o.deletions;
      if ((o.flags & 16) !== 0) {
         if (u !== null)
            for (var p = 0; p < u.length; p++) {
               var y = u[p];
               ci = y, Lo(y, o)
            }
         G_(o)
      }
      if (o.subtreeFlags & 10256)
         for (o = o.child; o !== null;) kv(o), o = o.sibling
   }

   function kv(o) {
      switch (o.tag) {
         case 0:
         case 11:
         case 15:
            gi(o), o.flags & 2048 && Xr(9, o, o.return);
            break;
         case 3:
            gi(o);
            break;
         case 12:
            gi(o);
            break;
         case 22:
            var u = o.stateNode;
            o.memoizedState !== null && u._visibility & 2 && (o.return === null || o.return.tag !== 13) ? (u._visibility &= -3, Po(o)) : gi(o);
            break;
         default:
            gi(o)
      }
   }

   function Po(o) {
      var u = o.deletions;
      if ((o.flags & 16) !== 0) {
         if (u !== null)
            for (var p = 0; p < u.length; p++) {
               var y = u[p];
               ci = y, Lo(y, o)
            }
         G_(o)
      }
      for (o = o.child; o !== null;) {
         switch (u = o, u.tag) {
            case 0:
            case 11:
            case 15:
               Xr(8, u, u.return), Po(u);
               break;
            case 22:
               p = u.stateNode, p._visibility & 2 && (p._visibility &= -3, Po(u));
               break;
            default:
               Po(u)
         }
         o = o.sibling
      }
   }

   function Lo(o, u) {
      for (; ci !== null;) {
         var p = ci;
         switch (p.tag) {
            case 0:
            case 11:
            case 15:
               Xr(8, p, u);
               break;
            case 23:
            case 22:
               if (p.memoizedState !== null && p.memoizedState.cachePool !== null) {
                  var y = p.memoizedState.cachePool.pool;
                  y != null && y.refCount++
               }
               break;
            case 24:
               nf(p.memoizedState.cache)
         }
         if (y = p.child, y !== null) y.return = p, ci = y;
         else e: for (p = o; ci !== null;) {
            y = ci;
            var M = y.sibling,
               R = y.return;
            if (fn(y), y === p) {
               ci = null;
               break e
            }
            if (M !== null) {
               M.return = R, ci = M;
               break e
            }
            ci = R
         }
      }
   }
   var Pi = {
         getCacheForType: function (o) {
            var u = Oi(Ji),
               p = u.data.get(o);
            return p === void 0 && (p = o(), u.data.set(o, p)), p
         }
      },
      jv = typeof WeakMap == "function" ? WeakMap : Map,
      Zn = 0,
      en = null,
      xn = null,
      Lt = 0,
      ln = 0,
      Di = null,
      Zr = !1,
      bf = !1,
      Tf = !1,
      wa = 0,
      xi = 0,
      to = 0,
      Bo = 0,
      fc = 0,
      Ra = 0,
      Hn = 0,
      Qn = null,
      Vt = null,
      wn = !1,
      ri = 0,
      Zs = 1 / 0,
      Ca = null,
      Qr = null,
      us = 0,
      Qs = null,
      hi = null,
      Jr = 0,
      wl = 0,
      sd = null,
      $r = null,
      zo = 0,
      hc = null;

   function Li() {
      if ((Zn & 2) !== 0 && Lt !== 0) return Lt & -Lt;
      if (k.T !== null) {
         var o = rn;
         return o !== 0 ? o : gE()
      }
      return ut()
   }

   function om() {
      Ra === 0 && (Ra = (Lt & 536870912) === 0 || jn ? le() : 536870912);
      var o = ui.current;
      return o !== null && (o.flags |= 32), Ra
   }

   function dr(o, u, p) {
      (o === en && (ln === 2 || ln === 9) || o.cancelPendingCommit !== null) && (bu(o, 0), no(o, Lt, Ra, !1)), Ie(o, p), ((Zn & 2) === 0 || o !== en) && (o === en && ((Zn & 2) === 0 && (Bo |= p), xi === 4 && no(o, Lt, Ra, !1)), Mu(o))
   }

   function Ef(o, u, p) {
      if ((Zn & 6) !== 0) throw Error(i(327));
      var y = !p && (u & 124) === 0 && (u & o.expiredLanes) === 0 || Rt(o, u),
         M = y ? A(o, u) : d(o, u, !0),
         R = y;
      do {
         if (M === 0) {
            bf && !y && no(o, u, 0, !1);
            break
         } else {
            if (p = o.current.alternate, R && !Su(p)) {
               M = d(o, u, !1), R = !1;
               continue
            }
            if (M === 2) {
               if (R = u, o.errorRecoveryDisabledLanes & R) var V = 0;
               else V = o.pendingLanes & -536870913, V = V !== 0 ? V : V & 536870912 ? 536870912 : 0;
               if (V !== 0) {
                  u = V;
                  e: {
                     var W = o;M = Qn;
                     var se = W.current.memoizedState.isDehydrated;
                     if (se && (bu(W, V).flags |= 256), V = d(W, V, !1), V !== 2) {
                        if (Tf && !se) {
                           W.errorRecoveryDisabledLanes |= R, Bo |= R, M = 4;
                           break e
                        }
                        R = Vt, Vt = M, R !== null && (Vt === null ? Vt = R : Vt.push.apply(Vt, R))
                     }
                     M = V
                  }
                  if (R = !1, M !== 2) continue
               }
            }
            if (M === 1) {
               bu(o, 0), no(o, u, 0, !0);
               break
            }
            e: {
               switch (y = o, R = M, R) {
                  case 0:
                  case 1:
                     throw Error(i(345));
                  case 4:
                     if ((u & 4194048) !== u) break;
                  case 6:
                     no(y, u, Ra, !Zr);
                     break e;
                  case 2:
                     Vt = null;
                     break;
                  case 3:
                  case 5:
                     break;
                  default:
                     throw Error(i(329))
               }
               if ((u & 62914560) === u && (M = ri + 300 - te(), 10 < M)) {
                  if (no(y, u, Ra, !Zr), jt(y, 0, !0) !== 0) break e;
                  y.timeoutHandle = BC(rd.bind(null, y, p, Vt, Ca, wn, u, Ra, Bo, Hn, Zr, R, 2, -0, 0), M);
                  break e
               }
               rd(y, p, Vt, Ca, wn, u, Ra, Bo, Hn, Zr, R, 0, -0, 0)
            }
         }
         break
      } while (!0);
      Mu(o)
   }

   function rd(o, u, p, y, M, R, V, W, se, Se, Ve, qe, Me, Ae) {
      if (o.timeoutHandle = -1, qe = u.subtreeFlags, (qe & 8192 || (qe & 16785408) === 16785408) && (Qv = {
            stylesheets: null,
            count: 0,
            unsuspend: SH
         }, V_(u), qe = TH(), qe !== null)) {
         o.cancelPendingCommit = qe(tt.bind(null, o, u, R, p, y, M, V, W, se, Ve, 1, Me, Ae)), no(o, R, V, !Se);
         return
      }
      tt(o, u, R, p, y, M, V, W, se)
   }

   function Su(o) {
      for (var u = o;;) {
         var p = u.tag;
         if ((p === 0 || p === 11 || p === 15) && u.flags & 16384 && (p = u.updateQueue, p !== null && (p = p.stores, p !== null)))
            for (var y = 0; y < p.length; y++) {
               var M = p[y],
                  R = M.getSnapshot;
               M = M.value;
               try {
                  if (!xr(R(), M)) return !1
               } catch {
                  return !1
               }
            }
         if (p = u.child, u.subtreeFlags & 16384 && p !== null) p.return = u, u = p;
         else {
            if (u === o) break;
            for (; u.sibling === null;) {
               if (u.return === null || u.return === o) return !0;
               u = u.return
            }
            u.sibling.return = u.return, u = u.sibling
         }
      }
      return !0
   }

   function no(o, u, p, y) {
      u &= ~fc, u &= ~Bo, o.suspendedLanes |= u, o.pingedLanes &= ~u, y && (o.warmLanes |= u), y = o.expirationTimes;
      for (var M = u; 0 < M;) {
         var R = 31 - Ze(M),
            V = 1 << R;
         y[R] = -1, M &= ~V
      }
      p !== 0 && at(o, p, u)
   }

   function Io() {
      return (Zn & 6) === 0 ? (qv(0), !1) : !0
   }

   function dc() {
      if (xn !== null) {
         if (ln === 0) var o = xn.return;
         else o = xn, ml = ru = null, Av(o), Qu = null, Qh = 0, o = xn;
         for (; o !== null;) yf(o.alternate, o), o = o.return;
         xn = null
      }
   }

   function bu(o, u) {
      var p = o.timeoutHandle;
      p !== -1 && (o.timeoutHandle = -1, sH(p)), p = o.cancelPendingCommit, p !== null && (o.cancelPendingCommit = null, p()), dc(), en = o, xn = p = Vi(o.current, null), Lt = u, ln = 0, Di = null, Zr = !1, bf = Rt(o, u), Tf = !1, Hn = Ra = fc = Bo = to = xi = 0, Vt = Qn = null, wn = !1, (u & 8) !== 0 && (u |= u & 32);
      var y = o.entangledLanes;
      if (y !== 0)
         for (o = o.entanglements, y &= u; 0 < y;) {
            var M = 31 - Ze(y),
               R = 1 << M;
            u |= o[M], y &= ~R
         }
      return wa = u, Ph(), p
   }

   function lm(o, u) {
      an = null, k.H = Zh, u === jh || u === Wa ? (u = Sv(), ln = 3) : u === _v ? (u = Sv(), ln = 4) : ln = u === H_ ? 8 : u !== null && typeof u == "object" && typeof u.then == "function" ? 6 : 1, Di = u, xn === null && (xi = 1, $p(o, zs(u, o.current)))
   }

   function Mf() {
      var o = k.H;
      return k.H = Zh, o === null ? Zh : o
   }

   function um() {
      var o = k.A;
      return k.A = Pi, o
   }

   function f() {
      xi = 4, Zr || (Lt & 4194048) !== Lt && ui.current !== null || (bf = !0), (to & 134217727) === 0 && (Bo & 134217727) === 0 || en === null || no(en, Lt, Ra, !1)
   }

   function d(o, u, p) {
      var y = Zn;
      Zn |= 2;
      var M = Mf(),
         R = um();
      (en !== o || Lt !== u) && (Ca = null, bu(o, u)), u = !1;
      var V = xi;
      e: do try {
            if (ln !== 0 && xn !== null) {
               var W = xn,
                  se = Di;
               switch (ln) {
                  case 8:
                     dc(), V = 6;
                     break e;
                  case 3:
                  case 2:
                  case 9:
                  case 6:
                     ui.current === null && (u = !0);
                     var Se = ln;
                     if (ln = 0, Di = null, re(o, W, se, Se), p && bf) {
                        V = 0;
                        break e
                     }
                     break;
                  default:
                     Se = ln, ln = 0, Di = null, re(o, W, se, Se)
               }
            }
            _(), V = xi;
            break
         } catch (Ve) {
            lm(o, Ve)
         }
         while (!0);
         return u && o.shellSuspendCounter++, ml = ru = null, Zn = y, k.H = M, k.A = R, xn === null && (en = null, Lt = 0, Ph()), V
   }

   function _() {
      for (; xn !== null;) L(xn)
   }

   function A(o, u) {
      var p = Zn;
      Zn |= 2;
      var y = Mf(),
         M = um();
      en !== o || Lt !== u ? (Ca = null, Zs = te() + 500, bu(o, u)) : bf = Rt(o, u);
      e: do try {
            if (ln !== 0 && xn !== null) {
               u = xn;
               var R = Di;
               t: switch (ln) {
                  case 1:
                     ln = 0, Di = null, re(o, u, R, 1);
                     break;
                  case 2:
                  case 9:
                     if (Ip(R)) {
                        ln = 0, Di = null, Y(u);
                        break
                     }
                     u = function () {
                        ln !== 2 && ln !== 9 || en !== o || (ln = 7), Mu(o)
                     }, R.then(u, u);
                     break e;
                  case 3:
                     ln = 7;
                     break e;
                  case 4:
                     ln = 5;
                     break e;
                  case 7:
                     Ip(R) ? (ln = 0, Di = null, Y(u)) : (ln = 0, Di = null, re(o, u, R, 7));
                     break;
                  case 5:
                     var V = null;
                     switch (xn.tag) {
                        case 26:
                           V = xn.memoizedState;
                        case 5:
                        case 27:
                           var W = xn;
                           if (!V || YC(V)) {
                              ln = 0, Di = null;
                              var se = W.sibling;
                              if (se !== null) xn = se;
                              else {
                                 var Se = W.return;
                                 Se !== null ? (xn = Se, ve(Se)) : xn = null
                              }
                              break t
                           }
                     }
                     ln = 0, Di = null, re(o, u, R, 5);
                     break;
                  case 6:
                     ln = 0, Di = null, re(o, u, R, 6);
                     break;
                  case 8:
                     dc(), xi = 6;
                     break e;
                  default:
                     throw Error(i(462))
               }
            }
            D();
            break
         } catch (Ve) {
            lm(o, Ve)
         }
         while (!0);
         return ml = ru = null, k.H = y, k.A = M, Zn = p, xn !== null ? 0 : (en = null, Lt = 0, Ph(), xi)
   }

   function D() {
      for (; xn !== null && !sn();) L(xn)
   }

   function L(o) {
      var u = sc(o.alternate, o, wa);
      o.memoizedProps = o.pendingProps, u === null ? ve(o) : xn = u
   }

   function Y(o) {
      var u = o,
         p = u.alternate;
      switch (u.tag) {
         case 15:
         case 0:
            u = jr(p, u, u.pendingProps, u.type, void 0, Lt);
            break;
         case 11:
            u = jr(p, u, u.pendingProps, u.type.render, u.ref, Lt);
            break;
         case 5:
            Av(u);
         default:
            yf(p, u), u = xn = dv(u, wa), u = sc(p, u, wa)
      }
      o.memoizedProps = o.pendingProps, u === null ? ve(o) : xn = u
   }

   function re(o, u, p, y) {
      ml = ru = null, Av(u), Qu = null, Qh = 0;
      var M = u.return;
      try {
         if (pE(o, M, u, p, Lt)) {
            xi = 1, $p(o, zs(p, o.current)), xn = null;
            return
         }
      } catch (R) {
         if (M !== null) throw xn = M, R;
         xi = 1, $p(o, zs(p, o.current)), xn = null;
         return
      }
      u.flags & 32768 ? (jn || y === 1 ? o = !0 : bf || (Lt & 536870912) !== 0 ? o = !1 : (Zr = o = !0, (y === 2 || y === 9 || y === 3 || y === 6) && (y = ui.current, y !== null && y.tag === 13 && (y.flags |= 16384))), He(u, o)) : ve(u)
   }

   function ve(o) {
      var u = o;
      do {
         if ((u.flags & 32768) !== 0) {
            He(u, Zr);
            return
         }
         o = u.return;
         var p = Gv(u.alternate, u, wa);
         if (p !== null) {
            xn = p;
            return
         }
         if (u = u.sibling, u !== null) {
            xn = u;
            return
         }
         xn = u = o
      } while (u !== null);
      xi === 0 && (xi = 5)
   }

   function He(o, u) {
      do {
         var p = vf(o.alternate, o);
         if (p !== null) {
            p.flags &= 32767, xn = p;
            return
         }
         if (p = o.return, p !== null && (p.flags |= 32768, p.subtreeFlags = 0, p.deletions = null), !u && (o = o.sibling, o !== null)) {
            xn = o;
            return
         }
         xn = o = p
      } while (o !== null);
      xi = 6, xn = null
   }

   function tt(o, u, p, y, M, R, V, W, se) {
      o.cancelPendingCommit = null;
      do Tu(); while (us !== 0);
      if ((Zn & 6) !== 0) throw Error(i(327));
      if (u !== null) {
         if (u === o.current) throw Error(i(177));
         if (R = u.lanes | u.childLanes, R |= Cp, nt(o, p, R, V, W, se), o === en && (xn = en = null, Lt = 0), hi = u, Qs = o, Jr = p, wl = R, sd = M, $r = y, (u.subtreeFlags & 10256) !== 0 || (u.flags & 10256) !== 0 ? (o.callbackNode = null, o.callbackPriority = 0, qn(K, function () {
               return Eu(), null
            })) : (o.callbackNode = null, o.callbackPriority = 0), y = (u.flags & 13878) !== 0, (u.subtreeFlags & 13878) !== 0 || y) {
            y = k.T, k.T = null, M = Z.p, Z.p = 2, V = Zn, Zn |= 4;
            try {
               ls(o, u, p)
            } finally {
               Zn = V, Z.p = M, k.T = y
            }
         }
         us = 1, ft(), pt(), tn()
      }
   }

   function ft() {
      if (us === 1) {
         us = 0;
         var o = Qs,
            u = hi,
            p = (u.flags & 13878) !== 0;
         if ((u.subtreeFlags & 13878) !== 0 || p) {
            p = k.T, k.T = null;
            var y = Z.p;
            Z.p = 2;
            var M = Zn;
            Zn |= 4;
            try {
               im(u, o);
               var R = EE,
                  V = av(o.containerInfo),
                  W = R.focusedElem,
                  se = R.selectionRange;
               if (V !== W && W && W.ownerDocument && rv(W.ownerDocument.documentElement, W)) {
                  if (se !== null && Nh(W)) {
                     var Se = se.start,
                        Ve = se.end;
                     if (Ve === void 0 && (Ve = Se), "selectionStart" in W) W.selectionStart = Se, W.selectionEnd = Math.min(Ve, W.value.length);
                     else {
                        var qe = W.ownerDocument || document,
                           Me = qe && qe.defaultView || window;
                        if (Me.getSelection) {
                           var Ae = Me.getSelection(),
                              Qt = W.textContent.length,
                              Gt = Math.min(se.start, Qt),
                              yi = se.end === void 0 ? Gt : Math.min(se.end, Qt);
                           !Ae.extend && Gt > yi && (V = yi, yi = Gt, Gt = V);
                           var ge = sv(W, Gt),
                              he = sv(W, yi);
                           if (ge && he && (Ae.rangeCount !== 1 || Ae.anchorNode !== ge.node || Ae.anchorOffset !== ge.offset || Ae.focusNode !== he.node || Ae.focusOffset !== he.offset)) {
                              var _e = qe.createRange();
                              _e.setStart(ge.node, ge.offset), Ae.removeAllRanges(), Gt > yi ? (Ae.addRange(_e), Ae.extend(he.node, he.offset)) : (_e.setEnd(he.node, he.offset), Ae.addRange(_e))
                           }
                        }
                     }
                  }
                  for (qe = [], Ae = W; Ae = Ae.parentNode;) Ae.nodeType === 1 && qe.push({
                     element: Ae,
                     left: Ae.scrollLeft,
                     top: Ae.scrollTop
                  });
                  for (typeof W.focus == "function" && W.focus(), W = 0; W < qe.length; W++) {
                     var ke = qe[W];
                     ke.element.scrollLeft = ke.left, ke.element.scrollTop = ke.top
                  }
               }
               J_ = !!TE, EE = TE = null
            } finally {
               Zn = M, Z.p = y, k.T = p
            }
         }
         o.current = u, us = 2
      }
   }

   function pt() {
      if (us === 2) {
         us = 0;
         var o = Qs,
            u = hi,
            p = (u.flags & 8772) !== 0;
         if ((u.subtreeFlags & 8772) !== 0 || p) {
            p = k.T, k.T = null;
            var y = Z.p;
            Z.p = 2;
            var M = Zn;
            Zn |= 4;
            try {
               Ml(o, u.alternate, u)
            } finally {
               Zn = M, Z.p = y, k.T = p
            }
         }
         us = 3
      }
   }

   function tn() {
      if (us === 4 || us === 3) {
         us = 0, ze();
         var o = Qs,
            u = hi,
            p = Jr,
            y = $r;
         (u.subtreeFlags & 10256) !== 0 || (u.flags & 10256) !== 0 ? us = 5 : (us = 0, hi = Qs = null, ea(o, o.pendingLanes));
         var M = o.pendingLanes;
         if (M === 0 && (Qr = null), Yn(p), u = u.stateNode, Ye && typeof Ye.onCommitFiberRoot == "function") try {
            Ye.onCommitFiberRoot(De, u, void 0, (u.current.flags & 128) === 128)
         } catch {}
         if (y !== null) {
            u = k.T, M = Z.p, Z.p = 2, k.T = null;
            try {
               for (var R = o.onRecoverableError, V = 0; V < y.length; V++) {
                  var W = y[V];
                  R(W.value, {
                     componentStack: W.stack
                  })
               }
            } finally {
               k.T = u, Z.p = M
            }
         }(Jr & 3) !== 0 && Tu(), Mu(o), M = o.pendingLanes, (p & 4194090) !== 0 && (M & 42) !== 0 ? o === hc ? zo++ : (zo = 0, hc = o) : zo = 0, qv(0)
      }
   }

   function ea(o, u) {
      (o.pooledCacheLanes &= u) === 0 && (u = o.pooledCache, u != null && (o.pooledCache = null, nf(u)))
   }

   function Tu(o) {
      return ft(), pt(), tn(), Eu()
   }

   function Eu() {
      if (us !== 5) return !1;
      var o = Qs,
         u = wl;
      wl = 0;
      var p = Yn(Jr),
         y = k.T,
         M = Z.p;
      try {
         Z.p = 32 > p ? 32 : p, k.T = null, p = sd, sd = null;
         var R = Qs,
            V = Jr;
         if (us = 0, hi = Qs = null, Jr = 0, (Zn & 6) !== 0) throw Error(i(331));
         var W = Zn;
         if (Zn |= 4, kv(R.current), am(R, R.current, V, p), Zn = W, qv(0, !1), Ye && typeof Ye.onPostCommitFiberRoot == "function") try {
            Ye.onPostCommitFiberRoot(De, R)
         } catch {}
         return !0
      } finally {
         Z.p = M, k.T = y, ea(o, u)
      }
   }

   function Ee(o, u, p) {
      u = zs(p, u), u = em(o.stateNode, u, 2), o = yl(o, u, 2), o !== null && (Ie(o, 2), Mu(o))
   }

   function ce(o, u, p) {
      if (o.tag === 3) Ee(o, o, p);
      else
         for (; u !== null;) {
            if (u.tag === 3) {
               Ee(u, o, p);
               break
            } else if (u.tag === 1) {
               var y = u.stateNode;
               if (typeof u.type.getDerivedStateFromError == "function" || typeof y.componentDidCatch == "function" && (Qr === null || !Qr.has(y))) {
                  o = zs(p, o), p = F_(2), y = yl(u, p, 2), y !== null && (tm(p, y, u, o), Ie(y, 2), Mu(y));
                  break
               }
            }
            u = u.return
         }
   }

   function Ce(o, u, p) {
      var y = o.pingCache;
      if (y === null) {
         y = o.pingCache = new jv;
         var M = new Set;
         y.set(u, M)
      } else M = y.get(u), M === void 0 && (M = new Set, y.set(u, M));
      M.has(p) || (Tf = !0, M.add(p), o = $e.bind(null, o, u, p), u.then(o, o))
   }

   function $e(o, u, p) {
      var y = o.pingCache;
      y !== null && y.delete(u), o.pingedLanes |= o.suspendedLanes & p, o.warmLanes &= ~p, en === o && (Lt & p) === p && (xi === 4 || xi === 3 && (Lt & 62914560) === Lt && 300 > te() - ri ? (Zn & 2) === 0 && bu(o, 0) : fc |= p, Hn === Lt && (Hn = 0)), Mu(o)
   }

   function Nt(o, u) {
      u === 0 && (u = rt()), o = dl(o, u), o !== null && (Ie(o, u), Mu(o))
   }

   function _i(o) {
      var u = o.memoizedState,
         p = 0;
      u !== null && (p = u.retryLane), Nt(o, p)
   }

   function Kt(o, u) {
      var p = 0;
      switch (o.tag) {
         case 13:
            var y = o.stateNode,
               M = o.memoizedState;
            M !== null && (p = M.retryLane);
            break;
         case 19:
            y = o.stateNode;
            break;
         case 22:
            y = o.stateNode._retryCache;
            break;
         default:
            throw Error(i(314))
      }
      y !== null && y.delete(u), Nt(o, p)
   }

   function qn(o, u) {
      return lt(o, u)
   }
   var qi = null,
      bn = null,
      Fo = !1,
      cm = !1,
      mE = !1,
      ad = 0;

   function Mu(o) {
      o !== bn && o.next === null && (bn === null ? qi = bn = o : bn = bn.next = o), cm = !0, Fo || (Fo = !0, KF())
   }

   function qv(o, u) {
      if (!mE && cm) {
         mE = !0;
         do
            for (var p = !1, y = qi; y !== null;) {
               if (o !== 0) {
                  var M = y.pendingLanes;
                  if (M === 0) var R = 0;
                  else {
                     var V = y.suspendedLanes,
                        W = y.pingedLanes;
                     R = (1 << 31 - Ze(42 | o) + 1) - 1, R &= M & ~(V & ~W), R = R & 201326741 ? R & 201326741 | 1 : R ? R | 2 : 0
                  }
                  R !== 0 && (p = !0, AC(y, R))
               } else R = Lt, R = jt(y, y === en ? R : 0, y.cancelPendingCommit !== null || y.timeoutHandle !== -1), (R & 3) === 0 || Rt(y, R) || (p = !0, AC(y, R));
               y = y.next
            }
         while (p);
         mE = !1
      }
   }

   function YF() {
      TC()
   }

   function TC() {
      cm = Fo = !1;
      var o = 0;
      ad !== 0 && (iH() && (o = ad), ad = 0);
      for (var u = te(), p = null, y = qi; y !== null;) {
         var M = y.next,
            R = EC(y, u);
         R === 0 ? (y.next = null, p === null ? qi = M : p.next = M, M === null && (bn = p)) : (p = y, (o !== 0 || (R & 3) !== 0) && (cm = !0)), y = M
      }
      qv(o)
   }

   function EC(o, u) {
      for (var p = o.suspendedLanes, y = o.pingedLanes, M = o.expirationTimes, R = o.pendingLanes & -62914561; 0 < R;) {
         var V = 31 - Ze(R),
            W = 1 << V,
            se = M[V];
         se === -1 ? ((W & p) === 0 || (W & y) !== 0) && (M[V] = cn(W, u)) : se <= u && (o.expiredLanes |= W), R &= ~W
      }
      if (u = en, p = Lt, p = jt(o, o === u ? p : 0, o.cancelPendingCommit !== null || o.timeoutHandle !== -1), y = o.callbackNode, p === 0 || o === u && (ln === 2 || ln === 9) || o.cancelPendingCommit !== null) return y !== null && y !== null && ne(y), o.callbackNode = null, o.callbackPriority = 0;
      if ((p & 3) === 0 || Rt(o, p)) {
         if (u = p & -p, u === o.callbackPriority) return u;
         switch (y !== null && ne(y), Yn(p)) {
            case 2:
            case 8:
               p = Ue;
               break;
            case 32:
               p = K;
               break;
            case 268435456:
               p = me;
               break;
            default:
               p = K
         }
         return y = MC.bind(null, o), p = lt(p, y), o.callbackPriority = u, o.callbackNode = p, u
      }
      return y !== null && y !== null && ne(y), o.callbackPriority = 2, o.callbackNode = null, 2
   }

   function MC(o, u) {
      if (us !== 0 && us !== 5) return o.callbackNode = null, o.callbackPriority = 0, null;
      var p = o.callbackNode;
      if (Tu() && o.callbackNode !== p) return null;
      var y = Lt;
      return y = jt(o, o === en ? y : 0, o.cancelPendingCommit !== null || o.timeoutHandle !== -1), y === 0 ? null : (Ef(o, y, u), EC(o, te()), o.callbackNode != null && o.callbackNode === p ? MC.bind(null, o) : null)
   }

   function AC(o, u) {
      if (Tu()) return null;
      Ef(o, u, !0)
   }

   function KF() {
      rH(function () {
         (Zn & 6) !== 0 ? lt(Je, YF) : TC()
      })
   }

   function gE() {
      return ad === 0 && (ad = le()), ad
   }

   function wC(o) {
      return o == null || typeof o == "symbol" || typeof o == "boolean" ? null : typeof o == "function" ? o : yh("" + o)
   }

   function RC(o, u) {
      var p = u.ownerDocument.createElement("input");
      return p.name = u.name, p.value = u.value, o.id && p.setAttribute("form", o.id), u.parentNode.insertBefore(p, u), o = new FormData(o), p.parentNode.removeChild(p), o
   }

   function ZF(o, u, p, y, M) {
      if (u === "submit" && p && p.stateNode === M) {
         var R = wC((M[St] || null).action),
            V = y.submitter;
         V && (u = (u = V[St] || null) ? wC(u.formAction) : V.getAttribute("formAction"), u !== null && (R = u, V = null));
         var W = new kc("action", "action", null, y, M);
         o.push({
            event: W,
            listeners: [{
               instance: null,
               listener: function () {
                  if (y.defaultPrevented) {
                     if (ad !== 0) {
                        var se = V ? RC(M, V) : new FormData(M);
                        Iv(p, {
                           pending: !0,
                           data: se,
                           method: M.method,
                           action: R
                        }, null, se)
                     }
                  } else typeof R == "function" && (W.preventDefault(), se = V ? RC(M, V) : new FormData(M), Iv(p, {
                     pending: !0,
                     data: se,
                     method: M.method,
                     action: R
                  }, R, se))
               },
               currentTarget: M
            }]
         })
      }
   }
   for (var vE = 0; vE < Uh.length; vE++) {
      var yE = Uh[vE],
         QF = yE.toLowerCase(),
         JF = yE[0].toUpperCase() + yE.slice(1);
      xs(QF, "on" + JF)
   }
   xs(or, "onAnimationEnd"), xs(uv, "onAnimationIteration"), xs(Sr, "onAnimationStart"), xs("dblclick", "onDoubleClick"), xs("focusin", "onFocus"), xs("focusout", "onBlur"), xs(Qx, "onTransitionRun"), xs(fl, "onTransitionStart"), xs(Qc, "onTransitionCancel"), xs(hl, "onTransitionEnd"), X("onMouseEnter", ["mouseout", "mouseover"]), X("onMouseLeave", ["mouseout", "mouseover"]), X("onPointerEnter", ["pointerout", "pointerover"]), X("onPointerLeave", ["pointerout", "pointerover"]), ei("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), ei("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), ei("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), ei("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), ei("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), ei("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
   var Xv = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),
      $F = new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Xv));

   function CC(o, u) {
      u = (u & 4) !== 0;
      for (var p = 0; p < o.length; p++) {
         var y = o[p],
            M = y.event;
         y = y.listeners;
         e: {
            var R = void 0;
            if (u)
               for (var V = y.length - 1; 0 <= V; V--) {
                  var W = y[V],
                     se = W.instance,
                     Se = W.currentTarget;
                  if (W = W.listener, se !== R && M.isPropagationStopped()) break e;
                  R = W, M.currentTarget = Se;
                  try {
                     R(M)
                  } catch (Ve) {
                     $u(Ve)
                  }
                  M.currentTarget = null, R = se
               } else
                  for (V = 0; V < y.length; V++) {
                     if (W = y[V], se = W.instance, Se = W.currentTarget, W = W.listener, se !== R && M.isPropagationStopped()) break e;
                     R = W, M.currentTarget = Se;
                     try {
                        R(M)
                     } catch (Ve) {
                        $u(Ve)
                     }
                     M.currentTarget = null, R = se
                  }
         }
      }
   }

   function On(o, u) {
      var p = u[Dt];
      p === void 0 && (p = u[Dt] = new Set);
      var y = o + "__bubble";
      p.has(y) || (DC(u, o, 2, !1), p.add(y))
   }

   function xE(o, u, p) {
      var y = 0;
      u && (y |= 4), DC(p, o, y, u)
   }
   var k_ = "_reactListening" + Math.random().toString(36).slice(2);

   function _E(o) {
      if (!o[k_]) {
         o[k_] = !0, Ns.forEach(function (p) {
            p !== "selectionchange" && ($F.has(p) || xE(p, !1, o), xE(p, !0, o))
         });
         var u = o.nodeType === 9 ? o : o.ownerDocument;
         u === null || u[k_] || (u[k_] = !0, xE("selectionchange", !1, u))
      }
   }

   function DC(o, u, p, y) {
      switch (eD(u)) {
         case 2:
            var M = AH;
            break;
         case 8:
            M = wH;
            break;
         default:
            M = PE
      }
      p = M.bind(null, u, p, o), M = void 0, !_h || u !== "touchstart" && u !== "touchmove" && u !== "wheel" || (M = !0), y ? M !== void 0 ? o.addEventListener(u, p, {
         capture: !0,
         passive: M
      }) : o.addEventListener(u, p, !0) : M !== void 0 ? o.addEventListener(u, p, {
         passive: M
      }) : o.addEventListener(u, p, !1)
   }

   function SE(o, u, p, y, M) {
      var R = y;
      if ((u & 1) === 0 && (u & 2) === 0 && y !== null) e: for (;;) {
         if (y === null) return;
         var V = y.tag;
         if (V === 3 || V === 4) {
            var W = y.stateNode.containerInfo;
            if (W === M) break;
            if (V === 4)
               for (V = y.return; V !== null;) {
                  var se = V.tag;
                  if ((se === 3 || se === 4) && V.stateNode.containerInfo === M) return;
                  V = V.return
               }
            for (; W !== null;) {
               if (V = Mn(W), V === null) return;
               if (se = V.tag, se === 5 || se === 6 || se === 26 || se === 27) {
                  y = R = V;
                  continue e
               }
               W = W.parentNode
            }
         }
         y = y.return
      }
      Xg(function () {
         var Se = R,
            Ve = gp(p),
            qe = [];
         e: {
            var Me = Rp.get(o);
            if (Me !== void 0) {
               var Ae = kc,
                  Qt = o;
               switch (o) {
                  case "keypress":
                     if (Wl(p) === 0) break e;
                  case "keydown":
                  case "keyup":
                     Ae = Qg;
                     break;
                  case "focusin":
                     Qt = "focus", Ae = yp;
                     break;
                  case "focusout":
                     Qt = "blur", Ae = yp;
                     break;
                  case "beforeblur":
                  case "afterblur":
                     Ae = yp;
                     break;
                  case "click":
                     if (p.button === 2) break e;
                  case "auxclick":
                  case "dblclick":
                  case "mousedown":
                  case "mousemove":
                  case "mouseup":
                  case "mouseout":
                  case "mouseover":
                  case "contextmenu":
                     Ae = Kg;
                     break;
                  case "drag":
                  case "dragend":
                  case "dragenter":
                  case "dragexit":
                  case "dragleave":
                  case "dragover":
                  case "dragstart":
                  case "drop":
                     Ae = iE;
                     break;
                  case "touchcancel":
                  case "touchend":
                  case "touchmove":
                  case "touchstart":
                     Ae = $g;
                     break;
                  case or:
                  case uv:
                  case Sr:
                     Ae = Bx;
                     break;
                  case hl:
                     Ae = ol;
                     break;
                  case "scroll":
                  case "scrollend":
                     Ae = Ux;
                     break;
                  case "wheel":
                     Ae = sE;
                     break;
                  case "copy":
                  case "cut":
                  case "paste":
                     Ae = Ix;
                     break;
                  case "gotpointercapture":
                  case "lostpointercapture":
                  case "pointercancel":
                  case "pointerdown":
                  case "pointermove":
                  case "pointerout":
                  case "pointerover":
                  case "pointerup":
                     Ae = _p;
                     break;
                  case "toggle":
                  case "beforetoggle":
                     Ae = Kl
               }
               var Gt = (u & 4) !== 0,
                  yi = !Gt && (o === "scroll" || o === "scrollend"),
                  ge = Gt ? Me !== null ? Me + "Capture" : null : Me;
               Gt = [];
               for (var he = Se, _e; he !== null;) {
                  var ke = he;
                  if (_e = ke.stateNode, ke = ke.tag, ke !== 5 && ke !== 26 && ke !== 27 || _e === null || ge === null || (ke = Hc(he, ge), ke != null && Gt.push(Wv(he, ke, _e))), yi) break;
                  he = he.return
               }
               0 < Gt.length && (Me = new Ae(Me, Qt, null, p, Ve), qe.push({
                  event: Me,
                  listeners: Gt
               }))
            }
         }
         if ((u & 7) === 0) {
            e: {
               if (Me = o === "mouseover" || o === "pointerover", Ae = o === "mouseout" || o === "pointerout", Me && p !== mp && (Qt = p.relatedTarget || p.fromElement) && (Mn(Qt) || Qt[gt])) break e;
               if ((Ae || Me) && (Me = Ve.window === Ve ? Ve : (Me = Ve.ownerDocument) ? Me.defaultView || Me.parentWindow : window, Ae ? (Qt = p.relatedTarget || p.toElement, Ae = Se, Qt = Qt ? Mn(Qt) : null, Qt !== null && (yi = r(Qt), Gt = Qt.tag, Qt !== yi || Gt !== 5 && Gt !== 27 && Gt !== 6) && (Qt = null)) : (Ae = null, Qt = Se), Ae !== Qt)) {
                  if (Gt = Kg, ke = "onMouseLeave", ge = "onMouseEnter", he = "mouse", (o === "pointerout" || o === "pointerover") && (Gt = _p, ke = "onPointerLeave", ge = "onPointerEnter", he = "pointer"), yi = Ae == null ? Me : Zi(Ae), _e = Qt == null ? Me : Zi(Qt), Me = new Gt(ke, he + "leave", Ae, p, Ve), Me.target = yi, Me.relatedTarget = _e, ke = null, Mn(Ve) === Se && (Gt = new Gt(ge, he + "enter", Qt, p, Ve), Gt.target = _e, Gt.relatedTarget = yi, ke = Gt), yi = ke, Ae && Qt) t: {
                     for (Gt = Ae, ge = Qt, he = 0, _e = Gt; _e; _e = fm(_e)) he++;
                     for (_e = 0, ke = ge; ke; ke = fm(ke)) _e++;
                     for (; 0 < he - _e;) Gt = fm(Gt),
                     he--;
                     for (; 0 < _e - he;) ge = fm(ge),
                     _e--;
                     for (; he--;) {
                        if (Gt === ge || ge !== null && Gt === ge.alternate) break t;
                        Gt = fm(Gt), ge = fm(ge)
                     }
                     Gt = null
                  }
                  else Gt = null;
                  Ae !== null && NC(qe, Me, Ae, Gt, !1), Qt !== null && yi !== null && NC(qe, yi, Qt, Gt, !0)
               }
            }
            e: {
               if (Me = Se ? Zi(Se) : window, Ae = Me.nodeName && Me.nodeName.toLowerCase(), Ae === "select" || Ae === "input" && Me.type === "file") var Et = bp;
               else if (iv(Me))
                  if (Tp) Et = Jl;
                  else {
                     Et = Yx;
                     var Rn = rE
                  }
               else Ae = Me.nodeName,
               !Ae || Ae.toLowerCase() !== "input" || Me.type !== "checkbox" && Me.type !== "radio" ? Se && pp(Se.elementType) && (Et = bp) : Et = Dh;
               if (Et && (Et = Et(o, Se))) {
                  yr(qe, Et, p, Ve);
                  break e
               }
               Rn && Rn(o, Me, Se),
               o === "focusout" && Se && Me.type === "number" && Se.memoizedProps.value != null && Us(Me, "number", Me.value)
            }
            switch (Rn = Se ? Zi(Se) : window, o) {
               case "focusin":
                  (iv(Rn) || Rn.contentEditable === "true") && (ul = Rn, Mp = Se, Oh = null);
                  break;
               case "focusout":
                  Oh = Mp = ul = null;
                  break;
               case "mousedown":
                  Ap = !0;
                  break;
               case "contextmenu":
               case "mouseup":
               case "dragend":
                  Ap = !1, lv(qe, p, Ve);
                  break;
               case "selectionchange":
                  if (ov) break;
               case "keydown":
               case "keyup":
                  lv(qe, p, Ve)
            }
            var Ot;
            if (Eh) e: {
               switch (o) {
                  case "compositionstart":
                     var qt = "onCompositionStart";
                     break e;
                  case "compositionend":
                     qt = "onCompositionEnd";
                     break e;
                  case "compositionupdate":
                     qt = "onCompositionUpdate";
                     break e
               }
               qt = void 0
            }
            else Ql ? wh(o, p) && (qt = "onCompositionEnd") : o === "keydown" && p.keyCode === 229 && (qt = "onCompositionStart");qt && (Ah && p.locale !== "ko" && (Ql || qt !== "onCompositionStart" ? qt === "onCompositionEnd" && Ql && (Ot = Yg()) : (rl = Ve, Wg = "value" in rl ? rl.value : rl.textContent, Ql = !0)), Rn = j_(Se, qt), 0 < Rn.length && (qt = new xp(qt, o, null, p, Ve), qe.push({
               event: qt,
               listeners: Rn
            }), Ot ? qt.data = Ot : (Ot = tv(p), Ot !== null && (qt.data = Ot)))),
            (Ot = Mh ? Rh(o, p) : nv(o, p)) && (qt = j_(Se, "onBeforeInput"), 0 < qt.length && (Rn = new xp("onBeforeInput", "beforeinput", null, p, Ve), qe.push({
               event: Rn,
               listeners: qt
            }), Rn.data = Ot)),
            ZF(qe, o, Se, p, Ve)
         }
         CC(qe, u)
      })
   }

   function Wv(o, u, p) {
      return {
         instance: o,
         listener: u,
         currentTarget: p
      }
   }

   function j_(o, u) {
      for (var p = u + "Capture", y = []; o !== null;) {
         var M = o,
            R = M.stateNode;
         if (M = M.tag, M !== 5 && M !== 26 && M !== 27 || R === null || (M = Hc(o, p), M != null && y.unshift(Wv(o, M, R)), M = Hc(o, u), M != null && y.push(Wv(o, M, R))), o.tag === 3) return y;
         o = o.return
      }
      return []
   }

   function fm(o) {
      if (o === null) return null;
      do o = o.return; while (o && o.tag !== 5 && o.tag !== 27);
      return o || null
   }

   function NC(o, u, p, y, M) {
      for (var R = u._reactName, V = []; p !== null && p !== y;) {
         var W = p,
            se = W.alternate,
            Se = W.stateNode;
         if (W = W.tag, se !== null && se === y) break;
         W !== 5 && W !== 26 && W !== 27 || Se === null || (se = Se, M ? (Se = Hc(p, R), Se != null && V.unshift(Wv(p, Se, se))) : M || (Se = Hc(p, R), Se != null && V.push(Wv(p, Se, se)))), p = p.return
      }
      V.length !== 0 && o.push({
         event: u,
         listeners: V
      })
   }
   var eH = /\r\n?/g,
      tH = /\u0000|\uFFFD/g;

   function OC(o) {
      return (typeof o == "string" ? o : "" + o).replace(eH, `
`).replace(tH, "")
   }

   function UC(o, u) {
      return u = OC(u), OC(o) === u
   }

   function q_() {}

   function vi(o, u, p, y, M, R) {
      switch (p) {
         case "children":
            typeof y == "string" ? u === "body" || u === "textarea" && y === "" || rr(o, y) : (typeof y == "number" || typeof y == "bigint") && u !== "body" && rr(o, "" + y);
            break;
         case "className":
            st(o, "class", y);
            break;
         case "tabIndex":
            st(o, "tabindex", y);
            break;
         case "dir":
         case "role":
         case "viewBox":
         case "width":
         case "height":
            st(o, p, y);
            break;
         case "style":
            vh(o, y, R);
            break;
         case "data":
            if (u !== "object") {
               st(o, "data", y);
               break
            }
         case "src":
         case "href":
            if (y === "" && (u !== "a" || p !== "href")) {
               o.removeAttribute(p);
               break
            }
            if (y == null || typeof y == "function" || typeof y == "symbol" || typeof y == "boolean") {
               o.removeAttribute(p);
               break
            }
            y = yh("" + y), o.setAttribute(p, y);
            break;
         case "action":
         case "formAction":
            if (typeof y == "function") {
               o.setAttribute(p, "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");
               break
            } else typeof R == "function" && (p === "formAction" ? (u !== "input" && vi(o, u, "name", M.name, M, null), vi(o, u, "formEncType", M.formEncType, M, null), vi(o, u, "formMethod", M.formMethod, M, null), vi(o, u, "formTarget", M.formTarget, M, null)) : (vi(o, u, "encType", M.encType, M, null), vi(o, u, "method", M.method, M, null), vi(o, u, "target", M.target, M, null)));
            if (y == null || typeof y == "symbol" || typeof y == "boolean") {
               o.removeAttribute(p);
               break
            }
            y = yh("" + y), o.setAttribute(p, y);
            break;
         case "onClick":
            y != null && (o.onclick = q_);
            break;
         case "onScroll":
            y != null && On("scroll", o);
            break;
         case "onScrollEnd":
            y != null && On("scrollend", o);
            break;
         case "dangerouslySetInnerHTML":
            if (y != null) {
               if (typeof y != "object" || !("__html" in y)) throw Error(i(61));
               if (p = y.__html, p != null) {
                  if (M.children != null) throw Error(i(60));
                  o.innerHTML = p
               }
            }
            break;
         case "multiple":
            o.multiple = y && typeof y != "function" && typeof y != "symbol";
            break;
         case "muted":
            o.muted = y && typeof y != "function" && typeof y != "symbol";
            break;
         case "suppressContentEditableWarning":
         case "suppressHydrationWarning":
         case "defaultValue":
         case "defaultChecked":
         case "innerHTML":
         case "ref":
            break;
         case "autoFocus":
            break;
         case "xlinkHref":
            if (y == null || typeof y == "function" || typeof y == "boolean" || typeof y == "symbol") {
               o.removeAttribute("xlink:href");
               break
            }
            p = yh("" + y), o.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", p);
            break;
         case "contentEditable":
         case "spellCheck":
         case "draggable":
         case "value":
         case "autoReverse":
         case "externalResourcesRequired":
         case "focusable":
         case "preserveAlpha":
            y != null && typeof y != "function" && typeof y != "symbol" ? o.setAttribute(p, "" + y) : o.removeAttribute(p);
            break;
         case "inert":
         case "allowFullScreen":
         case "async":
         case "autoPlay":
         case "controls":
         case "default":
         case "defer":
         case "disabled":
         case "disablePictureInPicture":
         case "disableRemotePlayback":
         case "formNoValidate":
         case "hidden":
         case "loop":
         case "noModule":
         case "noValidate":
         case "open":
         case "playsInline":
         case "readOnly":
         case "required":
         case "reversed":
         case "scoped":
         case "seamless":
         case "itemScope":
            y && typeof y != "function" && typeof y != "symbol" ? o.setAttribute(p, "") : o.removeAttribute(p);
            break;
         case "capture":
         case "download":
            y === !0 ? o.setAttribute(p, "") : y !== !1 && y != null && typeof y != "function" && typeof y != "symbol" ? o.setAttribute(p, y) : o.removeAttribute(p);
            break;
         case "cols":
         case "rows":
         case "size":
         case "span":
            y != null && typeof y != "function" && typeof y != "symbol" && !isNaN(y) && 1 <= y ? o.setAttribute(p, y) : o.removeAttribute(p);
            break;
         case "rowSpan":
         case "start":
            y == null || typeof y == "function" || typeof y == "symbol" || isNaN(y) ? o.removeAttribute(p) : o.setAttribute(p, y);
            break;
         case "popover":
            On("beforetoggle", o), On("toggle", o), je(o, "popover", y);
            break;
         case "xlinkActuate":
            ot(o, "http://www.w3.org/1999/xlink", "xlink:actuate", y);
            break;
         case "xlinkArcrole":
            ot(o, "http://www.w3.org/1999/xlink", "xlink:arcrole", y);
            break;
         case "xlinkRole":
            ot(o, "http://www.w3.org/1999/xlink", "xlink:role", y);
            break;
         case "xlinkShow":
            ot(o, "http://www.w3.org/1999/xlink", "xlink:show", y);
            break;
         case "xlinkTitle":
            ot(o, "http://www.w3.org/1999/xlink", "xlink:title", y);
            break;
         case "xlinkType":
            ot(o, "http://www.w3.org/1999/xlink", "xlink:type", y);
            break;
         case "xmlBase":
            ot(o, "http://www.w3.org/XML/1998/namespace", "xml:base", y);
            break;
         case "xmlLang":
            ot(o, "http://www.w3.org/XML/1998/namespace", "xml:lang", y);
            break;
         case "xmlSpace":
            ot(o, "http://www.w3.org/XML/1998/namespace", "xml:space", y);
            break;
         case "is":
            je(o, "is", y);
            break;
         case "innerText":
         case "textContent":
            break;
         default:
            (!(2 < p.length) || p[0] !== "o" && p[0] !== "O" || p[1] !== "n" && p[1] !== "N") && (p = jg.get(p) || p, je(o, p, y))
      }
   }

   function bE(o, u, p, y, M, R) {
      switch (p) {
         case "style":
            vh(o, y, R);
            break;
         case "dangerouslySetInnerHTML":
            if (y != null) {
               if (typeof y != "object" || !("__html" in y)) throw Error(i(61));
               if (p = y.__html, p != null) {
                  if (M.children != null) throw Error(i(60));
                  o.innerHTML = p
               }
            }
            break;
         case "children":
            typeof y == "string" ? rr(o, y) : (typeof y == "number" || typeof y == "bigint") && rr(o, "" + y);
            break;
         case "onScroll":
            y != null && On("scroll", o);
            break;
         case "onScrollEnd":
            y != null && On("scrollend", o);
            break;
         case "onClick":
            y != null && (o.onclick = q_);
            break;
         case "suppressContentEditableWarning":
         case "suppressHydrationWarning":
         case "innerHTML":
         case "ref":
            break;
         case "innerText":
         case "textContent":
            break;
         default:
            if (!Ei.hasOwnProperty(p)) e: {
               if (p[0] === "o" && p[1] === "n" && (M = p.endsWith("Capture"), u = p.slice(2, M ? p.length - 7 : void 0), R = o[St] || null, R = R != null ? R[p] : null, typeof R == "function" && o.removeEventListener(u, R, M), typeof y == "function")) {
                  typeof R != "function" && R !== null && (p in o ? o[p] = null : o.hasAttribute(p) && o.removeAttribute(p)), o.addEventListener(u, y, M);
                  break e
               }
               p in o ? o[p] = y : y === !0 ? o.setAttribute(p, "") : je(o, p, y)
            }
      }
   }

   function pr(o, u, p) {
      switch (u) {
         case "div":
         case "span":
         case "svg":
         case "path":
         case "a":
         case "g":
         case "p":
         case "li":
            break;
         case "img":
            On("error", o), On("load", o);
            var y = !1,
               M = !1,
               R;
            for (R in p)
               if (p.hasOwnProperty(R)) {
                  var V = p[R];
                  if (V != null) switch (R) {
                     case "src":
                        y = !0;
                        break;
                     case "srcSet":
                        M = !0;
                        break;
                     case "children":
                     case "dangerouslySetInnerHTML":
                        throw Error(i(137, u));
                     default:
                        vi(o, u, R, V, p, null)
                  }
               } M && vi(o, u, "srcSet", p.srcSet, p, null), y && vi(o, u, "src", p.src, p, null);
            return;
         case "input":
            On("invalid", o);
            var W = R = V = M = null,
               se = null,
               Se = null;
            for (y in p)
               if (p.hasOwnProperty(y)) {
                  var Ve = p[y];
                  if (Ve != null) switch (y) {
                     case "name":
                        M = Ve;
                        break;
                     case "type":
                        V = Ve;
                        break;
                     case "checked":
                        se = Ve;
                        break;
                     case "defaultChecked":
                        Se = Ve;
                        break;
                     case "value":
                        R = Ve;
                        break;
                     case "defaultValue":
                        W = Ve;
                        break;
                     case "children":
                     case "dangerouslySetInnerHTML":
                        if (Ve != null) throw Error(i(137, u));
                        break;
                     default:
                        vi(o, u, y, Ve, p, null)
                  }
               } si(o, R, W, se, Se, V, M, !1), Ri(o);
            return;
         case "select":
            On("invalid", o), y = V = R = null;
            for (M in p)
               if (p.hasOwnProperty(M) && (W = p[M], W != null)) switch (M) {
                  case "value":
                     R = W;
                     break;
                  case "defaultValue":
                     V = W;
                     break;
                  case "multiple":
                     y = W;
                  default:
                     vi(o, u, M, W, p, null)
               }
            u = R, p = V, o.multiple = !!y, u != null ? Qi(o, !!y, u, !1) : p != null && Qi(o, !!y, p, !0);
            return;
         case "textarea":
            On("invalid", o), R = M = y = null;
            for (V in p)
               if (p.hasOwnProperty(V) && (W = p[V], W != null)) switch (V) {
                  case "value":
                     y = W;
                     break;
                  case "defaultValue":
                     M = W;
                     break;
                  case "children":
                     R = W;
                     break;
                  case "dangerouslySetInnerHTML":
                     if (W != null) throw Error(i(91));
                     break;
                  default:
                     vi(o, u, V, W, p, null)
               }
            ys(o, y, M, R), Ri(o);
            return;
         case "option":
            for (se in p)
               if (p.hasOwnProperty(se) && (y = p[se], y != null)) switch (se) {
                  case "selected":
                     o.selected = y && typeof y != "function" && typeof y != "symbol";
                     break;
                  default:
                     vi(o, u, se, y, p, null)
               }
            return;
         case "dialog":
            On("beforetoggle", o), On("toggle", o), On("cancel", o), On("close", o);
            break;
         case "iframe":
         case "object":
            On("load", o);
            break;
         case "video":
         case "audio":
            for (y = 0; y < Xv.length; y++) On(Xv[y], o);
            break;
         case "image":
            On("error", o), On("load", o);
            break;
         case "details":
            On("toggle", o);
            break;
         case "embed":
         case "source":
         case "link":
            On("error", o), On("load", o);
         case "area":
         case "base":
         case "br":
         case "col":
         case "hr":
         case "keygen":
         case "meta":
         case "param":
         case "track":
         case "wbr":
         case "menuitem":
            for (Se in p)
               if (p.hasOwnProperty(Se) && (y = p[Se], y != null)) switch (Se) {
                  case "children":
                  case "dangerouslySetInnerHTML":
                     throw Error(i(137, u));
                  default:
                     vi(o, u, Se, y, p, null)
               }
            return;
         default:
            if (pp(u)) {
               for (Ve in p) p.hasOwnProperty(Ve) && (y = p[Ve], y !== void 0 && bE(o, u, Ve, y, p, void 0));
               return
            }
      }
      for (W in p) p.hasOwnProperty(W) && (y = p[W], y != null && vi(o, u, W, y, p, null))
   }

   function nH(o, u, p, y) {
      switch (u) {
         case "div":
         case "span":
         case "svg":
         case "path":
         case "a":
         case "g":
         case "p":
         case "li":
            break;
         case "input":
            var M = null,
               R = null,
               V = null,
               W = null,
               se = null,
               Se = null,
               Ve = null;
            for (Ae in p) {
               var qe = p[Ae];
               if (p.hasOwnProperty(Ae) && qe != null) switch (Ae) {
                  case "checked":
                     break;
                  case "value":
                     break;
                  case "defaultValue":
                     se = qe;
                  default:
                     y.hasOwnProperty(Ae) || vi(o, u, Ae, null, y, qe)
               }
            }
            for (var Me in y) {
               var Ae = y[Me];
               if (qe = p[Me], y.hasOwnProperty(Me) && (Ae != null || qe != null)) switch (Me) {
                  case "type":
                     R = Ae;
                     break;
                  case "name":
                     M = Ae;
                     break;
                  case "checked":
                     Se = Ae;
                     break;
                  case "defaultChecked":
                     Ve = Ae;
                     break;
                  case "value":
                     V = Ae;
                     break;
                  case "defaultValue":
                     W = Ae;
                     break;
                  case "children":
                  case "dangerouslySetInnerHTML":
                     if (Ae != null) throw Error(i(137, u));
                     break;
                  default:
                     Ae !== qe && vi(o, u, Me, Ae, y, qe)
               }
            }
            So(o, V, W, se, Se, Ve, R, M);
            return;
         case "select":
            Ae = V = W = Me = null;
            for (R in p)
               if (se = p[R], p.hasOwnProperty(R) && se != null) switch (R) {
                  case "value":
                     break;
                  case "multiple":
                     Ae = se;
                  default:
                     y.hasOwnProperty(R) || vi(o, u, R, null, y, se)
               }
            for (M in y)
               if (R = y[M], se = p[M], y.hasOwnProperty(M) && (R != null || se != null)) switch (M) {
                  case "value":
                     Me = R;
                     break;
                  case "defaultValue":
                     W = R;
                     break;
                  case "multiple":
                     V = R;
                  default:
                     R !== se && vi(o, u, M, R, y, se)
               }
            u = W, p = V, y = Ae, Me != null ? Qi(o, !!p, Me, !1) : !!y != !!p && (u != null ? Qi(o, !!p, u, !0) : Qi(o, !!p, p ? [] : "", !1));
            return;
         case "textarea":
            Ae = Me = null;
            for (W in p)
               if (M = p[W], p.hasOwnProperty(W) && M != null && !y.hasOwnProperty(W)) switch (W) {
                  case "value":
                     break;
                  case "children":
                     break;
                  default:
                     vi(o, u, W, null, y, M)
               }
            for (V in y)
               if (M = y[V], R = p[V], y.hasOwnProperty(V) && (M != null || R != null)) switch (V) {
                  case "value":
                     Me = M;
                     break;
                  case "defaultValue":
                     Ae = M;
                     break;
                  case "children":
                     break;
                  case "dangerouslySetInnerHTML":
                     if (M != null) throw Error(i(91));
                     break;
                  default:
                     M !== R && vi(o, u, V, M, y, R)
               }
            vs(o, Me, Ae);
            return;
         case "option":
            for (var Qt in p)
               if (Me = p[Qt], p.hasOwnProperty(Qt) && Me != null && !y.hasOwnProperty(Qt)) switch (Qt) {
                  case "selected":
                     o.selected = !1;
                     break;
                  default:
                     vi(o, u, Qt, null, y, Me)
               }
            for (se in y)
               if (Me = y[se], Ae = p[se], y.hasOwnProperty(se) && Me !== Ae && (Me != null || Ae != null)) switch (se) {
                  case "selected":
                     o.selected = Me && typeof Me != "function" && typeof Me != "symbol";
                     break;
                  default:
                     vi(o, u, se, Me, y, Ae)
               }
            return;
         case "img":
         case "link":
         case "area":
         case "base":
         case "br":
         case "col":
         case "embed":
         case "hr":
         case "keygen":
         case "meta":
         case "param":
         case "source":
         case "track":
         case "wbr":
         case "menuitem":
            for (var Gt in p) Me = p[Gt], p.hasOwnProperty(Gt) && Me != null && !y.hasOwnProperty(Gt) && vi(o, u, Gt, null, y, Me);
            for (Se in y)
               if (Me = y[Se], Ae = p[Se], y.hasOwnProperty(Se) && Me !== Ae && (Me != null || Ae != null)) switch (Se) {
                  case "children":
                  case "dangerouslySetInnerHTML":
                     if (Me != null) throw Error(i(137, u));
                     break;
                  default:
                     vi(o, u, Se, Me, y, Ae)
               }
            return;
         default:
            if (pp(u)) {
               for (var yi in p) Me = p[yi], p.hasOwnProperty(yi) && Me !== void 0 && !y.hasOwnProperty(yi) && bE(o, u, yi, void 0, y, Me);
               for (Ve in y) Me = y[Ve], Ae = p[Ve], !y.hasOwnProperty(Ve) || Me === Ae || Me === void 0 && Ae === void 0 || bE(o, u, Ve, Me, y, Ae);
               return
            }
      }
      for (var ge in p) Me = p[ge], p.hasOwnProperty(ge) && Me != null && !y.hasOwnProperty(ge) && vi(o, u, ge, null, y, Me);
      for (qe in y) Me = y[qe], Ae = p[qe], !y.hasOwnProperty(qe) || Me === Ae || Me == null && Ae == null || vi(o, u, qe, Me, y, Ae)
   }
   var TE = null,
      EE = null;

   function X_(o) {
      return o.nodeType === 9 ? o : o.ownerDocument
   }

   function PC(o) {
      switch (o) {
         case "http://www.w3.org/2000/svg":
            return 1;
         case "http://www.w3.org/1998/Math/MathML":
            return 2;
         default:
            return 0
      }
   }

   function LC(o, u) {
      if (o === 0) switch (u) {
         case "svg":
            return 1;
         case "math":
            return 2;
         default:
            return 0
      }
      return o === 1 && u === "foreignObject" ? 0 : o
   }

   function ME(o, u) {
      return o === "textarea" || o === "noscript" || typeof u.children == "string" || typeof u.children == "number" || typeof u.children == "bigint" || typeof u.dangerouslySetInnerHTML == "object" && u.dangerouslySetInnerHTML !== null && u.dangerouslySetInnerHTML.__html != null
   }
   var AE = null;

   function iH() {
      var o = window.event;
      return o && o.type === "popstate" ? o === AE ? !1 : (AE = o, !0) : (AE = null, !1)
   }
   var BC = typeof setTimeout == "function" ? setTimeout : void 0,
      sH = typeof clearTimeout == "function" ? clearTimeout : void 0,
      zC = typeof Promise == "function" ? Promise : void 0,
      rH = typeof queueMicrotask == "function" ? queueMicrotask : typeof zC < "u" ? function (o) {
         return zC.resolve(null).then(o).catch(aH)
      } : BC;

   function aH(o) {
      setTimeout(function () {
         throw o
      })
   }

   function Af(o) {
      return o === "head"
   }

   function IC(o, u) {
      var p = u,
         y = 0,
         M = 0;
      do {
         var R = p.nextSibling;
         if (o.removeChild(p), R && R.nodeType === 8)
            if (p = R.data, p === "/$") {
               if (0 < y && 8 > y) {
                  p = y;
                  var V = o.ownerDocument;
                  if (p & 1 && Yv(V.documentElement), p & 2 && Yv(V.body), p & 4)
                     for (p = V.head, Yv(p), V = p.firstChild; V;) {
                        var W = V.nextSibling,
                           se = V.nodeName;
                        V[ii] || se === "SCRIPT" || se === "STYLE" || se === "LINK" && V.rel.toLowerCase() === "stylesheet" || p.removeChild(V), V = W
                     }
               }
               if (M === 0) {
                  o.removeChild(R), n0(u);
                  return
               }
               M--
            } else p === "$" || p === "$?" || p === "$!" ? M++ : y = p.charCodeAt(0) - 48;
         else y = 0;
         p = R
      } while (p);
      n0(u)
   }

   function wE(o) {
      var u = o.firstChild;
      for (u && u.nodeType === 10 && (u = u.nextSibling); u;) {
         var p = u;
         switch (u = u.nextSibling, p.nodeName) {
            case "HTML":
            case "HEAD":
            case "BODY":
               wE(p), Ft(p);
               continue;
            case "SCRIPT":
            case "STYLE":
               continue;
            case "LINK":
               if (p.rel.toLowerCase() === "stylesheet") continue
         }
         o.removeChild(p)
      }
   }

   function oH(o, u, p, y) {
      for (; o.nodeType === 1;) {
         var M = p;
         if (o.nodeName.toLowerCase() !== u.toLowerCase()) {
            if (!y && (o.nodeName !== "INPUT" || o.type !== "hidden")) break
         } else if (y) {
            if (!o[ii]) switch (u) {
               case "meta":
                  if (!o.hasAttribute("itemprop")) break;
                  return o;
               case "link":
                  if (R = o.getAttribute("rel"), R === "stylesheet" && o.hasAttribute("data-precedence")) break;
                  if (R !== M.rel || o.getAttribute("href") !== (M.href == null || M.href === "" ? null : M.href) || o.getAttribute("crossorigin") !== (M.crossOrigin == null ? null : M.crossOrigin) || o.getAttribute("title") !== (M.title == null ? null : M.title)) break;
                  return o;
               case "style":
                  if (o.hasAttribute("data-precedence")) break;
                  return o;
               case "script":
                  if (R = o.getAttribute("src"), (R !== (M.src == null ? null : M.src) || o.getAttribute("type") !== (M.type == null ? null : M.type) || o.getAttribute("crossorigin") !== (M.crossOrigin == null ? null : M.crossOrigin)) && R && o.hasAttribute("async") && !o.hasAttribute("itemprop")) break;
                  return o;
               default:
                  return o
            }
         } else if (u === "input" && o.type === "hidden") {
            var R = M.name == null ? null : "" + M.name;
            if (M.type === "hidden" && o.getAttribute("name") === R) return o
         } else return o;
         if (o = Rl(o.nextSibling), o === null) break
      }
      return null
   }

   function lH(o, u, p) {
      if (u === "") return null;
      for (; o.nodeType !== 3;)
         if ((o.nodeType !== 1 || o.nodeName !== "INPUT" || o.type !== "hidden") && !p || (o = Rl(o.nextSibling), o === null)) return null;
      return o
   }

   function RE(o) {
      return o.data === "$!" || o.data === "$?" && o.ownerDocument.readyState === "complete"
   }

   function uH(o, u) {
      var p = o.ownerDocument;
      if (o.data !== "$?" || p.readyState === "complete") u();
      else {
         var y = function () {
            u(), p.removeEventListener("DOMContentLoaded", y)
         };
         p.addEventListener("DOMContentLoaded", y), o._reactRetry = y
      }
   }

   function Rl(o) {
      for (; o != null; o = o.nextSibling) {
         var u = o.nodeType;
         if (u === 1 || u === 3) break;
         if (u === 8) {
            if (u = o.data, u === "$" || u === "$!" || u === "$?" || u === "F!" || u === "F") break;
            if (u === "/$") return null
         }
      }
      return o
   }
   var CE = null;

   function FC(o) {
      o = o.previousSibling;
      for (var u = 0; o;) {
         if (o.nodeType === 8) {
            var p = o.data;
            if (p === "$" || p === "$!" || p === "$?") {
               if (u === 0) return o;
               u--
            } else p === "/$" && u++
         }
         o = o.previousSibling
      }
      return null
   }

   function HC(o, u, p) {
      switch (u = X_(p), o) {
         case "html":
            if (o = u.documentElement, !o) throw Error(i(452));
            return o;
         case "head":
            if (o = u.head, !o) throw Error(i(453));
            return o;
         case "body":
            if (o = u.body, !o) throw Error(i(454));
            return o;
         default:
            throw Error(i(451))
      }
   }

   function Yv(o) {
      for (var u = o.attributes; u.length;) o.removeAttributeNode(u[0]);
      Ft(o)
   }
   var Ho = new Map,
      VC = new Set;

   function W_(o) {
      return typeof o.getRootNode == "function" ? o.getRootNode() : o.nodeType === 9 ? o : o.ownerDocument
   }
   var pc = Z.d;
   Z.d = {
      f: cH,
      r: fH,
      D: hH,
      C: dH,
      L: pH,
      m: mH,
      X: vH,
      S: gH,
      M: yH
   };

   function cH() {
      var o = pc.f(),
         u = Io();
      return o || u
   }

   function fH(o) {
      var u = gn(o);
      u !== null && u.tag === 5 && u.type === "form" ? A_(u) : pc.r(o)
   }
   var hm = typeof document > "u" ? null : document;

   function GC(o, u, p) {
      var y = hm;
      if (y && typeof u == "string" && u) {
         var M = li(u);
         M = 'link[rel="' + o + '"][href="' + M + '"]', typeof p == "string" && (M += '[crossorigin="' + p + '"]'), VC.has(M) || (VC.add(M), o = {
            rel: o,
            crossOrigin: p,
            href: u
         }, y.querySelector(M) === null && (u = y.createElement("link"), pr(u, "link", o), Pn(u), y.head.appendChild(u)))
      }
   }

   function hH(o) {
      pc.D(o), GC("dns-prefetch", o, null)
   }

   function dH(o, u) {
      pc.C(o, u), GC("preconnect", o, u)
   }

   function pH(o, u, p) {
      pc.L(o, u, p);
      var y = hm;
      if (y && o && u) {
         var M = 'link[rel="preload"][as="' + li(u) + '"]';
         u === "image" && p && p.imageSrcSet ? (M += '[imagesrcset="' + li(p.imageSrcSet) + '"]', typeof p.imageSizes == "string" && (M += '[imagesizes="' + li(p.imageSizes) + '"]')) : M += '[href="' + li(o) + '"]';
         var R = M;
         switch (u) {
            case "style":
               R = dm(o);
               break;
            case "script":
               R = pm(o)
         }
         Ho.has(R) || (o = m({
            rel: "preload",
            href: u === "image" && p && p.imageSrcSet ? void 0 : o,
            as: u
         }, p), Ho.set(R, o), y.querySelector(M) !== null || u === "style" && y.querySelector(Kv(R)) || u === "script" && y.querySelector(Zv(R)) || (u = y.createElement("link"), pr(u, "link", o), Pn(u), y.head.appendChild(u)))
      }
   }

   function mH(o, u) {
      pc.m(o, u);
      var p = hm;
      if (p && o) {
         var y = u && typeof u.as == "string" ? u.as : "script",
            M = 'link[rel="modulepreload"][as="' + li(y) + '"][href="' + li(o) + '"]',
            R = M;
         switch (y) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script":
               R = pm(o)
         }
         if (!Ho.has(R) && (o = m({
               rel: "modulepreload",
               href: o
            }, u), Ho.set(R, o), p.querySelector(M) === null)) {
            switch (y) {
               case "audioworklet":
               case "paintworklet":
               case "serviceworker":
               case "sharedworker":
               case "worker":
               case "script":
                  if (p.querySelector(Zv(R))) return
            }
            y = p.createElement("link"), pr(y, "link", o), Pn(y), p.head.appendChild(y)
         }
      }
   }

   function gH(o, u, p) {
      pc.S(o, u, p);
      var y = hm;
      if (y && o) {
         var M = zn(y).hoistableStyles,
            R = dm(o);
         u = u || "default";
         var V = M.get(R);
         if (!V) {
            var W = {
               loading: 0,
               preload: null
            };
            if (V = y.querySelector(Kv(R))) W.loading = 5;
            else {
               o = m({
                  rel: "stylesheet",
                  href: o,
                  "data-precedence": u
               }, p), (p = Ho.get(R)) && DE(o, p);
               var se = V = y.createElement("link");
               Pn(se), pr(se, "link", o), se._p = new Promise(function (Se, Ve) {
                  se.onload = Se, se.onerror = Ve
               }), se.addEventListener("load", function () {
                  W.loading |= 1
               }), se.addEventListener("error", function () {
                  W.loading |= 2
               }), W.loading |= 4, Y_(V, u, y)
            }
            V = {
               type: "stylesheet",
               instance: V,
               count: 1,
               state: W
            }, M.set(R, V)
         }
      }
   }

   function vH(o, u) {
      pc.X(o, u);
      var p = hm;
      if (p && o) {
         var y = zn(p).hoistableScripts,
            M = pm(o),
            R = y.get(M);
         R || (R = p.querySelector(Zv(M)), R || (o = m({
            src: o,
            async: !0
         }, u), (u = Ho.get(M)) && NE(o, u), R = p.createElement("script"), Pn(R), pr(R, "link", o), p.head.appendChild(R)), R = {
            type: "script",
            instance: R,
            count: 1,
            state: null
         }, y.set(M, R))
      }
   }

   function yH(o, u) {
      pc.M(o, u);
      var p = hm;
      if (p && o) {
         var y = zn(p).hoistableScripts,
            M = pm(o),
            R = y.get(M);
         R || (R = p.querySelector(Zv(M)), R || (o = m({
            src: o,
            async: !0,
            type: "module"
         }, u), (u = Ho.get(M)) && NE(o, u), R = p.createElement("script"), Pn(R), pr(R, "link", o), p.head.appendChild(R)), R = {
            type: "script",
            instance: R,
            count: 1,
            state: null
         }, y.set(M, R))
      }
   }

   function kC(o, u, p, y) {
      var M = (M = Pe.current) ? W_(M) : null;
      if (!M) throw Error(i(446));
      switch (o) {
         case "meta":
         case "title":
            return null;
         case "style":
            return typeof p.precedence == "string" && typeof p.href == "string" ? (u = dm(p.href), p = zn(M).hoistableStyles, y = p.get(u), y || (y = {
               type: "style",
               instance: null,
               count: 0,
               state: null
            }, p.set(u, y)), y) : {
               type: "void",
               instance: null,
               count: 0,
               state: null
            };
         case "link":
            if (p.rel === "stylesheet" && typeof p.href == "string" && typeof p.precedence == "string") {
               o = dm(p.href);
               var R = zn(M).hoistableStyles,
                  V = R.get(o);
               if (V || (M = M.ownerDocument || M, V = {
                     type: "stylesheet",
                     instance: null,
                     count: 0,
                     state: {
                        loading: 0,
                        preload: null
                     }
                  }, R.set(o, V), (R = M.querySelector(Kv(o))) && !R._p && (V.instance = R, V.state.loading = 5), Ho.has(o) || (p = {
                     rel: "preload",
                     as: "style",
                     href: p.href,
                     crossOrigin: p.crossOrigin,
                     integrity: p.integrity,
                     media: p.media,
                     hrefLang: p.hrefLang,
                     referrerPolicy: p.referrerPolicy
                  }, Ho.set(o, p), R || xH(M, o, p, V.state))), u && y === null) throw Error(i(528, ""));
               return V
            }
            if (u && y !== null) throw Error(i(529, ""));
            return null;
         case "script":
            return u = p.async, p = p.src, typeof p == "string" && u && typeof u != "function" && typeof u != "symbol" ? (u = pm(p), p = zn(M).hoistableScripts, y = p.get(u), y || (y = {
               type: "script",
               instance: null,
               count: 0,
               state: null
            }, p.set(u, y)), y) : {
               type: "void",
               instance: null,
               count: 0,
               state: null
            };
         default:
            throw Error(i(444, o))
      }
   }

   function dm(o) {
      return 'href="' + li(o) + '"'
   }

   function Kv(o) {
      return 'link[rel="stylesheet"][' + o + "]"
   }

   function jC(o) {
      return m({}, o, {
         "data-precedence": o.precedence,
         precedence: null
      })
   }

   function xH(o, u, p, y) {
      o.querySelector('link[rel="preload"][as="style"][' + u + "]") ? y.loading = 1 : (u = o.createElement("link"), y.preload = u, u.addEventListener("load", function () {
         return y.loading |= 1
      }), u.addEventListener("error", function () {
         return y.loading |= 2
      }), pr(u, "link", p), Pn(u), o.head.appendChild(u))
   }

   function pm(o) {
      return '[src="' + li(o) + '"]'
   }

   function Zv(o) {
      return "script[async]" + o
   }

   function qC(o, u, p) {
      if (u.count++, u.instance === null) switch (u.type) {
         case "style":
            var y = o.querySelector('style[data-href~="' + li(p.href) + '"]');
            if (y) return u.instance = y, Pn(y), y;
            var M = m({}, p, {
               "data-href": p.href,
               "data-precedence": p.precedence,
               href: null,
               precedence: null
            });
            return y = (o.ownerDocument || o).createElement("style"), Pn(y), pr(y, "style", M), Y_(y, p.precedence, o), u.instance = y;
         case "stylesheet":
            M = dm(p.href);
            var R = o.querySelector(Kv(M));
            if (R) return u.state.loading |= 4, u.instance = R, Pn(R), R;
            y = jC(p), (M = Ho.get(M)) && DE(y, M), R = (o.ownerDocument || o).createElement("link"), Pn(R);
            var V = R;
            return V._p = new Promise(function (W, se) {
               V.onload = W, V.onerror = se
            }), pr(R, "link", y), u.state.loading |= 4, Y_(R, p.precedence, o), u.instance = R;
         case "script":
            return R = pm(p.src), (M = o.querySelector(Zv(R))) ? (u.instance = M, Pn(M), M) : (y = p, (M = Ho.get(R)) && (y = m({}, p), NE(y, M)), o = o.ownerDocument || o, M = o.createElement("script"), Pn(M), pr(M, "link", y), o.head.appendChild(M), u.instance = M);
         case "void":
            return null;
         default:
            throw Error(i(443, u.type))
      } else u.type === "stylesheet" && (u.state.loading & 4) === 0 && (y = u.instance, u.state.loading |= 4, Y_(y, p.precedence, o));
      return u.instance
   }

   function Y_(o, u, p) {
      for (var y = p.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'), M = y.length ? y[y.length - 1] : null, R = M, V = 0; V < y.length; V++) {
         var W = y[V];
         if (W.dataset.precedence === u) R = W;
         else if (R !== M) break
      }
      R ? R.parentNode.insertBefore(o, R.nextSibling) : (u = p.nodeType === 9 ? p.head : p, u.insertBefore(o, u.firstChild))
   }

   function DE(o, u) {
      o.crossOrigin == null && (o.crossOrigin = u.crossOrigin), o.referrerPolicy == null && (o.referrerPolicy = u.referrerPolicy), o.title == null && (o.title = u.title)
   }

   function NE(o, u) {
      o.crossOrigin == null && (o.crossOrigin = u.crossOrigin), o.referrerPolicy == null && (o.referrerPolicy = u.referrerPolicy), o.integrity == null && (o.integrity = u.integrity)
   }
   var K_ = null;

   function XC(o, u, p) {
      if (K_ === null) {
         var y = new Map,
            M = K_ = new Map;
         M.set(p, y)
      } else M = K_, y = M.get(p), y || (y = new Map, M.set(p, y));
      if (y.has(o)) return y;
      for (y.set(o, null), p = p.getElementsByTagName(o), M = 0; M < p.length; M++) {
         var R = p[M];
         if (!(R[ii] || R[Qe] || o === "link" && R.getAttribute("rel") === "stylesheet") && R.namespaceURI !== "http://www.w3.org/2000/svg") {
            var V = R.getAttribute(u) || "";
            V = o + V;
            var W = y.get(V);
            W ? W.push(R) : y.set(V, [R])
         }
      }
      return y
   }

   function WC(o, u, p) {
      o = o.ownerDocument || o, o.head.insertBefore(p, u === "title" ? o.querySelector("head > title") : null)
   }

   function _H(o, u, p) {
      if (p === 1 || u.itemProp != null) return !1;
      switch (o) {
         case "meta":
         case "title":
            return !0;
         case "style":
            if (typeof u.precedence != "string" || typeof u.href != "string" || u.href === "") break;
            return !0;
         case "link":
            if (typeof u.rel != "string" || typeof u.href != "string" || u.href === "" || u.onLoad || u.onError) break;
            switch (u.rel) {
               case "stylesheet":
                  return o = u.disabled, typeof u.precedence == "string" && o == null;
               default:
                  return !0
            }
         case "script":
            if (u.async && typeof u.async != "function" && typeof u.async != "symbol" && !u.onLoad && !u.onError && u.src && typeof u.src == "string") return !0
      }
      return !1
   }

   function YC(o) {
      return !(o.type === "stylesheet" && (o.state.loading & 3) === 0)
   }
   var Qv = null;

   function SH() {}

   function bH(o, u, p) {
      if (Qv === null) throw Error(i(475));
      var y = Qv;
      if (u.type === "stylesheet" && (typeof p.media != "string" || matchMedia(p.media).matches !== !1) && (u.state.loading & 4) === 0) {
         if (u.instance === null) {
            var M = dm(p.href),
               R = o.querySelector(Kv(M));
            if (R) {
               o = R._p, o !== null && typeof o == "object" && typeof o.then == "function" && (y.count++, y = Z_.bind(y), o.then(y, y)), u.state.loading |= 4, u.instance = R, Pn(R);
               return
            }
            R = o.ownerDocument || o, p = jC(p), (M = Ho.get(M)) && DE(p, M), R = R.createElement("link"), Pn(R);
            var V = R;
            V._p = new Promise(function (W, se) {
               V.onload = W, V.onerror = se
            }), pr(R, "link", p), u.instance = R
         }
         y.stylesheets === null && (y.stylesheets = new Map), y.stylesheets.set(u, o), (o = u.state.preload) && (u.state.loading & 3) === 0 && (y.count++, u = Z_.bind(y), o.addEventListener("load", u), o.addEventListener("error", u))
      }
   }

   function TH() {
      if (Qv === null) throw Error(i(475));
      var o = Qv;
      return o.stylesheets && o.count === 0 && OE(o, o.stylesheets), 0 < o.count ? function (u) {
         var p = setTimeout(function () {
            if (o.stylesheets && OE(o, o.stylesheets), o.unsuspend) {
               var y = o.unsuspend;
               o.unsuspend = null, y()
            }
         }, 6e4);
         return o.unsuspend = u,
            function () {
               o.unsuspend = null, clearTimeout(p)
            }
      } : null
   }

   function Z_() {
      if (this.count--, this.count === 0) {
         if (this.stylesheets) OE(this, this.stylesheets);
         else if (this.unsuspend) {
            var o = this.unsuspend;
            this.unsuspend = null, o()
         }
      }
   }
   var Q_ = null;

   function OE(o, u) {
      o.stylesheets = null, o.unsuspend !== null && (o.count++, Q_ = new Map, u.forEach(EH, o), Q_ = null, Z_.call(o))
   }

   function EH(o, u) {
      if (!(u.state.loading & 4)) {
         var p = Q_.get(o);
         if (p) var y = p.get(null);
         else {
            p = new Map, Q_.set(o, p);
            for (var M = o.querySelectorAll("link[data-precedence],style[data-precedence]"), R = 0; R < M.length; R++) {
               var V = M[R];
               (V.nodeName === "LINK" || V.getAttribute("media") !== "not all") && (p.set(V.dataset.precedence, V), y = V)
            }
            y && p.set(null, y)
         }
         M = u.instance, V = M.getAttribute("data-precedence"), R = p.get(V) || y, R === y && p.set(null, M), p.set(V, M), this.count++, y = Z_.bind(this), M.addEventListener("load", y), M.addEventListener("error", y), R ? R.parentNode.insertBefore(M, R.nextSibling) : (o = o.nodeType === 9 ? o.head : o, o.insertBefore(M, o.firstChild)), u.state.loading |= 4
      }
   }
   var Jv = {
      $$typeof: C,
      Provider: null,
      Consumer: null,
      _currentValue: J,
      _currentValue2: J,
      _threadCount: 0
   };

   function MH(o, u, p, y, M, R, V, W) {
      this.tag = 1, this.containerInfo = o, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = Re(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Re(0), this.hiddenUpdates = Re(null), this.identifierPrefix = y, this.onUncaughtError = M, this.onCaughtError = R, this.onRecoverableError = V, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = W, this.incompleteTransitions = new Map
   }

   function KC(o, u, p, y, M, R, V, W, se, Se, Ve, qe) {
      return o = new MH(o, u, p, V, W, se, Se, qe), u = 1, R === !0 && (u |= 24), R = br(3, null, null, u), o.current = R, R.stateNode = o, u = Lp(), u.refCount++, o.pooledCache = u, u.refCount++, R.memoizedState = {
         element: y,
         isDehydrated: p,
         cache: u
      }, bv(R), o
   }

   function ZC(o) {
      return o ? (o = tu, o) : tu
   }

   function QC(o, u, p, y, M, R) {
      M = ZC(M), y.context === null ? y.context = M : y.pendingContext = M, y = wo(u), y.payload = {
         element: p
      }, R = R === void 0 ? null : R, R !== null && (y.callback = R), p = yl(o, y, u), p !== null && (dr(p, o, u), Zu(p, o, u))
   }

   function JC(o, u) {
      if (o = o.memoizedState, o !== null && o.dehydrated !== null) {
         var p = o.retryLane;
         o.retryLane = p !== 0 && p < u ? p : u
      }
   }

   function UE(o, u) {
      JC(o, u), (o = o.alternate) && JC(o, u)
   }

   function $C(o) {
      if (o.tag === 13) {
         var u = dl(o, 67108864);
         u !== null && dr(u, o, 67108864), UE(o, 67108864)
      }
   }
   var J_ = !0;

   function AH(o, u, p, y) {
      var M = k.T;
      k.T = null;
      var R = Z.p;
      try {
         Z.p = 2, PE(o, u, p, y)
      } finally {
         Z.p = R, k.T = M
      }
   }

   function wH(o, u, p, y) {
      var M = k.T;
      k.T = null;
      var R = Z.p;
      try {
         Z.p = 8, PE(o, u, p, y)
      } finally {
         Z.p = R, k.T = M
      }
   }

   function PE(o, u, p, y) {
      if (J_) {
         var M = LE(y);
         if (M === null) SE(o, u, y, $_, p), tD(o, y);
         else if (CH(M, o, u, p, y)) y.stopPropagation();
         else if (tD(o, y), u & 4 && -1 < RH.indexOf(o)) {
            for (; M !== null;) {
               var R = gn(M);
               if (R !== null) switch (R.tag) {
                  case 3:
                     if (R = R.stateNode, R.current.memoizedState.isDehydrated) {
                        var V = it(R.pendingLanes);
                        if (V !== 0) {
                           var W = R;
                           for (W.pendingLanes |= 2, W.entangledLanes |= 2; V;) {
                              var se = 1 << 31 - Ze(V);
                              W.entanglements[1] |= se, V &= ~se
                           }
                           Mu(R), (Zn & 6) === 0 && (Zs = te() + 500, qv(0))
                        }
                     }
                     break;
                  case 13:
                     W = dl(R, 2), W !== null && dr(W, R, 2), Io(), UE(R, 2)
               }
               if (R = LE(y), R === null && SE(o, u, y, $_, p), R === M) break;
               M = R
            }
            M !== null && y.stopPropagation()
         } else SE(o, u, y, null, p)
      }
   }

   function LE(o) {
      return o = gp(o), BE(o)
   }
   var $_ = null;

   function BE(o) {
      if ($_ = null, o = Mn(o), o !== null) {
         var u = r(o);
         if (u === null) o = null;
         else {
            var p = u.tag;
            if (p === 13) {
               if (o = a(u), o !== null) return o;
               o = null
            } else if (p === 3) {
               if (u.stateNode.current.memoizedState.isDehydrated) return u.tag === 3 ? u.stateNode.containerInfo : null;
               o = null
            } else u !== o && (o = null)
         }
      }
      return $_ = o, null
   }

   function eD(o) {
      switch (o) {
         case "beforetoggle":
         case "cancel":
         case "click":
         case "close":
         case "contextmenu":
         case "copy":
         case "cut":
         case "auxclick":
         case "dblclick":
         case "dragend":
         case "dragstart":
         case "drop":
         case "focusin":
         case "focusout":
         case "input":
         case "invalid":
         case "keydown":
         case "keypress":
         case "keyup":
         case "mousedown":
         case "mouseup":
         case "paste":
         case "pause":
         case "play":
         case "pointercancel":
         case "pointerdown":
         case "pointerup":
         case "ratechange":
         case "reset":
         case "resize":
         case "seeked":
         case "submit":
         case "toggle":
         case "touchcancel":
         case "touchend":
         case "touchstart":
         case "volumechange":
         case "change":
         case "selectionchange":
         case "textInput":
         case "compositionstart":
         case "compositionend":
         case "compositionupdate":
         case "beforeblur":
         case "afterblur":
         case "beforeinput":
         case "blur":
         case "fullscreenchange":
         case "focus":
         case "hashchange":
         case "popstate":
         case "select":
         case "selectstart":
            return 2;
         case "drag":
         case "dragenter":
         case "dragexit":
         case "dragleave":
         case "dragover":
         case "mousemove":
         case "mouseout":
         case "mouseover":
         case "pointermove":
         case "pointerout":
         case "pointerover":
         case "scroll":
         case "touchmove":
         case "wheel":
         case "mouseenter":
         case "mouseleave":
         case "pointerenter":
         case "pointerleave":
            return 8;
         case "message":
            switch (Be()) {
               case Je:
                  return 2;
               case Ue:
                  return 8;
               case K:
               case G:
                  return 32;
               case me:
                  return 268435456;
               default:
                  return 32
            }
         default:
            return 32
      }
   }
   var zE = !1,
      wf = null,
      Rf = null,
      Cf = null,
      $v = new Map,
      e0 = new Map,
      Df = [],
      RH = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");

   function tD(o, u) {
      switch (o) {
         case "focusin":
         case "focusout":
            wf = null;
            break;
         case "dragenter":
         case "dragleave":
            Rf = null;
            break;
         case "mouseover":
         case "mouseout":
            Cf = null;
            break;
         case "pointerover":
         case "pointerout":
            $v.delete(u.pointerId);
            break;
         case "gotpointercapture":
         case "lostpointercapture":
            e0.delete(u.pointerId)
      }
   }

   function t0(o, u, p, y, M, R) {
      return o === null || o.nativeEvent !== R ? (o = {
         blockedOn: u,
         domEventName: p,
         eventSystemFlags: y,
         nativeEvent: R,
         targetContainers: [M]
      }, u !== null && (u = gn(u), u !== null && $C(u)), o) : (o.eventSystemFlags |= y, u = o.targetContainers, M !== null && u.indexOf(M) === -1 && u.push(M), o)
   }

   function CH(o, u, p, y, M) {
      switch (u) {
         case "focusin":
            return wf = t0(wf, o, u, p, y, M), !0;
         case "dragenter":
            return Rf = t0(Rf, o, u, p, y, M), !0;
         case "mouseover":
            return Cf = t0(Cf, o, u, p, y, M), !0;
         case "pointerover":
            var R = M.pointerId;
            return $v.set(R, t0($v.get(R) || null, o, u, p, y, M)), !0;
         case "gotpointercapture":
            return R = M.pointerId, e0.set(R, t0(e0.get(R) || null, o, u, p, y, M)), !0
      }
      return !1
   }

   function nD(o) {
      var u = Mn(o.target);
      if (u !== null) {
         var p = r(u);
         if (p !== null) {
            if (u = p.tag, u === 13) {
               if (u = a(p), u !== null) {
                  o.blockedOn = u, _t(o.priority, function () {
                     if (p.tag === 13) {
                        var y = Li();
                        y = mn(y);
                        var M = dl(p, y);
                        M !== null && dr(M, p, y), UE(p, y)
                     }
                  });
                  return
               }
            } else if (u === 3 && p.stateNode.current.memoizedState.isDehydrated) {
               o.blockedOn = p.tag === 3 ? p.stateNode.containerInfo : null;
               return
            }
         }
      }
      o.blockedOn = null
   }

   function eS(o) {
      if (o.blockedOn !== null) return !1;
      for (var u = o.targetContainers; 0 < u.length;) {
         var p = LE(o.nativeEvent);
         if (p === null) {
            p = o.nativeEvent;
            var y = new p.constructor(p.type, p);
            mp = y, p.target.dispatchEvent(y), mp = null
         } else return u = gn(p), u !== null && $C(u), o.blockedOn = p, !1;
         u.shift()
      }
      return !0
   }

   function iD(o, u, p) {
      eS(o) && p.delete(u)
   }

   function DH() {
      zE = !1, wf !== null && eS(wf) && (wf = null), Rf !== null && eS(Rf) && (Rf = null), Cf !== null && eS(Cf) && (Cf = null), $v.forEach(iD), e0.forEach(iD)
   }

   function tS(o, u) {
      o.blockedOn === u && (o.blockedOn = null, zE || (zE = !0, n.unstable_scheduleCallback(n.unstable_NormalPriority, DH)))
   }
   var nS = null;

   function sD(o) {
      nS !== o && (nS = o, n.unstable_scheduleCallback(n.unstable_NormalPriority, function () {
         nS === o && (nS = null);
         for (var u = 0; u < o.length; u += 3) {
            var p = o[u],
               y = o[u + 1],
               M = o[u + 2];
            if (typeof y != "function") {
               if (BE(y || p) === null) continue;
               break
            }
            var R = gn(p);
            R !== null && (o.splice(u, 3), u -= 3, Iv(R, {
               pending: !0,
               data: M,
               method: p.method,
               action: y
            }, y, M))
         }
      }))
   }

   function n0(o) {
      function u(se) {
         return tS(se, o)
      }
      wf !== null && tS(wf, o), Rf !== null && tS(Rf, o), Cf !== null && tS(Cf, o), $v.forEach(u), e0.forEach(u);
      for (var p = 0; p < Df.length; p++) {
         var y = Df[p];
         y.blockedOn === o && (y.blockedOn = null)
      }
      for (; 0 < Df.length && (p = Df[0], p.blockedOn === null);) nD(p), p.blockedOn === null && Df.shift();
      if (p = (o.ownerDocument || o).$$reactFormReplay, p != null)
         for (y = 0; y < p.length; y += 3) {
            var M = p[y],
               R = p[y + 1],
               V = M[St] || null;
            if (typeof R == "function") V || sD(p);
            else if (V) {
               var W = null;
               if (R && R.hasAttribute("formAction")) {
                  if (M = R, V = R[St] || null) W = V.formAction;
                  else if (BE(M) !== null) continue
               } else W = V.action;
               typeof W == "function" ? p[y + 1] = W : (p.splice(y, 3), y -= 3), sD(p)
            }
         }
   }

   function IE(o) {
      this._internalRoot = o
   }
   iS.prototype.render = IE.prototype.render = function (o) {
      var u = this._internalRoot;
      if (u === null) throw Error(i(409));
      var p = u.current,
         y = Li();
      QC(p, y, o, u, null, null)
   }, iS.prototype.unmount = IE.prototype.unmount = function () {
      var o = this._internalRoot;
      if (o !== null) {
         this._internalRoot = null;
         var u = o.containerInfo;
         QC(o.current, 2, null, o, null, null), Io(), u[gt] = null
      }
   };

   function iS(o) {
      this._internalRoot = o
   }
   iS.prototype.unstable_scheduleHydration = function (o) {
      if (o) {
         var u = ut();
         o = {
            blockedOn: null,
            target: o,
            priority: u
         };
         for (var p = 0; p < Df.length && u !== 0 && u < Df[p].priority; p++);
         Df.splice(p, 0, o), p === 0 && nD(o)
      }
   };
   var rD = e.version;
   if (rD !== "19.1.0") throw Error(i(527, rD, "19.1.0"));
   Z.findDOMNode = function (o) {
      var u = o._reactInternals;
      if (u === void 0) throw typeof o.render == "function" ? Error(i(188)) : (o = Object.keys(o).join(","), Error(i(268, o)));
      return o = c(u), o = o !== null ? h(o) : null, o = o === null ? null : o.stateNode, o
   };
   var NH = {
      bundleType: 0,
      version: "19.1.0",
      rendererPackageName: "react-dom",
      currentDispatcherRef: k,
      reconcilerVersion: "19.1.0"
   };
   if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
      var sS = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (!sS.isDisabled && sS.supportsFiber) try {
         De = sS.inject(NH), Ye = sS
      } catch {}
   }
   return s0.createRoot = function (o, u) {
      if (!s(o)) throw Error(i(299));
      var p = !1,
         y = "",
         M = $h,
         R = Jp,
         V = I_,
         W = null;
      return u != null && (u.unstable_strictMode === !0 && (p = !0), u.identifierPrefix !== void 0 && (y = u.identifierPrefix), u.onUncaughtError !== void 0 && (M = u.onUncaughtError), u.onCaughtError !== void 0 && (R = u.onCaughtError), u.onRecoverableError !== void 0 && (V = u.onRecoverableError), u.unstable_transitionCallbacks !== void 0 && (W = u.unstable_transitionCallbacks)), u = KC(o, 1, !1, null, null, p, y, M, R, V, W, null), o[gt] = u.current, _E(o), new IE(u)
   }, s0.hydrateRoot = function (o, u, p) {
      if (!s(o)) throw Error(i(299));
      var y = !1,
         M = "",
         R = $h,
         V = Jp,
         W = I_,
         se = null,
         Se = null;
      return p != null && (p.unstable_strictMode === !0 && (y = !0), p.identifierPrefix !== void 0 && (M = p.identifierPrefix), p.onUncaughtError !== void 0 && (R = p.onUncaughtError), p.onCaughtError !== void 0 && (V = p.onCaughtError), p.onRecoverableError !== void 0 && (W = p.onRecoverableError), p.unstable_transitionCallbacks !== void 0 && (se = p.unstable_transitionCallbacks), p.formState !== void 0 && (Se = p.formState)), u = KC(o, 1, !0, u, p ?? null, y, M, R, V, W, se, Se), u.context = ZC(null), p = u.current, y = Li(), y = mn(y), M = wo(y), M.callback = null, yl(p, M, y), p = y, u.current.lanes = p, Ie(u, p), Mu(u), o[gt] = u.current, _E(o), new iS(u)
   }, s0.version = "19.1.0", s0
}
var mD;

function GH() {
   if (mD) return VE.exports;
   mD = 1;

   function n() {
      if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try {
         __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)
      } catch (e) {
         console.error(e)
      }
   }
   return n(), VE.exports = VH(), VE.exports
}
var kH = GH();
const jH = lx(kH);
var r0 = {},
   gD;

function qH() {
   if (gD) return r0;
   gD = 1, Object.defineProperty(r0, "__esModule", {
      value: !0
   }), r0.parse = a, r0.serialize = h;
   const n = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/,
      e = /^[\u0021-\u003A\u003C-\u007E]*$/,
      t = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i,
      i = /^[\u0020-\u003A\u003D-\u007E]*$/,
      s = Object.prototype.toString,
      r = (() => {
         const v = function () {};
         return v.prototype = Object.create(null), v
      })();

   function a(v, x) {
      const S = new r,
         E = v.length;
      if (E < 2) return S;
      const T = (x == null ? void 0 : x.decode) || m;
      let b = 0;
      do {
         const w = v.indexOf("=", b);
         if (w === -1) break;
         const C = v.indexOf(";", b),
            N = C === -1 ? E : C;
         if (w > N) {
            b = v.lastIndexOf(";", w - 1) + 1;
            continue
         }
         const U = l(v, b, w),
            z = c(v, w, U),
            B = v.slice(U, z);
         if (S[B] === void 0) {
            let I = l(v, w + 1, N),
               O = c(v, N, I);
            const P = T(v.slice(I, O));
            S[B] = P
         }
         b = N + 1
      } while (b < E);
      return S
   }

   function l(v, x, S) {
      do {
         const E = v.charCodeAt(x);
         if (E !== 32 && E !== 9) return x
      } while (++x < S);
      return S
   }

   function c(v, x, S) {
      for (; x > S;) {
         const E = v.charCodeAt(--x);
         if (E !== 32 && E !== 9) return x + 1
      }
      return S
   }

   function h(v, x, S) {
      const E = (S == null ? void 0 : S.encode) || encodeURIComponent;
      if (!n.test(v)) throw new TypeError(`argument name is invalid: ${v}`);
      const T = E(x);
      if (!e.test(T)) throw new TypeError(`argument val is invalid: ${x}`);
      let b = v + "=" + T;
      if (!S) return b;
      if (S.maxAge !== void 0) {
         if (!Number.isInteger(S.maxAge)) throw new TypeError(`option maxAge is invalid: ${S.maxAge}`);
         b += "; Max-Age=" + S.maxAge
      }
      if (S.domain) {
         if (!t.test(S.domain)) throw new TypeError(`option domain is invalid: ${S.domain}`);
         b += "; Domain=" + S.domain
      }
      if (S.path) {
         if (!i.test(S.path)) throw new TypeError(`option path is invalid: ${S.path}`);
         b += "; Path=" + S.path
      }
      if (S.expires) {
         if (!g(S.expires) || !Number.isFinite(S.expires.valueOf())) throw new TypeError(`option expires is invalid: ${S.expires}`);
         b += "; Expires=" + S.expires.toUTCString()
      }
      if (S.httpOnly && (b += "; HttpOnly"), S.secure && (b += "; Secure"), S.partitioned && (b += "; Partitioned"), S.priority) switch (typeof S.priority == "string" ? S.priority.toLowerCase() : void 0) {
         case "low":
            b += "; Priority=Low";
            break;
         case "medium":
            b += "; Priority=Medium";
            break;
         case "high":
            b += "; Priority=High";
            break;
         default:
            throw new TypeError(`option priority is invalid: ${S.priority}`)
      }
      if (S.sameSite) switch (typeof S.sameSite == "string" ? S.sameSite.toLowerCase() : S.sameSite) {
         case !0:
         case "strict":
            b += "; SameSite=Strict";
            break;
         case "lax":
            b += "; SameSite=Lax";
            break;
         case "none":
            b += "; SameSite=None";
            break;
         default:
            throw new TypeError(`option sameSite is invalid: ${S.sameSite}`)
      }
      return b
   }

   function m(v) {
      if (v.indexOf("%") === -1) return v;
      try {
         return decodeURIComponent(v)
      } catch {
         return v
      }
   }

   function g(v) {
      return s.call(v) === "[object Date]"
   }
   return r0
}
qH();
var vD = "popstate";

function XH(n = {}) {
   function e(i, s) {
      let {
         pathname: r,
         search: a,
         hash: l
      } = i.location;
      return BA("", {
         pathname: r,
         search: a,
         hash: l
      }, s.state && s.state.usr || null, s.state && s.state.key || "default")
   }

   function t(i, s) {
      return typeof s == "string" ? s : my(s)
   }
   return YH(e, t, null, n)
}

function Fi(n, e) {
   if (n === !1 || n === null || typeof n > "u") throw new Error(e)
}

function Fl(n, e) {
   if (!n) {
      typeof console < "u" && console.warn(e);
      try {
         throw new Error(e)
      } catch {}
   }
}

function WH() {
   return Math.random().toString(36).substring(2, 10)
}

function yD(n, e) {
   return {
      usr: n.state,
      key: n.key,
      idx: e
   }
}

function BA(n, e, t = null, i) {
   return {
      pathname: typeof n == "string" ? n : n.pathname,
      search: "",
      hash: "",
      ...typeof e == "string" ? Cg(e) : e,
      state: t,
      key: e && e.key || i || WH()
   }
}

function my({
   pathname: n = "/",
   search: e = "",
   hash: t = ""
}) {
   return e && e !== "?" && (n += e.charAt(0) === "?" ? e : "?" + e), t && t !== "#" && (n += t.charAt(0) === "#" ? t : "#" + t), n
}

function Cg(n) {
   let e = {};
   if (n) {
      let t = n.indexOf("#");
      t >= 0 && (e.hash = n.substring(t), n = n.substring(0, t));
      let i = n.indexOf("?");
      i >= 0 && (e.search = n.substring(i), n = n.substring(0, i)), n && (e.pathname = n)
   }
   return e
}

function YH(n, e, t, i = {}) {
   let {
      window: s = document.defaultView,
      v5Compat: r = !1
   } = i, a = s.history, l = "POP", c = null, h = m();
   h == null && (h = 0, a.replaceState({
      ...a.state,
      idx: h
   }, ""));

   function m() {
      return (a.state || {
         idx: null
      }).idx
   }

   function g() {
      l = "POP";
      let T = m(),
         b = T == null ? null : T - h;
      h = T, c && c({
         action: l,
         location: E.location,
         delta: b
      })
   }

   function v(T, b) {
      l = "PUSH";
      let w = BA(E.location, T, b);
      h = m() + 1;
      let C = yD(w, h),
         N = E.createHref(w);
      try {
         a.pushState(C, "", N)
      } catch (U) {
         if (U instanceof DOMException && U.name === "DataCloneError") throw U;
         s.location.assign(N)
      }
      r && c && c({
         action: l,
         location: E.location,
         delta: 1
      })
   }

   function x(T, b) {
      l = "REPLACE";
      let w = BA(E.location, T, b);
      h = m();
      let C = yD(w, h),
         N = E.createHref(w);
      a.replaceState(C, "", N), r && c && c({
         action: l,
         location: E.location,
         delta: 0
      })
   }

   function S(T) {
      return KH(T)
   }
   let E = {
      get action() {
         return l
      },
      get location() {
         return n(s, a)
      },
      listen(T) {
         if (c) throw new Error("A history only accepts one active listener");
         return s.addEventListener(vD, g), c = T, () => {
            s.removeEventListener(vD, g), c = null
         }
      },
      createHref(T) {
         return e(s, T)
      },
      createURL: S,
      encodeLocation(T) {
         let b = S(T);
         return {
            pathname: b.pathname,
            search: b.search,
            hash: b.hash
         }
      },
      push: v,
      replace: x,
      go(T) {
         return a.go(T)
      }
   };
   return E
}

function KH(n, e = !1) {
   let t = "http://localhost";
   typeof window < "u" && (t = window.location.origin !== "null" ? window.location.origin : window.location.href), Fi(t, "No window.location.(origin|href) available to create URL");
   let i = typeof n == "string" ? n : my(n);
   return i = i.replace(/ $/, "%20"), !e && i.startsWith("//") && (i = t + i), new URL(i, t)
}

function mP(n, e, t = "/") {
   return ZH(n, e, t, !1)
}

function ZH(n, e, t, i) {
   let s = typeof e == "string" ? Cg(e) : e,
      r = Oc(s.pathname || "/", t);
   if (r == null) return null;
   let a = gP(n);
   QH(a);
   let l = null;
   for (let c = 0; l == null && c < a.length; ++c) {
      let h = l5(r);
      l = a5(a[c], h, i)
   }
   return l
}

function gP(n, e = [], t = [], i = "") {
   let s = (r, a, l) => {
      let c = {
         relativePath: l === void 0 ? r.path || "" : l,
         caseSensitive: r.caseSensitive === !0,
         childrenIndex: a,
         route: r
      };
      c.relativePath.startsWith("/") && (Fi(c.relativePath.startsWith(i), `Absolute route path "${c.relativePath}" nested under path "${i}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`), c.relativePath = c.relativePath.slice(i.length));
      let h = Cc([i, c.relativePath]),
         m = t.concat(c);
      r.children && r.children.length > 0 && (Fi(r.index !== !0, `Index routes must not have child routes. Please remove all child routes from route path "${h}".`), gP(r.children, e, m, h)), !(r.path == null && !r.index) && e.push({
         path: h,
         score: s5(h, r.index),
         routesMeta: m
      })
   };
   return n.forEach((r, a) => {
      var l;
      if (r.path === "" || !((l = r.path) != null && l.includes("?"))) s(r, a);
      else
         for (let c of vP(r.path)) s(r, a, c)
   }), e
}

function vP(n) {
   let e = n.split("/");
   if (e.length === 0) return [];
   let [t, ...i] = e, s = t.endsWith("?"), r = t.replace(/\?$/, "");
   if (i.length === 0) return s ? [r, ""] : [r];
   let a = vP(i.join("/")),
      l = [];
   return l.push(...a.map(c => c === "" ? r : [r, c].join("/"))), s && l.push(...a), l.map(c => n.startsWith("/") && c === "" ? "/" : c)
}

function QH(n) {
   n.sort((e, t) => e.score !== t.score ? t.score - e.score : r5(e.routesMeta.map(i => i.childrenIndex), t.routesMeta.map(i => i.childrenIndex)))
}
var JH = /^:[\w-]+$/,
   $H = 3,
   e5 = 2,
   t5 = 1,
   n5 = 10,
   i5 = -2,
   xD = n => n === "*";

function s5(n, e) {
   let t = n.split("/"),
      i = t.length;
   return t.some(xD) && (i += i5), e && (i += e5), t.filter(s => !xD(s)).reduce((s, r) => s + (JH.test(r) ? $H : r === "" ? t5 : n5), i)
}

function r5(n, e) {
   return n.length === e.length && n.slice(0, -1).every((i, s) => i === e[s]) ? n[n.length - 1] - e[e.length - 1] : 0
}

function a5(n, e, t = !1) {
   let {
      routesMeta: i
   } = n, s = {}, r = "/", a = [];
   for (let l = 0; l < i.length; ++l) {
      let c = i[l],
         h = l === i.length - 1,
         m = r === "/" ? e : e.slice(r.length) || "/",
         g = jb({
            path: c.relativePath,
            caseSensitive: c.caseSensitive,
            end: h
         }, m),
         v = c.route;
      if (!g && h && t && !i[i.length - 1].route.index && (g = jb({
            path: c.relativePath,
            caseSensitive: c.caseSensitive,
            end: !1
         }, m)), !g) return null;
      Object.assign(s, g.params), a.push({
         params: s,
         pathname: Cc([r, g.pathname]),
         pathnameBase: h5(Cc([r, g.pathnameBase])),
         route: v
      }), g.pathnameBase !== "/" && (r = Cc([r, g.pathnameBase]))
   }
   return a
}

function jb(n, e) {
   typeof n == "string" && (n = {
      path: n,
      caseSensitive: !1,
      end: !0
   });
   let [t, i] = o5(n.path, n.caseSensitive, n.end), s = e.match(t);
   if (!s) return null;
   let r = s[0],
      a = r.replace(/(.)\/+$/, "$1"),
      l = s.slice(1);
   return {
      params: i.reduce((h, {
         paramName: m,
         isOptional: g
      }, v) => {
         if (m === "*") {
            let S = l[v] || "";
            a = r.slice(0, r.length - S.length).replace(/(.)\/+$/, "$1")
         }
         const x = l[v];
         return g && !x ? h[m] = void 0 : h[m] = (x || "").replace(/%2F/g, "/"), h
      }, {}),
      pathname: r,
      pathnameBase: a,
      pattern: n
   }
}

function o5(n, e = !1, t = !0) {
   Fl(n === "*" || !n.endsWith("*") || n.endsWith("/*"), `Route path "${n}" will be treated as if it were "${n.replace(/\*$/,"/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${n.replace(/\*$/,"/*")}".`);
   let i = [],
      s = "^" + n.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (a, l, c) => (i.push({
         paramName: l,
         isOptional: c != null
      }), c ? "/?([^\\/]+)?" : "/([^\\/]+)"));
   return n.endsWith("*") ? (i.push({
      paramName: "*"
   }), s += n === "*" || n === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : t ? s += "\\/*$" : n !== "" && n !== "/" && (s += "(?:(?=\\/|$))"), [new RegExp(s, e ? void 0 : "i"), i]
}

function l5(n) {
   try {
      return n.split("/").map(e => decodeURIComponent(e).replace(/\//g, "%2F")).join("/")
   } catch (e) {
      return Fl(!1, `The URL path "${n}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${e}).`), n
   }
}

function Oc(n, e) {
   if (e === "/") return n;
   if (!n.toLowerCase().startsWith(e.toLowerCase())) return null;
   let t = e.endsWith("/") ? e.length - 1 : e.length,
      i = n.charAt(t);
   return i && i !== "/" ? null : n.slice(t) || "/"
}

function u5(n, e = "/") {
   let {
      pathname: t,
      search: i = "",
      hash: s = ""
   } = typeof n == "string" ? Cg(n) : n;
   return {
      pathname: t ? t.startsWith("/") ? t : c5(t, e) : e,
      search: d5(i),
      hash: p5(s)
   }
}

function c5(n, e) {
   let t = e.replace(/\/+$/, "").split("/");
   return n.split("/").forEach(s => {
      s === ".." ? t.length > 1 && t.pop() : s !== "." && t.push(s)
   }), t.length > 1 ? t.join("/") : "/"
}

function qE(n, e, t, i) {
   return `Cannot include a '${n}' character in a manually specified \`to.${e}\` field [${JSON.stringify(i)}].  Please separate it out to the \`to.${t}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.`
}

function f5(n) {
   return n.filter((e, t) => t === 0 || e.route.path && e.route.path.length > 0)
}

function cR(n) {
   let e = f5(n);
   return e.map((t, i) => i === e.length - 1 ? t.pathname : t.pathnameBase)
}

function fR(n, e, t, i = !1) {
   let s;
   typeof n == "string" ? s = Cg(n) : (s = {
      ...n
   }, Fi(!s.pathname || !s.pathname.includes("?"), qE("?", "pathname", "search", s)), Fi(!s.pathname || !s.pathname.includes("#"), qE("#", "pathname", "hash", s)), Fi(!s.search || !s.search.includes("#"), qE("#", "search", "hash", s)));
   let r = n === "" || s.pathname === "",
      a = r ? "/" : s.pathname,
      l;
   if (a == null) l = t;
   else {
      let g = e.length - 1;
      if (!i && a.startsWith("..")) {
         let v = a.split("/");
         for (; v[0] === "..";) v.shift(), g -= 1;
         s.pathname = v.join("/")
      }
      l = g >= 0 ? e[g] : "/"
   }
   let c = u5(s, l),
      h = a && a !== "/" && a.endsWith("/"),
      m = (r || a === ".") && t.endsWith("/");
   return !c.pathname.endsWith("/") && (h || m) && (c.pathname += "/"), c
}
var Cc = n => n.join("/").replace(/\/\/+/g, "/"),
   h5 = n => n.replace(/\/+$/, "").replace(/^\/*/, "/"),
   d5 = n => !n || n === "?" ? "" : n.startsWith("?") ? n : "?" + n,
   p5 = n => !n || n === "#" ? "" : n.startsWith("#") ? n : "#" + n;

function m5(n) {
   return n != null && typeof n.status == "number" && typeof n.statusText == "string" && typeof n.internal == "boolean" && "data" in n
}
var yP = ["POST", "PUT", "PATCH", "DELETE"];
new Set(yP);
var g5 = ["GET", ...yP];
new Set(g5);
var Dg = j.createContext(null);
Dg.displayName = "DataRouter";
var J1 = j.createContext(null);
J1.displayName = "DataRouterState";
var xP = j.createContext({
   isTransitioning: !1
});
xP.displayName = "ViewTransition";
var v5 = j.createContext(new Map);
v5.displayName = "Fetchers";
var y5 = j.createContext(null);
y5.displayName = "Await";
var Gl = j.createContext(null);
Gl.displayName = "Navigation";
var ux = j.createContext(null);
ux.displayName = "Location";
var kl = j.createContext({
   outlet: null,
   matches: [],
   isDataRoute: !1
});
kl.displayName = "Route";
var hR = j.createContext(null);
hR.displayName = "RouteError";

function x5(n, {
   relative: e
} = {}) {
   Fi(Ng(), "useHref() may be used only in the context of a <Router> component.");
   let {
      basename: t,
      navigator: i
   } = j.useContext(Gl), {
      hash: s,
      pathname: r,
      search: a
   } = cx(n, {
      relative: e
   }), l = r;
   return t !== "/" && (l = r === "/" ? t : Cc([t, r])), i.createHref({
      pathname: l,
      search: a,
      hash: s
   })
}

function Ng() {
   return j.useContext(ux) != null
}

function il() {
   return Fi(Ng(), "useLocation() may be used only in the context of a <Router> component."), j.useContext(ux).location
}
var _P = "You should call navigate() in a React.useEffect(), not when your component is first rendered.";

function SP(n) {
   j.useContext(Gl).static || j.useLayoutEffect(n)
}

function ju() {
   let {
      isDataRoute: n
   } = j.useContext(kl);
   return n ? O5() : _5()
}

function _5() {
   Fi(Ng(), "useNavigate() may be used only in the context of a <Router> component.");
   let n = j.useContext(Dg),
      {
         basename: e,
         navigator: t
      } = j.useContext(Gl),
      {
         matches: i
      } = j.useContext(kl),
      {
         pathname: s
      } = il(),
      r = JSON.stringify(cR(i)),
      a = j.useRef(!1);
   return SP(() => {
      a.current = !0
   }), j.useCallback((c, h = {}) => {
      if (Fl(a.current, _P), !a.current) return;
      if (typeof c == "number") {
         t.go(c);
         return
      }
      let m = fR(c, JSON.parse(r), s, h.relative === "path");
      n == null && e !== "/" && (m.pathname = m.pathname === "/" ? e : Cc([e, m.pathname])), (h.replace ? t.replace : t.push)(m, h.state, h)
   }, [e, t, r, s, n])
}
j.createContext(null);

function bP() {
   let {
      matches: n
   } = j.useContext(kl), e = n[n.length - 1];
   return e ? e.params : {}
}

function cx(n, {
   relative: e
} = {}) {
   let {
      matches: t
   } = j.useContext(kl), {
      pathname: i
   } = il(), s = JSON.stringify(cR(t));
   return j.useMemo(() => fR(n, JSON.parse(s), i, e === "path"), [n, s, i, e])
}

function S5(n, e) {
   return TP(n, e)
}

function TP(n, e, t, i) {
   var b;
   Fi(Ng(), "useRoutes() may be used only in the context of a <Router> component.");
   let {
      navigator: s
   } = j.useContext(Gl), {
      matches: r
   } = j.useContext(kl), a = r[r.length - 1], l = a ? a.params : {}, c = a ? a.pathname : "/", h = a ? a.pathnameBase : "/", m = a && a.route; {
      let w = m && m.path || "";
      EP(c, !m || w.endsWith("*") || w.endsWith("*?"), `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${c}" (under <Route path="${w}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${w}"> to <Route path="${w==="/"?"*":`${w}/*`}">.`)
   }
   let g = il(),
      v;
   if (e) {
      let w = typeof e == "string" ? Cg(e) : e;
      Fi(h === "/" || ((b = w.pathname) == null ? void 0 : b.startsWith(h)), `When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${h}" but pathname "${w.pathname}" was given in the \`location\` prop.`), v = w
   } else v = g;
   let x = v.pathname || "/",
      S = x;
   if (h !== "/") {
      let w = h.replace(/^\//, "").split("/");
      S = "/" + x.replace(/^\//, "").split("/").slice(w.length).join("/")
   }
   let E = mP(n, {
      pathname: S
   });
   Fl(m || E != null, `No routes matched location "${v.pathname}${v.search}${v.hash}" `), Fl(E == null || E[E.length - 1].route.element !== void 0 || E[E.length - 1].route.Component !== void 0 || E[E.length - 1].route.lazy !== void 0, `Matched leaf route at location "${v.pathname}${v.search}${v.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`);
   let T = A5(E && E.map(w => Object.assign({}, w, {
      params: Object.assign({}, l, w.params),
      pathname: Cc([h, s.encodeLocation ? s.encodeLocation(w.pathname).pathname : w.pathname]),
      pathnameBase: w.pathnameBase === "/" ? h : Cc([h, s.encodeLocation ? s.encodeLocation(w.pathnameBase).pathname : w.pathnameBase])
   })), r, t, i);
   return e && T ? j.createElement(ux.Provider, {
      value: {
         location: {
            pathname: "/",
            search: "",
            hash: "",
            state: null,
            key: "default",
            ...v
         },
         navigationType: "POP"
      }
   }, T) : T
}

function b5() {
   let n = N5(),
      e = m5(n) ? `${n.status} ${n.statusText}` : n instanceof Error ? n.message : JSON.stringify(n),
      t = n instanceof Error ? n.stack : null,
      i = "rgba(200,200,200, 0.5)",
      s = {
         padding: "0.5rem",
         backgroundColor: i
      },
      r = {
         padding: "2px 4px",
         backgroundColor: i
      },
      a = null;
   return console.error("Error handled by React Router default ErrorBoundary:", n), a = j.createElement(j.Fragment, null, j.createElement("p", null, " Hey developer "), j.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", j.createElement("code", {
      style: r
   }, "ErrorBoundary"), " or", " ", j.createElement("code", {
      style: r
   }, "errorElement"), " prop on your route.")), j.createElement(j.Fragment, null, j.createElement("h2", null, "Unexpected Application Error!"), j.createElement("h3", {
      style: {
         fontStyle: "italic"
      }
   }, e), t ? j.createElement("pre", {
      style: s
   }, t) : null, a)
}
var T5 = j.createElement(b5, null),
   E5 = class extends j.Component {
      constructor(n) {
         super(n), this.state = {
            location: n.location,
            revalidation: n.revalidation,
            error: n.error
         }
      }
      static getDerivedStateFromError(n) {
         return {
            error: n
         }
      }
      static getDerivedStateFromProps(n, e) {
         return e.location !== n.location || e.revalidation !== "idle" && n.revalidation === "idle" ? {
            error: n.error,
            location: n.location,
            revalidation: n.revalidation
         } : {
            error: n.error !== void 0 ? n.error : e.error,
            location: e.location,
            revalidation: n.revalidation || e.revalidation
         }
      }
      componentDidCatch(n, e) {
         console.error("React Router caught the following error during render", n, e)
      }
      render() {
         return this.state.error !== void 0 ? j.createElement(kl.Provider, {
            value: this.props.routeContext
         }, j.createElement(hR.Provider, {
            value: this.state.error,
            children: this.props.component
         })) : this.props.children
      }
   };

function M5({
   routeContext: n,
   match: e,
   children: t
}) {
   let i = j.useContext(Dg);
   return i && i.static && i.staticContext && (e.route.errorElement || e.route.ErrorBoundary) && (i.staticContext._deepestRenderedBoundaryId = e.route.id), j.createElement(kl.Provider, {
      value: n
   }, t)
}

function A5(n, e = [], t = null, i = null) {
   if (n == null) {
      if (!t) return null;
      if (t.errors) n = t.matches;
      else if (e.length === 0 && !t.initialized && t.matches.length > 0) n = t.matches;
      else return null
   }
   let s = n,
      r = t == null ? void 0 : t.errors;
   if (r != null) {
      let c = s.findIndex(h => h.route.id && (r == null ? void 0 : r[h.route.id]) !== void 0);
      Fi(c >= 0, `Could not find a matching route for errors on route IDs: ${Object.keys(r).join(",")}`), s = s.slice(0, Math.min(s.length, c + 1))
   }
   let a = !1,
      l = -1;
   if (t)
      for (let c = 0; c < s.length; c++) {
         let h = s[c];
         if ((h.route.HydrateFallback || h.route.hydrateFallbackElement) && (l = c), h.route.id) {
            let {
               loaderData: m,
               errors: g
            } = t, v = h.route.loader && !m.hasOwnProperty(h.route.id) && (!g || g[h.route.id] === void 0);
            if (h.route.lazy || v) {
               a = !0, l >= 0 ? s = s.slice(0, l + 1) : s = [s[0]];
               break
            }
         }
      }
   return s.reduceRight((c, h, m) => {
      let g, v = !1,
         x = null,
         S = null;
      t && (g = r && h.route.id ? r[h.route.id] : void 0, x = h.route.errorElement || T5, a && (l < 0 && m === 0 ? (EP("route-fallback", !1, "No `HydrateFallback` element provided to render during initial hydration"), v = !0, S = null) : l === m && (v = !0, S = h.route.hydrateFallbackElement || null)));
      let E = e.concat(s.slice(0, m + 1)),
         T = () => {
            let b;
            return g ? b = x : v ? b = S : h.route.Component ? b = j.createElement(h.route.Component, null) : h.route.element ? b = h.route.element : b = c, j.createElement(M5, {
               match: h,
               routeContext: {
                  outlet: c,
                  matches: E,
                  isDataRoute: t != null
               },
               children: b
            })
         };
      return t && (h.route.ErrorBoundary || h.route.errorElement || m === 0) ? j.createElement(E5, {
         location: t.location,
         revalidation: t.revalidation,
         component: x,
         error: g,
         children: T(),
         routeContext: {
            outlet: null,
            matches: E,
            isDataRoute: !0
         }
      }) : T()
   }, null)
}

function dR(n) {
   return `${n} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`
}

function w5(n) {
   let e = j.useContext(Dg);
   return Fi(e, dR(n)), e
}

function R5(n) {
   let e = j.useContext(J1);
   return Fi(e, dR(n)), e
}

function C5(n) {
   let e = j.useContext(kl);
   return Fi(e, dR(n)), e
}

function pR(n) {
   let e = C5(n),
      t = e.matches[e.matches.length - 1];
   return Fi(t.route.id, `${n} can only be used on routes that contain a unique "id"`), t.route.id
}

function D5() {
   return pR("useRouteId")
}

function N5() {
   var i;
   let n = j.useContext(hR),
      e = R5("useRouteError"),
      t = pR("useRouteError");
   return n !== void 0 ? n : (i = e.errors) == null ? void 0 : i[t]
}

function O5() {
   let {
      router: n
   } = w5("useNavigate"), e = pR("useNavigate"), t = j.useRef(!1);
   return SP(() => {
      t.current = !0
   }), j.useCallback(async (s, r = {}) => {
      Fl(t.current, _P), t.current && (typeof s == "number" ? n.navigate(s) : await n.navigate(s, {
         fromRouteId: e,
         ...r
      }))
   }, [n, e])
}
var _D = {};

function EP(n, e, t) {
   !e && !_D[n] && (_D[n] = !0, Fl(!1, t))
}
j.memo(U5);

function U5({
   routes: n,
   future: e,
   state: t
}) {
   return TP(n, void 0, t, e)
}

function zA({
   to: n,
   replace: e,
   state: t,
   relative: i
}) {
   Fi(Ng(), "<Navigate> may be used only in the context of a <Router> component.");
   let {
      static: s
   } = j.useContext(Gl);
   Fl(!s, "<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change.");
   let {
      matches: r
   } = j.useContext(kl), {
      pathname: a
   } = il(), l = ju(), c = fR(n, cR(r), a, i === "path"), h = JSON.stringify(c);
   return j.useEffect(() => {
      l(JSON.parse(h), {
         replace: e,
         state: t,
         relative: i
      })
   }, [l, h, i, e, t]), null
}

function jo(n) {
   Fi(!1, "A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.")
}

function P5({
   basename: n = "/",
   children: e = null,
   location: t,
   navigationType: i = "POP",
   navigator: s,
   static: r = !1
}) {
   Fi(!Ng(), "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.");
   let a = n.replace(/^\/*/, "/"),
      l = j.useMemo(() => ({
         basename: a,
         navigator: s,
         static: r,
         future: {}
      }), [a, s, r]);
   typeof t == "string" && (t = Cg(t));
   let {
      pathname: c = "/",
      search: h = "",
      hash: m = "",
      state: g = null,
      key: v = "default"
   } = t, x = j.useMemo(() => {
      let S = Oc(c, a);
      return S == null ? null : {
         location: {
            pathname: S,
            search: h,
            hash: m,
            state: g,
            key: v
         },
         navigationType: i
      }
   }, [a, c, h, m, g, v, i]);
   return Fl(x != null, `<Router basename="${a}"> is not able to match the URL "${c}${h}${m}" because it does not start with the basename, so the <Router> won't render anything.`), x == null ? null : j.createElement(Gl.Provider, {
      value: l
   }, j.createElement(ux.Provider, {
      children: e,
      value: x
   }))
}

function L5({
   children: n,
   location: e
}) {
   return S5(IA(n), e)
}

function IA(n, e = []) {
   let t = [];
   return j.Children.forEach(n, (i, s) => {
      if (!j.isValidElement(i)) return;
      let r = [...e, s];
      if (i.type === j.Fragment) {
         t.push.apply(t, IA(i.props.children, r));
         return
      }
      Fi(i.type === jo, `[${typeof i.type=="string"?i.type:i.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`), Fi(!i.props.index || !i.props.children, "An index route cannot have child routes.");
      let a = {
         id: i.props.id || r.join("-"),
         caseSensitive: i.props.caseSensitive,
         element: i.props.element,
         Component: i.props.Component,
         index: i.props.index,
         path: i.props.path,
         loader: i.props.loader,
         action: i.props.action,
         hydrateFallbackElement: i.props.hydrateFallbackElement,
         HydrateFallback: i.props.HydrateFallback,
         errorElement: i.props.errorElement,
         ErrorBoundary: i.props.ErrorBoundary,
         hasErrorBoundary: i.props.hasErrorBoundary === !0 || i.props.ErrorBoundary != null || i.props.errorElement != null,
         shouldRevalidate: i.props.shouldRevalidate,
         handle: i.props.handle,
         lazy: i.props.lazy
      };
      i.props.children && (a.children = IA(i.props.children, r)), t.push(a)
   }), t
}
var vb = "get",
   yb = "application/x-www-form-urlencoded";

function $1(n) {
   return n != null && typeof n.tagName == "string"
}

function B5(n) {
   return $1(n) && n.tagName.toLowerCase() === "button"
}

function z5(n) {
   return $1(n) && n.tagName.toLowerCase() === "form"
}

function I5(n) {
   return $1(n) && n.tagName.toLowerCase() === "input"
}

function F5(n) {
   return !!(n.metaKey || n.altKey || n.ctrlKey || n.shiftKey)
}

function H5(n, e) {
   return n.button === 0 && (!e || e === "_self") && !F5(n)
}
var rS = null;

function V5() {
   if (rS === null) try {
      new FormData(document.createElement("form"), 0), rS = !1
   } catch {
      rS = !0
   }
   return rS
}
var G5 = new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]);

function XE(n) {
   return n != null && !G5.has(n) ? (Fl(!1, `"${n}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${yb}"`), null) : n
}

function k5(n, e) {
   let t, i, s, r, a;
   if (z5(n)) {
      let l = n.getAttribute("action");
      i = l ? Oc(l, e) : null, t = n.getAttribute("method") || vb, s = XE(n.getAttribute("enctype")) || yb, r = new FormData(n)
   } else if (B5(n) || I5(n) && (n.type === "submit" || n.type === "image")) {
      let l = n.form;
      if (l == null) throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');
      let c = n.getAttribute("formaction") || l.getAttribute("action");
      if (i = c ? Oc(c, e) : null, t = n.getAttribute("formmethod") || l.getAttribute("method") || vb, s = XE(n.getAttribute("formenctype")) || XE(l.getAttribute("enctype")) || yb, r = new FormData(l, n), !V5()) {
         let {
            name: h,
            type: m,
            value: g
         } = n;
         if (m === "image") {
            let v = h ? `${h}.` : "";
            r.append(`${v}x`, "0"), r.append(`${v}y`, "0")
         } else h && r.append(h, g)
      }
   } else {
      if ($1(n)) throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');
      t = vb, i = null, s = yb, a = n
   }
   return r && s === "text/plain" && (a = r, r = void 0), {
      action: i,
      method: t.toLowerCase(),
      encType: s,
      formData: r,
      body: a
   }
}

function mR(n, e) {
   if (n === !1 || n === null || typeof n > "u") throw new Error(e)
}
async function j5(n, e) {
   if (n.id in e) return e[n.id];
   try {
      let t = await import(n.module);
      return e[n.id] = t, t
   } catch (t) {
      return console.error(`Error loading route module \`${n.module}\`, reloading page...`), console.error(t), window.__reactRouterContext && window.__reactRouterContext.isSpaMode, window.location.reload(), new Promise(() => {})
   }
}

function q5(n) {
   return n == null ? !1 : n.href == null ? n.rel === "preload" && typeof n.imageSrcSet == "string" && typeof n.imageSizes == "string" : typeof n.rel == "string" && typeof n.href == "string"
}
async function X5(n, e, t) {
   let i = await Promise.all(n.map(async s => {
      let r = e.routes[s.route.id];
      if (r) {
         let a = await j5(r, t);
         return a.links ? a.links() : []
      }
      return []
   }));
   return Z5(i.flat(1).filter(q5).filter(s => s.rel === "stylesheet" || s.rel === "preload").map(s => s.rel === "stylesheet" ? {
      ...s,
      rel: "prefetch",
      as: "style"
   } : {
      ...s,
      rel: "prefetch"
   }))
}

function SD(n, e, t, i, s, r) {
   let a = (c, h) => t[h] ? c.route.id !== t[h].route.id : !0,
      l = (c, h) => {
         var m;
         return t[h].pathname !== c.pathname || ((m = t[h].route.path) == null ? void 0 : m.endsWith("*")) && t[h].params["*"] !== c.params["*"]
      };
   return r === "assets" ? e.filter((c, h) => a(c, h) || l(c, h)) : r === "data" ? e.filter((c, h) => {
      var g;
      let m = i.routes[c.route.id];
      if (!m || !m.hasLoader) return !1;
      if (a(c, h) || l(c, h)) return !0;
      if (c.route.shouldRevalidate) {
         let v = c.route.shouldRevalidate({
            currentUrl: new URL(s.pathname + s.search + s.hash, window.origin),
            currentParams: ((g = t[0]) == null ? void 0 : g.params) || {},
            nextUrl: new URL(n, window.origin),
            nextParams: c.params,
            defaultShouldRevalidate: !0
         });
         if (typeof v == "boolean") return v
      }
      return !0
   }) : []
}

function W5(n, e, {
   includeHydrateFallback: t
} = {}) {
   return Y5(n.map(i => {
      let s = e.routes[i.route.id];
      if (!s) return [];
      let r = [s.module];
      return s.clientActionModule && (r = r.concat(s.clientActionModule)), s.clientLoaderModule && (r = r.concat(s.clientLoaderModule)), t && s.hydrateFallbackModule && (r = r.concat(s.hydrateFallbackModule)), s.imports && (r = r.concat(s.imports)), r
   }).flat(1))
}

function Y5(n) {
   return [...new Set(n)]
}

function K5(n) {
   let e = {},
      t = Object.keys(n).sort();
   for (let i of t) e[i] = n[i];
   return e
}

function Z5(n, e) {
   let t = new Set;
   return new Set(e), n.reduce((i, s) => {
      let r = JSON.stringify(K5(s));
      return t.has(r) || (t.add(r), i.push({
         key: r,
         link: s
      })), i
   }, [])
}
Object.getOwnPropertyNames(Object.prototype).sort().join("\0");
var Q5 = new Set([100, 101, 204, 205]);

function J5(n, e) {
   let t = typeof n == "string" ? new URL(n, typeof window > "u" ? "server://singlefetch/" : window.location.origin) : n;
   return t.pathname === "/" ? t.pathname = "_root.data" : e && Oc(t.pathname, e) === "/" ? t.pathname = `${e.replace(/\/$/,"")}/_root.data` : t.pathname = `${t.pathname.replace(/\/$/,"")}.data`, t
}

function MP() {
   let n = j.useContext(Dg);
   return mR(n, "You must render this element inside a <DataRouterContext.Provider> element"), n
}

function $5() {
   let n = j.useContext(J1);
   return mR(n, "You must render this element inside a <DataRouterStateContext.Provider> element"), n
}
var gR = j.createContext(void 0);
gR.displayName = "FrameworkContext";

function AP() {
   let n = j.useContext(gR);
   return mR(n, "You must render this element inside a <HydratedRouter> element"), n
}

function eV(n, e) {
   let t = j.useContext(gR),
      [i, s] = j.useState(!1),
      [r, a] = j.useState(!1),
      {
         onFocus: l,
         onBlur: c,
         onMouseEnter: h,
         onMouseLeave: m,
         onTouchStart: g
      } = e,
      v = j.useRef(null);
   j.useEffect(() => {
      if (n === "render" && a(!0), n === "viewport") {
         let E = b => {
               b.forEach(w => {
                  a(w.isIntersecting)
               })
            },
            T = new IntersectionObserver(E, {
               threshold: .5
            });
         return v.current && T.observe(v.current), () => {
            T.disconnect()
         }
      }
   }, [n]), j.useEffect(() => {
      if (i) {
         let E = setTimeout(() => {
            a(!0)
         }, 100);
         return () => {
            clearTimeout(E)
         }
      }
   }, [i]);
   let x = () => {
         s(!0)
      },
      S = () => {
         s(!1), a(!1)
      };
   return t ? n !== "intent" ? [r, v, {}] : [r, v, {
      onFocus: a0(l, x),
      onBlur: a0(c, S),
      onMouseEnter: a0(h, x),
      onMouseLeave: a0(m, S),
      onTouchStart: a0(g, x)
   }] : [!1, v, {}]
}

function a0(n, e) {
   return t => {
      n && n(t), t.defaultPrevented || e(t)
   }
}

function tV({
   page: n,
   ...e
}) {
   let {
      router: t
   } = MP(), i = j.useMemo(() => mP(t.routes, n, t.basename), [t.routes, n, t.basename]);
   return i ? j.createElement(iV, {
      page: n,
      matches: i,
      ...e
   }) : null
}

function nV(n) {
   let {
      manifest: e,
      routeModules: t
   } = AP(), [i, s] = j.useState([]);
   return j.useEffect(() => {
      let r = !1;
      return X5(n, e, t).then(a => {
         r || s(a)
      }), () => {
         r = !0
      }
   }, [n, e, t]), i
}

function iV({
   page: n,
   matches: e,
   ...t
}) {
   let i = il(),
      {
         manifest: s,
         routeModules: r
      } = AP(),
      {
         basename: a
      } = MP(),
      {
         loaderData: l,
         matches: c
      } = $5(),
      h = j.useMemo(() => SD(n, e, c, s, i, "data"), [n, e, c, s, i]),
      m = j.useMemo(() => SD(n, e, c, s, i, "assets"), [n, e, c, s, i]),
      g = j.useMemo(() => {
         if (n === i.pathname + i.search + i.hash) return [];
         let S = new Set,
            E = !1;
         if (e.forEach(b => {
               var C;
               let w = s.routes[b.route.id];
               !w || !w.hasLoader || (!h.some(N => N.route.id === b.route.id) && b.route.id in l && ((C = r[b.route.id]) != null && C.shouldRevalidate) || w.hasClientLoader ? E = !0 : S.add(b.route.id))
            }), S.size === 0) return [];
         let T = J5(n, a);
         return E && S.size > 0 && T.searchParams.set("_routes", e.filter(b => S.has(b.route.id)).map(b => b.route.id).join(",")), [T.pathname + T.search]
      }, [a, l, i, s, h, e, n, r]),
      v = j.useMemo(() => W5(m, s), [m, s]),
      x = nV(m);
   return j.createElement(j.Fragment, null, g.map(S => j.createElement("link", {
      key: S,
      rel: "prefetch",
      as: "fetch",
      href: S,
      ...t
   })), v.map(S => j.createElement("link", {
      key: S,
      rel: "modulepreload",
      href: S,
      ...t
   })), x.map(({
      key: S,
      link: E
   }) => j.createElement("link", {
      key: S,
      ...E
   })))
}

function sV(...n) {
   return e => {
      n.forEach(t => {
         typeof t == "function" ? t(e) : t != null && (t.current = e)
      })
   }
}
var wP = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
try {
   wP && (window.__reactRouterVersion = "7.6.3")
} catch {}

function rV({
   basename: n,
   children: e,
   window: t
}) {
   let i = j.useRef();
   i.current == null && (i.current = XH({
      window: t,
      v5Compat: !0
   }));
   let s = i.current,
      [r, a] = j.useState({
         action: s.action,
         location: s.location
      }),
      l = j.useCallback(c => {
         j.startTransition(() => a(c))
      }, [a]);
   return j.useLayoutEffect(() => s.listen(l), [s, l]), j.createElement(P5, {
      basename: n,
      children: e,
      location: r.location,
      navigationType: r.action,
      navigator: s
   })
}
var RP = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,
   CP = j.forwardRef(function ({
      onClick: e,
      discover: t = "render",
      prefetch: i = "none",
      relative: s,
      reloadDocument: r,
      replace: a,
      state: l,
      target: c,
      to: h,
      preventScrollReset: m,
      viewTransition: g,
      ...v
   }, x) {
      let {
         basename: S
      } = j.useContext(Gl), E = typeof h == "string" && RP.test(h), T, b = !1;
      if (typeof h == "string" && E && (T = h, wP)) try {
         let O = new URL(window.location.href),
            P = h.startsWith("//") ? new URL(O.protocol + h) : new URL(h),
            q = Oc(P.pathname, S);
         P.origin === O.origin && q != null ? h = q + P.search + P.hash : b = !0
      } catch {
         Fl(!1, `<Link to="${h}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`)
      }
      let w = x5(h, {
            relative: s
         }),
         [C, N, U] = eV(i, v),
         z = uV(h, {
            replace: a,
            state: l,
            target: c,
            preventScrollReset: m,
            relative: s,
            viewTransition: g
         });

      function B(O) {
         e && e(O), O.defaultPrevented || z(O)
      }
      let I = j.createElement("a", {
         ...v,
         ...U,
         href: T || w,
         onClick: b || r ? e : B,
         ref: sV(x, N),
         target: c,
         "data-discover": !E && t === "render" ? "true" : void 0
      });
      return C && !E ? j.createElement(j.Fragment, null, I, j.createElement(tV, {
         page: w
      })) : I
   });
CP.displayName = "Link";
var aV = j.forwardRef(function ({
   "aria-current": e = "page",
   caseSensitive: t = !1,
   className: i = "",
   end: s = !1,
   style: r,
   to: a,
   viewTransition: l,
   children: c,
   ...h
}, m) {
   let g = cx(a, {
         relative: h.relative
      }),
      v = il(),
      x = j.useContext(J1),
      {
         navigator: S,
         basename: E
      } = j.useContext(Gl),
      T = x != null && pV(g) && l === !0,
      b = S.encodeLocation ? S.encodeLocation(g).pathname : g.pathname,
      w = v.pathname,
      C = x && x.navigation && x.navigation.location ? x.navigation.location.pathname : null;
   t || (w = w.toLowerCase(), C = C ? C.toLowerCase() : null, b = b.toLowerCase()), C && E && (C = Oc(C, E) || C);
   const N = b !== "/" && b.endsWith("/") ? b.length - 1 : b.length;
   let U = w === b || !s && w.startsWith(b) && w.charAt(N) === "/",
      z = C != null && (C === b || !s && C.startsWith(b) && C.charAt(b.length) === "/"),
      B = {
         isActive: U,
         isPending: z,
         isTransitioning: T
      },
      I = U ? e : void 0,
      O;
   typeof i == "function" ? O = i(B) : O = [i, U ? "active" : null, z ? "pending" : null, T ? "transitioning" : null].filter(Boolean).join(" ");
   let P = typeof r == "function" ? r(B) : r;
   return j.createElement(CP, {
      ...h,
      "aria-current": I,
      className: O,
      ref: m,
      style: P,
      to: a,
      viewTransition: l
   }, typeof c == "function" ? c(B) : c)
});
aV.displayName = "NavLink";
var oV = j.forwardRef(({
   discover: n = "render",
   fetcherKey: e,
   navigate: t,
   reloadDocument: i,
   replace: s,
   state: r,
   method: a = vb,
   action: l,
   onSubmit: c,
   relative: h,
   preventScrollReset: m,
   viewTransition: g,
   ...v
}, x) => {
   let S = hV(),
      E = dV(l, {
         relative: h
      }),
      T = a.toLowerCase() === "get" ? "get" : "post",
      b = typeof l == "string" && RP.test(l),
      w = C => {
         if (c && c(C), C.defaultPrevented) return;
         C.preventDefault();
         let N = C.nativeEvent.submitter,
            U = (N == null ? void 0 : N.getAttribute("formmethod")) || a;
         S(N || C.currentTarget, {
            fetcherKey: e,
            method: U,
            navigate: t,
            replace: s,
            state: r,
            relative: h,
            preventScrollReset: m,
            viewTransition: g
         })
      };
   return j.createElement("form", {
      ref: x,
      method: T,
      action: E,
      onSubmit: i ? c : w,
      ...v,
      "data-discover": !b && n === "render" ? "true" : void 0
   })
});
oV.displayName = "Form";

function lV(n) {
   return `${n} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.`
}

function DP(n) {
   let e = j.useContext(Dg);
   return Fi(e, lV(n)), e
}

function uV(n, {
   target: e,
   replace: t,
   state: i,
   preventScrollReset: s,
   relative: r,
   viewTransition: a
} = {}) {
   let l = ju(),
      c = il(),
      h = cx(n, {
         relative: r
      });
   return j.useCallback(m => {
      if (H5(m, e)) {
         m.preventDefault();
         let g = t !== void 0 ? t : my(c) === my(h);
         l(n, {
            replace: g,
            state: i,
            preventScrollReset: s,
            relative: r,
            viewTransition: a
         })
      }
   }, [c, l, h, t, i, e, n, s, r, a])
}
var cV = 0,
   fV = () => `__${String(++cV)}__`;

function hV() {
   let {
      router: n
   } = DP("useSubmit"), {
      basename: e
   } = j.useContext(Gl), t = D5();
   return j.useCallback(async (i, s = {}) => {
      let {
         action: r,
         method: a,
         encType: l,
         formData: c,
         body: h
      } = k5(i, e);
      if (s.navigate === !1) {
         let m = s.fetcherKey || fV();
         await n.fetch(m, t, s.action || r, {
            preventScrollReset: s.preventScrollReset,
            formData: c,
            body: h,
            formMethod: s.method || a,
            formEncType: s.encType || l,
            flushSync: s.flushSync
         })
      } else await n.navigate(s.action || r, {
         preventScrollReset: s.preventScrollReset,
         formData: c,
         body: h,
         formMethod: s.method || a,
         formEncType: s.encType || l,
         replace: s.replace,
         state: s.state,
         fromRouteId: t,
         flushSync: s.flushSync,
         viewTransition: s.viewTransition
      })
   }, [n, e, t])
}

function dV(n, {
   relative: e
} = {}) {
   let {
      basename: t
   } = j.useContext(Gl), i = j.useContext(kl);
   Fi(i, "useFormAction must be used inside a RouteContext");
   let [s] = i.matches.slice(-1), r = {
      ...cx(n || ".", {
         relative: e
      })
   }, a = il();
   if (n == null) {
      r.search = a.search;
      let l = new URLSearchParams(r.search),
         c = l.getAll("index");
      if (c.some(m => m === "")) {
         l.delete("index"), c.filter(g => g).forEach(g => l.append("index", g));
         let m = l.toString();
         r.search = m ? `?${m}` : ""
      }
   }
   return (!n || n === ".") && s.route.index && (r.search = r.search ? r.search.replace(/^\?/, "?index&") : "?index"), t !== "/" && (r.pathname = r.pathname === "/" ? t : Cc([t, r.pathname])), my(r)
}

function pV(n, e = {}) {
   let t = j.useContext(xP);
   Fi(t != null, "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?");
   let {
      basename: i
   } = DP("useViewTransitionState"), s = cx(n, {
      relative: e.relative
   });
   if (!t.isTransitioning) return !1;
   let r = Oc(t.currentLocation.pathname, i) || t.currentLocation.pathname,
      a = Oc(t.nextLocation.pathname, i) || t.nextLocation.pathname;
   return jb(s.pathname, a) != null || jb(s.pathname, r) != null
} [...Q5];
var mV = pP();

function gy() {
   return gy = Object.assign ? Object.assign.bind() : function (n) {
      for (var e = 1; e < arguments.length; e++) {
         var t = arguments[e];
         for (var i in t)({}).hasOwnProperty.call(t, i) && (n[i] = t[i])
      }
      return n
   }, gy.apply(null, arguments)
}

function gV(n, e) {
   if (n == null) return {};
   var t = {};
   for (var i in n)
      if ({}.hasOwnProperty.call(n, i)) {
         if (e.indexOf(i) !== -1) continue;
         t[i] = n[i]
      } return t
}

function FA(n, e) {
   return FA = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, i) {
      return t.__proto__ = i, t
   }, FA(n, e)
}

function NP(n, e) {
   n.prototype = Object.create(e.prototype), n.prototype.constructor = n, FA(n, e)
}

function vV(n) {
   if (n === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
   return n
}
var OP = j.createContext(null),
   yV = OP.Consumer,
   xV = OP.Provider,
   UP = function (n) {
      NP(e, n);

      function e() {
         for (var i, s = arguments.length, r = new Array(s), a = 0; a < s; a++) r[a] = arguments[a];
         return i = n.call.apply(n, [this].concat(r)) || this, i.state = {
            canUseDOM: !1
         }, i.headTags = null, i.index = -1, i
      }
      var t = e.prototype;
      return t.componentDidMount = function () {
         var s = this.props,
            r = s.tag,
            a = s.name,
            l = s.property;
         this.setState({
            canUseDOM: !0
         }), this.index = this.headTags.addClientTag(r, a || l)
      }, t.componentWillUnmount = function () {
         var s = this.props.tag;
         this.headTags.removeClientTag(s, this.index)
      }, t.render = function () {
         var s = this,
            r = this.props,
            a = r.tag,
            l = gV(r, ["tag"]),
            c = this.state.canUseDOM;
         return j.createElement(yV, null, function (h) {
            if (h == null) throw Error("<HeadProvider /> should be in the tree");
            if (s.headTags = h, c) {
               if (!h.shouldRenderTag(a, s.index)) return null;
               var m = j.createElement(a, l);
               return mV.createPortal(m, document.head)
            }
            var g = j.createElement(a, gy({
               "data-rh": ""
            }, l));
            return h.addServerTag(g), null
         })
      }, e
   }(j.Component),
   WE = ["title", "meta"],
   _V = function (n) {
      NP(e, n);

      function e() {
         for (var i, s = arguments.length, r = new Array(s), a = 0; a < s; a++) r[a] = arguments[a];
         return i = n.call.apply(n, [this].concat(r)) || this, i.indices = new Map, i.state = {
            addClientTag: function (c, h) {
               if (WE.indexOf(c) !== -1) {
                  i.setState(function (x) {
                     var S, E = x[c] || [];
                     return S = {}, S[c] = [].concat(E, [h]), S
                  });
                  var m = vV(i),
                     g = m.indices,
                     v = g.has(c) ? g.get(c) + 1 : 0;
                  return g.set(c, v), v
               }
               return -1
            },
            shouldRenderTag: function (c, h) {
               if (WE.indexOf(c) !== -1) {
                  var m = i.state[c];
                  return m && m.lastIndexOf(m[h]) === h
               }
               return !0
            },
            removeClientTag: function (c, h) {
               i.setState(function (m) {
                  var g = m[c];
                  if (g) {
                     var v;
                     return g[h] = null, v = {}, v[c] = g, v
                  }
                  return null
               })
            },
            addServerTag: function (c) {
               var h = i.props.headTags,
                  m = h === void 0 ? [] : h;
               if (WE.indexOf(c.type) !== -1) {
                  var g = m.findIndex(function (v) {
                     var x = v.props.name || v.props.property,
                        S = c.props.name || c.props.property;
                     return v.type === c.type && x === S
                  });
                  g !== -1 && m.splice(g, 1)
               }
               m.push(c)
            }
         }, i
      }
      var t = e.prototype;
      return t.componentDidMount = function () {
         var s = document.head.querySelectorAll('[data-rh=""]');
         Array.prototype.forEach.call(s, function (r) {
            return r.parentNode.removeChild(r)
         })
      }, t.render = function () {
         var s = this.props,
            r = s.headTags,
            a = s.children;
         if (typeof window > "u" && Array.isArray(r) === !1) throw Error("headTags array should be passed to <HeadProvider /> in node");
         return j.createElement(xV, {
            value: this.state
         }, a)
      }, e
   }(j.Component),
   SV = function (e) {
      return j.createElement(UP, gy({
         tag: "title"
      }, e))
   },
   bV = function (e) {
      return j.createElement(UP, gy({
         tag: "meta"
      }, e))
   };
/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const Og = "175",
   TV = {
      LEFT: 0,
      MIDDLE: 1,
      RIGHT: 2,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2
   },
   EV = {
      ROTATE: 0,
      PAN: 1,
      DOLLY_PAN: 2,
      DOLLY_ROTATE: 3
   },
   PP = 0,
   HA = 1,
   LP = 2,
   MV = 3,
   BP = 0,
   eT = 1,
   I0 = 2,
   Pl = 3,
   Hu = 0,
   Ds = 1,
   Ua = 2,
   nr = 0,
   Fd = 1,
   VA = 2,
   GA = 3,
   kA = 4,
   zP = 5,
   jf = 100,
   IP = 101,
   FP = 102,
   HP = 103,
   VP = 104,
   GP = 200,
   kP = 201,
   jP = 202,
   qP = 203,
   qb = 204,
   Xb = 205,
   XP = 206,
   WP = 207,
   YP = 208,
   KP = 209,
   ZP = 210,
   QP = 211,
   JP = 212,
   $P = 213,
   eL = 214,
   vy = 0,
   yy = 1,
   ug = 2,
   ih = 3,
   xy = 4,
   _y = 5,
   Sy = 6,
   by = 7,
   fx = 0,
   tL = 1,
   nL = 2,
   ho = 0,
   iL = 1,
   sL = 2,
   rL = 3,
   vR = 4,
   aL = 5,
   oL = 6,
   lL = 7,
   jA = "attached",
   uL = "detached",
   tT = 300,
   Uc = 301,
   sh = 302,
   Ty = 303,
   Ey = 304,
   Ug = 306,
   My = 1e3,
   Ko = 1001,
   Ay = 1002,
   ms = 1003,
   yR = 1004,
   AV = 1004,
   Gm = 1005,
   wV = 1005,
   Ni = 1006,
   F0 = 1007,
   RV = 1007,
   Du = 1008,
   CV = 1008,
   qs = 1009,
   xR = 1010,
   _R = 1011,
   cg = 1012,
   nT = 1013,
   Vu = 1014,
   ha = 1015,
   lp = 1016,
   iT = 1017,
   sT = 1018,
   Jd = 1020,
   SR = 35902,
   bR = 1021,
   TR = 1022,
   Lr = 1023,
   ER = 1024,
   MR = 1025,
   fg = 1026,
   $d = 1027,
   rT = 1028,
   hx = 1029,
   AR = 1030,
   aT = 1031,
   DV = 1032,
   oT = 1033,
   H0 = 33776,
   V0 = 33777,
   G0 = 33778,
   k0 = 33779,
   Wb = 35840,
   Yb = 35841,
   Kb = 35842,
   Zb = 35843,
   Qb = 36196,
   Jb = 37492,
   $b = 37496,
   e1 = 37808,
   t1 = 37809,
   n1 = 37810,
   i1 = 37811,
   s1 = 37812,
   r1 = 37813,
   a1 = 37814,
   o1 = 37815,
   l1 = 37816,
   u1 = 37817,
   c1 = 37818,
   f1 = 37819,
   h1 = 37820,
   d1 = 37821,
   j0 = 36492,
   p1 = 36494,
   m1 = 36495,
   wR = 36283,
   g1 = 36284,
   v1 = 36285,
   y1 = 36286,
   cL = 2200,
   fL = 2201,
   hL = 2202,
   wy = 2300,
   x1 = 2301,
   xb = 2302,
   Dd = 2400,
   Nd = 2401,
   Ry = 2402,
   lT = 2500,
   RR = 2501,
   NV = 0,
   OV = 1,
   UV = 2,
   Hl = 3200,
   dL = 3201,
   PV = 3202,
   LV = 3203,
   fh = 0,
   pL = 1,
   Bl = "",
   En = "srgb",
   Gu = "srgb-linear",
   Cy = "linear",
   di = "srgb",
   BV = 0,
   Td = 7680,
   zV = 7681,
   IV = 7682,
   FV = 7683,
   HV = 34055,
   VV = 34056,
   GV = 5386,
   kV = 512,
   jV = 513,
   qV = 514,
   XV = 515,
   WV = 516,
   YV = 517,
   KV = 518,
   qA = 519,
   mL = 512,
   gL = 513,
   vL = 514,
   CR = 515,
   yL = 516,
   xL = 517,
   _L = 518,
   SL = 519,
   Dy = 35044,
   ZV = 35048,
   QV = 35040,
   JV = 35045,
   $V = 35049,
   e6 = 35041,
   t6 = 35046,
   n6 = 35050,
   i6 = 35042,
   s6 = "100",
   XA = "300 es",
   zl = 2e3,
   Ny = 2001,
   r6 = {
      COMPUTE: "compute",
      RENDER: "render"
   };
class xo {
   addEventListener(e, t) {
      this._listeners === void 0 && (this._listeners = {});
      const i = this._listeners;
      i[e] === void 0 && (i[e] = []), i[e].indexOf(t) === -1 && i[e].push(t)
   }
   hasEventListener(e, t) {
      const i = this._listeners;
      return i === void 0 ? !1 : i[e] !== void 0 && i[e].indexOf(t) !== -1
   }
   removeEventListener(e, t) {
      const i = this._listeners;
      if (i === void 0) return;
      const s = i[e];
      if (s !== void 0) {
         const r = s.indexOf(t);
         r !== -1 && s.splice(r, 1)
      }
   }
   dispatchEvent(e) {
      const t = this._listeners;
      if (t === void 0) return;
      const i = t[e.type];
      if (i !== void 0) {
         e.target = this;
         const s = i.slice(0);
         for (let r = 0, a = s.length; r < a; r++) s[r].call(this, e);
         e.target = null
      }
   }
}
const wr = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let bD = 1234567;
const Hd = Math.PI / 180,
   hg = 180 / Math.PI;

function po() {
   const n = Math.random() * 4294967295 | 0,
      e = Math.random() * 4294967295 | 0,
      t = Math.random() * 4294967295 | 0,
      i = Math.random() * 4294967295 | 0;
   return (wr[n & 255] + wr[n >> 8 & 255] + wr[n >> 16 & 255] + wr[n >> 24 & 255] + "-" + wr[e & 255] + wr[e >> 8 & 255] + "-" + wr[e >> 16 & 15 | 64] + wr[e >> 24 & 255] + "-" + wr[t & 63 | 128] + wr[t >> 8 & 255] + "-" + wr[t >> 16 & 255] + wr[t >> 24 & 255] + wr[i & 255] + wr[i >> 8 & 255] + wr[i >> 16 & 255] + wr[i >> 24 & 255]).toLowerCase()
}

function on(n, e, t) {
   return Math.max(e, Math.min(t, n))
}

function DR(n, e) {
   return (n % e + e) % e
}

function a6(n, e, t, i, s) {
   return i + (n - e) * (s - i) / (t - e)
}

function o6(n, e, t) {
   return n !== e ? (t - n) / (e - n) : 0
}

function q0(n, e, t) {
   return (1 - t) * n + t * e
}

function l6(n, e, t, i) {
   return q0(n, e, 1 - Math.exp(-t * i))
}

function u6(n, e = 1) {
   return e - Math.abs(DR(n, e * 2) - e)
}

function c6(n, e, t) {
   return n <= e ? 0 : n >= t ? 1 : (n = (n - e) / (t - e), n * n * (3 - 2 * n))
}

function f6(n, e, t) {
   return n <= e ? 0 : n >= t ? 1 : (n = (n - e) / (t - e), n * n * n * (n * (n * 6 - 15) + 10))
}

function h6(n, e) {
   return n + Math.floor(Math.random() * (e - n + 1))
}

function d6(n, e) {
   return n + Math.random() * (e - n)
}

function p6(n) {
   return n * (.5 - Math.random())
}

function m6(n) {
   n !== void 0 && (bD = n);
   let e = bD += 1831565813;
   return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296
}

function g6(n) {
   return n * Hd
}

function v6(n) {
   return n * hg
}

function y6(n) {
   return (n & n - 1) === 0 && n !== 0
}

function x6(n) {
   return Math.pow(2, Math.ceil(Math.log(n) / Math.LN2))
}

function _6(n) {
   return Math.pow(2, Math.floor(Math.log(n) / Math.LN2))
}

function S6(n, e, t, i, s) {
   const r = Math.cos,
      a = Math.sin,
      l = r(t / 2),
      c = a(t / 2),
      h = r((e + i) / 2),
      m = a((e + i) / 2),
      g = r((e - i) / 2),
      v = a((e - i) / 2),
      x = r((i - e) / 2),
      S = a((i - e) / 2);
   switch (s) {
      case "XYX":
         n.set(l * m, c * g, c * v, l * h);
         break;
      case "YZY":
         n.set(c * v, l * m, c * g, l * h);
         break;
      case "ZXZ":
         n.set(c * g, c * v, l * m, l * h);
         break;
      case "XZX":
         n.set(l * m, c * S, c * x, l * h);
         break;
      case "YXY":
         n.set(c * x, l * m, c * S, l * h);
         break;
      case "ZYZ":
         n.set(c * S, c * x, l * m, l * h);
         break;
      default:
         console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + s)
   }
}

function ua(n, e) {
   switch (e.constructor) {
      case Float32Array:
         return n;
      case Uint32Array:
         return n / 4294967295;
      case Uint16Array:
         return n / 65535;
      case Uint8Array:
         return n / 255;
      case Int32Array:
         return Math.max(n / 2147483647, -1);
      case Int16Array:
         return Math.max(n / 32767, -1);
      case Int8Array:
         return Math.max(n / 127, -1);
      default:
         throw new Error("Invalid component type.")
   }
}

function hn(n, e) {
   switch (e.constructor) {
      case Float32Array:
         return n;
      case Uint32Array:
         return Math.round(n * 4294967295);
      case Uint16Array:
         return Math.round(n * 65535);
      case Uint8Array:
         return Math.round(n * 255);
      case Int32Array:
         return Math.round(n * 2147483647);
      case Int16Array:
         return Math.round(n * 32767);
      case Int8Array:
         return Math.round(n * 127);
      default:
         throw new Error("Invalid component type.")
   }
}
const bL = {
   DEG2RAD: Hd,
   RAD2DEG: hg,
   generateUUID: po,
   clamp: on,
   euclideanModulo: DR,
   mapLinear: a6,
   inverseLerp: o6,
   lerp: q0,
   damp: l6,
   pingpong: u6,
   smoothstep: c6,
   smootherstep: f6,
   randInt: h6,
   randFloat: d6,
   randFloatSpread: p6,
   seededRandom: m6,
   degToRad: g6,
   radToDeg: v6,
   isPowerOfTwo: y6,
   ceilPowerOfTwo: x6,
   floorPowerOfTwo: _6,
   setQuaternionFromProperEuler: S6,
   normalize: hn,
   denormalize: ua
};
class Fe {
   constructor(e = 0, t = 0) {
      Fe.prototype.isVector2 = !0, this.x = e, this.y = t
   }
   get width() {
      return this.x
   }
   set width(e) {
      this.x = e
   }
   get height() {
      return this.y
   }
   set height(e) {
      this.y = e
   }
   set(e, t) {
      return this.x = e, this.y = t, this
   }
   setScalar(e) {
      return this.x = e, this.y = e, this
   }
   setX(e) {
      return this.x = e, this
   }
   setY(e) {
      return this.y = e, this
   }
   setComponent(e, t) {
      switch (e) {
         case 0:
            this.x = t;
            break;
         case 1:
            this.y = t;
            break;
         default:
            throw new Error("index is out of range: " + e)
      }
      return this
   }
   getComponent(e) {
      switch (e) {
         case 0:
            return this.x;
         case 1:
            return this.y;
         default:
            throw new Error("index is out of range: " + e)
      }
   }
   clone() {
      return new this.constructor(this.x, this.y)
   }
   copy(e) {
      return this.x = e.x, this.y = e.y, this
   }
   add(e) {
      return this.x += e.x, this.y += e.y, this
   }
   addScalar(e) {
      return this.x += e, this.y += e, this
   }
   addVectors(e, t) {
      return this.x = e.x + t.x, this.y = e.y + t.y, this
   }
   addScaledVector(e, t) {
      return this.x += e.x * t, this.y += e.y * t, this
   }
   sub(e) {
      return this.x -= e.x, this.y -= e.y, this
   }
   subScalar(e) {
      return this.x -= e, this.y -= e, this
   }
   subVectors(e, t) {
      return this.x = e.x - t.x, this.y = e.y - t.y, this
   }
   multiply(e) {
      return this.x *= e.x, this.y *= e.y, this
   }
   multiplyScalar(e) {
      return this.x *= e, this.y *= e, this
   }
   divide(e) {
      return this.x /= e.x, this.y /= e.y, this
   }
   divideScalar(e) {
      return this.multiplyScalar(1 / e)
   }
   applyMatrix3(e) {
      const t = this.x,
         i = this.y,
         s = e.elements;
      return this.x = s[0] * t + s[3] * i + s[6], this.y = s[1] * t + s[4] * i + s[7], this
   }
   min(e) {
      return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
   }
   max(e) {
      return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
   }
   clamp(e, t) {
      return this.x = on(this.x, e.x, t.x), this.y = on(this.y, e.y, t.y), this
   }
   clampScalar(e, t) {
      return this.x = on(this.x, e, t), this.y = on(this.y, e, t), this
   }
   clampLength(e, t) {
      const i = this.length();
      return this.divideScalar(i || 1).multiplyScalar(on(i, e, t))
   }
   floor() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
   }
   ceil() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
   }
   round() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this
   }
   roundToZero() {
      return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this
   }
   negate() {
      return this.x = -this.x, this.y = -this.y, this
   }
   dot(e) {
      return this.x * e.x + this.y * e.y
   }
   cross(e) {
      return this.x * e.y - this.y * e.x
   }
   lengthSq() {
      return this.x * this.x + this.y * this.y
   }
   length() {
      return Math.sqrt(this.x * this.x + this.y * this.y)
   }
   manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y)
   }
   normalize() {
      return this.divideScalar(this.length() || 1)
   }
   angle() {
      return Math.atan2(-this.y, -this.x) + Math.PI
   }
   angleTo(e) {
      const t = Math.sqrt(this.lengthSq() * e.lengthSq());
      if (t === 0) return Math.PI / 2;
      const i = this.dot(e) / t;
      return Math.acos(on(i, -1, 1))
   }
   distanceTo(e) {
      return Math.sqrt(this.distanceToSquared(e))
   }
   distanceToSquared(e) {
      const t = this.x - e.x,
         i = this.y - e.y;
      return t * t + i * i
   }
   manhattanDistanceTo(e) {
      return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
   }
   setLength(e) {
      return this.normalize().multiplyScalar(e)
   }
   lerp(e, t) {
      return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
   }
   lerpVectors(e, t, i) {
      return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this
   }
   equals(e) {
      return e.x === this.x && e.y === this.y
   }
   fromArray(e, t = 0) {
      return this.x = e[t], this.y = e[t + 1], this
   }
   toArray(e = [], t = 0) {
      return e[t] = this.x, e[t + 1] = this.y, e
   }
   fromBufferAttribute(e, t) {
      return this.x = e.getX(t), this.y = e.getY(t), this
   }
   rotateAround(e, t) {
      const i = Math.cos(t),
         s = Math.sin(t),
         r = this.x - e.x,
         a = this.y - e.y;
      return this.x = r * i - a * s + e.x, this.y = r * s + a * i + e.y, this
   }
   random() {
      return this.x = Math.random(), this.y = Math.random(), this
   }*[Symbol.iterator]() {
      yield this.x, yield this.y
   }
}
class un {
   constructor(e, t, i, s, r, a, l, c, h) {
      un.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], e !== void 0 && this.set(e, t, i, s, r, a, l, c, h)
   }
   set(e, t, i, s, r, a, l, c, h) {
      const m = this.elements;
      return m[0] = e, m[1] = s, m[2] = l, m[3] = t, m[4] = r, m[5] = c, m[6] = i, m[7] = a, m[8] = h, this
   }
   identity() {
      return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
   }
   copy(e) {
      const t = this.elements,
         i = e.elements;
      return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], this
   }
   extractBasis(e, t, i) {
      return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), i.setFromMatrix3Column(this, 2), this
   }
   setFromMatrix4(e) {
      const t = e.elements;
      return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
   }
   multiply(e) {
      return this.multiplyMatrices(this, e)
   }
   premultiply(e) {
      return this.multiplyMatrices(e, this)
   }
   multiplyMatrices(e, t) {
      const i = e.elements,
         s = t.elements,
         r = this.elements,
         a = i[0],
         l = i[3],
         c = i[6],
         h = i[1],
         m = i[4],
         g = i[7],
         v = i[2],
         x = i[5],
         S = i[8],
         E = s[0],
         T = s[3],
         b = s[6],
         w = s[1],
         C = s[4],
         N = s[7],
         U = s[2],
         z = s[5],
         B = s[8];
      return r[0] = a * E + l * w + c * U, r[3] = a * T + l * C + c * z, r[6] = a * b + l * N + c * B, r[1] = h * E + m * w + g * U, r[4] = h * T + m * C + g * z, r[7] = h * b + m * N + g * B, r[2] = v * E + x * w + S * U, r[5] = v * T + x * C + S * z, r[8] = v * b + x * N + S * B, this
   }
   multiplyScalar(e) {
      const t = this.elements;
      return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
   }
   determinant() {
      const e = this.elements,
         t = e[0],
         i = e[1],
         s = e[2],
         r = e[3],
         a = e[4],
         l = e[5],
         c = e[6],
         h = e[7],
         m = e[8];
      return t * a * m - t * l * h - i * r * m + i * l * c + s * r * h - s * a * c
   }
   invert() {
      const e = this.elements,
         t = e[0],
         i = e[1],
         s = e[2],
         r = e[3],
         a = e[4],
         l = e[5],
         c = e[6],
         h = e[7],
         m = e[8],
         g = m * a - l * h,
         v = l * c - m * r,
         x = h * r - a * c,
         S = t * g + i * v + s * x;
      if (S === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
      const E = 1 / S;
      return e[0] = g * E, e[1] = (s * h - m * i) * E, e[2] = (l * i - s * a) * E, e[3] = v * E, e[4] = (m * t - s * c) * E, e[5] = (s * r - l * t) * E, e[6] = x * E, e[7] = (i * c - h * t) * E, e[8] = (a * t - i * r) * E, this
   }
   transpose() {
      let e;
      const t = this.elements;
      return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
   }
   getNormalMatrix(e) {
      return this.setFromMatrix4(e).invert().transpose()
   }
   transposeIntoArray(e) {
      const t = this.elements;
      return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
   }
   setUvTransform(e, t, i, s, r, a, l) {
      const c = Math.cos(r),
         h = Math.sin(r);
      return this.set(i * c, i * h, -i * (c * a + h * l) + a + e, -s * h, s * c, -s * (-h * a + c * l) + l + t, 0, 0, 1), this
   }
   scale(e, t) {
      return this.premultiply(YE.makeScale(e, t)), this
   }
   rotate(e) {
      return this.premultiply(YE.makeRotation(-e)), this
   }
   translate(e, t) {
      return this.premultiply(YE.makeTranslation(e, t)), this
   }
   makeTranslation(e, t) {
      return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1), this
   }
   makeRotation(e) {
      const t = Math.cos(e),
         i = Math.sin(e);
      return this.set(t, -i, 0, i, t, 0, 0, 0, 1), this
   }
   makeScale(e, t) {
      return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this
   }
   equals(e) {
      const t = this.elements,
         i = e.elements;
      for (let s = 0; s < 9; s++)
         if (t[s] !== i[s]) return !1;
      return !0
   }
   fromArray(e, t = 0) {
      for (let i = 0; i < 9; i++) this.elements[i] = e[i + t];
      return this
   }
   toArray(e = [], t = 0) {
      const i = this.elements;
      return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e
   }
   clone() {
      return new this.constructor().fromArray(this.elements)
   }
}
const YE = new un;

function TL(n) {
   for (let e = n.length - 1; e >= 0; --e)
      if (n[e] >= 65535) return !0;
   return !1
}
const b6 = {
   Int8Array,
   Uint8Array,
   Uint8ClampedArray,
   Int16Array,
   Uint16Array,
   Int32Array,
   Uint32Array,
   Float32Array,
   Float64Array
};

function km(n, e) {
   return new b6[n](e)
}

function Oy(n) {
   return document.createElementNS("http://www.w3.org/1999/xhtml", n)
}

function EL() {
   const n = Oy("canvas");
   return n.style.display = "block", n
}
const TD = {};

function _b(n) {
   n in TD || (TD[n] = !0, console.warn(n))
}

function T6(n, e, t) {
   return new Promise(function (i, s) {
      function r() {
         switch (n.clientWaitSync(e, n.SYNC_FLUSH_COMMANDS_BIT, 0)) {
            case n.WAIT_FAILED:
               s();
               break;
            case n.TIMEOUT_EXPIRED:
               setTimeout(r, t);
               break;
            default:
               i()
         }
      }
      setTimeout(r, t)
   })
}

function E6(n) {
   const e = n.elements;
   e[2] = .5 * e[2] + .5 * e[3], e[6] = .5 * e[6] + .5 * e[7], e[10] = .5 * e[10] + .5 * e[11], e[14] = .5 * e[14] + .5 * e[15]
}

function M6(n) {
   const e = n.elements;
   e[11] === -1 ? (e[10] = -e[10] - 1, e[14] = -e[14]) : (e[10] = -e[10], e[14] = -e[14] + 1)
}
const ED = new un().set(.4123908, .3575843, .1804808, .212639, .7151687, .0721923, .0193308, .1191948, .9505322),
   MD = new un().set(3.2409699, -1.5373832, -.4986108, -.9692436, 1.8759675, .0415551, .0556301, -.203977, 1.0569715);

function A6() {
   const n = {
         enabled: !0,
         workingColorSpace: Gu,
         spaces: {},
         convert: function (s, r, a) {
            return this.enabled === !1 || r === a || !r || !a || (this.spaces[r].transfer === di && (s.r = Dc(s.r), s.g = Dc(s.g), s.b = Dc(s.b)), this.spaces[r].primaries !== this.spaces[a].primaries && (s.applyMatrix3(this.spaces[r].toXYZ), s.applyMatrix3(this.spaces[a].fromXYZ)), this.spaces[a].transfer === di && (s.r = ng(s.r), s.g = ng(s.g), s.b = ng(s.b))), s
         },
         fromWorkingColorSpace: function (s, r) {
            return this.convert(s, this.workingColorSpace, r)
         },
         toWorkingColorSpace: function (s, r) {
            return this.convert(s, r, this.workingColorSpace)
         },
         getPrimaries: function (s) {
            return this.spaces[s].primaries
         },
         getTransfer: function (s) {
            return s === Bl ? Cy : this.spaces[s].transfer
         },
         getLuminanceCoefficients: function (s, r = this.workingColorSpace) {
            return s.fromArray(this.spaces[r].luminanceCoefficients)
         },
         define: function (s) {
            Object.assign(this.spaces, s)
         },
         _getMatrix: function (s, r, a) {
            return s.copy(this.spaces[r].toXYZ).multiply(this.spaces[a].fromXYZ)
         },
         _getDrawingBufferColorSpace: function (s) {
            return this.spaces[s].outputColorSpaceConfig.drawingBufferColorSpace
         },
         _getUnpackColorSpace: function (s = this.workingColorSpace) {
            return this.spaces[s].workingColorSpaceConfig.unpackColorSpace
         }
      },
      e = [.64, .33, .3, .6, .15, .06],
      t = [.2126, .7152, .0722],
      i = [.3127, .329];
   return n.define({
      [Gu]: {
         primaries: e,
         whitePoint: i,
         transfer: Cy,
         toXYZ: ED,
         fromXYZ: MD,
         luminanceCoefficients: t,
         workingColorSpaceConfig: {
            unpackColorSpace: En
         },
         outputColorSpaceConfig: {
            drawingBufferColorSpace: En
         }
      },
      [En]: {
         primaries: e,
         whitePoint: i,
         transfer: di,
         toXYZ: ED,
         fromXYZ: MD,
         luminanceCoefficients: t,
         outputColorSpaceConfig: {
            drawingBufferColorSpace: En
         }
      }
   }), n
}
const Vn = A6();

function Dc(n) {
   return n < .04045 ? n * .0773993808 : Math.pow(n * .9478672986 + .0521327014, 2.4)
}

function ng(n) {
   return n < .0031308 ? n * 12.92 : 1.055 * Math.pow(n, .41666) - .055
}
let mm;
class ML {
   static getDataURL(e, t = "image/png") {
      if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
      let i;
      if (e instanceof HTMLCanvasElement) i = e;
      else {
         mm === void 0 && (mm = Oy("canvas")), mm.width = e.width, mm.height = e.height;
         const s = mm.getContext("2d");
         e instanceof ImageData ? s.putImageData(e, 0, 0) : s.drawImage(e, 0, 0, e.width, e.height), i = mm
      }
      return i.toDataURL(t)
   }
   static sRGBToLinear(e) {
      if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
         const t = Oy("canvas");
         t.width = e.width, t.height = e.height;
         const i = t.getContext("2d");
         i.drawImage(e, 0, 0, e.width, e.height);
         const s = i.getImageData(0, 0, e.width, e.height),
            r = s.data;
         for (let a = 0; a < r.length; a++) r[a] = Dc(r[a] / 255) * 255;
         return i.putImageData(s, 0, 0), t
      } else if (e.data) {
         const t = e.data.slice(0);
         for (let i = 0; i < t.length; i++) t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[i] = Math.floor(Dc(t[i] / 255) * 255) : t[i] = Dc(t[i]);
         return {
            data: t,
            width: e.width,
            height: e.height
         }
      } else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e
   }
}
let w6 = 0;
class Xf {
   constructor(e = null) {
      this.isSource = !0, Object.defineProperty(this, "id", {
         value: w6++
      }), this.uuid = po(), this.data = e, this.dataReady = !0, this.version = 0
   }
   set needsUpdate(e) {
      e === !0 && this.version++
   }
   toJSON(e) {
      const t = e === void 0 || typeof e == "string";
      if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
      const i = {
            uuid: this.uuid,
            url: ""
         },
         s = this.data;
      if (s !== null) {
         let r;
         if (Array.isArray(s)) {
            r = [];
            for (let a = 0, l = s.length; a < l; a++) s[a].isDataTexture ? r.push(KE(s[a].image)) : r.push(KE(s[a]))
         } else r = KE(s);
         i.url = r
      }
      return t || (e.images[this.uuid] = i), i
   }
}

function KE(n) {
   return typeof HTMLImageElement < "u" && n instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && n instanceof ImageBitmap ? ML.getDataURL(n) : n.data ? {
      data: Array.from(n.data),
      width: n.width,
      height: n.height,
      type: n.data.constructor.name
   } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
}
let R6 = 0;
class Hi extends xo {
   constructor(e = Hi.DEFAULT_IMAGE, t = Hi.DEFAULT_MAPPING, i = Ko, s = Ko, r = Ni, a = Du, l = Lr, c = qs, h = Hi.DEFAULT_ANISOTROPY, m = Bl) {
      super(), this.isTexture = !0, Object.defineProperty(this, "id", {
         value: R6++
      }), this.uuid = po(), this.name = "", this.source = new Xf(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = i, this.wrapT = s, this.magFilter = r, this.minFilter = a, this.anisotropy = h, this.format = l, this.internalFormat = null, this.type = c, this.offset = new Fe(0, 0), this.repeat = new Fe(1, 1), this.center = new Fe(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new un, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = m, this.userData = {}, this.version = 0, this.onUpdate = null, this.renderTarget = null, this.isRenderTargetTexture = !1, this.pmremVersion = 0
   }
   get image() {
      return this.source.data
   }
   set image(e = null) {
      this.source.data = e
   }
   updateMatrix() {
      this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
   }
   clone() {
      return new this.constructor().copy(this)
   }
   copy(e) {
      return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.renderTarget = e.renderTarget, this.isRenderTargetTexture = e.isRenderTargetTexture, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this
   }
   toJSON(e) {
      const t = e === void 0 || typeof e == "string";
      if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
      const i = {
         metadata: {
            version: 4.6,
            type: "Texture",
            generator: "Texture.toJSON"
         },
         uuid: this.uuid,
         name: this.name,
         image: this.source.toJSON(e).uuid,
         mapping: this.mapping,
         channel: this.channel,
         repeat: [this.repeat.x, this.repeat.y],
         offset: [this.offset.x, this.offset.y],
         center: [this.center.x, this.center.y],
         rotation: this.rotation,
         wrap: [this.wrapS, this.wrapT],
         format: this.format,
         internalFormat: this.internalFormat,
         type: this.type,
         colorSpace: this.colorSpace,
         minFilter: this.minFilter,
         magFilter: this.magFilter,
         anisotropy: this.anisotropy,
         flipY: this.flipY,
         generateMipmaps: this.generateMipmaps,
         premultiplyAlpha: this.premultiplyAlpha,
         unpackAlignment: this.unpackAlignment
      };
      return Object.keys(this.userData).length > 0 && (i.userData = this.userData), t || (e.textures[this.uuid] = i), i
   }
   dispose() {
      this.dispatchEvent({
         type: "dispose"
      })
   }
   transformUv(e) {
      if (this.mapping !== tT) return e;
      if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
         case My:
            e.x = e.x - Math.floor(e.x);
            break;
         case Ko:
            e.x = e.x < 0 ? 0 : 1;
            break;
         case Ay:
            Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
            break
      }
      if (e.y < 0 || e.y > 1) switch (this.wrapT) {
         case My:
            e.y = e.y - Math.floor(e.y);
            break;
         case Ko:
            e.y = e.y < 0 ? 0 : 1;
            break;
         case Ay:
            Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
            break
      }
      return this.flipY && (e.y = 1 - e.y), e
   }
   set needsUpdate(e) {
      e === !0 && (this.version++, this.source.needsUpdate = !0)
   }
   set needsPMREMUpdate(e) {
      e === !0 && this.pmremVersion++
   }
}
Hi.DEFAULT_IMAGE = null;
Hi.DEFAULT_MAPPING = tT;
Hi.DEFAULT_ANISOTROPY = 1;
class Gn {
   constructor(e = 0, t = 0, i = 0, s = 1) {
      Gn.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = i, this.w = s
   }
   get width() {
      return this.z
   }
   set width(e) {
      this.z = e
   }
   get height() {
      return this.w
   }
   set height(e) {
      this.w = e
   }
   set(e, t, i, s) {
      return this.x = e, this.y = t, this.z = i, this.w = s, this
   }
   setScalar(e) {
      return this.x = e, this.y = e, this.z = e, this.w = e, this
   }
   setX(e) {
      return this.x = e, this
   }
   setY(e) {
      return this.y = e, this
   }
   setZ(e) {
      return this.z = e, this
   }
   setW(e) {
      return this.w = e, this
   }
   setComponent(e, t) {
      switch (e) {
         case 0:
            this.x = t;
            break;
         case 1:
            this.y = t;
            break;
         case 2:
            this.z = t;
            break;
         case 3:
            this.w = t;
            break;
         default:
            throw new Error("index is out of range: " + e)
      }
      return this
   }
   getComponent(e) {
      switch (e) {
         case 0:
            return this.x;
         case 1:
            return this.y;
         case 2:
            return this.z;
         case 3:
            return this.w;
         default:
            throw new Error("index is out of range: " + e)
      }
   }
   clone() {
      return new this.constructor(this.x, this.y, this.z, this.w)
   }
   copy(e) {
      return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this
   }
   add(e) {
      return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this
   }
   addScalar(e) {
      return this.x += e, this.y += e, this.z += e, this.w += e, this
   }
   addVectors(e, t) {
      return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
   }
   addScaledVector(e, t) {
      return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this
   }
   sub(e) {
      return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this
   }
   subScalar(e) {
      return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
   }
   subVectors(e, t) {
      return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
   }
   multiply(e) {
      return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this
   }
   multiplyScalar(e) {
      return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
   }
   applyMatrix4(e) {
      const t = this.x,
         i = this.y,
         s = this.z,
         r = this.w,
         a = e.elements;
      return this.x = a[0] * t + a[4] * i + a[8] * s + a[12] * r, this.y = a[1] * t + a[5] * i + a[9] * s + a[13] * r, this.z = a[2] * t + a[6] * i + a[10] * s + a[14] * r, this.w = a[3] * t + a[7] * i + a[11] * s + a[15] * r, this
   }
   divide(e) {
      return this.x /= e.x, this.y /= e.y, this.z /= e.z, this.w /= e.w, this
   }
   divideScalar(e) {
      return this.multiplyScalar(1 / e)
   }
   setAxisAngleFromQuaternion(e) {
      this.w = 2 * Math.acos(e.w);
      const t = Math.sqrt(1 - e.w * e.w);
      return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
   }
   setAxisAngleFromRotationMatrix(e) {
      let t, i, s, r;
      const c = e.elements,
         h = c[0],
         m = c[4],
         g = c[8],
         v = c[1],
         x = c[5],
         S = c[9],
         E = c[2],
         T = c[6],
         b = c[10];
      if (Math.abs(m - v) < .01 && Math.abs(g - E) < .01 && Math.abs(S - T) < .01) {
         if (Math.abs(m + v) < .1 && Math.abs(g + E) < .1 && Math.abs(S + T) < .1 && Math.abs(h + x + b - 3) < .1) return this.set(1, 0, 0, 0), this;
         t = Math.PI;
         const C = (h + 1) / 2,
            N = (x + 1) / 2,
            U = (b + 1) / 2,
            z = (m + v) / 4,
            B = (g + E) / 4,
            I = (S + T) / 4;
         return C > N && C > U ? C < .01 ? (i = 0, s = .707106781, r = .707106781) : (i = Math.sqrt(C), s = z / i, r = B / i) : N > U ? N < .01 ? (i = .707106781, s = 0, r = .707106781) : (s = Math.sqrt(N), i = z / s, r = I / s) : U < .01 ? (i = .707106781, s = .707106781, r = 0) : (r = Math.sqrt(U), i = B / r, s = I / r), this.set(i, s, r, t), this
      }
      let w = Math.sqrt((T - S) * (T - S) + (g - E) * (g - E) + (v - m) * (v - m));
      return Math.abs(w) < .001 && (w = 1), this.x = (T - S) / w, this.y = (g - E) / w, this.z = (v - m) / w, this.w = Math.acos((h + x + b - 1) / 2), this
   }
   setFromMatrixPosition(e) {
      const t = e.elements;
      return this.x = t[12], this.y = t[13], this.z = t[14], this.w = t[15], this
   }
   min(e) {
      return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
   }
   max(e) {
      return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
   }
   clamp(e, t) {
      return this.x = on(this.x, e.x, t.x), this.y = on(this.y, e.y, t.y), this.z = on(this.z, e.z, t.z), this.w = on(this.w, e.w, t.w), this
   }
   clampScalar(e, t) {
      return this.x = on(this.x, e, t), this.y = on(this.y, e, t), this.z = on(this.z, e, t), this.w = on(this.w, e, t), this
   }
   clampLength(e, t) {
      const i = this.length();
      return this.divideScalar(i || 1).multiplyScalar(on(i, e, t))
   }
   floor() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
   }
   ceil() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
   }
   round() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
   }
   roundToZero() {
      return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this
   }
   negate() {
      return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
   }
   dot(e) {
      return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
   }
   lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
   }
   length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
   }
   manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
   }
   normalize() {
      return this.divideScalar(this.length() || 1)
   }
   setLength(e) {
      return this.normalize().multiplyScalar(e)
   }
   lerp(e, t) {
      return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
   }
   lerpVectors(e, t, i) {
      return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this.w = e.w + (t.w - e.w) * i, this
   }
   equals(e) {
      return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
   }
   fromArray(e, t = 0) {
      return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this
   }
   toArray(e = [], t = 0) {
      return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e
   }
   fromBufferAttribute(e, t) {
      return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this
   }
   random() {
      return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
   }*[Symbol.iterator]() {
      yield this.x, yield this.y, yield this.z, yield this.w
   }
}
class uT extends xo {
   constructor(e = 1, t = 1, i = {}) {
      super(), this.isRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new Gn(0, 0, e, t), this.scissorTest = !1, this.viewport = new Gn(0, 0, e, t);
      const s = {
         width: e,
         height: t,
         depth: 1
      };
      i = Object.assign({
         generateMipmaps: !1,
         internalFormat: null,
         minFilter: Ni,
         depthBuffer: !0,
         stencilBuffer: !1,
         resolveDepthBuffer: !0,
         resolveStencilBuffer: !0,
         depthTexture: null,
         samples: 0,
         count: 1
      }, i);
      const r = new Hi(s, i.mapping, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.colorSpace);
      r.flipY = !1, r.generateMipmaps = i.generateMipmaps, r.internalFormat = i.internalFormat, this.textures = [];
      const a = i.count;
      for (let l = 0; l < a; l++) this.textures[l] = r.clone(), this.textures[l].isRenderTargetTexture = !0, this.textures[l].renderTarget = this;
      this.depthBuffer = i.depthBuffer, this.stencilBuffer = i.stencilBuffer, this.resolveDepthBuffer = i.resolveDepthBuffer, this.resolveStencilBuffer = i.resolveStencilBuffer, this._depthTexture = i.depthTexture, this.samples = i.samples
   }
   get texture() {
      return this.textures[0]
   }
   set texture(e) {
      this.textures[0] = e
   }
   set depthTexture(e) {
      this._depthTexture !== null && (this._depthTexture.renderTarget = null), e !== null && (e.renderTarget = this), this._depthTexture = e
   }
   get depthTexture() {
      return this._depthTexture
   }
   setSize(e, t, i = 1) {
      if (this.width !== e || this.height !== t || this.depth !== i) {
         this.width = e, this.height = t, this.depth = i;
         for (let s = 0, r = this.textures.length; s < r; s++) this.textures[s].image.width = e, this.textures[s].image.height = t, this.textures[s].image.depth = i;
         this.dispose()
      }
      this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t)
   }
   clone() {
      return new this.constructor().copy(this)
   }
   copy(e) {
      this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0;
      for (let t = 0, i = e.textures.length; t < i; t++) {
         this.textures[t] = e.textures[t].clone(), this.textures[t].isRenderTargetTexture = !0, this.textures[t].renderTarget = this;
         const s = Object.assign({}, e.textures[t].image);
         this.textures[t].source = new Xf(s)
      }
      return this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.resolveDepthBuffer = e.resolveDepthBuffer, this.resolveStencilBuffer = e.resolveStencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this
   }
   dispose() {
      this.dispatchEvent({
         type: "dispose"
      })
   }
}
class ss extends uT {
   constructor(e = 1, t = 1, i = {}) {
      super(e, t, i), this.isWebGLRenderTarget = !0
   }
}
class dx extends Hi {
   constructor(e = null, t = 1, i = 1, s = 1) {
      super(null), this.isDataArrayTexture = !0, this.image = {
         data: e,
         width: t,
         height: i,
         depth: s
      }, this.magFilter = ms, this.minFilter = ms, this.wrapR = Ko, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.layerUpdates = new Set
   }
   addLayerUpdate(e) {
      this.layerUpdates.add(e)
   }
   clearLayerUpdates() {
      this.layerUpdates.clear()
   }
}
class C6 extends ss {
   constructor(e = 1, t = 1, i = 1, s = {}) {
      super(e, t, s), this.isWebGLArrayRenderTarget = !0, this.depth = i, this.texture = new dx(null, e, t, i), this.texture.isRenderTargetTexture = !0
   }
}
class cT extends Hi {
   constructor(e = null, t = 1, i = 1, s = 1) {
      super(null), this.isData3DTexture = !0, this.image = {
         data: e,
         width: t,
         height: i,
         depth: s
      }, this.magFilter = ms, this.minFilter = ms, this.wrapR = Ko, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
   }
}
class D6 extends ss {
   constructor(e = 1, t = 1, i = 1, s = {}) {
      super(e, t, s), this.isWebGL3DRenderTarget = !0, this.depth = i, this.texture = new cT(null, e, t, i), this.texture.isRenderTargetTexture = !0
   }
}
class Ba {
   constructor(e = 0, t = 0, i = 0, s = 1) {
      this.isQuaternion = !0, this._x = e, this._y = t, this._z = i, this._w = s
   }
   static slerpFlat(e, t, i, s, r, a, l) {
      let c = i[s + 0],
         h = i[s + 1],
         m = i[s + 2],
         g = i[s + 3];
      const v = r[a + 0],
         x = r[a + 1],
         S = r[a + 2],
         E = r[a + 3];
      if (l === 0) {
         e[t + 0] = c, e[t + 1] = h, e[t + 2] = m, e[t + 3] = g;
         return
      }
      if (l === 1) {
         e[t + 0] = v, e[t + 1] = x, e[t + 2] = S, e[t + 3] = E;
         return
      }
      if (g !== E || c !== v || h !== x || m !== S) {
         let T = 1 - l;
         const b = c * v + h * x + m * S + g * E,
            w = b >= 0 ? 1 : -1,
            C = 1 - b * b;
         if (C > Number.EPSILON) {
            const U = Math.sqrt(C),
               z = Math.atan2(U, b * w);
            T = Math.sin(T * z) / U, l = Math.sin(l * z) / U
         }
         const N = l * w;
         if (c = c * T + v * N, h = h * T + x * N, m = m * T + S * N, g = g * T + E * N, T === 1 - l) {
            const U = 1 / Math.sqrt(c * c + h * h + m * m + g * g);
            c *= U, h *= U, m *= U, g *= U
         }
      }
      e[t] = c, e[t + 1] = h, e[t + 2] = m, e[t + 3] = g
   }
   static multiplyQuaternionsFlat(e, t, i, s, r, a) {
      const l = i[s],
         c = i[s + 1],
         h = i[s + 2],
         m = i[s + 3],
         g = r[a],
         v = r[a + 1],
         x = r[a + 2],
         S = r[a + 3];
      return e[t] = l * S + m * g + c * x - h * v, e[t + 1] = c * S + m * v + h * g - l * x, e[t + 2] = h * S + m * x + l * v - c * g, e[t + 3] = m * S - l * g - c * v - h * x, e
   }
   get x() {
      return this._x
   }
   set x(e) {
      this._x = e, this._onChangeCallback()
   }
   get y() {
      return this._y
   }
   set y(e) {
      this._y = e, this._onChangeCallback()
   }
   get z() {
      return this._z
   }
   set z(e) {
      this._z = e, this._onChangeCallback()
   }
   get w() {
      return this._w
   }
   set w(e) {
      this._w = e, this._onChangeCallback()
   }
   set(e, t, i, s) {
      return this._x = e, this._y = t, this._z = i, this._w = s, this._onChangeCallback(), this
   }
   clone() {
      return new this.constructor(this._x, this._y, this._z, this._w)
   }
   copy(e) {
      return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this
   }
   setFromEuler(e, t = !0) {
      const i = e._x,
         s = e._y,
         r = e._z,
         a = e._order,
         l = Math.cos,
         c = Math.sin,
         h = l(i / 2),
         m = l(s / 2),
         g = l(r / 2),
         v = c(i / 2),
         x = c(s / 2),
         S = c(r / 2);
      switch (a) {
         case "XYZ":
            this._x = v * m * g + h * x * S, this._y = h * x * g - v * m * S, this._z = h * m * S + v * x * g, this._w = h * m * g - v * x * S;
            break;
         case "YXZ":
            this._x = v * m * g + h * x * S, this._y = h * x * g - v * m * S, this._z = h * m * S - v * x * g, this._w = h * m * g + v * x * S;
            break;
         case "ZXY":
            this._x = v * m * g - h * x * S, this._y = h * x * g + v * m * S, this._z = h * m * S + v * x * g, this._w = h * m * g - v * x * S;
            break;
         case "ZYX":
            this._x = v * m * g - h * x * S, this._y = h * x * g + v * m * S, this._z = h * m * S - v * x * g, this._w = h * m * g + v * x * S;
            break;
         case "YZX":
            this._x = v * m * g + h * x * S, this._y = h * x * g + v * m * S, this._z = h * m * S - v * x * g, this._w = h * m * g - v * x * S;
            break;
         case "XZY":
            this._x = v * m * g - h * x * S, this._y = h * x * g - v * m * S, this._z = h * m * S + v * x * g, this._w = h * m * g + v * x * S;
            break;
         default:
            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + a)
      }
      return t === !0 && this._onChangeCallback(), this
   }
   setFromAxisAngle(e, t) {
      const i = t / 2,
         s = Math.sin(i);
      return this._x = e.x * s, this._y = e.y * s, this._z = e.z * s, this._w = Math.cos(i), this._onChangeCallback(), this
   }
   setFromRotationMatrix(e) {
      const t = e.elements,
         i = t[0],
         s = t[4],
         r = t[8],
         a = t[1],
         l = t[5],
         c = t[9],
         h = t[2],
         m = t[6],
         g = t[10],
         v = i + l + g;
      if (v > 0) {
         const x = .5 / Math.sqrt(v + 1);
         this._w = .25 / x, this._x = (m - c) * x, this._y = (r - h) * x, this._z = (a - s) * x
      } else if (i > l && i > g) {
         const x = 2 * Math.sqrt(1 + i - l - g);
         this._w = (m - c) / x, this._x = .25 * x, this._y = (s + a) / x, this._z = (r + h) / x
      } else if (l > g) {
         const x = 2 * Math.sqrt(1 + l - i - g);
         this._w = (r - h) / x, this._x = (s + a) / x, this._y = .25 * x, this._z = (c + m) / x
      } else {
         const x = 2 * Math.sqrt(1 + g - i - l);
         this._w = (a - s) / x, this._x = (r + h) / x, this._y = (c + m) / x, this._z = .25 * x
      }
      return this._onChangeCallback(), this
   }
   setFromUnitVectors(e, t) {
      let i = e.dot(t) + 1;
      return i < Number.EPSILON ? (i = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = i) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = i)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = i), this.normalize()
   }
   angleTo(e) {
      return 2 * Math.acos(Math.abs(on(this.dot(e), -1, 1)))
   }
   rotateTowards(e, t) {
      const i = this.angleTo(e);
      if (i === 0) return this;
      const s = Math.min(1, t / i);
      return this.slerp(e, s), this
   }
   identity() {
      return this.set(0, 0, 0, 1)
   }
   invert() {
      return this.conjugate()
   }
   conjugate() {
      return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
   }
   dot(e) {
      return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
   }
   lengthSq() {
      return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
   }
   length() {
      return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
   }
   normalize() {
      let e = this.length();
      return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this
   }
   multiply(e) {
      return this.multiplyQuaternions(this, e)
   }
   premultiply(e) {
      return this.multiplyQuaternions(e, this)
   }
   multiplyQuaternions(e, t) {
      const i = e._x,
         s = e._y,
         r = e._z,
         a = e._w,
         l = t._x,
         c = t._y,
         h = t._z,
         m = t._w;
      return this._x = i * m + a * l + s * h - r * c, this._y = s * m + a * c + r * l - i * h, this._z = r * m + a * h + i * c - s * l, this._w = a * m - i * l - s * c - r * h, this._onChangeCallback(), this
   }
   slerp(e, t) {
      if (t === 0) return this;
      if (t === 1) return this.copy(e);
      const i = this._x,
         s = this._y,
         r = this._z,
         a = this._w;
      let l = a * e._w + i * e._x + s * e._y + r * e._z;
      if (l < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, l = -l) : this.copy(e), l >= 1) return this._w = a, this._x = i, this._y = s, this._z = r, this;
      const c = 1 - l * l;
      if (c <= Number.EPSILON) {
         const x = 1 - t;
         return this._w = x * a + t * this._w, this._x = x * i + t * this._x, this._y = x * s + t * this._y, this._z = x * r + t * this._z, this.normalize(), this
      }
      const h = Math.sqrt(c),
         m = Math.atan2(h, l),
         g = Math.sin((1 - t) * m) / h,
         v = Math.sin(t * m) / h;
      return this._w = a * g + this._w * v, this._x = i * g + this._x * v, this._y = s * g + this._y * v, this._z = r * g + this._z * v, this._onChangeCallback(), this
   }
   slerpQuaternions(e, t, i) {
      return this.copy(e).slerp(t, i)
   }
   random() {
      const e = 2 * Math.PI * Math.random(),
         t = 2 * Math.PI * Math.random(),
         i = Math.random(),
         s = Math.sqrt(1 - i),
         r = Math.sqrt(i);
      return this.set(s * Math.sin(e), s * Math.cos(e), r * Math.sin(t), r * Math.cos(t))
   }
   equals(e) {
      return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
   }
   fromArray(e, t = 0) {
      return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this
   }
   toArray(e = [], t = 0) {
      return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e
   }
   fromBufferAttribute(e, t) {
      return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this._onChangeCallback(), this
   }
   toJSON() {
      return this.toArray()
   }
   _onChange(e) {
      return this._onChangeCallback = e, this
   }
   _onChangeCallback() {}*[Symbol.iterator]() {
      yield this._x, yield this._y, yield this._z, yield this._w
   }
}
class ee {
   constructor(e = 0, t = 0, i = 0) {
      ee.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = i
   }
   set(e, t, i) {
      return i === void 0 && (i = this.z), this.x = e, this.y = t, this.z = i, this
   }
   setScalar(e) {
      return this.x = e, this.y = e, this.z = e, this
   }
   setX(e) {
      return this.x = e, this
   }
   setY(e) {
      return this.y = e, this
   }
   setZ(e) {
      return this.z = e, this
   }
   setComponent(e, t) {
      switch (e) {
         case 0:
            this.x = t;
            break;
         case 1:
            this.y = t;
            break;
         case 2:
            this.z = t;
            break;
         default:
            throw new Error("index is out of range: " + e)
      }
      return this
   }
   getComponent(e) {
      switch (e) {
         case 0:
            return this.x;
         case 1:
            return this.y;
         case 2:
            return this.z;
         default:
            throw new Error("index is out of range: " + e)
      }
   }
   clone() {
      return new this.constructor(this.x, this.y, this.z)
   }
   copy(e) {
      return this.x = e.x, this.y = e.y, this.z = e.z, this
   }
   add(e) {
      return this.x += e.x, this.y += e.y, this.z += e.z, this
   }
   addScalar(e) {
      return this.x += e, this.y += e, this.z += e, this
   }
   addVectors(e, t) {
      return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
   }
   addScaledVector(e, t) {
      return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this
   }
   sub(e) {
      return this.x -= e.x, this.y -= e.y, this.z -= e.z, this
   }
   subScalar(e) {
      return this.x -= e, this.y -= e, this.z -= e, this
   }
   subVectors(e, t) {
      return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
   }
   multiply(e) {
      return this.x *= e.x, this.y *= e.y, this.z *= e.z, this
   }
   multiplyScalar(e) {
      return this.x *= e, this.y *= e, this.z *= e, this
   }
   multiplyVectors(e, t) {
      return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
   }
   applyEuler(e) {
      return this.applyQuaternion(AD.setFromEuler(e))
   }
   applyAxisAngle(e, t) {
      return this.applyQuaternion(AD.setFromAxisAngle(e, t))
   }
   applyMatrix3(e) {
      const t = this.x,
         i = this.y,
         s = this.z,
         r = e.elements;
      return this.x = r[0] * t + r[3] * i + r[6] * s, this.y = r[1] * t + r[4] * i + r[7] * s, this.z = r[2] * t + r[5] * i + r[8] * s, this
   }
   applyNormalMatrix(e) {
      return this.applyMatrix3(e).normalize()
   }
   applyMatrix4(e) {
      const t = this.x,
         i = this.y,
         s = this.z,
         r = e.elements,
         a = 1 / (r[3] * t + r[7] * i + r[11] * s + r[15]);
      return this.x = (r[0] * t + r[4] * i + r[8] * s + r[12]) * a, this.y = (r[1] * t + r[5] * i + r[9] * s + r[13]) * a, this.z = (r[2] * t + r[6] * i + r[10] * s + r[14]) * a, this
   }
   applyQuaternion(e) {
      const t = this.x,
         i = this.y,
         s = this.z,
         r = e.x,
         a = e.y,
         l = e.z,
         c = e.w,
         h = 2 * (a * s - l * i),
         m = 2 * (l * t - r * s),
         g = 2 * (r * i - a * t);
      return this.x = t + c * h + a * g - l * m, this.y = i + c * m + l * h - r * g, this.z = s + c * g + r * m - a * h, this
   }
   project(e) {
      return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
   }
   unproject(e) {
      return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
   }
   transformDirection(e) {
      const t = this.x,
         i = this.y,
         s = this.z,
         r = e.elements;
      return this.x = r[0] * t + r[4] * i + r[8] * s, this.y = r[1] * t + r[5] * i + r[9] * s, this.z = r[2] * t + r[6] * i + r[10] * s, this.normalize()
   }
   divide(e) {
      return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
   }
   divideScalar(e) {
      return this.multiplyScalar(1 / e)
   }
   min(e) {
      return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
   }
   max(e) {
      return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
   }
   clamp(e, t) {
      return this.x = on(this.x, e.x, t.x), this.y = on(this.y, e.y, t.y), this.z = on(this.z, e.z, t.z), this
   }
   clampScalar(e, t) {
      return this.x = on(this.x, e, t), this.y = on(this.y, e, t), this.z = on(this.z, e, t), this
   }
   clampLength(e, t) {
      const i = this.length();
      return this.divideScalar(i || 1).multiplyScalar(on(i, e, t))
   }
   floor() {
      return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
   }
   ceil() {
      return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
   }
   round() {
      return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
   }
   roundToZero() {
      return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this
   }
   negate() {
      return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
   }
   dot(e) {
      return this.x * e.x + this.y * e.y + this.z * e.z
   }
   lengthSq() {
      return this.x * this.x + this.y * this.y + this.z * this.z
   }
   length() {
      return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
   }
   manhattanLength() {
      return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
   }
   normalize() {
      return this.divideScalar(this.length() || 1)
   }
   setLength(e) {
      return this.normalize().multiplyScalar(e)
   }
   lerp(e, t) {
      return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
   }
   lerpVectors(e, t, i) {
      return this.x = e.x + (t.x - e.x) * i, this.y = e.y + (t.y - e.y) * i, this.z = e.z + (t.z - e.z) * i, this
   }
   cross(e) {
      return this.crossVectors(this, e)
   }
   crossVectors(e, t) {
      const i = e.x,
         s = e.y,
         r = e.z,
         a = t.x,
         l = t.y,
         c = t.z;
      return this.x = s * c - r * l, this.y = r * a - i * c, this.z = i * l - s * a, this
   }
   projectOnVector(e) {
      const t = e.lengthSq();
      if (t === 0) return this.set(0, 0, 0);
      const i = e.dot(this) / t;
      return this.copy(e).multiplyScalar(i)
   }
   projectOnPlane(e) {
      return ZE.copy(this).projectOnVector(e), this.sub(ZE)
   }
   reflect(e) {
      return this.sub(ZE.copy(e).multiplyScalar(2 * this.dot(e)))
   }
   angleTo(e) {
      const t = Math.sqrt(this.lengthSq() * e.lengthSq());
      if (t === 0) return Math.PI / 2;
      const i = this.dot(e) / t;
      return Math.acos(on(i, -1, 1))
   }
   distanceTo(e) {
      return Math.sqrt(this.distanceToSquared(e))
   }
   distanceToSquared(e) {
      const t = this.x - e.x,
         i = this.y - e.y,
         s = this.z - e.z;
      return t * t + i * i + s * s
   }
   manhattanDistanceTo(e) {
      return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
   }
   setFromSpherical(e) {
      return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
   }
   setFromSphericalCoords(e, t, i) {
      const s = Math.sin(t) * e;
      return this.x = s * Math.sin(i), this.y = Math.cos(t) * e, this.z = s * Math.cos(i), this
   }
   setFromCylindrical(e) {
      return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
   }
   setFromCylindricalCoords(e, t, i) {
      return this.x = e * Math.sin(t), this.y = i, this.z = e * Math.cos(t), this
   }
   setFromMatrixPosition(e) {
      const t = e.elements;
      return this.x = t[12], this.y = t[13], this.z = t[14], this
   }
   setFromMatrixScale(e) {
      const t = this.setFromMatrixColumn(e, 0).length(),
         i = this.setFromMatrixColumn(e, 1).length(),
         s = this.setFromMatrixColumn(e, 2).length();
      return this.x = t, this.y = i, this.z = s, this
   }
   setFromMatrixColumn(e, t) {
      return this.fromArray(e.elements, t * 4)
   }
   setFromMatrix3Column(e, t) {
      return this.fromArray(e.elements, t * 3)
   }
   setFromEuler(e) {
      return this.x = e._x, this.y = e._y, this.z = e._z, this
   }
   setFromColor(e) {
      return this.x = e.r, this.y = e.g, this.z = e.b, this
   }
   equals(e) {
      return e.x === this.x && e.y === this.y && e.z === this.z
   }
   fromArray(e, t = 0) {
      return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this
   }
   toArray(e = [], t = 0) {
      return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e
   }
   fromBufferAttribute(e, t) {
      return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this
   }
   random() {
      return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
   }
   randomDirection() {
      const e = Math.random() * Math.PI * 2,
         t = Math.random() * 2 - 1,
         i = Math.sqrt(1 - t * t);
      return this.x = i * Math.cos(e), this.y = t, this.z = i * Math.sin(e), this
   }*[Symbol.iterator]() {
      yield this.x, yield this.y, yield this.z
   }
}
const ZE = new ee,
   AD = new Ba;
class pa {
   constructor(e = new ee(1 / 0, 1 / 0, 1 / 0), t = new ee(-1 / 0, -1 / 0, -1 / 0)) {
      this.isBox3 = !0, this.min = e, this.max = t
   }
   set(e, t) {
      return this.min.copy(e), this.max.copy(t), this
   }
   setFromArray(e) {
      this.makeEmpty();
      for (let t = 0, i = e.length; t < i; t += 3) this.expandByPoint(Cl.fromArray(e, t));
      return this
   }
   setFromBufferAttribute(e) {
      this.makeEmpty();
      for (let t = 0, i = e.count; t < i; t++) this.expandByPoint(Cl.fromBufferAttribute(e, t));
      return this
   }
   setFromPoints(e) {
      this.makeEmpty();
      for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
      return this
   }
   setFromCenterAndSize(e, t) {
      const i = Cl.copy(t).multiplyScalar(.5);
      return this.min.copy(e).sub(i), this.max.copy(e).add(i), this
   }
   setFromObject(e, t = !1) {
      return this.makeEmpty(), this.expandByObject(e, t)
   }
   clone() {
      return new this.constructor().copy(this)
   }
   copy(e) {
      return this.min.copy(e.min), this.max.copy(e.max), this
   }
   makeEmpty() {
      return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
   }
   isEmpty() {
      return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
   }
   getCenter(e) {
      return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
   }
   getSize(e) {
      return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
   }
   expandByPoint(e) {
      return this.min.min(e), this.max.max(e), this
   }
   expandByVector(e) {
      return this.min.sub(e), this.max.add(e), this
   }
   expandByScalar(e) {
      return this.min.addScalar(-e), this.max.addScalar(e), this
   }
   expandByObject(e, t = !1) {
      e.updateWorldMatrix(!1, !1);
      const i = e.geometry;
      if (i !== void 0) {
         const r = i.getAttribute("position");
         if (t === !0 && r !== void 0 && e.isInstancedMesh !== !0)
            for (let a = 0, l = r.count; a < l; a++) e.isMesh === !0 ? e.getVertexPosition(a, Cl) : Cl.fromBufferAttribute(r, a), Cl.applyMatrix4(e.matrixWorld), this.expandByPoint(Cl);
         else e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), aS.copy(e.boundingBox)) : (i.boundingBox === null && i.computeBoundingBox(), aS.copy(i.boundingBox)), aS.applyMatrix4(e.matrixWorld), this.union(aS)
      }
      const s = e.children;
      for (let r = 0, a = s.length; r < a; r++) this.expandByObject(s[r], t);
      return this
   }
   containsPoint(e) {
      return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z
   }
   containsBox(e) {
      return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
   }
   getParameter(e, t) {
      return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
   }
   intersectsBox(e) {
      return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z
   }
   intersectsSphere(e) {
      return this.clampPoint(e.center, Cl), Cl.distanceToSquared(e.center) <= e.radius * e.radius
   }
   intersectsPlane(e) {
      let t, i;
      return e.normal.x > 0 ? (t = e.normal.x * this.min.x, i = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, i = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, i += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, i += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, i += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, i += e.normal.z * this.min.z), t <= -e.constant && i >= -e.constant
   }
   intersectsTriangle(e) {
      if (this.isEmpty()) return !1;
      this.getCenter(o0), oS.subVectors(this.max, o0), gm.subVectors(e.a, o0), vm.subVectors(e.b, o0), ym.subVectors(e.c, o0), Of.subVectors(vm, gm), Uf.subVectors(ym, vm), od.subVectors(gm, ym);
      let t = [0, -Of.z, Of.y, 0, -Uf.z, Uf.y, 0, -od.z, od.y, Of.z, 0, -Of.x, Uf.z, 0, -Uf.x, od.z, 0, -od.x, -Of.y, Of.x, 0, -Uf.y, Uf.x, 0, -od.y, od.x, 0];
      return !QE(t, gm, vm, ym, oS) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !QE(t, gm, vm, ym, oS)) ? !1 : (lS.crossVectors(Of, Uf), t = [lS.x, lS.y, lS.z], QE(t, gm, vm, ym, oS))
   }
   clampPoint(e, t) {
      return t.copy(e).clamp(this.min, this.max)
   }
   distanceToPoint(e) {
      return this.clampPoint(e, Cl).distanceTo(e)
   }
   getBoundingSphere(e) {
      return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(Cl).length() * .5), e
   }
   intersect(e) {
      return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
   }
   union(e) {
      return this.min.min(e.min), this.max.max(e.max), this
   }
   applyMatrix4(e) {
      return this.isEmpty() ? this : (mc[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), mc[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), mc[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), mc[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), mc[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), mc[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), mc[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), mc[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(mc), this)
   }
   translate(e) {
      return this.min.add(e), this.max.add(e), this
   }
   equals(e) {
      return e.min.equals(this.min) && e.max.equals(this.max)
   }
}
const mc = [new ee, new ee, new ee, new ee, new ee, new ee, new ee, new ee],
   Cl = new ee,
   aS = new pa,
   gm = new ee,
   vm = new ee,
   ym = new ee,
   Of = new ee,
   Uf = new ee,
   od = new ee,
   o0 = new ee,
   oS = new ee,
   lS = new ee,
   ld = new ee;

function QE(n, e, t, i, s) {
   for (let r = 0, a = n.length - 3; r <= a; r += 3) {
      ld.fromArray(n, r);
      const l = s.x * Math.abs(ld.x) + s.y * Math.abs(ld.y) + s.z * Math.abs(ld.z),
         c = e.dot(ld),
         h = t.dot(ld),
         m = i.dot(ld);
      if (Math.max(-Math.max(c, h, m), Math.min(c, h, m)) > l) return !1
   }
   return !0
}
const N6 = new pa,
   l0 = new ee,
   JE = new ee;
class zr {
   constructor(e = new ee, t = -1) {
      this.isSphere = !0, this.center = e, this.radius = t
   }
   set(e, t) {
      return this.center.copy(e), this.radius = t, this
   }
   setFromPoints(e, t) {
      const i = this.center;
      t !== void 0 ? i.copy(t) : N6.setFromPoints(e).getCenter(i);
      let s = 0;
      for (let r = 0, a = e.length; r < a; r++) s = Math.max(s, i.distanceToSquared(e[r]));
      return this.radius = Math.sqrt(s), this
   }
   copy(e) {
      return this.center.copy(e.center), this.radius = e.radius, this
   }
   isEmpty() {
      return this.radius < 0
   }
   makeEmpty() {
      return this.center.set(0, 0, 0), this.radius = -1, this
   }
   containsPoint(e) {
      return e.distanceToSquared(this.center) <= this.radius * this.radius
   }
   distanceToPoint(e) {
      return e.distanceTo(this.center) - this.radius
   }
   intersectsSphere(e) {
      const t = this.radius + e.radius;
      return e.center.distanceToSquared(this.center) <= t * t
   }
   intersectsBox(e) {
      return e.intersectsSphere(this)
   }
   intersectsPlane(e) {
      return Math.abs(e.distanceToPoint(this.center)) <= this.radius
   }
   clampPoint(e, t) {
      const i = this.center.distanceToSquared(e);
      return t.copy(e), i > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t
   }
   getBoundingBox(e) {
      return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e)
   }
   applyMatrix4(e) {
      return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this
   }
   translate(e) {
      return this.center.add(e), this
   }
   expandByPoint(e) {
      if (this.isEmpty()) return this.center.copy(e), this.radius = 0, this;
      l0.subVectors(e, this.center);
      const t = l0.lengthSq();
      if (t > this.radius * this.radius) {
         const i = Math.sqrt(t),
            s = (i - this.radius) * .5;
         this.center.addScaledVector(l0, s / i), this.radius += s
      }
      return this
   }
   union(e) {
      return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (JE.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(l0.copy(e.center).add(JE)), this.expandByPoint(l0.copy(e.center).sub(JE))), this)
   }
   equals(e) {
      return e.center.equals(this.center) && e.radius === this.radius
   }
   clone() {
      return new this.constructor().copy(this)
   }
}
const gc = new ee,
   $E = new ee,
   uS = new ee,
   Pf = new ee,
   eM = new ee,
   cS = new ee,
   tM = new ee;
class Pg {
   constructor(e = new ee, t = new ee(0, 0, -1)) {
      this.origin = e, this.direction = t
   }
   set(e, t) {
      return this.origin.copy(e), this.direction.copy(t), this
   }
   copy(e) {
      return this.origin.copy(e.origin), this.direction.copy(e.direction), this
   }
   at(e, t) {
      return t.copy(this.origin).addScaledVector(this.direction, e)
   }
   lookAt(e) {
      return this.direction.copy(e).sub(this.origin).normalize(), this
   }
   recast(e) {
      return this.origin.copy(this.at(e, gc)), this
   }
   closestPointToPoint(e, t) {
      t.subVectors(e, this.origin);
      const i = t.dot(this.direction);
      return i < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, i)
   }
   distanceToPoint(e) {
      return Math.sqrt(this.distanceSqToPoint(e))
   }
   distanceSqToPoint(e) {
      const t = gc.subVectors(e, this.origin).dot(this.direction);
      return t < 0 ? this.origin.distanceToSquared(e) : (gc.copy(this.origin).addScaledVector(this.direction, t), gc.distanceToSquared(e))
   }
   distanceSqToSegment(e, t, i, s) {
      $E.copy(e).add(t).multiplyScalar(.5), uS.copy(t).sub(e).normalize(), Pf.copy(this.origin).sub($E);
      const r = e.distanceTo(t) * .5,
         a = -this.direction.dot(uS),
         l = Pf.dot(this.direction),
         c = -Pf.dot(uS),
         h = Pf.lengthSq(),
         m = Math.abs(1 - a * a);
      let g, v, x, S;
      if (m > 0)
         if (g = a * c - l, v = a * l - c, S = r * m, g >= 0)
            if (v >= -S)
               if (v <= S) {
                  const E = 1 / m;
                  g *= E, v *= E, x = g * (g + a * v + 2 * l) + v * (a * g + v + 2 * c) + h
               } else v = r, g = Math.max(0, -(a * v + l)), x = -g * g + v * (v + 2 * c) + h;
      else v = -r, g = Math.max(0, -(a * v + l)), x = -g * g + v * (v + 2 * c) + h;
      else v <= -S ? (g = Math.max(0, -(-a * r + l)), v = g > 0 ? -r : Math.min(Math.max(-r, -c), r), x = -g * g + v * (v + 2 * c) + h) : v <= S ? (g = 0, v = Math.min(Math.max(-r, -c), r), x = v * (v + 2 * c) + h) : (g = Math.max(0, -(a * r + l)), v = g > 0 ? r : Math.min(Math.max(-r, -c), r), x = -g * g + v * (v + 2 * c) + h);
      else v = a > 0 ? -r : r, g = Math.max(0, -(a * v + l)), x = -g * g + v * (v + 2 * c) + h;
      return i && i.copy(this.origin).addScaledVector(this.direction, g), s && s.copy($E).addScaledVector(uS, v), x
   }
   intersectSphere(e, t) {
      gc.subVectors(e.center, this.origin);
      const i = gc.dot(this.direction),
         s = gc.dot(gc) - i * i,
         r = e.radius * e.radius;
      if (s > r) return null;
      const a = Math.sqrt(r - s),
         l = i - a,
         c = i + a;
      return c < 0 ? null : l < 0 ? this.at(c, t) : this.at(l, t)
   }
   intersectsSphere(e) {
      return this.distanceSqToPoint(e.center) <= e.radius * e.radius
   }
   distanceToPlane(e) {
      const t = e.normal.dot(this.direction);
      if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
      const i = -(this.origin.dot(e.normal) + e.constant) / t;
      return i >= 0 ? i : null
   }
   intersectPlane(e, t) {
      const i = this.distanceToPlane(e);
      return i === null ? null : this.at(i, t)
   }
   intersectsPlane(e) {
      const t = e.distanceToPoint(this.origin);
      return t === 0 || e.normal.dot(this.direction) * t < 0
   }
   intersectBox(e, t) {
      let i, s, r, a, l, c;
      const h = 1 / this.direction.x,
         m = 1 / this.direction.y,
         g = 1 / this.direction.z,
         v = this.origin;
      return h >= 0 ? (i = (e.min.x - v.x) * h, s = (e.max.x - v.x) * h) : (i = (e.max.x - v.x) * h, s = (e.min.x - v.x) * h), m >= 0 ? (r = (e.min.y - v.y) * m, a = (e.max.y - v.y) * m) : (r = (e.max.y - v.y) * m, a = (e.min.y - v.y) * m), i > a || r > s || ((r > i || isNaN(i)) && (i = r), (a < s || isNaN(s)) && (s = a), g >= 0 ? (l = (e.min.z - v.z) * g, c = (e.max.z - v.z) * g) : (l = (e.max.z - v.z) * g, c = (e.min.z - v.z) * g), i > c || l > s) || ((l > i || i !== i) && (i = l), (c < s || s !== s) && (s = c), s < 0) ? null : this.at(i >= 0 ? i : s, t)
   }
   intersectsBox(e) {
      return this.intersectBox(e, gc) !== null
   }
   intersectTriangle(e, t, i, s, r) {
      eM.subVectors(t, e), cS.subVectors(i, e), tM.crossVectors(eM, cS);
      let a = this.direction.dot(tM),
         l;
      if (a > 0) {
         if (s) return null;
         l = 1
      } else if (a < 0) l = -1, a = -a;
      else return null;
      Pf.subVectors(this.origin, e);
      const c = l * this.direction.dot(cS.crossVectors(Pf, cS));
      if (c < 0) return null;
      const h = l * this.direction.dot(eM.cross(Pf));
      if (h < 0 || c + h > a) return null;
      const m = -l * Pf.dot(tM);
      return m < 0 ? null : this.at(m / a, r)
   }
   applyMatrix4(e) {
      return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
   }
   equals(e) {
      return e.origin.equals(this.origin) && e.direction.equals(this.direction)
   }
   clone() {
      return new this.constructor().copy(this)
   }
}
class Zt {
   constructor(e, t, i, s, r, a, l, c, h, m, g, v, x, S, E, T) {
      Zt.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], e !== void 0 && this.set(e, t, i, s, r, a, l, c, h, m, g, v, x, S, E, T)
   }
   set(e, t, i, s, r, a, l, c, h, m, g, v, x, S, E, T) {
      const b = this.elements;
      return b[0] = e, b[4] = t, b[8] = i, b[12] = s, b[1] = r, b[5] = a, b[9] = l, b[13] = c, b[2] = h, b[6] = m, b[10] = g, b[14] = v, b[3] = x, b[7] = S, b[11] = E, b[15] = T, this
   }
   identity() {
      return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
   }
   clone() {
      return new Zt().fromArray(this.elements)
   }
   copy(e) {
      const t = this.elements,
         i = e.elements;
      return t[0] = i[0], t[1] = i[1], t[2] = i[2], t[3] = i[3], t[4] = i[4], t[5] = i[5], t[6] = i[6], t[7] = i[7], t[8] = i[8], t[9] = i[9], t[10] = i[10], t[11] = i[11], t[12] = i[12], t[13] = i[13], t[14] = i[14], t[15] = i[15], this
   }
   copyPosition(e) {
      const t = this.elements,
         i = e.elements;
      return t[12] = i[12], t[13] = i[13], t[14] = i[14], this
   }
   setFromMatrix3(e) {
      const t = e.elements;
      return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this
   }
   extractBasis(e, t, i) {
      return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this
   }
   makeBasis(e, t, i) {
      return this.set(e.x, t.x, i.x, 0, e.y, t.y, i.y, 0, e.z, t.z, i.z, 0, 0, 0, 0, 1), this
   }
   extractRotation(e) {
      const t = this.elements,
         i = e.elements,
         s = 1 / xm.setFromMatrixColumn(e, 0).length(),
         r = 1 / xm.setFromMatrixColumn(e, 1).length(),
         a = 1 / xm.setFromMatrixColumn(e, 2).length();
      return t[0] = i[0] * s, t[1] = i[1] * s, t[2] = i[2] * s, t[3] = 0, t[4] = i[4] * r, t[5] = i[5] * r, t[6] = i[6] * r, t[7] = 0, t[8] = i[8] * a, t[9] = i[9] * a, t[10] = i[10] * a, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
   }
   makeRotationFromEuler(e) {
      const t = this.elements,
         i = e.x,
         s = e.y,
         r = e.z,
         a = Math.cos(i),
         l = Math.sin(i),
         c = Math.cos(s),
         h = Math.sin(s),
         m = Math.cos(r),
         g = Math.sin(r);
      if (e.order === "XYZ") {
         const v = a * m,
            x = a * g,
            S = l * m,
            E = l * g;
         t[0] = c * m, t[4] = -c * g, t[8] = h, t[1] = x + S * h, t[5] = v - E * h, t[9] = -l * c, t[2] = E - v * h, t[6] = S + x * h, t[10] = a * c
      } else if (e.order === "YXZ") {
         const v = c * m,
            x = c * g,
            S = h * m,
            E = h * g;
         t[0] = v + E * l, t[4] = S * l - x, t[8] = a * h, t[1] = a * g, t[5] = a * m, t[9] = -l, t[2] = x * l - S, t[6] = E + v * l, t[10] = a * c
      } else if (e.order === "ZXY") {
         const v = c * m,
            x = c * g,
            S = h * m,
            E = h * g;
         t[0] = v - E * l, t[4] = -a * g, t[8] = S + x * l, t[1] = x + S * l, t[5] = a * m, t[9] = E - v * l, t[2] = -a * h, t[6] = l, t[10] = a * c
      } else if (e.order === "ZYX") {
         const v = a * m,
            x = a * g,
            S = l * m,
            E = l * g;
         t[0] = c * m, t[4] = S * h - x, t[8] = v * h + E, t[1] = c * g, t[5] = E * h + v, t[9] = x * h - S, t[2] = -h, t[6] = l * c, t[10] = a * c
      } else if (e.order === "YZX") {
         const v = a * c,
            x = a * h,
            S = l * c,
            E = l * h;
         t[0] = c * m, t[4] = E - v * g, t[8] = S * g + x, t[1] = g, t[5] = a * m, t[9] = -l * m, t[2] = -h * m, t[6] = x * g + S, t[10] = v - E * g
      } else if (e.order === "XZY") {
         const v = a * c,
            x = a * h,
            S = l * c,
            E = l * h;
         t[0] = c * m, t[4] = -g, t[8] = h * m, t[1] = v * g + E, t[5] = a * m, t[9] = x * g - S, t[2] = S * g - x, t[6] = l * m, t[10] = E * g + v
      }
      return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
   }
   makeRotationFromQuaternion(e) {
      return this.compose(O6, e, U6)
   }
   lookAt(e, t, i) {
      const s = this.elements;
      return io.subVectors(e, t), io.lengthSq() === 0 && (io.z = 1), io.normalize(), Lf.crossVectors(i, io), Lf.lengthSq() === 0 && (Math.abs(i.z) === 1 ? io.x += 1e-4 : io.z += 1e-4, io.normalize(), Lf.crossVectors(i, io)), Lf.normalize(), fS.crossVectors(io, Lf), s[0] = Lf.x, s[4] = fS.x, s[8] = io.x, s[1] = Lf.y, s[5] = fS.y, s[9] = io.y, s[2] = Lf.z, s[6] = fS.z, s[10] = io.z, this
   }
   multiply(e) {
      return this.multiplyMatrices(this, e)
   }
   premultiply(e) {
      return this.multiplyMatrices(e, this)
   }
   multiplyMatrices(e, t) {
      const i = e.elements,
         s = t.elements,
         r = this.elements,
         a = i[0],
         l = i[4],
         c = i[8],
         h = i[12],
         m = i[1],
         g = i[5],
         v = i[9],
         x = i[13],
         S = i[2],
         E = i[6],
         T = i[10],
         b = i[14],
         w = i[3],
         C = i[7],
         N = i[11],
         U = i[15],
         z = s[0],
         B = s[4],
         I = s[8],
         O = s[12],
         P = s[1],
         q = s[5],
         Q = s[9],
         $ = s[13],
         ae = s[2],
         fe = s[6],
         k = s[10],
         Z = s[14],
         J = s[3],
         pe = s[7],
         F = s[11],
         ie = s[15];
      return r[0] = a * z + l * P + c * ae + h * J, r[4] = a * B + l * q + c * fe + h * pe, r[8] = a * I + l * Q + c * k + h * F, r[12] = a * O + l * $ + c * Z + h * ie, r[1] = m * z + g * P + v * ae + x * J, r[5] = m * B + g * q + v * fe + x * pe, r[9] = m * I + g * Q + v * k + x * F, r[13] = m * O + g * $ + v * Z + x * ie, r[2] = S * z + E * P + T * ae + b * J, r[6] = S * B + E * q + T * fe + b * pe, r[10] = S * I + E * Q + T * k + b * F, r[14] = S * O + E * $ + T * Z + b * ie, r[3] = w * z + C * P + N * ae + U * J, r[7] = w * B + C * q + N * fe + U * pe, r[11] = w * I + C * Q + N * k + U * F, r[15] = w * O + C * $ + N * Z + U * ie, this
   }
   multiplyScalar(e) {
      const t = this.elements;
      return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
   }
   determinant() {
      const e = this.elements,
         t = e[0],
         i = e[4],
         s = e[8],
         r = e[12],
         a = e[1],
         l = e[5],
         c = e[9],
         h = e[13],
         m = e[2],
         g = e[6],
         v = e[10],
         x = e[14],
         S = e[3],
         E = e[7],
         T = e[11],
         b = e[15];
      return S * (+r * c * g - s * h * g - r * l * v + i * h * v + s * l * x - i * c * x) + E * (+t * c * x - t * h * v + r * a * v - s * a * x + s * h * m - r * c * m) + T * (+t * h * g - t * l * x - r * a * g + i * a * x + r * l * m - i * h * m) + b * (-s * l * m - t * c * g + t * l * v + s * a * g - i * a * v + i * c * m)
   }
   transpose() {
      const e = this.elements;
      let t;
      return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
   }
   setPosition(e, t, i) {
      const s = this.elements;
      return e.isVector3 ? (s[12] = e.x, s[13] = e.y, s[14] = e.z) : (s[12] = e, s[13] = t, s[14] = i), this
   }
   invert() {
      const e = this.elements,
         t = e[0],
         i = e[1],
         s = e[2],
         r = e[3],
         a = e[4],
         l = e[5],
         c = e[6],
         h = e[7],
         m = e[8],
         g = e[9],
         v = e[10],
         x = e[11],
         S = e[12],
         E = e[13],
         T = e[14],
         b = e[15],
         w = g * T * h - E * v * h + E * c * x - l * T * x - g * c * b + l * v * b,
         C = S * v * h - m * T * h - S * c * x + a * T * x + m * c * b - a * v * b,
         N = m * E * h - S * g * h + S * l * x - a * E * x - m * l * b + a * g * b,
         U = S * g * c - m * E * c - S * l * v + a * E * v + m * l * T - a * g * T,
         z = t * w + i * C + s * N + r * U;
      if (z === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      const B = 1 / z;
      return e[0] = w * B, e[1] = (E * v * r - g * T * r - E * s * x + i * T * x + g * s * b - i * v * b) * B, e[2] = (l * T * r - E * c * r + E * s * h - i * T * h - l * s * b + i * c * b) * B, e[3] = (g * c * r - l * v * r - g * s * h + i * v * h + l * s * x - i * c * x) * B, e[4] = C * B, e[5] = (m * T * r - S * v * r + S * s * x - t * T * x - m * s * b + t * v * b) * B, e[6] = (S * c * r - a * T * r - S * s * h + t * T * h + a * s * b - t * c * b) * B, e[7] = (a * v * r - m * c * r + m * s * h - t * v * h - a * s * x + t * c * x) * B, e[8] = N * B, e[9] = (S * g * r - m * E * r - S * i * x + t * E * x + m * i * b - t * g * b) * B, e[10] = (a * E * r - S * l * r + S * i * h - t * E * h - a * i * b + t * l * b) * B, e[11] = (m * l * r - a * g * r - m * i * h + t * g * h + a * i * x - t * l * x) * B, e[12] = U * B, e[13] = (m * E * s - S * g * s + S * i * v - t * E * v - m * i * T + t * g * T) * B, e[14] = (S * l * s - a * E * s - S * i * c + t * E * c + a * i * T - t * l * T) * B, e[15] = (a * g * s - m * l * s + m * i * c - t * g * c - a * i * v + t * l * v) * B, this
   }
   scale(e) {
      const t = this.elements,
         i = e.x,
         s = e.y,
         r = e.z;
      return t[0] *= i, t[4] *= s, t[8] *= r, t[1] *= i, t[5] *= s, t[9] *= r, t[2] *= i, t[6] *= s, t[10] *= r, t[3] *= i, t[7] *= s, t[11] *= r, this
   }
   getMaxScaleOnAxis() {
      const e = this.elements,
         t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
         i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
         s = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
      return Math.sqrt(Math.max(t, i, s))
   }
   makeTranslation(e, t, i) {
      return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1), this
   }
   makeRotationX(e) {
      const t = Math.cos(e),
         i = Math.sin(e);
      return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1), this
   }
   makeRotationY(e) {
      const t = Math.cos(e),
         i = Math.sin(e);
      return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1), this
   }
   makeRotationZ(e) {
      const t = Math.cos(e),
         i = Math.sin(e);
      return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
   }
   makeRotationAxis(e, t) {
      const i = Math.cos(t),
         s = Math.sin(t),
         r = 1 - i,
         a = e.x,
         l = e.y,
         c = e.z,
         h = r * a,
         m = r * l;
      return this.set(h * a + i, h * l - s * c, h * c + s * l, 0, h * l + s * c, m * l + i, m * c - s * a, 0, h * c - s * l, m * c + s * a, r * c * c + i, 0, 0, 0, 0, 1), this
   }
   makeScale(e, t, i) {
      return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this
   }
   makeShear(e, t, i, s, r, a) {
      return this.set(1, i, r, 0, e, 1, a, 0, t, s, 1, 0, 0, 0, 0, 1), this
   }
   compose(e, t, i) {
      const s = this.elements,
         r = t._x,
         a = t._y,
         l = t._z,
         c = t._w,
         h = r + r,
         m = a + a,
         g = l + l,
         v = r * h,
         x = r * m,
         S = r * g,
         E = a * m,
         T = a * g,
         b = l * g,
         w = c * h,
         C = c * m,
         N = c * g,
         U = i.x,
         z = i.y,
         B = i.z;
      return s[0] = (1 - (E + b)) * U, s[1] = (x + N) * U, s[2] = (S - C) * U, s[3] = 0, s[4] = (x - N) * z, s[5] = (1 - (v + b)) * z, s[6] = (T + w) * z, s[7] = 0, s[8] = (S + C) * B, s[9] = (T - w) * B, s[10] = (1 - (v + E)) * B, s[11] = 0, s[12] = e.x, s[13] = e.y, s[14] = e.z, s[15] = 1, this
   }
   decompose(e, t, i) {
      const s = this.elements;
      let r = xm.set(s[0], s[1], s[2]).length();
      const a = xm.set(s[4], s[5], s[6]).length(),
         l = xm.set(s[8], s[9], s[10]).length();
      this.determinant() < 0 && (r = -r), e.x = s[12], e.y = s[13], e.z = s[14], Dl.copy(this);
      const h = 1 / r,
         m = 1 / a,
         g = 1 / l;
      return Dl.elements[0] *= h, Dl.elements[1] *= h, Dl.elements[2] *= h, Dl.elements[4] *= m, Dl.elements[5] *= m, Dl.elements[6] *= m, Dl.elements[8] *= g, Dl.elements[9] *= g, Dl.elements[10] *= g, t.setFromRotationMatrix(Dl), i.x = r, i.y = a, i.z = l, this
   }
   makePerspective(e, t, i, s, r, a, l = zl) {
      const c = this.elements,
         h = 2 * r / (t - e),
         m = 2 * r / (i - s),
         g = (t + e) / (t - e),
         v = (i + s) / (i - s);
      let x, S;
      if (l === zl) x = -(a + r) / (a - r), S = -2 * a * r / (a - r);
      else if (l === Ny) x = -a / (a - r), S = -a * r / (a - r);
      else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + l);
      return c[0] = h, c[4] = 0, c[8] = g, c[12] = 0, c[1] = 0, c[5] = m, c[9] = v, c[13] = 0, c[2] = 0, c[6] = 0, c[10] = x, c[14] = S, c[3] = 0, c[7] = 0, c[11] = -1, c[15] = 0, this
   }
   makeOrthographic(e, t, i, s, r, a, l = zl) {
      const c = this.elements,
         h = 1 / (t - e),
         m = 1 / (i - s),
         g = 1 / (a - r),
         v = (t + e) * h,
         x = (i + s) * m;
      let S, E;
      if (l === zl) S = (a + r) * g, E = -2 * g;
      else if (l === Ny) S = r * g, E = -1 * g;
      else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + l);
      return c[0] = 2 * h, c[4] = 0, c[8] = 0, c[12] = -v, c[1] = 0, c[5] = 2 * m, c[9] = 0, c[13] = -x, c[2] = 0, c[6] = 0, c[10] = E, c[14] = -S, c[3] = 0, c[7] = 0, c[11] = 0, c[15] = 1, this
   }
   equals(e) {
      const t = this.elements,
         i = e.elements;
      for (let s = 0; s < 16; s++)
         if (t[s] !== i[s]) return !1;
      return !0
   }
   fromArray(e, t = 0) {
      for (let i = 0; i < 16; i++) this.elements[i] = e[i + t];
      return this
   }
   toArray(e = [], t = 0) {
      const i = this.elements;
      return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e[t + 9] = i[9], e[t + 10] = i[10], e[t + 11] = i[11], e[t + 12] = i[12], e[t + 13] = i[13], e[t + 14] = i[14], e[t + 15] = i[15], e
   }
}
const xm = new ee,
   Dl = new Zt,
   O6 = new ee(0, 0, 0),
   U6 = new ee(1, 1, 1),
   Lf = new ee,
   fS = new ee,
   io = new ee,
   wD = new Zt,
   RD = new Ba;
class go {
   constructor(e = 0, t = 0, i = 0, s = go.DEFAULT_ORDER) {
      this.isEuler = !0, this._x = e, this._y = t, this._z = i, this._order = s
   }
   get x() {
      return this._x
   }
   set x(e) {
      this._x = e, this._onChangeCallback()
   }
   get y() {
      return this._y
   }
   set y(e) {
      this._y = e, this._onChangeCallback()
   }
   get z() {
      return this._z
   }
   set z(e) {
      this._z = e, this._onChangeCallback()
   }
   get order() {
      return this._order
   }
   set order(e) {
      this._order = e, this._onChangeCallback()
   }
   set(e, t, i, s = this._order) {
      return this._x = e, this._y = t, this._z = i, this._order = s, this._onChangeCallback(), this
   }
   clone() {
      return new this.constructor(this._x, this._y, this._z, this._order)
   }
   copy(e) {
      return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this
   }
   setFromRotationMatrix(e, t = this._order, i = !0) {
      const s = e.elements,
         r = s[0],
         a = s[4],
         l = s[8],
         c = s[1],
         h = s[5],
         m = s[9],
         g = s[2],
         v = s[6],
         x = s[10];
      switch (t) {
         case "XYZ":
            this._y = Math.asin(on(l, -1, 1)), Math.abs(l) < .9999999 ? (this._x = Math.atan2(-m, x), this._z = Math.atan2(-a, r)) : (this._x = Math.atan2(v, h), this._z = 0);
            break;
         case "YXZ":
            this._x = Math.asin(-on(m, -1, 1)), Math.abs(m) < .9999999 ? (this._y = Math.atan2(l, x), this._z = Math.atan2(c, h)) : (this._y = Math.atan2(-g, r), this._z = 0);
            break;
         case "ZXY":
            this._x = Math.asin(on(v, -1, 1)), Math.abs(v) < .9999999 ? (this._y = Math.atan2(-g, x), this._z = Math.atan2(-a, h)) : (this._y = 0, this._z = Math.atan2(c, r));
            break;
         case "ZYX":
            this._y = Math.asin(-on(g, -1, 1)), Math.abs(g) < .9999999 ? (this._x = Math.atan2(v, x), this._z = Math.atan2(c, r)) : (this._x = 0, this._z = Math.atan2(-a, h));
            break;
         case "YZX":
            this._z = Math.asin(on(c, -1, 1)), Math.abs(c) < .9999999 ? (this._x = Math.atan2(-m, h), this._y = Math.atan2(-g, r)) : (this._x = 0, this._y = Math.atan2(l, x));
            break;
         case "XZY":
            this._z = Math.asin(-on(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(v, h), this._y = Math.atan2(l, r)) : (this._x = Math.atan2(-m, x), this._y = 0);
            break;
         default:
            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
      }
      return this._order = t, i === !0 && this._onChangeCallback(), this
   }
   setFromQuaternion(e, t, i) {
      return wD.makeRotationFromQuaternion(e), this.setFromRotationMatrix(wD, t, i)
   }
   setFromVector3(e, t = this._order) {
      return this.set(e.x, e.y, e.z, t)
   }
   reorder(e) {
      return RD.setFromEuler(this), this.setFromQuaternion(RD, e)
   }
   equals(e) {
      return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
   }
   fromArray(e) {
      return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this
   }
   toArray(e = [], t = 0) {
      return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e
   }
   _onChange(e) {
      return this._onChangeCallback = e, this
   }
   _onChangeCallback() {}*[Symbol.iterator]() {
      yield this._x, yield this._y, yield this._z, yield this._order
   }
}
go.DEFAULT_ORDER = "XYZ";
class dg {
   constructor() {
      this.mask = 1
   }
   set(e) {
      this.mask = (1 << e | 0) >>> 0
   }
   enable(e) {
      this.mask |= 1 << e | 0
   }
   enableAll() {
      this.mask = -1
   }
   toggle(e) {
      this.mask ^= 1 << e | 0
   }
   disable(e) {
      this.mask &= ~(1 << e | 0)
   }
   disableAll() {
      this.mask = 0
   }
   test(e) {
      return (this.mask & e.mask) !== 0
   }
   isEnabled(e) {
      return (this.mask & (1 << e | 0)) !== 0
   }
}
let P6 = 0;
const CD = new ee,
   _m = new Ba,
   vc = new Zt,
   hS = new ee,
   u0 = new ee,
   L6 = new ee,
   B6 = new Ba,
   DD = new ee(1, 0, 0),
   ND = new ee(0, 1, 0),
   OD = new ee(0, 0, 1),
   UD = {
      type: "added"
   },
   z6 = {
      type: "removed"
   },
   Sm = {
      type: "childadded",
      child: null
   },
   nM = {
      type: "childremoved",
      child: null
   };
class Wn extends xo {
   constructor() {
      super(), this.isObject3D = !0, Object.defineProperty(this, "id", {
         value: P6++
      }), this.uuid = po(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = Wn.DEFAULT_UP.clone();
      const e = new ee,
         t = new go,
         i = new Ba,
         s = new ee(1, 1, 1);

      function r() {
         i.setFromEuler(t, !1)
      }

      function a() {
         t.setFromQuaternion(i, void 0, !1)
      }
      t._onChange(r), i._onChange(a), Object.defineProperties(this, {
         position: {
            configurable: !0,
            enumerable: !0,
            value: e
         },
         rotation: {
            configurable: !0,
            enumerable: !0,
            value: t
         },
         quaternion: {
            configurable: !0,
            enumerable: !0,
            value: i
         },
         scale: {
            configurable: !0,
            enumerable: !0,
            value: s
         },
         modelViewMatrix: {
            value: new Zt
         },
         normalMatrix: {
            value: new un
         }
      }), this.matrix = new Zt, this.matrixWorld = new Zt, this.matrixAutoUpdate = Wn.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = Wn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new dg, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.customDepthMaterial = void 0, this.customDistanceMaterial = void 0, this.userData = {}
   }
   onBeforeShadow() {}
   onAfterShadow() {}
   onBeforeRender() {}
   onAfterRender() {}
   applyMatrix4(e) {
      this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale)
   }
   applyQuaternion(e) {
      return this.quaternion.premultiply(e), this
   }
   setRotationFromAxisAngle(e, t) {
      this.quaternion.setFromAxisAngle(e, t)
   }
   setRotationFromEuler(e) {
      this.quaternion.setFromEuler(e, !0)
   }
   setRotationFromMatrix(e) {
      this.quaternion.setFromRotationMatrix(e)
   }
   setRotationFromQuaternion(e) {
      this.quaternion.copy(e)
   }
   rotateOnAxis(e, t) {
      return _m.setFromAxisAngle(e, t), this.quaternion.multiply(_m), this
   }
   rotateOnWorldAxis(e, t) {
      return _m.setFromAxisAngle(e, t), this.quaternion.premultiply(_m), this
   }
   rotateX(e) {
      return this.rotateOnAxis(DD, e)
   }
   rotateY(e) {
      return this.rotateOnAxis(ND, e)
   }
   rotateZ(e) {
      return this.rotateOnAxis(OD, e)
   }
   translateOnAxis(e, t) {
      return CD.copy(e).applyQuaternion(this.quaternion), this.position.add(CD.multiplyScalar(t)), this
   }
   translateX(e) {
      return this.translateOnAxis(DD, e)
   }
   translateY(e) {
      return this.translateOnAxis(ND, e)
   }
   translateZ(e) {
      return this.translateOnAxis(OD, e)
   }
   localToWorld(e) {
      return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld)
   }
   worldToLocal(e) {
      return this.updateWorldMatrix(!0, !1), e.applyMatrix4(vc.copy(this.matrixWorld).invert())
   }
   lookAt(e, t, i) {
      e.isVector3 ? hS.copy(e) : hS.set(e, t, i);
      const s = this.parent;
      this.updateWorldMatrix(!0, !1), u0.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? vc.lookAt(u0, hS, this.up) : vc.lookAt(hS, u0, this.up), this.quaternion.setFromRotationMatrix(vc), s && (vc.extractRotation(s.matrixWorld), _m.setFromRotationMatrix(vc), this.quaternion.premultiply(_m.invert()))
   }
   add(e) {
      if (arguments.length > 1) {
         for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
         return this
      }
      return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(UD), Sm.child = e, this.dispatchEvent(Sm), Sm.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this)
   }
   remove(e) {
      if (arguments.length > 1) {
         for (let i = 0; i < arguments.length; i++) this.remove(arguments[i]);
         return this
      }
      const t = this.children.indexOf(e);
      return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(z6), nM.child = e, this.dispatchEvent(nM), nM.child = null), this
   }
   removeFromParent() {
      const e = this.parent;
      return e !== null && e.remove(this), this
   }
   clear() {
      return this.remove(...this.children)
   }
   attach(e) {
      return this.updateWorldMatrix(!0, !1), vc.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), vc.multiply(e.parent.matrixWorld)), e.applyMatrix4(vc), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(!1, !0), e.dispatchEvent(UD), Sm.child = e, this.dispatchEvent(Sm), Sm.child = null, this
   }
   getObjectById(e) {
      return this.getObjectByProperty("id", e)
   }
   getObjectByName(e) {
      return this.getObjectByProperty("name", e)
   }
   getObjectByProperty(e, t) {
      if (this[e] === t) return this;
      for (let i = 0, s = this.children.length; i < s; i++) {
         const a = this.children[i].getObjectByProperty(e, t);
         if (a !== void 0) return a
      }
   }
   getObjectsByProperty(e, t, i = []) {
      this[e] === t && i.push(this);
      const s = this.children;
      for (let r = 0, a = s.length; r < a; r++) s[r].getObjectsByProperty(e, t, i);
      return i
   }
   getWorldPosition(e) {
      return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
   }
   getWorldQuaternion(e) {
      return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(u0, e, L6), e
   }
   getWorldScale(e) {
      return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(u0, B6, e), e
   }
   getWorldDirection(e) {
      this.updateWorldMatrix(!0, !1);
      const t = this.matrixWorld.elements;
      return e.set(t[8], t[9], t[10]).normalize()
   }
   raycast() {}
   traverse(e) {
      e(this);
      const t = this.children;
      for (let i = 0, s = t.length; i < s; i++) t[i].traverse(e)
   }
   traverseVisible(e) {
      if (this.visible === !1) return;
      e(this);
      const t = this.children;
      for (let i = 0, s = t.length; i < s; i++) t[i].traverseVisible(e)
   }
   traverseAncestors(e) {
      const t = this.parent;
      t !== null && (e(t), t.traverseAncestors(e))
   }
   updateMatrix() {
      this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
   }
   updateMatrixWorld(e) {
      this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, e = !0);
      const t = this.children;
      for (let i = 0, s = t.length; i < s; i++) t[i].updateMatrixWorld(e)
   }
   updateWorldMatrix(e, t) {
      const i = this.parent;
      if (e === !0 && i !== null && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), t === !0) {
         const s = this.children;
         for (let r = 0, a = s.length; r < a; r++) s[r].updateWorldMatrix(!1, !0)
      }
   }
   toJSON(e) {
      const t = e === void 0 || typeof e == "string",
         i = {};
      t && (e = {
         geometries: {},
         materials: {},
         textures: {},
         images: {},
         shapes: {},
         skeletons: {},
         animations: {},
         nodes: {}
      }, i.metadata = {
         version: 4.6,
         type: "Object",
         generator: "Object3D.toJSON"
      });
      const s = {};
      s.uuid = this.uuid, s.type = this.type, this.name !== "" && (s.name = this.name), this.castShadow === !0 && (s.castShadow = !0), this.receiveShadow === !0 && (s.receiveShadow = !0), this.visible === !1 && (s.visible = !1), this.frustumCulled === !1 && (s.frustumCulled = !1), this.renderOrder !== 0 && (s.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (s.userData = this.userData), s.layers = this.layers.mask, s.matrix = this.matrix.toArray(), s.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (s.matrixAutoUpdate = !1), this.isInstancedMesh && (s.type = "InstancedMesh", s.count = this.count, s.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (s.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (s.type = "BatchedMesh", s.perObjectFrustumCulled = this.perObjectFrustumCulled, s.sortObjects = this.sortObjects, s.drawRanges = this._drawRanges, s.reservedRanges = this._reservedRanges, s.visibility = this._visibility, s.active = this._active, s.bounds = this._bounds.map(l => ({
         boxInitialized: l.boxInitialized,
         boxMin: l.box.min.toArray(),
         boxMax: l.box.max.toArray(),
         sphereInitialized: l.sphereInitialized,
         sphereRadius: l.sphere.radius,
         sphereCenter: l.sphere.center.toArray()
      })), s.maxInstanceCount = this._maxInstanceCount, s.maxVertexCount = this._maxVertexCount, s.maxIndexCount = this._maxIndexCount, s.geometryInitialized = this._geometryInitialized, s.geometryCount = this._geometryCount, s.matricesTexture = this._matricesTexture.toJSON(e), this._colorsTexture !== null && (s.colorsTexture = this._colorsTexture.toJSON(e)), this.boundingSphere !== null && (s.boundingSphere = {
         center: s.boundingSphere.center.toArray(),
         radius: s.boundingSphere.radius
      }), this.boundingBox !== null && (s.boundingBox = {
         min: s.boundingBox.min.toArray(),
         max: s.boundingBox.max.toArray()
      }));

      function r(l, c) {
         return l[c.uuid] === void 0 && (l[c.uuid] = c.toJSON(e)), c.uuid
      }
      if (this.isScene) this.background && (this.background.isColor ? s.background = this.background.toJSON() : this.background.isTexture && (s.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (s.environment = this.environment.toJSON(e).uuid);
      else if (this.isMesh || this.isLine || this.isPoints) {
         s.geometry = r(e.geometries, this.geometry);
         const l = this.geometry.parameters;
         if (l !== void 0 && l.shapes !== void 0) {
            const c = l.shapes;
            if (Array.isArray(c))
               for (let h = 0, m = c.length; h < m; h++) {
                  const g = c[h];
                  r(e.shapes, g)
               } else r(e.shapes, c)
         }
      }
      if (this.isSkinnedMesh && (s.bindMode = this.bindMode, s.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (r(e.skeletons, this.skeleton), s.skeleton = this.skeleton.uuid)), this.material !== void 0)
         if (Array.isArray(this.material)) {
            const l = [];
            for (let c = 0, h = this.material.length; c < h; c++) l.push(r(e.materials, this.material[c]));
            s.material = l
         } else s.material = r(e.materials, this.material);
      if (this.children.length > 0) {
         s.children = [];
         for (let l = 0; l < this.children.length; l++) s.children.push(this.children[l].toJSON(e).object)
      }
      if (this.animations.length > 0) {
         s.animations = [];
         for (let l = 0; l < this.animations.length; l++) {
            const c = this.animations[l];
            s.animations.push(r(e.animations, c))
         }
      }
      if (t) {
         const l = a(e.geometries),
            c = a(e.materials),
            h = a(e.textures),
            m = a(e.images),
            g = a(e.shapes),
            v = a(e.skeletons),
            x = a(e.animations),
            S = a(e.nodes);
         l.length > 0 && (i.geometries = l), c.length > 0 && (i.materials = c), h.length > 0 && (i.textures = h), m.length > 0 && (i.images = m), g.length > 0 && (i.shapes = g), v.length > 0 && (i.skeletons = v), x.length > 0 && (i.animations = x), S.length > 0 && (i.nodes = S)
      }
      return i.object = s, i;

      function a(l) {
         const c = [];
         for (const h in l) {
            const m = l[h];
            delete m.metadata, c.push(m)
         }
         return c
      }
   }
   clone(e) {
      return new this.constructor().copy(this, e)
   }
   copy(e, t = !0) {
      if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0)
         for (let i = 0; i < e.children.length; i++) {
            const s = e.children[i];
            this.add(s.clone())
         }
      return this
   }
}
Wn.DEFAULT_UP = new ee(0, 1, 0);
Wn.DEFAULT_MATRIX_AUTO_UPDATE = !0;
Wn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const Nl = new ee,
   yc = new ee,
   iM = new ee,
   xc = new ee,
   bm = new ee,
   Tm = new ee,
   PD = new ee,
   sM = new ee,
   rM = new ee,
   aM = new ee,
   oM = new Gn,
   lM = new Gn,
   uM = new Gn;
class Pa {
   constructor(e = new ee, t = new ee, i = new ee) {
      this.a = e, this.b = t, this.c = i
   }
   static getNormal(e, t, i, s) {
      s.subVectors(i, t), Nl.subVectors(e, t), s.cross(Nl);
      const r = s.lengthSq();
      return r > 0 ? s.multiplyScalar(1 / Math.sqrt(r)) : s.set(0, 0, 0)
   }
   static getBarycoord(e, t, i, s, r) {
      Nl.subVectors(s, t), yc.subVectors(i, t), iM.subVectors(e, t);
      const a = Nl.dot(Nl),
         l = Nl.dot(yc),
         c = Nl.dot(iM),
         h = yc.dot(yc),
         m = yc.dot(iM),
         g = a * h - l * l;
      if (g === 0) return r.set(0, 0, 0), null;
      const v = 1 / g,
         x = (h * c - l * m) * v,
         S = (a * m - l * c) * v;
      return r.set(1 - x - S, S, x)
   }
   static containsPoint(e, t, i, s) {
      return this.getBarycoord(e, t, i, s, xc) === null ? !1 : xc.x >= 0 && xc.y >= 0 && xc.x + xc.y <= 1
   }
   static getInterpolation(e, t, i, s, r, a, l, c) {
      return this.getBarycoord(e, t, i, s, xc) === null ? (c.x = 0, c.y = 0, "z" in c && (c.z = 0), "w" in c && (c.w = 0), null) : (c.setScalar(0), c.addScaledVector(r, xc.x), c.addScaledVector(a, xc.y), c.addScaledVector(l, xc.z), c)
   }
   static getInterpolatedAttribute(e, t, i, s, r, a) {
      return oM.setScalar(0), lM.setScalar(0), uM.setScalar(0), oM.fromBufferAttribute(e, t), lM.fromBufferAttribute(e, i), uM.fromBufferAttribute(e, s), a.setScalar(0), a.addScaledVector(oM, r.x), a.addScaledVector(lM, r.y), a.addScaledVector(uM, r.z), a
   }
   static isFrontFacing(e, t, i, s) {
      return Nl.subVectors(i, t), yc.subVectors(e, t), Nl.cross(yc).dot(s) < 0
   }
   set(e, t, i) {
      return this.a.copy(e), this.b.copy(t), this.c.copy(i), this
   }
   setFromPointsAndIndices(e, t, i, s) {
      return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[s]), this
   }
   setFromAttributeAndIndices(e, t, i, s) {
      return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, i), this.c.fromBufferAttribute(e, s), this
   }
   clone() {
      return new this.constructor().copy(this)
   }
   copy(e) {
      return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
   }
   getArea() {
      return Nl.subVectors(this.c, this.b), yc.subVectors(this.a, this.b), Nl.cross(yc).length() * .5
   }
   getMidpoint(e) {
      return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
   }
   getNormal(e) {
      return Pa.getNormal(this.a, this.b, this.c, e)
   }
   getPlane(e) {
      return e.setFromCoplanarPoints(this.a, this.b, this.c)
   }
   getBarycoord(e, t) {
      return Pa.getBarycoord(e, this.a, this.b, this.c, t)
   }
   getInterpolation(e, t, i, s, r) {
      return Pa.getInterpolation(e, this.a, this.b, this.c, t, i, s, r)
   }
   containsPoint(e) {
      return Pa.containsPoint(e, this.a, this.b, this.c)
   }
   isFrontFacing(e) {
      return Pa.isFrontFacing(this.a, this.b, this.c, e)
   }
   intersectsBox(e) {
      return e.intersectsTriangle(this)
   }
   closestPointToPoint(e, t) {
      const i = this.a,
         s = this.b,
         r = this.c;
      let a, l;
      bm.subVectors(s, i), Tm.subVectors(r, i), sM.subVectors(e, i);
      const c = bm.dot(sM),
         h = Tm.dot(sM);
      if (c <= 0 && h <= 0) return t.copy(i);
      rM.subVectors(e, s);
      const m = bm.dot(rM),
         g = Tm.dot(rM);
      if (m >= 0 && g <= m) return t.copy(s);
      const v = c * g - m * h;
      if (v <= 0 && c >= 0 && m <= 0) return a = c / (c - m), t.copy(i).addScaledVector(bm, a);
      aM.subVectors(e, r);
      const x = bm.dot(aM),
         S = Tm.dot(aM);
      if (S >= 0 && x <= S) return t.copy(r);
      const E = x * h - c * S;
      if (E <= 0 && h >= 0 && S <= 0) return l = h / (h - S), t.copy(i).addScaledVector(Tm, l);
      const T = m * S - x * g;
      if (T <= 0 && g - m >= 0 && x - S >= 0) return PD.subVectors(r, s), l = (g - m) / (g - m + (x - S)), t.copy(s).addScaledVector(PD, l);
      const b = 1 / (T + E + v);
      return a = E * b, l = v * b, t.copy(i).addScaledVector(bm, a).addScaledVector(Tm, l)
   }
   equals(e) {
      return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
   }
}
const AL = {
      aliceblue: 15792383,
      antiquewhite: 16444375,
      aqua: 65535,
      aquamarine: 8388564,
      azure: 15794175,
      beige: 16119260,
      bisque: 16770244,
      black: 0,
      blanchedalmond: 16772045,
      blue: 255,
      blueviolet: 9055202,
      brown: 10824234,
      burlywood: 14596231,
      cadetblue: 6266528,
      chartreuse: 8388352,
      chocolate: 13789470,
      coral: 16744272,
      cornflowerblue: 6591981,
      cornsilk: 16775388,
      crimson: 14423100,
      cyan: 65535,
      darkblue: 139,
      darkcyan: 35723,
      darkgoldenrod: 12092939,
      darkgray: 11119017,
      darkgreen: 25600,
      darkgrey: 11119017,
      darkkhaki: 12433259,
      darkmagenta: 9109643,
      darkolivegreen: 5597999,
      darkorange: 16747520,
      darkorchid: 10040012,
      darkred: 9109504,
      darksalmon: 15308410,
      darkseagreen: 9419919,
      darkslateblue: 4734347,
      darkslategray: 3100495,
      darkslategrey: 3100495,
      darkturquoise: 52945,
      darkviolet: 9699539,
      deeppink: 16716947,
      deepskyblue: 49151,
      dimgray: 6908265,
      dimgrey: 6908265,
      dodgerblue: 2003199,
      firebrick: 11674146,
      floralwhite: 16775920,
      forestgreen: 2263842,
      fuchsia: 16711935,
      gainsboro: 14474460,
      ghostwhite: 16316671,
      gold: 16766720,
      goldenrod: 14329120,
      gray: 8421504,
      green: 32768,
      greenyellow: 11403055,
      grey: 8421504,
      honeydew: 15794160,
      hotpink: 16738740,
      indianred: 13458524,
      indigo: 4915330,
      ivory: 16777200,
      khaki: 15787660,
      lavender: 15132410,
      lavenderblush: 16773365,
      lawngreen: 8190976,
      lemonchiffon: 16775885,
      lightblue: 11393254,
      lightcoral: 15761536,
      lightcyan: 14745599,
      lightgoldenrodyellow: 16448210,
      lightgray: 13882323,
      lightgreen: 9498256,
      lightgrey: 13882323,
      lightpink: 16758465,
      lightsalmon: 16752762,
      lightseagreen: 2142890,
      lightskyblue: 8900346,
      lightslategray: 7833753,
      lightslategrey: 7833753,
      lightsteelblue: 11584734,
      lightyellow: 16777184,
      lime: 65280,
      limegreen: 3329330,
      linen: 16445670,
      magenta: 16711935,
      maroon: 8388608,
      mediumaquamarine: 6737322,
      mediumblue: 205,
      mediumorchid: 12211667,
      mediumpurple: 9662683,
      mediumseagreen: 3978097,
      mediumslateblue: 8087790,
      mediumspringgreen: 64154,
      mediumturquoise: 4772300,
      mediumvioletred: 13047173,
      midnightblue: 1644912,
      mintcream: 16121850,
      mistyrose: 16770273,
      moccasin: 16770229,
      navajowhite: 16768685,
      navy: 128,
      oldlace: 16643558,
      olive: 8421376,
      olivedrab: 7048739,
      orange: 16753920,
      orangered: 16729344,
      orchid: 14315734,
      palegoldenrod: 15657130,
      palegreen: 10025880,
      paleturquoise: 11529966,
      palevioletred: 14381203,
      papayawhip: 16773077,
      peachpuff: 16767673,
      peru: 13468991,
      pink: 16761035,
      plum: 14524637,
      powderblue: 11591910,
      purple: 8388736,
      rebeccapurple: 6697881,
      red: 16711680,
      rosybrown: 12357519,
      royalblue: 4286945,
      saddlebrown: 9127187,
      salmon: 16416882,
      sandybrown: 16032864,
      seagreen: 3050327,
      seashell: 16774638,
      sienna: 10506797,
      silver: 12632256,
      skyblue: 8900331,
      slateblue: 6970061,
      slategray: 7372944,
      slategrey: 7372944,
      snow: 16775930,
      springgreen: 65407,
      steelblue: 4620980,
      tan: 13808780,
      teal: 32896,
      thistle: 14204888,
      tomato: 16737095,
      turquoise: 4251856,
      violet: 15631086,
      wheat: 16113331,
      white: 16777215,
      whitesmoke: 16119285,
      yellow: 16776960,
      yellowgreen: 10145074
   },
   Bf = {
      h: 0,
      s: 0,
      l: 0
   },
   dS = {
      h: 0,
      s: 0,
      l: 0
   };

function cM(n, e, t) {
   return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? n + (e - n) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? n + (e - n) * 6 * (2 / 3 - t) : n
}
class dt {
   constructor(e, t, i) {
      return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, i)
   }
   set(e, t, i) {
      if (t === void 0 && i === void 0) {
         const s = e;
         s && s.isColor ? this.copy(s) : typeof s == "number" ? this.setHex(s) : typeof s == "string" && this.setStyle(s)
      } else this.setRGB(e, t, i);
      return this
   }
   setScalar(e) {
      return this.r = e, this.g = e, this.b = e, this
   }
   setHex(e, t = En) {
      return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, Vn.toWorkingColorSpace(this, t), this
   }
   setRGB(e, t, i, s = Vn.workingColorSpace) {
      return this.r = e, this.g = t, this.b = i, Vn.toWorkingColorSpace(this, s), this
   }
   setHSL(e, t, i, s = Vn.workingColorSpace) {
      if (e = DR(e, 1), t = on(t, 0, 1), i = on(i, 0, 1), t === 0) this.r = this.g = this.b = i;
      else {
         const r = i <= .5 ? i * (1 + t) : i + t - i * t,
            a = 2 * i - r;
         this.r = cM(a, r, e + 1 / 3), this.g = cM(a, r, e), this.b = cM(a, r, e - 1 / 3)
      }
      return Vn.toWorkingColorSpace(this, s), this
   }
   setStyle(e, t = En) {
      function i(r) {
         r !== void 0 && parseFloat(r) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
      }
      let s;
      if (s = /^(\w+)\(([^\)]*)\)/.exec(e)) {
         let r;
         const a = s[1],
            l = s[2];
         switch (a) {
            case "rgb":
            case "rgba":
               if (r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l)) return i(r[4]), this.setRGB(Math.min(255, parseInt(r[1], 10)) / 255, Math.min(255, parseInt(r[2], 10)) / 255, Math.min(255, parseInt(r[3], 10)) / 255, t);
               if (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l)) return i(r[4]), this.setRGB(Math.min(100, parseInt(r[1], 10)) / 100, Math.min(100, parseInt(r[2], 10)) / 100, Math.min(100, parseInt(r[3], 10)) / 100, t);
               break;
            case "hsl":
            case "hsla":
               if (r = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(l)) return i(r[4]), this.setHSL(parseFloat(r[1]) / 360, parseFloat(r[2]) / 100, parseFloat(r[3]) / 100, t);
               break;
            default:
               console.warn("THREE.Color: Unknown color model " + e)
         }
      } else if (s = /^\#([A-Fa-f\d]+)$/.exec(e)) {
         const r = s[1],
            a = r.length;
         if (a === 3) return this.setRGB(parseInt(r.charAt(0), 16) / 15, parseInt(r.charAt(1), 16) / 15, parseInt(r.charAt(2), 16) / 15, t);
         if (a === 6) return this.setHex(parseInt(r, 16), t);
         console.warn("THREE.Color: Invalid hex color " + e)
      } else if (e && e.length > 0) return this.setColorName(e, t);
      return this
   }
   setColorName(e, t = En) {
      const i = AL[e.toLowerCase()];
      return i !== void 0 ? this.setHex(i, t) : console.warn("THREE.Color: Unknown color " + e), this
   }
   clone() {
      return new this.constructor(this.r, this.g, this.b)
   }
   copy(e) {
      return this.r = e.r, this.g = e.g, this.b = e.b, this
   }
   copySRGBToLinear(e) {
      return this.r = Dc(e.r), this.g = Dc(e.g), this.b = Dc(e.b), this
   }
   copyLinearToSRGB(e) {
      return this.r = ng(e.r), this.g = ng(e.g), this.b = ng(e.b), this
   }
   convertSRGBToLinear() {
      return this.copySRGBToLinear(this), this
   }
   convertLinearToSRGB() {
      return this.copyLinearToSRGB(this), this
   }
   getHex(e = En) {
      return Vn.fromWorkingColorSpace(Rr.copy(this), e), Math.round(on(Rr.r * 255, 0, 255)) * 65536 + Math.round(on(Rr.g * 255, 0, 255)) * 256 + Math.round(on(Rr.b * 255, 0, 255))
   }
   getHexString(e = En) {
      return ("000000" + this.getHex(e).toString(16)).slice(-6)
   }
   getHSL(e, t = Vn.workingColorSpace) {
      Vn.fromWorkingColorSpace(Rr.copy(this), t);
      const i = Rr.r,
         s = Rr.g,
         r = Rr.b,
         a = Math.max(i, s, r),
         l = Math.min(i, s, r);
      let c, h;
      const m = (l + a) / 2;
      if (l === a) c = 0, h = 0;
      else {
         const g = a - l;
         switch (h = m <= .5 ? g / (a + l) : g / (2 - a - l), a) {
            case i:
               c = (s - r) / g + (s < r ? 6 : 0);
               break;
            case s:
               c = (r - i) / g + 2;
               break;
            case r:
               c = (i - s) / g + 4;
               break
         }
         c /= 6
      }
      return e.h = c, e.s = h, e.l = m, e
   }
   getRGB(e, t = Vn.workingColorSpace) {
      return Vn.fromWorkingColorSpace(Rr.copy(this), t), e.r = Rr.r, e.g = Rr.g, e.b = Rr.b, e
   }
   getStyle(e = En) {
      Vn.fromWorkingColorSpace(Rr.copy(this), e);
      const t = Rr.r,
         i = Rr.g,
         s = Rr.b;
      return e !== En ? `color(${e} ${t.toFixed(3)} ${i.toFixed(3)} ${s.toFixed(3)})` : `rgb(${Math.round(t*255)},${Math.round(i*255)},${Math.round(s*255)})`
   }
   offsetHSL(e, t, i) {
      return this.getHSL(Bf), this.setHSL(Bf.h + e, Bf.s + t, Bf.l + i)
   }
   add(e) {
      return this.r += e.r, this.g += e.g, this.b += e.b, this
   }
   addColors(e, t) {
      return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
   }
   addScalar(e) {
      return this.r += e, this.g += e, this.b += e, this
   }
   sub(e) {
      return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
   }
   multiply(e) {
      return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
   }
   multiplyScalar(e) {
      return this.r *= e, this.g *= e, this.b *= e, this
   }
   lerp(e, t) {
      return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
   }
   lerpColors(e, t, i) {
      return this.r = e.r + (t.r - e.r) * i, this.g = e.g + (t.g - e.g) * i, this.b = e.b + (t.b - e.b) * i, this
   }
   lerpHSL(e, t) {
      this.getHSL(Bf), e.getHSL(dS);
      const i = q0(Bf.h, dS.h, t),
         s = q0(Bf.s, dS.s, t),
         r = q0(Bf.l, dS.l, t);
      return this.setHSL(i, s, r), this
   }
   setFromVector3(e) {
      return this.r = e.x, this.g = e.y, this.b = e.z, this
   }
   applyMatrix3(e) {
      const t = this.r,
         i = this.g,
         s = this.b,
         r = e.elements;
      return this.r = r[0] * t + r[3] * i + r[6] * s, this.g = r[1] * t + r[4] * i + r[7] * s, this.b = r[2] * t + r[5] * i + r[8] * s, this
   }
   equals(e) {
      return e.r === this.r && e.g === this.g && e.b === this.b
   }
   fromArray(e, t = 0) {
      return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this
   }
   toArray(e = [], t = 0) {
      return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e
   }
   fromBufferAttribute(e, t) {
      return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this
   }
   toJSON() {
      return this.getHex()
   }*[Symbol.iterator]() {
      yield this.r, yield this.g, yield this.b
   }
}
const Rr = new dt;
dt.NAMES = AL;
let I6 = 0;
class sr extends xo {
   constructor() {
      super(), this.isMaterial = !0, Object.defineProperty(this, "id", {
         value: I6++
      }), this.uuid = po(), this.name = "", this.type = "Material", this.blending = Fd, this.side = Hu, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = qb, this.blendDst = Xb, this.blendEquation = jf, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new dt(0, 0, 0), this.blendAlpha = 0, this.depthFunc = ih, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = qA, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Td, this.stencilZFail = Td, this.stencilZPass = Td, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.allowOverride = !0, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
   }
   get alphaTest() {
      return this._alphaTest
   }
   set alphaTest(e) {
      this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e
   }
   onBeforeRender() {}
   onBeforeCompile() {}
   customProgramCacheKey() {
      return this.onBeforeCompile.toString()
   }
   setValues(e) {
      if (e !== void 0)
         for (const t in e) {
            const i = e[t];
            if (i === void 0) {
               console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
               continue
            }
            const s = this[t];
            if (s === void 0) {
               console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
               continue
            }
            s && s.isColor ? s.set(i) : s && s.isVector3 && i && i.isVector3 ? s.copy(i) : this[t] = i
         }
   }
   toJSON(e) {
      const t = e === void 0 || typeof e == "string";
      t && (e = {
         textures: {},
         images: {}
      });
      const i = {
         metadata: {
            version: 4.6,
            type: "Material",
            generator: "Material.toJSON"
         }
      };
      i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.color && this.color.isColor && (i.color = this.color.getHex()), this.roughness !== void 0 && (i.roughness = this.roughness), this.metalness !== void 0 && (i.metalness = this.metalness), this.sheen !== void 0 && (i.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (i.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (i.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (i.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (i.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (i.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (i.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (i.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (i.shininess = this.shininess), this.clearcoat !== void 0 && (i.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (i.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (i.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (i.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, i.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (i.dispersion = this.dispersion), this.iridescence !== void 0 && (i.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (i.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (i.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (i.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (i.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (i.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (i.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (i.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (i.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (i.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (i.lightMap = this.lightMap.toJSON(e).uuid, i.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (i.aoMap = this.aoMap.toJSON(e).uuid, i.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (i.bumpMap = this.bumpMap.toJSON(e).uuid, i.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (i.normalMap = this.normalMap.toJSON(e).uuid, i.normalMapType = this.normalMapType, i.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (i.displacementMap = this.displacementMap.toJSON(e).uuid, i.displacementScale = this.displacementScale, i.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (i.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (i.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (i.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (i.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (i.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (i.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (i.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (i.combine = this.combine)), this.envMapRotation !== void 0 && (i.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (i.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (i.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (i.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (i.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (i.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (i.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (i.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (i.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (i.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (i.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (i.size = this.size), this.shadowSide !== null && (i.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (i.sizeAttenuation = this.sizeAttenuation), this.blending !== Fd && (i.blending = this.blending), this.side !== Hu && (i.side = this.side), this.vertexColors === !0 && (i.vertexColors = !0), this.opacity < 1 && (i.opacity = this.opacity), this.transparent === !0 && (i.transparent = !0), this.blendSrc !== qb && (i.blendSrc = this.blendSrc), this.blendDst !== Xb && (i.blendDst = this.blendDst), this.blendEquation !== jf && (i.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (i.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (i.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (i.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (i.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (i.blendAlpha = this.blendAlpha), this.depthFunc !== ih && (i.depthFunc = this.depthFunc), this.depthTest === !1 && (i.depthTest = this.depthTest), this.depthWrite === !1 && (i.depthWrite = this.depthWrite), this.colorWrite === !1 && (i.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (i.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== qA && (i.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (i.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (i.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== Td && (i.stencilFail = this.stencilFail), this.stencilZFail !== Td && (i.stencilZFail = this.stencilZFail), this.stencilZPass !== Td && (i.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (i.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (i.rotation = this.rotation), this.polygonOffset === !0 && (i.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (i.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (i.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (i.linewidth = this.linewidth), this.dashSize !== void 0 && (i.dashSize = this.dashSize), this.gapSize !== void 0 && (i.gapSize = this.gapSize), this.scale !== void 0 && (i.scale = this.scale), this.dithering === !0 && (i.dithering = !0), this.alphaTest > 0 && (i.alphaTest = this.alphaTest), this.alphaHash === !0 && (i.alphaHash = !0), this.alphaToCoverage === !0 && (i.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (i.premultipliedAlpha = !0), this.forceSinglePass === !0 && (i.forceSinglePass = !0), this.wireframe === !0 && (i.wireframe = !0), this.wireframeLinewidth > 1 && (i.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (i.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (i.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (i.flatShading = !0), this.visible === !1 && (i.visible = !1), this.toneMapped === !1 && (i.toneMapped = !1), this.fog === !1 && (i.fog = !1), Object.keys(this.userData).length > 0 && (i.userData = this.userData);

      function s(r) {
         const a = [];
         for (const l in r) {
            const c = r[l];
            delete c.metadata, a.push(c)
         }
         return a
      }
      if (t) {
         const r = s(e.textures),
            a = s(e.images);
         r.length > 0 && (i.textures = r), a.length > 0 && (i.images = a)
      }
      return i
   }
   clone() {
      return new this.constructor().copy(this)
   }
   copy(e) {
      this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
      const t = e.clippingPlanes;
      let i = null;
      if (t !== null) {
         const s = t.length;
         i = new Array(s);
         for (let r = 0; r !== s; ++r) i[r] = t[r].clone()
      }
      return this.clippingPlanes = i, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this
   }
   dispose() {
      this.dispatchEvent({
         type: "dispose"
      })
   }
   set needsUpdate(e) {
      e === !0 && this.version++
   }
   onBuild() {
      console.warn("Material: onBuild() has been removed.")
   }
}
class Fc extends sr {
   constructor(e) {
      super(), this.isMeshBasicMaterial = !0, this.type = "MeshBasicMaterial", this.color = new dt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new go, this.combine = fx, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e)
   }
   copy(e) {
      return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this
   }
}
const Ec = F6();

function F6() {
   const n = new ArrayBuffer(4),
      e = new Float32Array(n),
      t = new Uint32Array(n),
      i = new Uint32Array(512),
      s = new Uint32Array(512);
   for (let c = 0; c < 256; ++c) {
      const h = c - 127;
      h < -27 ? (i[c] = 0, i[c | 256] = 32768, s[c] = 24, s[c | 256] = 24) : h < -14 ? (i[c] = 1024 >> -h - 14, i[c | 256] = 1024 >> -h - 14 | 32768, s[c] = -h - 1, s[c | 256] = -h - 1) : h <= 15 ? (i[c] = h + 15 << 10, i[c | 256] = h + 15 << 10 | 32768, s[c] = 13, s[c | 256] = 13) : h < 128 ? (i[c] = 31744, i[c | 256] = 64512, s[c] = 24, s[c | 256] = 24) : (i[c] = 31744, i[c | 256] = 64512, s[c] = 13, s[c | 256] = 13)
   }
   const r = new Uint32Array(2048),
      a = new Uint32Array(64),
      l = new Uint32Array(64);
   for (let c = 1; c < 1024; ++c) {
      let h = c << 13,
         m = 0;
      for (;
         (h & 8388608) === 0;) h <<= 1, m -= 8388608;
      h &= -8388609, m += 947912704, r[c] = h | m
   }
   for (let c = 1024; c < 2048; ++c) r[c] = 939524096 + (c - 1024 << 13);
   for (let c = 1; c < 31; ++c) a[c] = c << 23;
   a[31] = 1199570944, a[32] = 2147483648;
   for (let c = 33; c < 63; ++c) a[c] = 2147483648 + (c - 32 << 23);
   a[63] = 3347054592;
   for (let c = 1; c < 64; ++c) c !== 32 && (l[c] = 1024);
   return {
      floatView: e,
      uint32View: t,
      baseTable: i,
      shiftTable: s,
      mantissaTable: r,
      exponentTable: a,
      offsetTable: l
   }
}

function Na(n) {
   Math.abs(n) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), n = on(n, -65504, 65504), Ec.floatView[0] = n;
   const e = Ec.uint32View[0],
      t = e >> 23 & 511;
   return Ec.baseTable[t] + ((e & 8388607) >> Ec.shiftTable[t])
}

function w0(n) {
   const e = n >> 10;
   return Ec.uint32View[0] = Ec.mantissaTable[Ec.offsetTable[e] + (n & 1023)] + Ec.exponentTable[e], Ec.floatView[0]
}
class H6 {
   static toHalfFloat(e) {
      return Na(e)
   }
   static fromHalfFloat(e) {
      return w0(e)
   }
}
const Es = new ee,
   pS = new Fe;
let V6 = 0;
class oi {
   constructor(e, t, i = !1) {
      if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
      this.isBufferAttribute = !0, Object.defineProperty(this, "id", {
         value: V6++
      }), this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = i, this.usage = Dy, this.updateRanges = [], this.gpuType = ha, this.version = 0
   }
   onUploadCallback() {}
   set needsUpdate(e) {
      e === !0 && this.version++
   }
   setUsage(e) {
      return this.usage = e, this
   }
   addUpdateRange(e, t) {
      this.updateRanges.push({
         start: e,
         count: t
      })
   }
   clearUpdateRanges() {
      this.updateRanges.length = 0
   }
   copy(e) {
      return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this
   }
   copyAt(e, t, i) {
      e *= this.itemSize, i *= t.itemSize;
      for (let s = 0, r = this.itemSize; s < r; s++) this.array[e + s] = t.array[i + s];
      return this
   }
   copyArray(e) {
      return this.array.set(e), this
   }
   applyMatrix3(e) {
      if (this.itemSize === 2)
         for (let t = 0, i = this.count; t < i; t++) pS.fromBufferAttribute(this, t), pS.applyMatrix3(e), this.setXY(t, pS.x, pS.y);
      else if (this.itemSize === 3)
         for (let t = 0, i = this.count; t < i; t++) Es.fromBufferAttribute(this, t), Es.applyMatrix3(e), this.setXYZ(t, Es.x, Es.y, Es.z);
      return this
   }
   applyMatrix4(e) {
      for (let t = 0, i = this.count; t < i; t++) Es.fromBufferAttribute(this, t), Es.applyMatrix4(e), this.setXYZ(t, Es.x, Es.y, Es.z);
      return this
   }
   applyNormalMatrix(e) {
      for (let t = 0, i = this.count; t < i; t++) Es.fromBufferAttribute(this, t), Es.applyNormalMatrix(e), this.setXYZ(t, Es.x, Es.y, Es.z);
      return this
   }
   transformDirection(e) {
      for (let t = 0, i = this.count; t < i; t++) Es.fromBufferAttribute(this, t), Es.transformDirection(e), this.setXYZ(t, Es.x, Es.y, Es.z);
      return this
   }
   set(e, t = 0) {
      return this.array.set(e, t), this
   }
   getComponent(e, t) {
      let i = this.array[e * this.itemSize + t];
      return this.normalized && (i = ua(i, this.array)), i
   }
   setComponent(e, t, i) {
      return this.normalized && (i = hn(i, this.array)), this.array[e * this.itemSize + t] = i, this
   }
   getX(e) {
      let t = this.array[e * this.itemSize];
      return this.normalized && (t = ua(t, this.array)), t
   }
   setX(e, t) {
      return this.normalized && (t = hn(t, this.array)), this.array[e * this.itemSize] = t, this
   }
   getY(e) {
      let t = this.array[e * this.itemSize + 1];
      return this.normalized && (t = ua(t, this.array)), t
   }
   setY(e, t) {
      return this.normalized && (t = hn(t, this.array)), this.array[e * this.itemSize + 1] = t, this
   }
   getZ(e) {
      let t = this.array[e * this.itemSize + 2];
      return this.normalized && (t = ua(t, this.array)), t
   }
   setZ(e, t) {
      return this.normalized && (t = hn(t, this.array)), this.array[e * this.itemSize + 2] = t, this
   }
   getW(e) {
      let t = this.array[e * this.itemSize + 3];
      return this.normalized && (t = ua(t, this.array)), t
   }
   setW(e, t) {
      return this.normalized && (t = hn(t, this.array)), this.array[e * this.itemSize + 3] = t, this
   }
   setXY(e, t, i) {
      return e *= this.itemSize, this.normalized && (t = hn(t, this.array), i = hn(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this
   }
   setXYZ(e, t, i, s) {
      return e *= this.itemSize, this.normalized && (t = hn(t, this.array), i = hn(i, this.array), s = hn(s, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = s, this
   }
   setXYZW(e, t, i, s, r) {
      return e *= this.itemSize, this.normalized && (t = hn(t, this.array), i = hn(i, this.array), s = hn(s, this.array), r = hn(r, this.array)), this.array[e + 0] = t, this.array[e + 1] = i, this.array[e + 2] = s, this.array[e + 3] = r, this
   }
   onUpload(e) {
      return this.onUploadCallback = e, this
   }
   clone() {
      return new this.constructor(this.array, this.itemSize).copy(this)
   }
   toJSON() {
      const e = {
         itemSize: this.itemSize,
         type: this.array.constructor.name,
         array: Array.from(this.array),
         normalized: this.normalized
      };
      return this.name !== "" && (e.name = this.name), this.usage !== Dy && (e.usage = this.usage), e
   }
}
class G6 extends oi {
   constructor(e, t, i) {
      super(new Int8Array(e), t, i)
   }
}
class k6 extends oi {
   constructor(e, t, i) {
      super(new Uint8Array(e), t, i)
   }
}
class j6 extends oi {
   constructor(e, t, i) {
      super(new Uint8ClampedArray(e), t, i)
   }
}
class q6 extends oi {
   constructor(e, t, i) {
      super(new Int16Array(e), t, i)
   }
}
class NR extends oi {
   constructor(e, t, i) {
      super(new Uint16Array(e), t, i)
   }
}
class X6 extends oi {
   constructor(e, t, i) {
      super(new Int32Array(e), t, i)
   }
}
class OR extends oi {
   constructor(e, t, i) {
      super(new Uint32Array(e), t, i)
   }
}
class W6 extends oi {
   constructor(e, t, i) {
      super(new Uint16Array(e), t, i), this.isFloat16BufferAttribute = !0
   }
   getX(e) {
      let t = w0(this.array[e * this.itemSize]);
      return this.normalized && (t = ua(t, this.array)), t
   }
   setX(e, t) {
      return this.normalized && (t = hn(t, this.array)), this.array[e * this.itemSize] = Na(t), this
   }
   getY(e) {
      let t = w0(this.array[e * this.itemSize + 1]);
      return this.normalized && (t = ua(t, this.array)), t
   }
   setY(e, t) {
      return this.normalized && (t = hn(t, this.array)), this.array[e * this.itemSize + 1] = Na(t), this
   }
   getZ(e) {
      let t = w0(this.array[e * this.itemSize + 2]);
      return this.normalized && (t = ua(t, this.array)), t
   }
   setZ(e, t) {
      return this.normalized && (t = hn(t, this.array)), this.array[e * this.itemSize + 2] = Na(t), this
   }
   getW(e) {
      let t = w0(this.array[e * this.itemSize + 3]);
      return this.normalized && (t = ua(t, this.array)), t
   }
   setW(e, t) {
      return this.normalized && (t = hn(t, this.array)), this.array[e * this.itemSize + 3] = Na(t), this
   }
   setXY(e, t, i) {
      return e *= this.itemSize, this.normalized && (t = hn(t, this.array), i = hn(i, this.array)), this.array[e + 0] = Na(t), this.array[e + 1] = Na(i), this
   }
   setXYZ(e, t, i, s) {
      return e *= this.itemSize, this.normalized && (t = hn(t, this.array), i = hn(i, this.array), s = hn(s, this.array)), this.array[e + 0] = Na(t), this.array[e + 1] = Na(i), this.array[e + 2] = Na(s), this
   }
   setXYZW(e, t, i, s, r) {
      return e *= this.itemSize, this.normalized && (t = hn(t, this.array), i = hn(i, this.array), s = hn(s, this.array), r = hn(r, this.array)), this.array[e + 0] = Na(t), this.array[e + 1] = Na(i), this.array[e + 2] = Na(s), this.array[e + 3] = Na(r), this
   }
}
class Ct extends oi {
   constructor(e, t, i) {
      super(new Float32Array(e), t, i)
   }
}
let Y6 = 0;
const Vo = new Zt,
   fM = new Wn,
   Em = new ee,
   so = new pa,
   c0 = new pa,
   $s = new ee;
class pn extends xo {
   constructor() {
      super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", {
         value: Y6++
      }), this.uuid = po(), this.name = "", this.type = "BufferGeometry", this.index = null, this.indirect = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
         start: 0,
         count: 1 / 0
      }, this.userData = {}
   }
   getIndex() {
      return this.index
   }
   setIndex(e) {
      return Array.isArray(e) ? this.index = new(TL(e) ? OR : NR)(e, 1) : this.index = e, this
   }
   setIndirect(e) {
      return this.indirect = e, this
   }
   getIndirect() {
      return this.indirect
   }
   getAttribute(e) {
      return this.attributes[e]
   }
   setAttribute(e, t) {
      return this.attributes[e] = t, this
   }
   deleteAttribute(e) {
      return delete this.attributes[e], this
   }
   hasAttribute(e) {
      return this.attributes[e] !== void 0
   }
   addGroup(e, t, i = 0) {
      this.groups.push({
         start: e,
         count: t,
         materialIndex: i
      })
   }
   clearGroups() {
      this.groups = []
   }
   setDrawRange(e, t) {
      this.drawRange.start = e, this.drawRange.count = t
   }
   applyMatrix4(e) {
      const t = this.attributes.position;
      t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0);
      const i = this.attributes.normal;
      if (i !== void 0) {
         const r = new un().getNormalMatrix(e);
         i.applyNormalMatrix(r), i.needsUpdate = !0
      }
      const s = this.attributes.tangent;
      return s !== void 0 && (s.transformDirection(e), s.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this
   }
   applyQuaternion(e) {
      return Vo.makeRotationFromQuaternion(e), this.applyMatrix4(Vo), this
   }
   rotateX(e) {
      return Vo.makeRotationX(e), this.applyMatrix4(Vo), this
   }
   rotateY(e) {
      return Vo.makeRotationY(e), this.applyMatrix4(Vo), this
   }
   rotateZ(e) {
      return Vo.makeRotationZ(e), this.applyMatrix4(Vo), this
   }
   translate(e, t, i) {
      return Vo.makeTranslation(e, t, i), this.applyMatrix4(Vo), this
   }
   scale(e, t, i) {
      return Vo.makeScale(e, t, i), this.applyMatrix4(Vo), this
   }
   lookAt(e) {
      return fM.lookAt(e), fM.updateMatrix(), this.applyMatrix4(fM.matrix), this
   }
   center() {
      return this.computeBoundingBox(), this.boundingBox.getCenter(Em).negate(), this.translate(Em.x, Em.y, Em.z), this
   }
   setFromPoints(e) {
      const t = this.getAttribute("position");
      if (t === void 0) {
         const i = [];
         for (let s = 0, r = e.length; s < r; s++) {
            const a = e[s];
            i.push(a.x, a.y, a.z || 0)
         }
         this.setAttribute("position", new Ct(i, 3))
      } else {
         const i = Math.min(e.length, t.count);
         for (let s = 0; s < i; s++) {
            const r = e[s];
            t.setXYZ(s, r.x, r.y, r.z || 0)
         }
         e.length > t.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."), t.needsUpdate = !0
      }
      return this
   }
   computeBoundingBox() {
      this.boundingBox === null && (this.boundingBox = new pa);
      const e = this.attributes.position,
         t = this.morphAttributes.position;
      if (e && e.isGLBufferAttribute) {
         console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(new ee(-1 / 0, -1 / 0, -1 / 0), new ee(1 / 0, 1 / 0, 1 / 0));
         return
      }
      if (e !== void 0) {
         if (this.boundingBox.setFromBufferAttribute(e), t)
            for (let i = 0, s = t.length; i < s; i++) {
               const r = t[i];
               so.setFromBufferAttribute(r), this.morphTargetsRelative ? ($s.addVectors(this.boundingBox.min, so.min), this.boundingBox.expandByPoint($s), $s.addVectors(this.boundingBox.max, so.max), this.boundingBox.expandByPoint($s)) : (this.boundingBox.expandByPoint(so.min), this.boundingBox.expandByPoint(so.max))
            }
      } else this.boundingBox.makeEmpty();
      (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
   }
   computeBoundingSphere() {
      this.boundingSphere === null && (this.boundingSphere = new zr);
      const e = this.attributes.position,
         t = this.morphAttributes.position;
      if (e && e.isGLBufferAttribute) {
         console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new ee, 1 / 0);
         return
      }
      if (e) {
         const i = this.boundingSphere.center;
         if (so.setFromBufferAttribute(e), t)
            for (let r = 0, a = t.length; r < a; r++) {
               const l = t[r];
               c0.setFromBufferAttribute(l), this.morphTargetsRelative ? ($s.addVectors(so.min, c0.min), so.expandByPoint($s), $s.addVectors(so.max, c0.max), so.expandByPoint($s)) : (so.expandByPoint(c0.min), so.expandByPoint(c0.max))
            }
         so.getCenter(i);
         let s = 0;
         for (let r = 0, a = e.count; r < a; r++) $s.fromBufferAttribute(e, r), s = Math.max(s, i.distanceToSquared($s));
         if (t)
            for (let r = 0, a = t.length; r < a; r++) {
               const l = t[r],
                  c = this.morphTargetsRelative;
               for (let h = 0, m = l.count; h < m; h++) $s.fromBufferAttribute(l, h), c && (Em.fromBufferAttribute(e, h), $s.add(Em)), s = Math.max(s, i.distanceToSquared($s))
            }
         this.boundingSphere.radius = Math.sqrt(s), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
      }
   }
   computeTangents() {
      const e = this.index,
         t = this.attributes;
      if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
         console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
         return
      }
      const i = t.position,
         s = t.normal,
         r = t.uv;
      this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new oi(new Float32Array(4 * i.count), 4));
      const a = this.getAttribute("tangent"),
         l = [],
         c = [];
      for (let I = 0; I < i.count; I++) l[I] = new ee, c[I] = new ee;
      const h = new ee,
         m = new ee,
         g = new ee,
         v = new Fe,
         x = new Fe,
         S = new Fe,
         E = new ee,
         T = new ee;

      function b(I, O, P) {
         h.fromBufferAttribute(i, I), m.fromBufferAttribute(i, O), g.fromBufferAttribute(i, P), v.fromBufferAttribute(r, I), x.fromBufferAttribute(r, O), S.fromBufferAttribute(r, P), m.sub(h), g.sub(h), x.sub(v), S.sub(v);
         const q = 1 / (x.x * S.y - S.x * x.y);
         isFinite(q) && (E.copy(m).multiplyScalar(S.y).addScaledVector(g, -x.y).multiplyScalar(q), T.copy(g).multiplyScalar(x.x).addScaledVector(m, -S.x).multiplyScalar(q), l[I].add(E), l[O].add(E), l[P].add(E), c[I].add(T), c[O].add(T), c[P].add(T))
      }
      let w = this.groups;
      w.length === 0 && (w = [{
         start: 0,
         count: e.count
      }]);
      for (let I = 0, O = w.length; I < O; ++I) {
         const P = w[I],
            q = P.start,
            Q = P.count;
         for (let $ = q, ae = q + Q; $ < ae; $ += 3) b(e.getX($ + 0), e.getX($ + 1), e.getX($ + 2))
      }
      const C = new ee,
         N = new ee,
         U = new ee,
         z = new ee;

      function B(I) {
         U.fromBufferAttribute(s, I), z.copy(U);
         const O = l[I];
         C.copy(O), C.sub(U.multiplyScalar(U.dot(O))).normalize(), N.crossVectors(z, O);
         const q = N.dot(c[I]) < 0 ? -1 : 1;
         a.setXYZW(I, C.x, C.y, C.z, q)
      }
      for (let I = 0, O = w.length; I < O; ++I) {
         const P = w[I],
            q = P.start,
            Q = P.count;
         for (let $ = q, ae = q + Q; $ < ae; $ += 3) B(e.getX($ + 0)), B(e.getX($ + 1)), B(e.getX($ + 2))
      }
   }
   computeVertexNormals() {
      const e = this.index,
         t = this.getAttribute("position");
      if (t !== void 0) {
         let i = this.getAttribute("normal");
         if (i === void 0) i = new oi(new Float32Array(t.count * 3), 3), this.setAttribute("normal", i);
         else
            for (let v = 0, x = i.count; v < x; v++) i.setXYZ(v, 0, 0, 0);
         const s = new ee,
            r = new ee,
            a = new ee,
            l = new ee,
            c = new ee,
            h = new ee,
            m = new ee,
            g = new ee;
         if (e)
            for (let v = 0, x = e.count; v < x; v += 3) {
               const S = e.getX(v + 0),
                  E = e.getX(v + 1),
                  T = e.getX(v + 2);
               s.fromBufferAttribute(t, S), r.fromBufferAttribute(t, E), a.fromBufferAttribute(t, T), m.subVectors(a, r), g.subVectors(s, r), m.cross(g), l.fromBufferAttribute(i, S), c.fromBufferAttribute(i, E), h.fromBufferAttribute(i, T), l.add(m), c.add(m), h.add(m), i.setXYZ(S, l.x, l.y, l.z), i.setXYZ(E, c.x, c.y, c.z), i.setXYZ(T, h.x, h.y, h.z)
            } else
               for (let v = 0, x = t.count; v < x; v += 3) s.fromBufferAttribute(t, v + 0), r.fromBufferAttribute(t, v + 1), a.fromBufferAttribute(t, v + 2), m.subVectors(a, r), g.subVectors(s, r), m.cross(g), i.setXYZ(v + 0, m.x, m.y, m.z), i.setXYZ(v + 1, m.x, m.y, m.z), i.setXYZ(v + 2, m.x, m.y, m.z);
         this.normalizeNormals(), i.needsUpdate = !0
      }
   }
   normalizeNormals() {
      const e = this.attributes.normal;
      for (let t = 0, i = e.count; t < i; t++) $s.fromBufferAttribute(e, t), $s.normalize(), e.setXYZ(t, $s.x, $s.y, $s.z)
   }
   toNonIndexed() {
      function e(l, c) {
         const h = l.array,
            m = l.itemSize,
            g = l.normalized,
            v = new h.constructor(c.length * m);
         let x = 0,
            S = 0;
         for (let E = 0, T = c.length; E < T; E++) {
            l.isInterleavedBufferAttribute ? x = c[E] * l.data.stride + l.offset : x = c[E] * m;
            for (let b = 0; b < m; b++) v[S++] = h[x++]
         }
         return new oi(v, m, g)
      }
      if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
      const t = new pn,
         i = this.index.array,
         s = this.attributes;
      for (const l in s) {
         const c = s[l],
            h = e(c, i);
         t.setAttribute(l, h)
      }
      const r = this.morphAttributes;
      for (const l in r) {
         const c = [],
            h = r[l];
         for (let m = 0, g = h.length; m < g; m++) {
            const v = h[m],
               x = e(v, i);
            c.push(x)
         }
         t.morphAttributes[l] = c
      }
      t.morphTargetsRelative = this.morphTargetsRelative;
      const a = this.groups;
      for (let l = 0, c = a.length; l < c; l++) {
         const h = a[l];
         t.addGroup(h.start, h.count, h.materialIndex)
      }
      return t
   }
   toJSON() {
      const e = {
         metadata: {
            version: 4.6,
            type: "BufferGeometry",
            generator: "BufferGeometry.toJSON"
         }
      };
      if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
         const c = this.parameters;
         for (const h in c) c[h] !== void 0 && (e[h] = c[h]);
         return e
      }
      e.data = {
         attributes: {}
      };
      const t = this.index;
      t !== null && (e.data.index = {
         type: t.array.constructor.name,
         array: Array.prototype.slice.call(t.array)
      });
      const i = this.attributes;
      for (const c in i) {
         const h = i[c];
         e.data.attributes[c] = h.toJSON(e.data)
      }
      const s = {};
      let r = !1;
      for (const c in this.morphAttributes) {
         const h = this.morphAttributes[c],
            m = [];
         for (let g = 0, v = h.length; g < v; g++) {
            const x = h[g];
            m.push(x.toJSON(e.data))
         }
         m.length > 0 && (s[c] = m, r = !0)
      }
      r && (e.data.morphAttributes = s, e.data.morphTargetsRelative = this.morphTargetsRelative);
      const a = this.groups;
      a.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(a)));
      const l = this.boundingSphere;
      return l !== null && (e.data.boundingSphere = {
         center: l.center.toArray(),
         radius: l.radius
      }), e
   }
   clone() {
      return new this.constructor().copy(this)
   }
   copy(e) {
      this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
      const t = {};
      this.name = e.name;
      const i = e.index;
      i !== null && this.setIndex(i.clone());
      const s = e.attributes;
      for (const h in s) {
         const m = s[h];
         this.setAttribute(h, m.clone(t))
      }
      const r = e.morphAttributes;
      for (const h in r) {
         const m = [],
            g = r[h];
         for (let v = 0, x = g.length; v < x; v++) m.push(g[v].clone(t));
         this.morphAttributes[h] = m
      }
      this.morphTargetsRelative = e.morphTargetsRelative;
      const a = e.groups;
      for (let h = 0, m = a.length; h < m; h++) {
         const g = a[h];
         this.addGroup(g.start, g.count, g.materialIndex)
      }
      const l = e.boundingBox;
      l !== null && (this.boundingBox = l.clone());
      const c = e.boundingSphere;
      return c !== null && (this.boundingSphere = c.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this
   }
   dispose() {
      this.dispatchEvent({
         type: "dispose"
      })
   }
}
const LD = new Zt,
   ud = new Pg,
   mS = new zr,
   BD = new ee,
   gS = new ee,
   vS = new ee,
   yS = new ee,
   hM = new ee,
   xS = new ee,
   zD = new ee,
   _S = new ee;
class ds extends Wn {
   constructor(e = new pn, t = new Fc) {
      super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets()
   }
   copy(e, t) {
      return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this
   }
   updateMorphTargets() {
      const t = this.geometry.morphAttributes,
         i = Object.keys(t);
      if (i.length > 0) {
         const s = t[i[0]];
         if (s !== void 0) {
            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
            for (let r = 0, a = s.length; r < a; r++) {
               const l = s[r].name || String(r);
               this.morphTargetInfluences.push(0), this.morphTargetDictionary[l] = r
            }
         }
      }
   }
   getVertexPosition(e, t) {
      const i = this.geometry,
         s = i.attributes.position,
         r = i.morphAttributes.position,
         a = i.morphTargetsRelative;
      t.fromBufferAttribute(s, e);
      const l = this.morphTargetInfluences;
      if (r && l) {
         xS.set(0, 0, 0);
         for (let c = 0, h = r.length; c < h; c++) {
            const m = l[c],
               g = r[c];
            m !== 0 && (hM.fromBufferAttribute(g, e), a ? xS.addScaledVector(hM, m) : xS.addScaledVector(hM.sub(t), m))
         }
         t.add(xS)
      }
      return t
   }
   raycast(e, t) {
      const i = this.geometry,
         s = this.material,
         r = this.matrixWorld;
      s !== void 0 && (i.boundingSphere === null && i.computeBoundingSphere(), mS.copy(i.boundingSphere), mS.applyMatrix4(r), ud.copy(e.ray).recast(e.near), !(mS.containsPoint(ud.origin) === !1 && (ud.intersectSphere(mS, BD) === null || ud.origin.distanceToSquared(BD) > (e.far - e.near) ** 2)) && (LD.copy(r).invert(), ud.copy(e.ray).applyMatrix4(LD), !(i.boundingBox !== null && ud.intersectsBox(i.boundingBox) === !1) && this._computeIntersections(e, t, ud)))
   }
   _computeIntersections(e, t, i) {
      let s;
      const r = this.geometry,
         a = this.material,
         l = r.index,
         c = r.attributes.position,
         h = r.attributes.uv,
         m = r.attributes.uv1,
         g = r.attributes.normal,
         v = r.groups,
         x = r.drawRange;
      if (l !== null)
         if (Array.isArray(a))
            for (let S = 0, E = v.length; S < E; S++) {
               const T = v[S],
                  b = a[T.materialIndex],
                  w = Math.max(T.start, x.start),
                  C = Math.min(l.count, Math.min(T.start + T.count, x.start + x.count));
               for (let N = w, U = C; N < U; N += 3) {
                  const z = l.getX(N),
                     B = l.getX(N + 1),
                     I = l.getX(N + 2);
                  s = SS(this, b, e, i, h, m, g, z, B, I), s && (s.faceIndex = Math.floor(N / 3), s.face.materialIndex = T.materialIndex, t.push(s))
               }
            } else {
               const S = Math.max(0, x.start),
                  E = Math.min(l.count, x.start + x.count);
               for (let T = S, b = E; T < b; T += 3) {
                  const w = l.getX(T),
                     C = l.getX(T + 1),
                     N = l.getX(T + 2);
                  s = SS(this, a, e, i, h, m, g, w, C, N), s && (s.faceIndex = Math.floor(T / 3), t.push(s))
               }
            } else if (c !== void 0)
               if (Array.isArray(a))
                  for (let S = 0, E = v.length; S < E; S++) {
                     const T = v[S],
                        b = a[T.materialIndex],
                        w = Math.max(T.start, x.start),
                        C = Math.min(c.count, Math.min(T.start + T.count, x.start + x.count));
                     for (let N = w, U = C; N < U; N += 3) {
                        const z = N,
                           B = N + 1,
                           I = N + 2;
                        s = SS(this, b, e, i, h, m, g, z, B, I), s && (s.faceIndex = Math.floor(N / 3), s.face.materialIndex = T.materialIndex, t.push(s))
                     }
                  } else {
                     const S = Math.max(0, x.start),
                        E = Math.min(c.count, x.start + x.count);
                     for (let T = S, b = E; T < b; T += 3) {
                        const w = T,
                           C = T + 1,
                           N = T + 2;
                        s = SS(this, a, e, i, h, m, g, w, C, N), s && (s.faceIndex = Math.floor(T / 3), t.push(s))
                     }
                  }
   }
}

function K6(n, e, t, i, s, r, a, l) {
   let c;
   if (e.side === Ds ? c = i.intersectTriangle(a, r, s, !0, l) : c = i.intersectTriangle(s, r, a, e.side === Hu, l), c === null) return null;
   _S.copy(l), _S.applyMatrix4(n.matrixWorld);
   const h = t.ray.origin.distanceTo(_S);
   return h < t.near || h > t.far ? null : {
      distance: h,
      point: _S.clone(),
      object: n
   }
}

function SS(n, e, t, i, s, r, a, l, c, h) {
   n.getVertexPosition(l, gS), n.getVertexPosition(c, vS), n.getVertexPosition(h, yS);
   const m = K6(n, e, t, i, gS, vS, yS, zD);
   if (m) {
      const g = new ee;
      Pa.getBarycoord(zD, gS, vS, yS, g), s && (m.uv = Pa.getInterpolatedAttribute(s, l, c, h, g, new Fe)), r && (m.uv1 = Pa.getInterpolatedAttribute(r, l, c, h, g, new Fe)), a && (m.normal = Pa.getInterpolatedAttribute(a, l, c, h, g, new ee), m.normal.dot(i.direction) > 0 && m.normal.multiplyScalar(-1));
      const v = {
         a: l,
         b: c,
         c: h,
         normal: new ee,
         materialIndex: 0
      };
      Pa.getNormal(gS, vS, yS, v.normal), m.face = v, m.barycoord = g
   }
   return m
}
class up extends pn {
   constructor(e = 1, t = 1, i = 1, s = 1, r = 1, a = 1) {
      super(), this.type = "BoxGeometry", this.parameters = {
         width: e,
         height: t,
         depth: i,
         widthSegments: s,
         heightSegments: r,
         depthSegments: a
      };
      const l = this;
      s = Math.floor(s), r = Math.floor(r), a = Math.floor(a);
      const c = [],
         h = [],
         m = [],
         g = [];
      let v = 0,
         x = 0;
      S("z", "y", "x", -1, -1, i, t, e, a, r, 0), S("z", "y", "x", 1, -1, i, t, -e, a, r, 1), S("x", "z", "y", 1, 1, e, i, t, s, a, 2), S("x", "z", "y", 1, -1, e, i, -t, s, a, 3), S("x", "y", "z", 1, -1, e, t, i, s, r, 4), S("x", "y", "z", -1, -1, e, t, -i, s, r, 5), this.setIndex(c), this.setAttribute("position", new Ct(h, 3)), this.setAttribute("normal", new Ct(m, 3)), this.setAttribute("uv", new Ct(g, 2));

      function S(E, T, b, w, C, N, U, z, B, I, O) {
         const P = N / B,
            q = U / I,
            Q = N / 2,
            $ = U / 2,
            ae = z / 2,
            fe = B + 1,
            k = I + 1;
         let Z = 0,
            J = 0;
         const pe = new ee;
         for (let F = 0; F < k; F++) {
            const ie = F * q - $;
            for (let ye = 0; ye < fe; ye++) {
               const we = ye * P - Q;
               pe[E] = we * w, pe[T] = ie * C, pe[b] = ae, h.push(pe.x, pe.y, pe.z), pe[E] = 0, pe[T] = 0, pe[b] = z > 0 ? 1 : -1, m.push(pe.x, pe.y, pe.z), g.push(ye / B), g.push(1 - F / I), Z += 1
            }
         }
         for (let F = 0; F < I; F++)
            for (let ie = 0; ie < B; ie++) {
               const ye = v + ie + fe * F,
                  we = v + ie + fe * (F + 1),
                  oe = v + (ie + 1) + fe * (F + 1),
                  be = v + (ie + 1) + fe * F;
               c.push(ye, we, be), c.push(we, oe, be), J += 6
            }
         l.addGroup(x, J, O), x += J, v += Z
      }
   }
   copy(e) {
      return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
   }
   static fromJSON(e) {
      return new up(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments)
   }
}

function pg(n) {
   const e = {};
   for (const t in n) {
      e[t] = {};
      for (const i in n[t]) {
         const s = n[t][i];
         s && (s.isColor || s.isMatrix3 || s.isMatrix4 || s.isVector2 || s.isVector3 || s.isVector4 || s.isTexture || s.isQuaternion) ? s.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[t][i] = null) : e[t][i] = s.clone() : Array.isArray(s) ? e[t][i] = s.slice() : e[t][i] = s
      }
   }
   return e
}

function sa(n) {
   const e = {};
   for (let t = 0; t < n.length; t++) {
      const i = pg(n[t]);
      for (const s in i) e[s] = i[s]
   }
   return e
}

function Z6(n) {
   const e = [];
   for (let t = 0; t < n.length; t++) e.push(n[t].clone());
   return e
}

function wL(n) {
   const e = n.getRenderTarget();
   return e === null ? n.outputColorSpace : e.isXRRenderTarget === !0 ? e.texture.colorSpace : Vn.workingColorSpace
}
const RL = {
   clone: pg,
   merge: sa
};
var Q6 = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
   J6 = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class gs extends sr {
   constructor(e) {
      super(), this.isShaderMaterial = !0, this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = Q6, this.fragmentShader = J6, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
         clipCullDistance: !1,
         multiDraw: !1
      }, this.defaultAttributeValues = {
         color: [1, 1, 1],
         uv: [0, 0],
         uv1: [0, 0]
      }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e)
   }
   copy(e) {
      return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = pg(e.uniforms), this.uniformsGroups = Z6(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this
   }
   toJSON(e) {
      const t = super.toJSON(e);
      t.glslVersion = this.glslVersion, t.uniforms = {};
      for (const s in this.uniforms) {
         const a = this.uniforms[s].value;
         a && a.isTexture ? t.uniforms[s] = {
            type: "t",
            value: a.toJSON(e).uuid
         } : a && a.isColor ? t.uniforms[s] = {
            type: "c",
            value: a.getHex()
         } : a && a.isVector2 ? t.uniforms[s] = {
            type: "v2",
            value: a.toArray()
         } : a && a.isVector3 ? t.uniforms[s] = {
            type: "v3",
            value: a.toArray()
         } : a && a.isVector4 ? t.uniforms[s] = {
            type: "v4",
            value: a.toArray()
         } : a && a.isMatrix3 ? t.uniforms[s] = {
            type: "m3",
            value: a.toArray()
         } : a && a.isMatrix4 ? t.uniforms[s] = {
            type: "m4",
            value: a.toArray()
         } : t.uniforms[s] = {
            value: a
         }
      }
      Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping;
      const i = {};
      for (const s in this.extensions) this.extensions[s] === !0 && (i[s] = !0);
      return Object.keys(i).length > 0 && (t.extensions = i), t
   }
}
class px extends Wn {
   constructor() {
      super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new Zt, this.projectionMatrix = new Zt, this.projectionMatrixInverse = new Zt, this.coordinateSystem = zl
   }
   copy(e, t) {
      return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this
   }
   getWorldDirection(e) {
      return super.getWorldDirection(e).negate()
   }
   updateMatrixWorld(e) {
      super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
   }
   updateWorldMatrix(e, t) {
      super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
   }
   clone() {
      return new this.constructor().copy(this)
   }
}
const zf = new ee,
   ID = new Fe,
   FD = new Fe;
class Cs extends px {
   constructor(e = 50, t = 1, i = .1, s = 2e3) {
      super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = i, this.far = s, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
   }
   copy(e, t) {
      return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this
   }
   setFocalLength(e) {
      const t = .5 * this.getFilmHeight() / e;
      this.fov = hg * 2 * Math.atan(t), this.updateProjectionMatrix()
   }
   getFocalLength() {
      const e = Math.tan(Hd * .5 * this.fov);
      return .5 * this.getFilmHeight() / e
   }
   getEffectiveFOV() {
      return hg * 2 * Math.atan(Math.tan(Hd * .5 * this.fov) / this.zoom)
   }
   getFilmWidth() {
      return this.filmGauge * Math.min(this.aspect, 1)
   }
   getFilmHeight() {
      return this.filmGauge / Math.max(this.aspect, 1)
   }
   getViewBounds(e, t, i) {
      zf.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse), t.set(zf.x, zf.y).multiplyScalar(-e / zf.z), zf.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse), i.set(zf.x, zf.y).multiplyScalar(-e / zf.z)
   }
   getViewSize(e, t) {
      return this.getViewBounds(e, ID, FD), t.subVectors(FD, ID)
   }
   setViewOffset(e, t, i, s, r, a) {
      this.aspect = e / t, this.view === null && (this.view = {
         enabled: !0,
         fullWidth: 1,
         fullHeight: 1,
         offsetX: 0,
         offsetY: 0,
         width: 1,
         height: 1
      }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = s, this.view.width = r, this.view.height = a, this.updateProjectionMatrix()
   }
   clearViewOffset() {
      this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix()
   }
   updateProjectionMatrix() {
      const e = this.near;
      let t = e * Math.tan(Hd * .5 * this.fov) / this.zoom,
         i = 2 * t,
         s = this.aspect * i,
         r = -.5 * s;
      const a = this.view;
      if (this.view !== null && this.view.enabled) {
         const c = a.fullWidth,
            h = a.fullHeight;
         r += a.offsetX * s / c, t -= a.offsetY * i / h, s *= a.width / c, i *= a.height / h
      }
      const l = this.filmOffset;
      l !== 0 && (r += e * l / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + s, t, t - i, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
   }
   toJSON(e) {
      const t = super.toJSON(e);
      return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t
   }
}
const Mm = -90,
   Am = 1;
class CL extends Wn {
   constructor(e, t, i) {
      super(), this.type = "CubeCamera", this.renderTarget = i, this.coordinateSystem = null, this.activeMipmapLevel = 0;
      const s = new Cs(Mm, Am, e, t);
      s.layers = this.layers, this.add(s);
      const r = new Cs(Mm, Am, e, t);
      r.layers = this.layers, this.add(r);
      const a = new Cs(Mm, Am, e, t);
      a.layers = this.layers, this.add(a);
      const l = new Cs(Mm, Am, e, t);
      l.layers = this.layers, this.add(l);
      const c = new Cs(Mm, Am, e, t);
      c.layers = this.layers, this.add(c);
      const h = new Cs(Mm, Am, e, t);
      h.layers = this.layers, this.add(h)
   }
   updateCoordinateSystem() {
      const e = this.coordinateSystem,
         t = this.children.concat(),
         [i, s, r, a, l, c] = t;
      for (const h of t) this.remove(h);
      if (e === zl) i.up.set(0, 1, 0), i.lookAt(1, 0, 0), s.up.set(0, 1, 0), s.lookAt(-1, 0, 0), r.up.set(0, 0, -1), r.lookAt(0, 1, 0), a.up.set(0, 0, 1), a.lookAt(0, -1, 0), l.up.set(0, 1, 0), l.lookAt(0, 0, 1), c.up.set(0, 1, 0), c.lookAt(0, 0, -1);
      else if (e === Ny) i.up.set(0, -1, 0), i.lookAt(-1, 0, 0), s.up.set(0, -1, 0), s.lookAt(1, 0, 0), r.up.set(0, 0, 1), r.lookAt(0, 1, 0), a.up.set(0, 0, -1), a.lookAt(0, -1, 0), l.up.set(0, -1, 0), l.lookAt(0, 0, 1), c.up.set(0, -1, 0), c.lookAt(0, 0, -1);
      else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
      for (const h of t) this.add(h), h.updateMatrixWorld()
   }
   update(e, t) {
      this.parent === null && this.updateMatrixWorld();
      const {
         renderTarget: i,
         activeMipmapLevel: s
      } = this;
      this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
      const [r, a, l, c, h, m] = this.children, g = e.getRenderTarget(), v = e.getActiveCubeFace(), x = e.getActiveMipmapLevel(), S = e.xr.enabled;
      e.xr.enabled = !1;
      const E = i.texture.generateMipmaps;
      i.texture.generateMipmaps = !1, e.setRenderTarget(i, 0, s), e.render(t, r), e.setRenderTarget(i, 1, s), e.render(t, a), e.setRenderTarget(i, 2, s), e.render(t, l), e.setRenderTarget(i, 3, s), e.render(t, c), e.setRenderTarget(i, 4, s), e.render(t, h), i.texture.generateMipmaps = E, e.setRenderTarget(i, 5, s), e.render(t, m), e.setRenderTarget(g, v, x), e.xr.enabled = S, i.texture.needsPMREMUpdate = !0
   }
}
class mx extends Hi {
   constructor(e = [], t = Uc, i, s, r, a, l, c, h, m) {
      super(e, t, i, s, r, a, l, c, h, m), this.isCubeTexture = !0, this.flipY = !1
   }
   get images() {
      return this.image
   }
   set images(e) {
      this.image = e
   }
}
class DL extends ss {
   constructor(e = 1, t = {}) {
      super(e, e, t), this.isWebGLCubeRenderTarget = !0;
      const i = {
            width: e,
            height: e,
            depth: 1
         },
         s = [i, i, i, i, i, i];
      this.texture = new mx(s, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : Ni
   }
   fromEquirectangularTexture(e, t) {
      this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
      const i = {
            uniforms: {
               tEquirect: {
                  value: null
               }
            },
            vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
            fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
         },
         s = new up(5, 5, 5),
         r = new gs({
            name: "CubemapFromEquirect",
            uniforms: pg(i.uniforms),
            vertexShader: i.vertexShader,
            fragmentShader: i.fragmentShader,
            side: Ds,
            blending: nr
         });
      r.uniforms.tEquirect.value = t;
      const a = new ds(s, r),
         l = t.minFilter;
      return t.minFilter === Du && (t.minFilter = Ni), new CL(1, 10, this).update(e, a), t.minFilter = l, a.geometry.dispose(), a.material.dispose(), this
   }
   clear(e, t = !0, i = !0, s = !0) {
      const r = e.getRenderTarget();
      for (let a = 0; a < 6; a++) e.setRenderTarget(this, a), e.clear(t, i, s);
      e.setRenderTarget(r)
   }
}
class jm extends Wn {
   constructor() {
      super(), this.isGroup = !0, this.type = "Group"
   }
}
const $6 = {
   type: "move"
};
class Sb {
   constructor() {
      this._targetRay = null, this._grip = null, this._hand = null
   }
   getHandSpace() {
      return this._hand === null && (this._hand = new jm, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
         pinching: !1
      }), this._hand
   }
   getTargetRaySpace() {
      return this._targetRay === null && (this._targetRay = new jm, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new ee, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new ee), this._targetRay
   }
   getGripSpace() {
      return this._grip === null && (this._grip = new jm, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new ee, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new ee), this._grip
   }
   dispatchEvent(e) {
      return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this
   }
   connect(e) {
      if (e && e.hand) {
         const t = this._hand;
         if (t)
            for (const i of e.hand.values()) this._getHandJoint(t, i)
      }
      return this.dispatchEvent({
         type: "connected",
         data: e
      }), this
   }
   disconnect(e) {
      return this.dispatchEvent({
         type: "disconnected",
         data: e
      }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this
   }
   update(e, t, i) {
      let s = null,
         r = null,
         a = null;
      const l = this._targetRay,
         c = this._grip,
         h = this._hand;
      if (e && t.session.visibilityState !== "visible-blurred") {
         if (h && e.hand) {
            a = !0;
            for (const E of e.hand.values()) {
               const T = t.getJointPose(E, i),
                  b = this._getHandJoint(h, E);
               T !== null && (b.matrix.fromArray(T.transform.matrix), b.matrix.decompose(b.position, b.rotation, b.scale), b.matrixWorldNeedsUpdate = !0, b.jointRadius = T.radius), b.visible = T !== null
            }
            const m = h.joints["index-finger-tip"],
               g = h.joints["thumb-tip"],
               v = m.position.distanceTo(g.position),
               x = .02,
               S = .005;
            h.inputState.pinching && v > x + S ? (h.inputState.pinching = !1, this.dispatchEvent({
               type: "pinchend",
               handedness: e.handedness,
               target: this
            })) : !h.inputState.pinching && v <= x - S && (h.inputState.pinching = !0, this.dispatchEvent({
               type: "pinchstart",
               handedness: e.handedness,
               target: this
            }))
         } else c !== null && e.gripSpace && (r = t.getPose(e.gripSpace, i), r !== null && (c.matrix.fromArray(r.transform.matrix), c.matrix.decompose(c.position, c.rotation, c.scale), c.matrixWorldNeedsUpdate = !0, r.linearVelocity ? (c.hasLinearVelocity = !0, c.linearVelocity.copy(r.linearVelocity)) : c.hasLinearVelocity = !1, r.angularVelocity ? (c.hasAngularVelocity = !0, c.angularVelocity.copy(r.angularVelocity)) : c.hasAngularVelocity = !1));
         l !== null && (s = t.getPose(e.targetRaySpace, i), s === null && r !== null && (s = r), s !== null && (l.matrix.fromArray(s.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), l.matrixWorldNeedsUpdate = !0, s.linearVelocity ? (l.hasLinearVelocity = !0, l.linearVelocity.copy(s.linearVelocity)) : l.hasLinearVelocity = !1, s.angularVelocity ? (l.hasAngularVelocity = !0, l.angularVelocity.copy(s.angularVelocity)) : l.hasAngularVelocity = !1, this.dispatchEvent($6)))
      }
      return l !== null && (l.visible = s !== null), c !== null && (c.visible = r !== null), h !== null && (h.visible = a !== null), this
   }
   _getHandJoint(e, t) {
      if (e.joints[t.jointName] === void 0) {
         const i = new jm;
         i.matrixAutoUpdate = !1, i.visible = !1, e.joints[t.jointName] = i, e.add(i)
      }
      return e.joints[t.jointName]
   }
}
class fT {
   constructor(e, t = 25e-5) {
      this.isFogExp2 = !0, this.name = "", this.color = new dt(e), this.density = t
   }
   clone() {
      return new fT(this.color, this.density)
   }
   toJSON() {
      return {
         type: "FogExp2",
         name: this.name,
         color: this.color.getHex(),
         density: this.density
      }
   }
}
class hT {
   constructor(e, t = 1, i = 1e3) {
      this.isFog = !0, this.name = "", this.color = new dt(e), this.near = t, this.far = i
   }
   clone() {
      return new hT(this.color, this.near, this.far)
   }
   toJSON() {
      return {
         type: "Fog",
         name: this.name,
         color: this.color.getHex(),
         near: this.near,
         far: this.far
      }
   }
}
class mg extends Wn {
   constructor() {
      super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new go, this.environmentIntensity = 1, this.environmentRotation = new go, this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
         detail: this
      }))
   }
   copy(e, t) {
      return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentIntensity = e.environmentIntensity, this.environmentRotation.copy(e.environmentRotation), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this
   }
   toJSON(e) {
      const t = super.toJSON(e);
      return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity), t.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (t.object.environmentIntensity = this.environmentIntensity), t.object.environmentRotation = this.environmentRotation.toArray(), t
   }
}
class dT {
   constructor(e, t) {
      this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = Dy, this.updateRanges = [], this.version = 0, this.uuid = po()
   }
   onUploadCallback() {}
   set needsUpdate(e) {
      e === !0 && this.version++
   }
   setUsage(e) {
      return this.usage = e, this
   }
   addUpdateRange(e, t) {
      this.updateRanges.push({
         start: e,
         count: t
      })
   }
   clearUpdateRanges() {
      this.updateRanges.length = 0
   }
   copy(e) {
      return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this
   }
   copyAt(e, t, i) {
      e *= this.stride, i *= t.stride;
      for (let s = 0, r = this.stride; s < r; s++) this.array[e + s] = t.array[i + s];
      return this
   }
   set(e, t = 0) {
      return this.array.set(e, t), this
   }
   clone(e) {
      e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = po()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
      const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),
         i = new this.constructor(t, this.stride);
      return i.setUsage(this.usage), i
   }
   onUpload(e) {
      return this.onUploadCallback = e, this
   }
   toJSON(e) {
      return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = po()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
         uuid: this.uuid,
         buffer: this.array.buffer._uuid,
         type: this.array.constructor.name,
         stride: this.stride
      }
   }
}
const ta = new ee;
class ep {
   constructor(e, t, i, s = !1) {
      this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = i, this.normalized = s
   }
   get count() {
      return this.data.count
   }
   get array() {
      return this.data.array
   }
   set needsUpdate(e) {
      this.data.needsUpdate = e
   }
   applyMatrix4(e) {
      for (let t = 0, i = this.data.count; t < i; t++) ta.fromBufferAttribute(this, t), ta.applyMatrix4(e), this.setXYZ(t, ta.x, ta.y, ta.z);
      return this
   }
   applyNormalMatrix(e) {
      for (let t = 0, i = this.count; t < i; t++) ta.fromBufferAttribute(this, t), ta.applyNormalMatrix(e), this.setXYZ(t, ta.x, ta.y, ta.z);
      return this
   }
   transformDirection(e) {
      for (let t = 0, i = this.count; t < i; t++) ta.fromBufferAttribute(this, t), ta.transformDirection(e), this.setXYZ(t, ta.x, ta.y, ta.z);
      return this
   }
   getComponent(e, t) {
      let i = this.array[e * this.data.stride + this.offset + t];
      return this.normalized && (i = ua(i, this.array)), i
   }
   setComponent(e, t, i) {
      return this.normalized && (i = hn(i, this.array)), this.data.array[e * this.data.stride + this.offset + t] = i, this
   }
   setX(e, t) {
      return this.normalized && (t = hn(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this
   }
   setY(e, t) {
      return this.normalized && (t = hn(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this
   }
   setZ(e, t) {
      return this.normalized && (t = hn(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this
   }
   setW(e, t) {
      return this.normalized && (t = hn(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this
   }
   getX(e) {
      let t = this.data.array[e * this.data.stride + this.offset];
      return this.normalized && (t = ua(t, this.array)), t
   }
   getY(e) {
      let t = this.data.array[e * this.data.stride + this.offset + 1];
      return this.normalized && (t = ua(t, this.array)), t
   }
   getZ(e) {
      let t = this.data.array[e * this.data.stride + this.offset + 2];
      return this.normalized && (t = ua(t, this.array)), t
   }
   getW(e) {
      let t = this.data.array[e * this.data.stride + this.offset + 3];
      return this.normalized && (t = ua(t, this.array)), t
   }
   setXY(e, t, i) {
      return e = e * this.data.stride + this.offset, this.normalized && (t = hn(t, this.array), i = hn(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this
   }
   setXYZ(e, t, i, s) {
      return e = e * this.data.stride + this.offset, this.normalized && (t = hn(t, this.array), i = hn(i, this.array), s = hn(s, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = s, this
   }
   setXYZW(e, t, i, s, r) {
      return e = e * this.data.stride + this.offset, this.normalized && (t = hn(t, this.array), i = hn(i, this.array), s = hn(s, this.array), r = hn(r, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = i, this.data.array[e + 2] = s, this.data.array[e + 3] = r, this
   }
   clone(e) {
      if (e === void 0) {
         console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
         const t = [];
         for (let i = 0; i < this.count; i++) {
            const s = i * this.data.stride + this.offset;
            for (let r = 0; r < this.itemSize; r++) t.push(this.data.array[s + r])
         }
         return new oi(new this.array.constructor(t), this.itemSize, this.normalized)
      } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new ep(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
   }
   toJSON(e) {
      if (e === void 0) {
         console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
         const t = [];
         for (let i = 0; i < this.count; i++) {
            const s = i * this.data.stride + this.offset;
            for (let r = 0; r < this.itemSize; r++) t.push(this.data.array[s + r])
         }
         return {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: t,
            normalized: this.normalized
         }
      } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
         isInterleavedBufferAttribute: !0,
         itemSize: this.itemSize,
         data: this.data.uuid,
         offset: this.offset,
         normalized: this.normalized
      }
   }
}
class UR extends sr {
   constructor(e) {
      super(), this.isSpriteMaterial = !0, this.type = "SpriteMaterial", this.color = new dt(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e)
   }
   copy(e) {
      return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this
   }
}
let wm;
const f0 = new ee,
   Rm = new ee,
   Cm = new ee,
   Dm = new Fe,
   h0 = new Fe,
   NL = new Zt,
   bS = new ee,
   d0 = new ee,
   TS = new ee,
   HD = new Fe,
   dM = new Fe,
   VD = new Fe;
class OL extends Wn {
   constructor(e = new UR) {
      if (super(), this.isSprite = !0, this.type = "Sprite", wm === void 0) {
         wm = new pn;
         const t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),
            i = new dT(t, 5);
         wm.setIndex([0, 1, 2, 0, 2, 3]), wm.setAttribute("position", new ep(i, 3, 0, !1)), wm.setAttribute("uv", new ep(i, 2, 3, !1))
      }
      this.geometry = wm, this.material = e, this.center = new Fe(.5, .5)
   }
   raycast(e, t) {
      e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Rm.setFromMatrixScale(this.matrixWorld), NL.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), Cm.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && Rm.multiplyScalar(-Cm.z);
      const i = this.material.rotation;
      let s, r;
      i !== 0 && (r = Math.cos(i), s = Math.sin(i));
      const a = this.center;
      ES(bS.set(-.5, -.5, 0), Cm, a, Rm, s, r), ES(d0.set(.5, -.5, 0), Cm, a, Rm, s, r), ES(TS.set(.5, .5, 0), Cm, a, Rm, s, r), HD.set(0, 0), dM.set(1, 0), VD.set(1, 1);
      let l = e.ray.intersectTriangle(bS, d0, TS, !1, f0);
      if (l === null && (ES(d0.set(-.5, .5, 0), Cm, a, Rm, s, r), dM.set(0, 1), l = e.ray.intersectTriangle(bS, TS, d0, !1, f0), l === null)) return;
      const c = e.ray.origin.distanceTo(f0);
      c < e.near || c > e.far || t.push({
         distance: c,
         point: f0.clone(),
         uv: Pa.getInterpolation(f0, bS, d0, TS, HD, dM, VD, new Fe),
         face: null,
         object: this
      })
   }
   copy(e, t) {
      return super.copy(e, t), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this
   }
}

function ES(n, e, t, i, s, r) {
   Dm.subVectors(n, t).addScalar(.5).multiply(i), s !== void 0 ? (h0.x = r * Dm.x - s * Dm.y, h0.y = s * Dm.x + r * Dm.y) : h0.copy(Dm), n.copy(e), n.x += h0.x, n.y += h0.y, n.applyMatrix4(NL)
}
const MS = new ee,
   GD = new ee;
class UL extends Wn {
   constructor() {
      super(), this.isLOD = !0, this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
         levels: {
            enumerable: !0,
            value: []
         }
      }), this.autoUpdate = !0
   }
   copy(e) {
      super.copy(e, !1);
      const t = e.levels;
      for (let i = 0, s = t.length; i < s; i++) {
         const r = t[i];
         this.addLevel(r.object.clone(), r.distance, r.hysteresis)
      }
      return this.autoUpdate = e.autoUpdate, this
   }
   addLevel(e, t = 0, i = 0) {
      t = Math.abs(t);
      const s = this.levels;
      let r;
      for (r = 0; r < s.length && !(t < s[r].distance); r++);
      return s.splice(r, 0, {
         distance: t,
         hysteresis: i,
         object: e
      }), this.add(e), this
   }
   removeLevel(e) {
      const t = this.levels;
      for (let i = 0; i < t.length; i++)
         if (t[i].distance === e) {
            const s = t.splice(i, 1);
            return this.remove(s[0].object), !0
         } return !1
   }
   getCurrentLevel() {
      return this._currentLevel
   }
   getObjectForDistance(e) {
      const t = this.levels;
      if (t.length > 0) {
         let i, s;
         for (i = 1, s = t.length; i < s; i++) {
            let r = t[i].distance;
            if (t[i].object.visible && (r -= r * t[i].hysteresis), e < r) break
         }
         return t[i - 1].object
      }
      return null
   }
   raycast(e, t) {
      if (this.levels.length > 0) {
         MS.setFromMatrixPosition(this.matrixWorld);
         const s = e.ray.origin.distanceTo(MS);
         this.getObjectForDistance(s).raycast(e, t)
      }
   }
   update(e) {
      const t = this.levels;
      if (t.length > 1) {
         MS.setFromMatrixPosition(e.matrixWorld), GD.setFromMatrixPosition(this.matrixWorld);
         const i = MS.distanceTo(GD) / e.zoom;
         t[0].object.visible = !0;
         let s, r;
         for (s = 1, r = t.length; s < r; s++) {
            let a = t[s].distance;
            if (t[s].object.visible && (a -= a * t[s].hysteresis), i >= a) t[s - 1].object.visible = !1, t[s].object.visible = !0;
            else break
         }
         for (this._currentLevel = s - 1; s < r; s++) t[s].object.visible = !1
      }
   }
   toJSON(e) {
      const t = super.toJSON(e);
      this.autoUpdate === !1 && (t.object.autoUpdate = !1), t.object.levels = [];
      const i = this.levels;
      for (let s = 0, r = i.length; s < r; s++) {
         const a = i[s];
         t.object.levels.push({
            object: a.object.uuid,
            distance: a.distance,
            hysteresis: a.hysteresis
         })
      }
      return t
   }
}
const kD = new ee,
   jD = new Gn,
   qD = new Gn,
   eG = new ee,
   XD = new Zt,
   AS = new ee,
   pM = new zr,
   WD = new Zt,
   mM = new Pg;
class PL extends ds {
   constructor(e, t) {
      super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = jA, this.bindMatrix = new Zt, this.bindMatrixInverse = new Zt, this.boundingBox = null, this.boundingSphere = null
   }
   computeBoundingBox() {
      const e = this.geometry;
      this.boundingBox === null && (this.boundingBox = new pa), this.boundingBox.makeEmpty();
      const t = e.getAttribute("position");
      for (let i = 0; i < t.count; i++) this.getVertexPosition(i, AS), this.boundingBox.expandByPoint(AS)
   }
   computeBoundingSphere() {
      const e = this.geometry;
      this.boundingSphere === null && (this.boundingSphere = new zr), this.boundingSphere.makeEmpty();
      const t = e.getAttribute("position");
      for (let i = 0; i < t.count; i++) this.getVertexPosition(i, AS), this.boundingSphere.expandByPoint(AS)
   }
   copy(e, t) {
      return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this
   }
   raycast(e, t) {
      const i = this.material,
         s = this.matrixWorld;
      i !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), pM.copy(this.boundingSphere), pM.applyMatrix4(s), e.ray.intersectsSphere(pM) !== !1 && (WD.copy(s).invert(), mM.copy(e.ray).applyMatrix4(WD), !(this.boundingBox !== null && mM.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(e, t, mM)))
   }
   getVertexPosition(e, t) {
      return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t
   }
   bind(e, t) {
      this.skeleton = e, t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert()
   }
   pose() {
      this.skeleton.pose()
   }
   normalizeSkinWeights() {
      const e = new Gn,
         t = this.geometry.attributes.skinWeight;
      for (let i = 0, s = t.count; i < s; i++) {
         e.fromBufferAttribute(t, i);
         const r = 1 / e.manhattanLength();
         r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0), t.setXYZW(i, e.x, e.y, e.z, e.w)
      }
   }
   updateMatrixWorld(e) {
      super.updateMatrixWorld(e), this.bindMode === jA ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === uL ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
   }
   applyBoneTransform(e, t) {
      const i = this.skeleton,
         s = this.geometry;
      jD.fromBufferAttribute(s.attributes.skinIndex, e), qD.fromBufferAttribute(s.attributes.skinWeight, e), kD.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
      for (let r = 0; r < 4; r++) {
         const a = qD.getComponent(r);
         if (a !== 0) {
            const l = jD.getComponent(r);
            XD.multiplyMatrices(i.bones[l].matrixWorld, i.boneInverses[l]), t.addScaledVector(eG.copy(kD).applyMatrix4(XD), a)
         }
      }
      return t.applyMatrix4(this.bindMatrixInverse)
   }
}
class PR extends Wn {
   constructor() {
      super(), this.isBone = !0, this.type = "Bone"
   }
}
class Pu extends Hi {
   constructor(e = null, t = 1, i = 1, s, r, a, l, c, h = ms, m = ms, g, v) {
      super(null, a, l, c, h, m, s, r, g, v), this.isDataTexture = !0, this.image = {
         data: e,
         width: t,
         height: i
      }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
   }
}
const YD = new Zt,
   tG = new Zt;
class pT {
   constructor(e = [], t = []) {
      this.uuid = po(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.init()
   }
   init() {
      const e = this.bones,
         t = this.boneInverses;
      if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0) this.calculateInverses();
      else if (e.length !== t.length) {
         console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
         for (let i = 0, s = this.bones.length; i < s; i++) this.boneInverses.push(new Zt)
      }
   }
   calculateInverses() {
      this.boneInverses.length = 0;
      for (let e = 0, t = this.bones.length; e < t; e++) {
         const i = new Zt;
         this.bones[e] && i.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(i)
      }
   }
   pose() {
      for (let e = 0, t = this.bones.length; e < t; e++) {
         const i = this.bones[e];
         i && i.matrixWorld.copy(this.boneInverses[e]).invert()
      }
      for (let e = 0, t = this.bones.length; e < t; e++) {
         const i = this.bones[e];
         i && (i.parent && i.parent.isBone ? (i.matrix.copy(i.parent.matrixWorld).invert(), i.matrix.multiply(i.matrixWorld)) : i.matrix.copy(i.matrixWorld), i.matrix.decompose(i.position, i.quaternion, i.scale))
      }
   }
   update() {
      const e = this.bones,
         t = this.boneInverses,
         i = this.boneMatrices,
         s = this.boneTexture;
      for (let r = 0, a = e.length; r < a; r++) {
         const l = e[r] ? e[r].matrixWorld : tG;
         YD.multiplyMatrices(l, t[r]), YD.toArray(i, r * 16)
      }
      s !== null && (s.needsUpdate = !0)
   }
   clone() {
      return new pT(this.bones, this.boneInverses)
   }
   computeBoneTexture() {
      let e = Math.sqrt(this.bones.length * 4);
      e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
      const t = new Float32Array(e * e * 4);
      t.set(this.boneMatrices);
      const i = new Pu(t, e, e, Lr, ha);
      return i.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = i, this
   }
   getBoneByName(e) {
      for (let t = 0, i = this.bones.length; t < i; t++) {
         const s = this.bones[t];
         if (s.name === e) return s
      }
   }
   dispose() {
      this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null)
   }
   fromJSON(e, t) {
      this.uuid = e.uuid;
      for (let i = 0, s = e.bones.length; i < s; i++) {
         const r = e.bones[i];
         let a = t[r];
         a === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", r), a = new PR), this.bones.push(a), this.boneInverses.push(new Zt().fromArray(e.boneInverses[i]))
      }
      return this.init(), this
   }
   toJSON() {
      const e = {
         metadata: {
            version: 4.6,
            type: "Skeleton",
            generator: "Skeleton.toJSON"
         },
         bones: [],
         boneInverses: []
      };
      e.uuid = this.uuid;
      const t = this.bones,
         i = this.boneInverses;
      for (let s = 0, r = t.length; s < r; s++) {
         const a = t[s];
         e.bones.push(a.uuid);
         const l = i[s];
         e.boneInverses.push(l.toArray())
      }
      return e
   }
}
class gg extends oi {
   constructor(e, t, i, s = 1) {
      super(e, t, i), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = s
   }
   copy(e) {
      return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this
   }
   toJSON() {
      const e = super.toJSON();
      return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e
   }
}
const Nm = new Zt,
   KD = new Zt,
   wS = [],
   ZD = new pa,
   nG = new Zt,
   p0 = new ds,
   m0 = new zr;
class LL extends ds {
   constructor(e, t, i) {
      super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new gg(new Float32Array(i * 16), 16), this.instanceColor = null, this.morphTexture = null, this.count = i, this.boundingBox = null, this.boundingSphere = null;
      for (let s = 0; s < i; s++) this.setMatrixAt(s, nG)
   }
   computeBoundingBox() {
      const e = this.geometry,
         t = this.count;
      this.boundingBox === null && (this.boundingBox = new pa), e.boundingBox === null && e.computeBoundingBox(), this.boundingBox.makeEmpty();
      for (let i = 0; i < t; i++) this.getMatrixAt(i, Nm), ZD.copy(e.boundingBox).applyMatrix4(Nm), this.boundingBox.union(ZD)
   }
   computeBoundingSphere() {
      const e = this.geometry,
         t = this.count;
      this.boundingSphere === null && (this.boundingSphere = new zr), e.boundingSphere === null && e.computeBoundingSphere(), this.boundingSphere.makeEmpty();
      for (let i = 0; i < t; i++) this.getMatrixAt(i, Nm), m0.copy(e.boundingSphere).applyMatrix4(Nm), this.boundingSphere.union(m0)
   }
   copy(e, t) {
      return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this
   }
   getColorAt(e, t) {
      t.fromArray(this.instanceColor.array, e * 3)
   }
   getMatrixAt(e, t) {
      t.fromArray(this.instanceMatrix.array, e * 16)
   }
   getMorphAt(e, t) {
      const i = t.morphTargetInfluences,
         s = this.morphTexture.source.data.data,
         r = i.length + 1,
         a = e * r + 1;
      for (let l = 0; l < i.length; l++) i[l] = s[a + l]
   }
   raycast(e, t) {
      const i = this.matrixWorld,
         s = this.count;
      if (p0.geometry = this.geometry, p0.material = this.material, p0.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), m0.copy(this.boundingSphere), m0.applyMatrix4(i), e.ray.intersectsSphere(m0) !== !1))
         for (let r = 0; r < s; r++) {
            this.getMatrixAt(r, Nm), KD.multiplyMatrices(i, Nm), p0.matrixWorld = KD, p0.raycast(e, wS);
            for (let a = 0, l = wS.length; a < l; a++) {
               const c = wS[a];
               c.instanceId = r, c.object = this, t.push(c)
            }
            wS.length = 0
         }
   }
   setColorAt(e, t) {
      this.instanceColor === null && (this.instanceColor = new gg(new Float32Array(this.instanceMatrix.count * 3).fill(1), 3)), t.toArray(this.instanceColor.array, e * 3)
   }
   setMatrixAt(e, t) {
      t.toArray(this.instanceMatrix.array, e * 16)
   }
   setMorphAt(e, t) {
      const i = t.morphTargetInfluences,
         s = i.length + 1;
      this.morphTexture === null && (this.morphTexture = new Pu(new Float32Array(s * this.count), s, this.count, rT, ha));
      const r = this.morphTexture.source.data.data;
      let a = 0;
      for (let h = 0; h < i.length; h++) a += i[h];
      const l = this.geometry.morphTargetsRelative ? 1 : 1 - a,
         c = s * e;
      r[c] = l, r.set(i, c + 1)
   }
   updateMorphTargets() {}
   dispose() {
      this.dispatchEvent({
         type: "dispose"
      }), this.morphTexture !== null && (this.morphTexture.dispose(), this.morphTexture = null)
   }
}
const gM = new ee,
   iG = new ee,
   sG = new un;
class kf {
   constructor(e = new ee(1, 0, 0), t = 0) {
      this.isPlane = !0, this.normal = e, this.constant = t
   }
   set(e, t) {
      return this.normal.copy(e), this.constant = t, this
   }
   setComponents(e, t, i, s) {
      return this.normal.set(e, t, i), this.constant = s, this
   }
   setFromNormalAndCoplanarPoint(e, t) {
      return this.normal.copy(e), this.constant = -t.dot(this.normal), this
   }
   setFromCoplanarPoints(e, t, i) {
      const s = gM.subVectors(i, t).cross(iG.subVectors(e, t)).normalize();
      return this.setFromNormalAndCoplanarPoint(s, e), this
   }
   copy(e) {
      return this.normal.copy(e.normal), this.constant = e.constant, this
   }
   normalize() {
      const e = 1 / this.normal.length();
      return this.normal.multiplyScalar(e), this.constant *= e, this
   }
   negate() {
      return this.constant *= -1, this.normal.negate(), this
   }
   distanceToPoint(e) {
      return this.normal.dot(e) + this.constant
   }
   distanceToSphere(e) {
      return this.distanceToPoint(e.center) - e.radius
   }
   projectPoint(e, t) {
      return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
   }
   intersectLine(e, t) {
      const i = e.delta(gM),
         s = this.normal.dot(i);
      if (s === 0) return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
      const r = -(e.start.dot(this.normal) + this.constant) / s;
      return r < 0 || r > 1 ? null : t.copy(e.start).addScaledVector(i, r)
   }
   intersectsLine(e) {
      const t = this.distanceToPoint(e.start),
         i = this.distanceToPoint(e.end);
      return t < 0 && i > 0 || i < 0 && t > 0
   }
   intersectsBox(e) {
      return e.intersectsPlane(this)
   }
   intersectsSphere(e) {
      return e.intersectsPlane(this)
   }
   coplanarPoint(e) {
      return e.copy(this.normal).multiplyScalar(-this.constant)
   }
   applyMatrix4(e, t) {
      const i = t || sG.getNormalMatrix(e),
         s = this.coplanarPoint(gM).applyMatrix4(e),
         r = this.normal.applyMatrix3(i).normalize();
      return this.constant = -s.dot(r), this
   }
   translate(e) {
      return this.constant -= e.dot(this.normal), this
   }
   equals(e) {
      return e.normal.equals(this.normal) && e.constant === this.constant
   }
   clone() {
      return new this.constructor().copy(this)
   }
}
const cd = new zr,
   RS = new ee;
class gx {
   constructor(e = new kf, t = new kf, i = new kf, s = new kf, r = new kf, a = new kf) {
      this.planes = [e, t, i, s, r, a]
   }
   set(e, t, i, s, r, a) {
      const l = this.planes;
      return l[0].copy(e), l[1].copy(t), l[2].copy(i), l[3].copy(s), l[4].copy(r), l[5].copy(a), this
   }
   copy(e) {
      const t = this.planes;
      for (let i = 0; i < 6; i++) t[i].copy(e.planes[i]);
      return this
   }
   setFromProjectionMatrix(e, t = zl) {
      const i = this.planes,
         s = e.elements,
         r = s[0],
         a = s[1],
         l = s[2],
         c = s[3],
         h = s[4],
         m = s[5],
         g = s[6],
         v = s[7],
         x = s[8],
         S = s[9],
         E = s[10],
         T = s[11],
         b = s[12],
         w = s[13],
         C = s[14],
         N = s[15];
      if (i[0].setComponents(c - r, v - h, T - x, N - b).normalize(), i[1].setComponents(c + r, v + h, T + x, N + b).normalize(), i[2].setComponents(c + a, v + m, T + S, N + w).normalize(), i[3].setComponents(c - a, v - m, T - S, N - w).normalize(), i[4].setComponents(c - l, v - g, T - E, N - C).normalize(), t === zl) i[5].setComponents(c + l, v + g, T + E, N + C).normalize();
      else if (t === Ny) i[5].setComponents(l, g, E, C).normalize();
      else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
      return this
   }
   intersectsObject(e) {
      if (e.boundingSphere !== void 0) e.boundingSphere === null && e.computeBoundingSphere(), cd.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
      else {
         const t = e.geometry;
         t.boundingSphere === null && t.computeBoundingSphere(), cd.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)
      }
      return this.intersectsSphere(cd)
   }
   intersectsSprite(e) {
      return cd.center.set(0, 0, 0), cd.radius = .7071067811865476, cd.applyMatrix4(e.matrixWorld), this.intersectsSphere(cd)
   }
   intersectsSphere(e) {
      const t = this.planes,
         i = e.center,
         s = -e.radius;
      for (let r = 0; r < 6; r++)
         if (t[r].distanceToPoint(i) < s) return !1;
      return !0
   }
   intersectsBox(e) {
      const t = this.planes;
      for (let i = 0; i < 6; i++) {
         const s = t[i];
         if (RS.x = s.normal.x > 0 ? e.max.x : e.min.x, RS.y = s.normal.y > 0 ? e.max.y : e.min.y, RS.z = s.normal.z > 0 ? e.max.z : e.min.z, s.distanceToPoint(RS) < 0) return !1
      }
      return !0
   }
   containsPoint(e) {
      const t = this.planes;
      for (let i = 0; i < 6; i++)
         if (t[i].distanceToPoint(e) < 0) return !1;
      return !0
   }
   clone() {
      return new this.constructor().copy(this)
   }
}

function vM(n, e) {
   return n - e
}

function rG(n, e) {
   return n.z - e.z
}

function aG(n, e) {
   return e.z - n.z
}
class oG {
   constructor() {
      this.index = 0, this.pool = [], this.list = []
   }
   push(e, t, i, s) {
      const r = this.pool,
         a = this.list;
      this.index >= r.length && r.push({
         start: -1,
         count: -1,
         z: -1,
         index: -1
      });
      const l = r[this.index];
      a.push(l), this.index++, l.start = e, l.count = t, l.z = i, l.index = s
   }
   reset() {
      this.list.length = 0, this.index = 0
   }
}
const Da = new Zt,
   lG = new dt(1, 1, 1),
   yM = new gx,
   CS = new pa,
   fd = new zr,
   g0 = new ee,
   QD = new ee,
   uG = new ee,
   xM = new oG,
   Cr = new ds,
   DS = [];

function cG(n, e, t = 0) {
   const i = e.itemSize;
   if (n.isInterleavedBufferAttribute || n.array.constructor !== e.array.constructor) {
      const s = n.count;
      for (let r = 0; r < s; r++)
         for (let a = 0; a < i; a++) e.setComponent(r + t, a, n.getComponent(r, a))
   } else e.array.set(n.array, t * i);
   e.needsUpdate = !0
}

function hd(n, e) {
   if (n.constructor !== e.constructor) {
      const t = Math.min(n.length, e.length);
      for (let i = 0; i < t; i++) e[i] = n[i]
   } else {
      const t = Math.min(n.length, e.length);
      e.set(new n.constructor(n.buffer, 0, t))
   }
}
class BL extends ds {
   constructor(e, t, i = t * 2, s) {
      super(new pn, s), this.isBatchedMesh = !0, this.perObjectFrustumCulled = !0, this.sortObjects = !0, this.boundingBox = null, this.boundingSphere = null, this.customSort = null, this._instanceInfo = [], this._geometryInfo = [], this._availableInstanceIds = [], this._availableGeometryIds = [], this._nextIndexStart = 0, this._nextVertexStart = 0, this._geometryCount = 0, this._visibilityChanged = !0, this._geometryInitialized = !1, this._maxInstanceCount = e, this._maxVertexCount = t, this._maxIndexCount = i, this._multiDrawCounts = new Int32Array(e), this._multiDrawStarts = new Int32Array(e), this._multiDrawCount = 0, this._multiDrawInstances = null, this._matricesTexture = null, this._indirectTexture = null, this._colorsTexture = null, this._initMatricesTexture(), this._initIndirectTexture()
   }
   get maxInstanceCount() {
      return this._maxInstanceCount
   }
   get instanceCount() {
      return this._instanceInfo.length - this._availableInstanceIds.length
   }
   get unusedVertexCount() {
      return this._maxVertexCount - this._nextVertexStart
   }
   get unusedIndexCount() {
      return this._maxIndexCount - this._nextIndexStart
   }
   _initMatricesTexture() {
      let e = Math.sqrt(this._maxInstanceCount * 4);
      e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
      const t = new Float32Array(e * e * 4),
         i = new Pu(t, e, e, Lr, ha);
      this._matricesTexture = i
   }
   _initIndirectTexture() {
      let e = Math.sqrt(this._maxInstanceCount);
      e = Math.ceil(e);
      const t = new Uint32Array(e * e),
         i = new Pu(t, e, e, hx, Vu);
      this._indirectTexture = i
   }
   _initColorsTexture() {
      let e = Math.sqrt(this._maxInstanceCount);
      e = Math.ceil(e);
      const t = new Float32Array(e * e * 4).fill(1),
         i = new Pu(t, e, e, Lr, ha);
      i.colorSpace = Vn.workingColorSpace, this._colorsTexture = i
   }
   _initializeGeometry(e) {
      const t = this.geometry,
         i = this._maxVertexCount,
         s = this._maxIndexCount;
      if (this._geometryInitialized === !1) {
         for (const r in e.attributes) {
            const a = e.getAttribute(r),
               {
                  array: l,
                  itemSize: c,
                  normalized: h
               } = a,
               m = new l.constructor(i * c),
               g = new oi(m, c, h);
            t.setAttribute(r, g)
         }
         if (e.getIndex() !== null) {
            const r = i > 65535 ? new Uint32Array(s) : new Uint16Array(s);
            t.setIndex(new oi(r, 1))
         }
         this._geometryInitialized = !0
      }
   }
   _validateGeometry(e) {
      const t = this.geometry;
      if (!!e.getIndex() != !!t.getIndex()) throw new Error('THREE.BatchedMesh: All geometries must consistently have "index".');
      for (const i in t.attributes) {
         if (!e.hasAttribute(i)) throw new Error(`THREE.BatchedMesh: Added geometry missing "${i}". All geometries must have consistent attributes.`);
         const s = e.getAttribute(i),
            r = t.getAttribute(i);
         if (s.itemSize !== r.itemSize || s.normalized !== r.normalized) throw new Error("THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value.")
      }
   }
   validateInstanceId(e) {
      const t = this._instanceInfo;
      if (e < 0 || e >= t.length || t[e].active === !1) throw new Error(`THREE.BatchedMesh: Invalid instanceId ${e}. Instance is either out of range or has been deleted.`)
   }
   validateGeometryId(e) {
      const t = this._geometryInfo;
      if (e < 0 || e >= t.length || t[e].active === !1) throw new Error(`THREE.BatchedMesh: Invalid geometryId ${e}. Geometry is either out of range or has been deleted.`)
   }
   setCustomSort(e) {
      return this.customSort = e, this
   }
   computeBoundingBox() {
      this.boundingBox === null && (this.boundingBox = new pa);
      const e = this.boundingBox,
         t = this._instanceInfo;
      e.makeEmpty();
      for (let i = 0, s = t.length; i < s; i++) {
         if (t[i].active === !1) continue;
         const r = t[i].geometryIndex;
         this.getMatrixAt(i, Da), this.getBoundingBoxAt(r, CS).applyMatrix4(Da), e.union(CS)
      }
   }
   computeBoundingSphere() {
      this.boundingSphere === null && (this.boundingSphere = new zr);
      const e = this.boundingSphere,
         t = this._instanceInfo;
      e.makeEmpty();
      for (let i = 0, s = t.length; i < s; i++) {
         if (t[i].active === !1) continue;
         const r = t[i].geometryIndex;
         this.getMatrixAt(i, Da), this.getBoundingSphereAt(r, fd).applyMatrix4(Da), e.union(fd)
      }
   }
   addInstance(e) {
      if (this._instanceInfo.length >= this.maxInstanceCount && this._availableInstanceIds.length === 0) throw new Error("THREE.BatchedMesh: Maximum item count reached.");
      const i = {
         visible: !0,
         active: !0,
         geometryIndex: e
      };
      let s = null;
      this._availableInstanceIds.length > 0 ? (this._availableInstanceIds.sort(vM), s = this._availableInstanceIds.shift(), this._instanceInfo[s] = i) : (s = this._instanceInfo.length, this._instanceInfo.push(i));
      const r = this._matricesTexture;
      Da.identity().toArray(r.image.data, s * 16), r.needsUpdate = !0;
      const a = this._colorsTexture;
      return a && (lG.toArray(a.image.data, s * 4), a.needsUpdate = !0), this._visibilityChanged = !0, s
   }
   addGeometry(e, t = -1, i = -1) {
      this._initializeGeometry(e), this._validateGeometry(e);
      const s = {
            vertexStart: -1,
            vertexCount: -1,
            reservedVertexCount: -1,
            indexStart: -1,
            indexCount: -1,
            reservedIndexCount: -1,
            start: -1,
            count: -1,
            boundingBox: null,
            boundingSphere: null,
            active: !0
         },
         r = this._geometryInfo;
      s.vertexStart = this._nextVertexStart, s.reservedVertexCount = t === -1 ? e.getAttribute("position").count : t;
      const a = e.getIndex();
      if (a !== null && (s.indexStart = this._nextIndexStart, s.reservedIndexCount = i === -1 ? a.count : i), s.indexStart !== -1 && s.indexStart + s.reservedIndexCount > this._maxIndexCount || s.vertexStart + s.reservedVertexCount > this._maxVertexCount) throw new Error("THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size.");
      let c;
      return this._availableGeometryIds.length > 0 ? (this._availableGeometryIds.sort(vM), c = this._availableGeometryIds.shift(), r[c] = s) : (c = this._geometryCount, this._geometryCount++, r.push(s)), this.setGeometryAt(c, e), this._nextIndexStart = s.indexStart + s.reservedIndexCount, this._nextVertexStart = s.vertexStart + s.reservedVertexCount, c
   }
   setGeometryAt(e, t) {
      if (e >= this._geometryCount) throw new Error("THREE.BatchedMesh: Maximum geometry count reached.");
      this._validateGeometry(t);
      const i = this.geometry,
         s = i.getIndex() !== null,
         r = i.getIndex(),
         a = t.getIndex(),
         l = this._geometryInfo[e];
      if (s && a.count > l.reservedIndexCount || t.attributes.position.count > l.reservedVertexCount) throw new Error("THREE.BatchedMesh: Reserved space not large enough for provided geometry.");
      const c = l.vertexStart,
         h = l.reservedVertexCount;
      l.vertexCount = t.getAttribute("position").count;
      for (const m in i.attributes) {
         const g = t.getAttribute(m),
            v = i.getAttribute(m);
         cG(g, v, c);
         const x = g.itemSize;
         for (let S = g.count, E = h; S < E; S++) {
            const T = c + S;
            for (let b = 0; b < x; b++) v.setComponent(T, b, 0)
         }
         v.needsUpdate = !0, v.addUpdateRange(c * x, h * x)
      }
      if (s) {
         const m = l.indexStart,
            g = l.reservedIndexCount;
         l.indexCount = t.getIndex().count;
         for (let v = 0; v < a.count; v++) r.setX(m + v, c + a.getX(v));
         for (let v = a.count, x = g; v < x; v++) r.setX(m + v, c);
         r.needsUpdate = !0, r.addUpdateRange(m, l.reservedIndexCount)
      }
      return l.start = s ? l.indexStart : l.vertexStart, l.count = s ? l.indexCount : l.vertexCount, l.boundingBox = null, t.boundingBox !== null && (l.boundingBox = t.boundingBox.clone()), l.boundingSphere = null, t.boundingSphere !== null && (l.boundingSphere = t.boundingSphere.clone()), this._visibilityChanged = !0, e
   }
   deleteGeometry(e) {
      const t = this._geometryInfo;
      if (e >= t.length || t[e].active === !1) return this;
      const i = this._instanceInfo;
      for (let s = 0, r = i.length; s < r; s++) i[s].active && i[s].geometryIndex === e && this.deleteInstance(s);
      return t[e].active = !1, this._availableGeometryIds.push(e), this._visibilityChanged = !0, this
   }
   deleteInstance(e) {
      return this.validateInstanceId(e), this._instanceInfo[e].active = !1, this._availableInstanceIds.push(e), this._visibilityChanged = !0, this
   }
   optimize() {
      let e = 0,
         t = 0;
      const i = this._geometryInfo,
         s = i.map((a, l) => l).sort((a, l) => i[a].vertexStart - i[l].vertexStart),
         r = this.geometry;
      for (let a = 0, l = i.length; a < l; a++) {
         const c = s[a],
            h = i[c];
         if (h.active !== !1) {
            if (r.index !== null) {
               if (h.indexStart !== t) {
                  const {
                     indexStart: m,
                     vertexStart: g,
                     reservedIndexCount: v
                  } = h, x = r.index, S = x.array, E = e - g;
                  for (let T = m; T < m + v; T++) S[T] = S[T] + E;
                  x.array.copyWithin(t, m, m + v), x.addUpdateRange(t, v), h.indexStart = t
               }
               t += h.reservedIndexCount
            }
            if (h.vertexStart !== e) {
               const {
                  vertexStart: m,
                  reservedVertexCount: g
               } = h, v = r.attributes;
               for (const x in v) {
                  const S = v[x],
                     {
                        array: E,
                        itemSize: T
                     } = S;
                  E.copyWithin(e * T, m * T, (m + g) * T), S.addUpdateRange(e * T, g * T)
               }
               h.vertexStart = e
            }
            e += h.reservedVertexCount, h.start = r.index ? h.indexStart : h.vertexStart, this._nextIndexStart = r.index ? h.indexStart + h.reservedIndexCount : 0, this._nextVertexStart = h.vertexStart + h.reservedVertexCount
         }
      }
      return this
   }
   getBoundingBoxAt(e, t) {
      if (e >= this._geometryCount) return null;
      const i = this.geometry,
         s = this._geometryInfo[e];
      if (s.boundingBox === null) {
         const r = new pa,
            a = i.index,
            l = i.attributes.position;
         for (let c = s.start, h = s.start + s.count; c < h; c++) {
            let m = c;
            a && (m = a.getX(m)), r.expandByPoint(g0.fromBufferAttribute(l, m))
         }
         s.boundingBox = r
      }
      return t.copy(s.boundingBox), t
   }
   getBoundingSphereAt(e, t) {
      if (e >= this._geometryCount) return null;
      const i = this.geometry,
         s = this._geometryInfo[e];
      if (s.boundingSphere === null) {
         const r = new zr;
         this.getBoundingBoxAt(e, CS), CS.getCenter(r.center);
         const a = i.index,
            l = i.attributes.position;
         let c = 0;
         for (let h = s.start, m = s.start + s.count; h < m; h++) {
            let g = h;
            a && (g = a.getX(g)), g0.fromBufferAttribute(l, g), c = Math.max(c, r.center.distanceToSquared(g0))
         }
         r.radius = Math.sqrt(c), s.boundingSphere = r
      }
      return t.copy(s.boundingSphere), t
   }
   setMatrixAt(e, t) {
      this.validateInstanceId(e);
      const i = this._matricesTexture,
         s = this._matricesTexture.image.data;
      return t.toArray(s, e * 16), i.needsUpdate = !0, this
   }
   getMatrixAt(e, t) {
      return this.validateInstanceId(e), t.fromArray(this._matricesTexture.image.data, e * 16)
   }
   setColorAt(e, t) {
      return this.validateInstanceId(e), this._colorsTexture === null && this._initColorsTexture(), t.toArray(this._colorsTexture.image.data, e * 4), this._colorsTexture.needsUpdate = !0, this
   }
   getColorAt(e, t) {
      return this.validateInstanceId(e), t.fromArray(this._colorsTexture.image.data, e * 4)
   }
   setVisibleAt(e, t) {
      return this.validateInstanceId(e), this._instanceInfo[e].visible === t ? this : (this._instanceInfo[e].visible = t, this._visibilityChanged = !0, this)
   }
   getVisibleAt(e) {
      return this.validateInstanceId(e), this._instanceInfo[e].visible
   }
   setGeometryIdAt(e, t) {
      return this.validateInstanceId(e), this.validateGeometryId(t), this._instanceInfo[e].geometryIndex = t, this
   }
   getGeometryIdAt(e) {
      return this.validateInstanceId(e), this._instanceInfo[e].geometryIndex
   }
   getGeometryRangeAt(e, t = {}) {
      this.validateGeometryId(e);
      const i = this._geometryInfo[e];
      return t.vertexStart = i.vertexStart, t.vertexCount = i.vertexCount, t.reservedVertexCount = i.reservedVertexCount, t.indexStart = i.indexStart, t.indexCount = i.indexCount, t.reservedIndexCount = i.reservedIndexCount, t.start = i.start, t.count = i.count, t
   }
   setInstanceCount(e) {
      const t = this._availableInstanceIds,
         i = this._instanceInfo;
      for (t.sort(vM); t[t.length - 1] === i.length;) i.pop(), t.pop();
      if (e < i.length) throw new Error(`BatchedMesh: Instance ids outside the range ${e} are being used. Cannot shrink instance count.`);
      const s = new Int32Array(e),
         r = new Int32Array(e);
      hd(this._multiDrawCounts, s), hd(this._multiDrawStarts, r), this._multiDrawCounts = s, this._multiDrawStarts = r, this._maxInstanceCount = e;
      const a = this._indirectTexture,
         l = this._matricesTexture,
         c = this._colorsTexture;
      a.dispose(), this._initIndirectTexture(), hd(a.image.data, this._indirectTexture.image.data), l.dispose(), this._initMatricesTexture(), hd(l.image.data, this._matricesTexture.image.data), c && (c.dispose(), this._initColorsTexture(), hd(c.image.data, this._colorsTexture.image.data))
   }
   setGeometrySize(e, t) {
      const i = [...this._geometryInfo].filter(l => l.active);
      if (Math.max(...i.map(l => l.vertexStart + l.reservedVertexCount)) > e) throw new Error(`BatchedMesh: Geometry vertex values are being used outside the range ${t}. Cannot shrink further.`);
      if (this.geometry.index && Math.max(...i.map(c => c.indexStart + c.reservedIndexCount)) > t) throw new Error(`BatchedMesh: Geometry index values are being used outside the range ${t}. Cannot shrink further.`);
      const r = this.geometry;
      r.dispose(), this._maxVertexCount = e, this._maxIndexCount = t, this._geometryInitialized && (this._geometryInitialized = !1, this.geometry = new pn, this._initializeGeometry(r));
      const a = this.geometry;
      r.index && hd(r.index.array, a.index.array);
      for (const l in r.attributes) hd(r.attributes[l].array, a.attributes[l].array)
   }
   raycast(e, t) {
      const i = this._instanceInfo,
         s = this._geometryInfo,
         r = this.matrixWorld,
         a = this.geometry;
      Cr.material = this.material, Cr.geometry.index = a.index, Cr.geometry.attributes = a.attributes, Cr.geometry.boundingBox === null && (Cr.geometry.boundingBox = new pa), Cr.geometry.boundingSphere === null && (Cr.geometry.boundingSphere = new zr);
      for (let l = 0, c = i.length; l < c; l++) {
         if (!i[l].visible || !i[l].active) continue;
         const h = i[l].geometryIndex,
            m = s[h];
         Cr.geometry.setDrawRange(m.start, m.count), this.getMatrixAt(l, Cr.matrixWorld).premultiply(r), this.getBoundingBoxAt(h, Cr.geometry.boundingBox), this.getBoundingSphereAt(h, Cr.geometry.boundingSphere), Cr.raycast(e, DS);
         for (let g = 0, v = DS.length; g < v; g++) {
            const x = DS[g];
            x.object = this, x.batchId = l, t.push(x)
         }
         DS.length = 0
      }
      Cr.material = null, Cr.geometry.index = null, Cr.geometry.attributes = {}, Cr.geometry.setDrawRange(0, 1 / 0)
   }
   copy(e) {
      return super.copy(e), this.geometry = e.geometry.clone(), this.perObjectFrustumCulled = e.perObjectFrustumCulled, this.sortObjects = e.sortObjects, this.boundingBox = e.boundingBox !== null ? e.boundingBox.clone() : null, this.boundingSphere = e.boundingSphere !== null ? e.boundingSphere.clone() : null, this._geometryInfo = e._geometryInfo.map(t => ({
         ...t,
         boundingBox: t.boundingBox !== null ? t.boundingBox.clone() : null,
         boundingSphere: t.boundingSphere !== null ? t.boundingSphere.clone() : null
      })), this._instanceInfo = e._instanceInfo.map(t => ({
         ...t
      })), this._maxInstanceCount = e._maxInstanceCount, this._maxVertexCount = e._maxVertexCount, this._maxIndexCount = e._maxIndexCount, this._geometryInitialized = e._geometryInitialized, this._geometryCount = e._geometryCount, this._multiDrawCounts = e._multiDrawCounts.slice(), this._multiDrawStarts = e._multiDrawStarts.slice(), this._matricesTexture = e._matricesTexture.clone(), this._matricesTexture.image.data = this._matricesTexture.image.data.slice(), this._colorsTexture !== null && (this._colorsTexture = e._colorsTexture.clone(), this._colorsTexture.image.data = this._colorsTexture.image.data.slice()), this
   }
   dispose() {
      this.geometry.dispose(), this._matricesTexture.dispose(), this._matricesTexture = null, this._indirectTexture.dispose(), this._indirectTexture = null, this._colorsTexture !== null && (this._colorsTexture.dispose(), this._colorsTexture = null)
   }
   onBeforeRender(e, t, i, s, r) {
      if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects) return;
      const a = s.getIndex(),
         l = a === null ? 1 : a.array.BYTES_PER_ELEMENT,
         c = this._instanceInfo,
         h = this._multiDrawStarts,
         m = this._multiDrawCounts,
         g = this._geometryInfo,
         v = this.perObjectFrustumCulled,
         x = this._indirectTexture,
         S = x.image.data;
      v && (Da.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse).multiply(this.matrixWorld), yM.setFromProjectionMatrix(Da, e.coordinateSystem));
      let E = 0;
      if (this.sortObjects) {
         Da.copy(this.matrixWorld).invert(), g0.setFromMatrixPosition(i.matrixWorld).applyMatrix4(Da), QD.set(0, 0, -1).transformDirection(i.matrixWorld).transformDirection(Da);
         for (let w = 0, C = c.length; w < C; w++)
            if (c[w].visible && c[w].active) {
               const N = c[w].geometryIndex;
               this.getMatrixAt(w, Da), this.getBoundingSphereAt(N, fd).applyMatrix4(Da);
               let U = !1;
               if (v && (U = !yM.intersectsSphere(fd)), !U) {
                  const z = g[N],
                     B = uG.subVectors(fd.center, g0).dot(QD);
                  xM.push(z.start, z.count, B, w)
               }
            } const T = xM.list,
            b = this.customSort;
         b === null ? T.sort(r.transparent ? aG : rG) : b.call(this, T, i);
         for (let w = 0, C = T.length; w < C; w++) {
            const N = T[w];
            h[E] = N.start * l, m[E] = N.count, S[E] = N.index, E++
         }
         xM.reset()
      } else
         for (let T = 0, b = c.length; T < b; T++)
            if (c[T].visible && c[T].active) {
               const w = c[T].geometryIndex;
               let C = !1;
               if (v && (this.getMatrixAt(T, Da), this.getBoundingSphereAt(w, fd).applyMatrix4(Da), C = !yM.intersectsSphere(fd)), !C) {
                  const N = g[w];
                  h[E] = N.start * l, m[E] = N.count, S[E] = T, E++
               }
            } x.needsUpdate = !0, this._multiDrawCount = E, this._visibilityChanged = !1
   }
   onBeforeShadow(e, t, i, s, r, a) {
      this.onBeforeRender(e, null, s, r, a)
   }
}
class ma extends sr {
   constructor(e) {
      super(), this.isLineBasicMaterial = !0, this.type = "LineBasicMaterial", this.color = new dt(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e)
   }
   copy(e) {
      return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this
   }
}
const _1 = new ee,
   S1 = new ee,
   JD = new Zt,
   v0 = new Pg,
   NS = new zr,
   _M = new ee,
   $D = new ee;
class rh extends Wn {
   constructor(e = new pn, t = new ma) {
      super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets()
   }
   copy(e, t) {
      return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this
   }
   computeLineDistances() {
      const e = this.geometry;
      if (e.index === null) {
         const t = e.attributes.position,
            i = [0];
         for (let s = 1, r = t.count; s < r; s++) _1.fromBufferAttribute(t, s - 1), S1.fromBufferAttribute(t, s), i[s] = i[s - 1], i[s] += _1.distanceTo(S1);
         e.setAttribute("lineDistance", new Ct(i, 1))
      } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      return this
   }
   raycast(e, t) {
      const i = this.geometry,
         s = this.matrixWorld,
         r = e.params.Line.threshold,
         a = i.drawRange;
      if (i.boundingSphere === null && i.computeBoundingSphere(), NS.copy(i.boundingSphere), NS.applyMatrix4(s), NS.radius += r, e.ray.intersectsSphere(NS) === !1) return;
      JD.copy(s).invert(), v0.copy(e.ray).applyMatrix4(JD);
      const l = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
         c = l * l,
         h = this.isLineSegments ? 2 : 1,
         m = i.index,
         v = i.attributes.position;
      if (m !== null) {
         const x = Math.max(0, a.start),
            S = Math.min(m.count, a.start + a.count);
         for (let E = x, T = S - 1; E < T; E += h) {
            const b = m.getX(E),
               w = m.getX(E + 1),
               C = OS(this, e, v0, c, b, w, E);
            C && t.push(C)
         }
         if (this.isLineLoop) {
            const E = m.getX(S - 1),
               T = m.getX(x),
               b = OS(this, e, v0, c, E, T, S - 1);
            b && t.push(b)
         }
      } else {
         const x = Math.max(0, a.start),
            S = Math.min(v.count, a.start + a.count);
         for (let E = x, T = S - 1; E < T; E += h) {
            const b = OS(this, e, v0, c, E, E + 1, E);
            b && t.push(b)
         }
         if (this.isLineLoop) {
            const E = OS(this, e, v0, c, S - 1, x, S - 1);
            E && t.push(E)
         }
      }
   }
   updateMorphTargets() {
      const t = this.geometry.morphAttributes,
         i = Object.keys(t);
      if (i.length > 0) {
         const s = t[i[0]];
         if (s !== void 0) {
            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
            for (let r = 0, a = s.length; r < a; r++) {
               const l = s[r].name || String(r);
               this.morphTargetInfluences.push(0), this.morphTargetDictionary[l] = r
            }
         }
      }
   }
}

function OS(n, e, t, i, s, r, a) {
   const l = n.geometry.attributes.position;
   if (_1.fromBufferAttribute(l, s), S1.fromBufferAttribute(l, r), t.distanceSqToSegment(_1, S1, _M, $D) > i) return;
   _M.applyMatrix4(n.matrixWorld);
   const h = e.ray.origin.distanceTo(_M);
   if (!(h < e.near || h > e.far)) return {
      distance: h,
      point: $D.clone().applyMatrix4(n.matrixWorld),
      index: a,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: n
   }
}
const e3 = new ee,
   t3 = new ee;
class qu extends rh {
   constructor(e, t) {
      super(e, t), this.isLineSegments = !0, this.type = "LineSegments"
   }
   computeLineDistances() {
      const e = this.geometry;
      if (e.index === null) {
         const t = e.attributes.position,
            i = [];
         for (let s = 0, r = t.count; s < r; s += 2) e3.fromBufferAttribute(t, s), t3.fromBufferAttribute(t, s + 1), i[s] = s === 0 ? 0 : i[s - 1], i[s + 1] = i[s] + e3.distanceTo(t3);
         e.setAttribute("lineDistance", new Ct(i, 1))
      } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
      return this
   }
}
class zL extends rh {
   constructor(e, t) {
      super(e, t), this.isLineLoop = !0, this.type = "LineLoop"
   }
}
class LR extends sr {
   constructor(e) {
      super(), this.isPointsMaterial = !0, this.type = "PointsMaterial", this.color = new dt(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e)
   }
   copy(e) {
      return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this
   }
}
const n3 = new Zt,
   WA = new Pg,
   US = new zr,
   PS = new ee;
class IL extends Wn {
   constructor(e = new pn, t = new LR) {
      super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.morphTargetDictionary = void 0, this.morphTargetInfluences = void 0, this.updateMorphTargets()
   }
   copy(e, t) {
      return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this
   }
   raycast(e, t) {
      const i = this.geometry,
         s = this.matrixWorld,
         r = e.params.Points.threshold,
         a = i.drawRange;
      if (i.boundingSphere === null && i.computeBoundingSphere(), US.copy(i.boundingSphere), US.applyMatrix4(s), US.radius += r, e.ray.intersectsSphere(US) === !1) return;
      n3.copy(s).invert(), WA.copy(e.ray).applyMatrix4(n3);
      const l = r / ((this.scale.x + this.scale.y + this.scale.z) / 3),
         c = l * l,
         h = i.index,
         g = i.attributes.position;
      if (h !== null) {
         const v = Math.max(0, a.start),
            x = Math.min(h.count, a.start + a.count);
         for (let S = v, E = x; S < E; S++) {
            const T = h.getX(S);
            PS.fromBufferAttribute(g, T), i3(PS, T, c, s, e, t, this)
         }
      } else {
         const v = Math.max(0, a.start),
            x = Math.min(g.count, a.start + a.count);
         for (let S = v, E = x; S < E; S++) PS.fromBufferAttribute(g, S), i3(PS, S, c, s, e, t, this)
      }
   }
   updateMorphTargets() {
      const t = this.geometry.morphAttributes,
         i = Object.keys(t);
      if (i.length > 0) {
         const s = t[i[0]];
         if (s !== void 0) {
            this.morphTargetInfluences = [], this.morphTargetDictionary = {};
            for (let r = 0, a = s.length; r < a; r++) {
               const l = s[r].name || String(r);
               this.morphTargetInfluences.push(0), this.morphTargetDictionary[l] = r
            }
         }
      }
   }
}

function i3(n, e, t, i, s, r, a) {
   const l = WA.distanceSqToPoint(n);
   if (l < t) {
      const c = new ee;
      WA.closestPointToPoint(n, c), c.applyMatrix4(i);
      const h = s.ray.origin.distanceTo(c);
      if (h < s.near || h > s.far) return;
      r.push({
         distance: h,
         distanceToRay: Math.sqrt(l),
         point: c,
         index: e,
         face: null,
         faceIndex: null,
         barycoord: null,
         object: a
      })
   }
}
class FL extends Hi {
   constructor(e, t, i, s, r = Ni, a = Ni, l, c, h) {
      super(e, t, i, s, r, a, l, c, h), this.isVideoTexture = !0, this.generateMipmaps = !1;
      const m = this;

      function g() {
         m.needsUpdate = !0, e.requestVideoFrameCallback(g)
      }
      "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(g)
   }
   clone() {
      return new this.constructor(this.image).copy(this)
   }
   update() {
      const e = this.image;
      "requestVideoFrameCallback" in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
   }
}
class fG extends FL {
   constructor(e, t, i, s, r, a, l, c) {
      super({}, e, t, i, s, r, a, l, c), this.isVideoFrameTexture = !0
   }
   update() {}
   clone() {
      return new this.constructor().copy(this)
   }
   setFrame(e) {
      this.image = e, this.needsUpdate = !0
   }
}
class hG extends Hi {
   constructor(e, t) {
      super({
         width: e,
         height: t
      }), this.isFramebufferTexture = !0, this.magFilter = ms, this.minFilter = ms, this.generateMipmaps = !1, this.needsUpdate = !0
   }
}
class mT extends Hi {
   constructor(e, t, i, s, r, a, l, c, h, m, g, v) {
      super(null, a, l, c, h, m, s, r, g, v), this.isCompressedTexture = !0, this.image = {
         width: t,
         height: i
      }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1
   }
}
class dG extends mT {
   constructor(e, t, i, s, r, a) {
      super(e, t, i, r, a), this.isCompressedArrayTexture = !0, this.image.depth = s, this.wrapR = Ko, this.layerUpdates = new Set
   }
   addLayerUpdate(e) {
      this.layerUpdates.add(e)
   }
   clearLayerUpdates() {
      this.layerUpdates.clear()
   }
}
class pG extends mT {
   constructor(e, t, i) {
      super(void 0, e[0].width, e[0].height, t, i, Uc), this.isCompressedCubeTexture = !0, this.isCubeTexture = !0, this.image = e
   }
}
class mG extends Hi {
   constructor(e, t, i, s, r, a, l, c, h) {
      super(e, t, i, s, r, a, l, c, h), this.isCanvasTexture = !0, this.needsUpdate = !0
   }
}
class vx extends Hi {
   constructor(e, t, i = Vu, s, r, a, l = ms, c = ms, h, m = fg) {
      if (m !== fg && m !== $d) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
      super(null, s, r, a, l, c, m, i, h), this.isDepthTexture = !0, this.image = {
         width: e,
         height: t
      }, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null
   }
   copy(e) {
      return super.copy(e), this.source = new Xf(Object.assign({}, e.image)), this.compareFunction = e.compareFunction, this
   }
   toJSON(e) {
      const t = super.toJSON(e);
      return this.compareFunction !== null && (t.compareFunction = this.compareFunction), t
   }
}
class jl {
   constructor() {
      this.type = "Curve", this.arcLengthDivisions = 200, this.needsUpdate = !1, this.cacheArcLengths = null
   }
   getPoint() {
      console.warn("THREE.Curve: .getPoint() not implemented.")
   }
   getPointAt(e, t) {
      const i = this.getUtoTmapping(e);
      return this.getPoint(i, t)
   }
   getPoints(e = 5) {
      const t = [];
      for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
      return t
   }
   getSpacedPoints(e = 5) {
      const t = [];
      for (let i = 0; i <= e; i++) t.push(this.getPointAt(i / e));
      return t
   }
   getLength() {
      const e = this.getLengths();
      return e[e.length - 1]
   }
   getLengths(e = this.arcLengthDivisions) {
      if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
      this.needsUpdate = !1;
      const t = [];
      let i, s = this.getPoint(0),
         r = 0;
      t.push(0);
      for (let a = 1; a <= e; a++) i = this.getPoint(a / e), r += i.distanceTo(s), t.push(r), s = i;
      return this.cacheArcLengths = t, t
   }
   updateArcLengths() {
      this.needsUpdate = !0, this.getLengths()
   }
   getUtoTmapping(e, t = null) {
      const i = this.getLengths();
      let s = 0;
      const r = i.length;
      let a;
      t ? a = t : a = e * i[r - 1];
      let l = 0,
         c = r - 1,
         h;
      for (; l <= c;)
         if (s = Math.floor(l + (c - l) / 2), h = i[s] - a, h < 0) l = s + 1;
         else if (h > 0) c = s - 1;
      else {
         c = s;
         break
      }
      if (s = c, i[s] === a) return s / (r - 1);
      const m = i[s],
         v = i[s + 1] - m,
         x = (a - m) / v;
      return (s + x) / (r - 1)
   }
   getTangent(e, t) {
      let s = e - 1e-4,
         r = e + 1e-4;
      s < 0 && (s = 0), r > 1 && (r = 1);
      const a = this.getPoint(s),
         l = this.getPoint(r),
         c = t || (a.isVector2 ? new Fe : new ee);
      return c.copy(l).sub(a).normalize(), c
   }
   getTangentAt(e, t) {
      const i = this.getUtoTmapping(e);
      return this.getTangent(i, t)
   }
   computeFrenetFrames(e, t = !1) {
      const i = new ee,
         s = [],
         r = [],
         a = [],
         l = new ee,
         c = new Zt;
      for (let x = 0; x <= e; x++) {
         const S = x / e;
         s[x] = this.getTangentAt(S, new ee)
      }
      r[0] = new ee, a[0] = new ee;
      let h = Number.MAX_VALUE;
      const m = Math.abs(s[0].x),
         g = Math.abs(s[0].y),
         v = Math.abs(s[0].z);
      m <= h && (h = m, i.set(1, 0, 0)), g <= h && (h = g, i.set(0, 1, 0)), v <= h && i.set(0, 0, 1), l.crossVectors(s[0], i).normalize(), r[0].crossVectors(s[0], l), a[0].crossVectors(s[0], r[0]);
      for (let x = 1; x <= e; x++) {
         if (r[x] = r[x - 1].clone(), a[x] = a[x - 1].clone(), l.crossVectors(s[x - 1], s[x]), l.length() > Number.EPSILON) {
            l.normalize();
            const S = Math.acos(on(s[x - 1].dot(s[x]), -1, 1));
            r[x].applyMatrix4(c.makeRotationAxis(l, S))
         }
         a[x].crossVectors(s[x], r[x])
      }
      if (t === !0) {
         let x = Math.acos(on(r[0].dot(r[e]), -1, 1));
         x /= e, s[0].dot(l.crossVectors(r[0], r[e])) > 0 && (x = -x);
         for (let S = 1; S <= e; S++) r[S].applyMatrix4(c.makeRotationAxis(s[S], x * S)), a[S].crossVectors(s[S], r[S])
      }
      return {
         tangents: s,
         normals: r,
         binormals: a
      }
   }
   clone() {
      return new this.constructor().copy(this)
   }
   copy(e) {
      return this.arcLengthDivisions = e.arcLengthDivisions, this
   }
   toJSON() {
      const e = {
         metadata: {
            version: 4.6,
            type: "Curve",
            generator: "Curve.toJSON"
         }
      };
      return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e
   }
   fromJSON(e) {
      return this.arcLengthDivisions = e.arcLengthDivisions, this
   }
}
class gT extends jl {
   constructor(e = 0, t = 0, i = 1, s = 1, r = 0, a = Math.PI * 2, l = !1, c = 0) {
      super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = i, this.yRadius = s, this.aStartAngle = r, this.aEndAngle = a, this.aClockwise = l, this.aRotation = c
   }
   getPoint(e, t = new Fe) {
      const i = t,
         s = Math.PI * 2;
      let r = this.aEndAngle - this.aStartAngle;
      const a = Math.abs(r) < Number.EPSILON;
      for (; r < 0;) r += s;
      for (; r > s;) r -= s;
      r < Number.EPSILON && (a ? r = 0 : r = s), this.aClockwise === !0 && !a && (r === s ? r = -s : r = r - s);
      const l = this.aStartAngle + e * r;
      let c = this.aX + this.xRadius * Math.cos(l),
         h = this.aY + this.yRadius * Math.sin(l);
      if (this.aRotation !== 0) {
         const m = Math.cos(this.aRotation),
            g = Math.sin(this.aRotation),
            v = c - this.aX,
            x = h - this.aY;
         c = v * m - x * g + this.aX, h = v * g + x * m + this.aY
      }
      return i.set(c, h)
   }
   copy(e) {
      return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
   }
   toJSON() {
      const e = super.toJSON();
      return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e
   }
   fromJSON(e) {
      return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
   }
}
class HL extends gT {
   constructor(e, t, i, s, r, a) {
      super(e, t, i, i, s, r, a), this.isArcCurve = !0, this.type = "ArcCurve"
   }
}

function BR() {
   let n = 0,
      e = 0,
      t = 0,
      i = 0;

   function s(r, a, l, c) {
      n = r, e = l, t = -3 * r + 3 * a - 2 * l - c, i = 2 * r - 2 * a + l + c
   }
   return {
      initCatmullRom: function (r, a, l, c, h) {
         s(a, l, h * (l - r), h * (c - a))
      },
      initNonuniformCatmullRom: function (r, a, l, c, h, m, g) {
         let v = (a - r) / h - (l - r) / (h + m) + (l - a) / m,
            x = (l - a) / m - (c - a) / (m + g) + (c - l) / g;
         v *= m, x *= m, s(a, l, v, x)
      },
      calc: function (r) {
         const a = r * r,
            l = a * r;
         return n + e * r + t * a + i * l
      }
   }
}
const LS = new ee,
   SM = new BR,
   bM = new BR,
   TM = new BR;
class VL extends jl {
   constructor(e = [], t = !1, i = "centripetal", s = .5) {
      super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = i, this.tension = s
   }
   getPoint(e, t = new ee) {
      const i = t,
         s = this.points,
         r = s.length,
         a = (r - (this.closed ? 0 : 1)) * e;
      let l = Math.floor(a),
         c = a - l;
      this.closed ? l += l > 0 ? 0 : (Math.floor(Math.abs(l) / r) + 1) * r : c === 0 && l === r - 1 && (l = r - 2, c = 1);
      let h, m;
      this.closed || l > 0 ? h = s[(l - 1) % r] : (LS.subVectors(s[0], s[1]).add(s[0]), h = LS);
      const g = s[l % r],
         v = s[(l + 1) % r];
      if (this.closed || l + 2 < r ? m = s[(l + 2) % r] : (LS.subVectors(s[r - 1], s[r - 2]).add(s[r - 1]), m = LS), this.curveType === "centripetal" || this.curveType === "chordal") {
         const x = this.curveType === "chordal" ? .5 : .25;
         let S = Math.pow(h.distanceToSquared(g), x),
            E = Math.pow(g.distanceToSquared(v), x),
            T = Math.pow(v.distanceToSquared(m), x);
         E < 1e-4 && (E = 1), S < 1e-4 && (S = E), T < 1e-4 && (T = E), SM.initNonuniformCatmullRom(h.x, g.x, v.x, m.x, S, E, T), bM.initNonuniformCatmullRom(h.y, g.y, v.y, m.y, S, E, T), TM.initNonuniformCatmullRom(h.z, g.z, v.z, m.z, S, E, T)
      } else this.curveType === "catmullrom" && (SM.initCatmullRom(h.x, g.x, v.x, m.x, this.tension), bM.initCatmullRom(h.y, g.y, v.y, m.y, this.tension), TM.initCatmullRom(h.z, g.z, v.z, m.z, this.tension));
      return i.set(SM.calc(c), bM.calc(c), TM.calc(c)), i
   }
   copy(e) {
      super.copy(e), this.points = [];
      for (let t = 0, i = e.points.length; t < i; t++) {
         const s = e.points[t];
         this.points.push(s.clone())
      }
      return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
   }
   toJSON() {
      const e = super.toJSON();
      e.points = [];
      for (let t = 0, i = this.points.length; t < i; t++) {
         const s = this.points[t];
         e.points.push(s.toArray())
      }
      return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e
   }
   fromJSON(e) {
      super.fromJSON(e), this.points = [];
      for (let t = 0, i = e.points.length; t < i; t++) {
         const s = e.points[t];
         this.points.push(new ee().fromArray(s))
      }
      return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
   }
}

function s3(n, e, t, i, s) {
   const r = (i - e) * .5,
      a = (s - t) * .5,
      l = n * n,
      c = n * l;
   return (2 * t - 2 * i + r + a) * c + (-3 * t + 3 * i - 2 * r - a) * l + r * n + t
}

function gG(n, e) {
   const t = 1 - n;
   return t * t * e
}

function vG(n, e) {
   return 2 * (1 - n) * n * e
}

function yG(n, e) {
   return n * n * e
}

function X0(n, e, t, i) {
   return gG(n, e) + vG(n, t) + yG(n, i)
}

function xG(n, e) {
   const t = 1 - n;
   return t * t * t * e
}

function _G(n, e) {
   const t = 1 - n;
   return 3 * t * t * n * e
}

function SG(n, e) {
   return 3 * (1 - n) * n * n * e
}

function bG(n, e) {
   return n * n * n * e
}

function W0(n, e, t, i, s) {
   return xG(n, e) + _G(n, t) + SG(n, i) + bG(n, s)
}
class zR extends jl {
   constructor(e = new Fe, t = new Fe, i = new Fe, s = new Fe) {
      super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = s
   }
   getPoint(e, t = new Fe) {
      const i = t,
         s = this.v0,
         r = this.v1,
         a = this.v2,
         l = this.v3;
      return i.set(W0(e, s.x, r.x, a.x, l.x), W0(e, s.y, r.y, a.y, l.y)), i
   }
   copy(e) {
      return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
   }
   toJSON() {
      const e = super.toJSON();
      return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
   }
   fromJSON(e) {
      return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
   }
}
class GL extends jl {
   constructor(e = new ee, t = new ee, i = new ee, s = new ee) {
      super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = i, this.v3 = s
   }
   getPoint(e, t = new ee) {
      const i = t,
         s = this.v0,
         r = this.v1,
         a = this.v2,
         l = this.v3;
      return i.set(W0(e, s.x, r.x, a.x, l.x), W0(e, s.y, r.y, a.y, l.y), W0(e, s.z, r.z, a.z, l.z)), i
   }
   copy(e) {
      return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
   }
   toJSON() {
      const e = super.toJSON();
      return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
   }
   fromJSON(e) {
      return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
   }
}
class IR extends jl {
   constructor(e = new Fe, t = new Fe) {
      super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = t
   }
   getPoint(e, t = new Fe) {
      const i = t;
      return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i
   }
   getPointAt(e, t) {
      return this.getPoint(e, t)
   }
   getTangent(e, t = new Fe) {
      return t.subVectors(this.v2, this.v1).normalize()
   }
   getTangentAt(e, t) {
      return this.getTangent(e, t)
   }
   copy(e) {
      return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
   }
   toJSON() {
      const e = super.toJSON();
      return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
   }
   fromJSON(e) {
      return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
   }
}
class kL extends jl {
   constructor(e = new ee, t = new ee) {
      super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = t
   }
   getPoint(e, t = new ee) {
      const i = t;
      return e === 1 ? i.copy(this.v2) : (i.copy(this.v2).sub(this.v1), i.multiplyScalar(e).add(this.v1)), i
   }
   getPointAt(e, t) {
      return this.getPoint(e, t)
   }
   getTangent(e, t = new ee) {
      return t.subVectors(this.v2, this.v1).normalize()
   }
   getTangentAt(e, t) {
      return this.getTangent(e, t)
   }
   copy(e) {
      return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
   }
   toJSON() {
      const e = super.toJSON();
      return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
   }
   fromJSON(e) {
      return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
   }
}
class FR extends jl {
   constructor(e = new Fe, t = new Fe, i = new Fe) {
      super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = i
   }
   getPoint(e, t = new Fe) {
      const i = t,
         s = this.v0,
         r = this.v1,
         a = this.v2;
      return i.set(X0(e, s.x, r.x, a.x), X0(e, s.y, r.y, a.y)), i
   }
   copy(e) {
      return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
   }
   toJSON() {
      const e = super.toJSON();
      return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
   }
   fromJSON(e) {
      return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
   }
}
class HR extends jl {
   constructor(e = new ee, t = new ee, i = new ee) {
      super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = i
   }
   getPoint(e, t = new ee) {
      const i = t,
         s = this.v0,
         r = this.v1,
         a = this.v2;
      return i.set(X0(e, s.x, r.x, a.x), X0(e, s.y, r.y, a.y), X0(e, s.z, r.z, a.z)), i
   }
   copy(e) {
      return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
   }
   toJSON() {
      const e = super.toJSON();
      return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
   }
   fromJSON(e) {
      return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
   }
}
class VR extends jl {
   constructor(e = []) {
      super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e
   }
   getPoint(e, t = new Fe) {
      const i = t,
         s = this.points,
         r = (s.length - 1) * e,
         a = Math.floor(r),
         l = r - a,
         c = s[a === 0 ? a : a - 1],
         h = s[a],
         m = s[a > s.length - 2 ? s.length - 1 : a + 1],
         g = s[a > s.length - 3 ? s.length - 1 : a + 2];
      return i.set(s3(l, c.x, h.x, m.x, g.x), s3(l, c.y, h.y, m.y, g.y)), i
   }
   copy(e) {
      super.copy(e), this.points = [];
      for (let t = 0, i = e.points.length; t < i; t++) {
         const s = e.points[t];
         this.points.push(s.clone())
      }
      return this
   }
   toJSON() {
      const e = super.toJSON();
      e.points = [];
      for (let t = 0, i = this.points.length; t < i; t++) {
         const s = this.points[t];
         e.points.push(s.toArray())
      }
      return e
   }
   fromJSON(e) {
      super.fromJSON(e), this.points = [];
      for (let t = 0, i = e.points.length; t < i; t++) {
         const s = e.points[t];
         this.points.push(new Fe().fromArray(s))
      }
      return this
   }
}
var b1 = Object.freeze({
   __proto__: null,
   ArcCurve: HL,
   CatmullRomCurve3: VL,
   CubicBezierCurve: zR,
   CubicBezierCurve3: GL,
   EllipseCurve: gT,
   LineCurve: IR,
   LineCurve3: kL,
   QuadraticBezierCurve: FR,
   QuadraticBezierCurve3: HR,
   SplineCurve: VR
});
class jL extends jl {
   constructor() {
      super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1
   }
   add(e) {
      this.curves.push(e)
   }
   closePath() {
      const e = this.curves[0].getPoint(0),
         t = this.curves[this.curves.length - 1].getPoint(1);
      if (!e.equals(t)) {
         const i = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
         this.curves.push(new b1[i](t, e))
      }
      return this
   }
   getPoint(e, t) {
      const i = e * this.getLength(),
         s = this.getCurveLengths();
      let r = 0;
      for (; r < s.length;) {
         if (s[r] >= i) {
            const a = s[r] - i,
               l = this.curves[r],
               c = l.getLength(),
               h = c === 0 ? 0 : 1 - a / c;
            return l.getPointAt(h, t)
         }
         r++
      }
      return null
   }
   getLength() {
      const e = this.getCurveLengths();
      return e[e.length - 1]
   }
   updateArcLengths() {
      this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
   }
   getCurveLengths() {
      if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
      const e = [];
      let t = 0;
      for (let i = 0, s = this.curves.length; i < s; i++) t += this.curves[i].getLength(), e.push(t);
      return this.cacheLengths = e, e
   }
   getSpacedPoints(e = 40) {
      const t = [];
      for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
      return this.autoClose && t.push(t[0]), t
   }
   getPoints(e = 12) {
      const t = [];
      let i;
      for (let s = 0, r = this.curves; s < r.length; s++) {
         const a = r[s],
            l = a.isEllipseCurve ? e * 2 : a.isLineCurve || a.isLineCurve3 ? 1 : a.isSplineCurve ? e * a.points.length : e,
            c = a.getPoints(l);
         for (let h = 0; h < c.length; h++) {
            const m = c[h];
            i && i.equals(m) || (t.push(m), i = m)
         }
      }
      return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t
   }
   copy(e) {
      super.copy(e), this.curves = [];
      for (let t = 0, i = e.curves.length; t < i; t++) {
         const s = e.curves[t];
         this.curves.push(s.clone())
      }
      return this.autoClose = e.autoClose, this
   }
   toJSON() {
      const e = super.toJSON();
      e.autoClose = this.autoClose, e.curves = [];
      for (let t = 0, i = this.curves.length; t < i; t++) {
         const s = this.curves[t];
         e.curves.push(s.toJSON())
      }
      return e
   }
   fromJSON(e) {
      super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
      for (let t = 0, i = e.curves.length; t < i; t++) {
         const s = e.curves[t];
         this.curves.push(new b1[s.type]().fromJSON(s))
      }
      return this
   }
}
class Uy extends jL {
   constructor(e) {
      super(), this.type = "Path", this.currentPoint = new Fe, e && this.setFromPoints(e)
   }
   setFromPoints(e) {
      this.moveTo(e[0].x, e[0].y);
      for (let t = 1, i = e.length; t < i; t++) this.lineTo(e[t].x, e[t].y);
      return this
   }
   moveTo(e, t) {
      return this.currentPoint.set(e, t), this
   }
   lineTo(e, t) {
      const i = new IR(this.currentPoint.clone(), new Fe(e, t));
      return this.curves.push(i), this.currentPoint.set(e, t), this
   }
   quadraticCurveTo(e, t, i, s) {
      const r = new FR(this.currentPoint.clone(), new Fe(e, t), new Fe(i, s));
      return this.curves.push(r), this.currentPoint.set(i, s), this
   }
   bezierCurveTo(e, t, i, s, r, a) {
      const l = new zR(this.currentPoint.clone(), new Fe(e, t), new Fe(i, s), new Fe(r, a));
      return this.curves.push(l), this.currentPoint.set(r, a), this
   }
   splineThru(e) {
      const t = [this.currentPoint.clone()].concat(e),
         i = new VR(t);
      return this.curves.push(i), this.currentPoint.copy(e[e.length - 1]), this
   }
   arc(e, t, i, s, r, a) {
      const l = this.currentPoint.x,
         c = this.currentPoint.y;
      return this.absarc(e + l, t + c, i, s, r, a), this
   }
   absarc(e, t, i, s, r, a) {
      return this.absellipse(e, t, i, i, s, r, a), this
   }
   ellipse(e, t, i, s, r, a, l, c) {
      const h = this.currentPoint.x,
         m = this.currentPoint.y;
      return this.absellipse(e + h, t + m, i, s, r, a, l, c), this
   }
   absellipse(e, t, i, s, r, a, l, c) {
      const h = new gT(e, t, i, s, r, a, l, c);
      if (this.curves.length > 0) {
         const g = h.getPoint(0);
         g.equals(this.currentPoint) || this.lineTo(g.x, g.y)
      }
      this.curves.push(h);
      const m = h.getPoint(1);
      return this.currentPoint.copy(m), this
   }
   copy(e) {
      return super.copy(e), this.currentPoint.copy(e.currentPoint), this
   }
   toJSON() {
      const e = super.toJSON();
      return e.currentPoint = this.currentPoint.toArray(), e
   }
   fromJSON(e) {
      return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this
   }
}
class yx extends pn {
   constructor(e = [new Fe(0, -.5), new Fe(.5, 0), new Fe(0, .5)], t = 12, i = 0, s = Math.PI * 2) {
      super(), this.type = "LatheGeometry", this.parameters = {
         points: e,
         segments: t,
         phiStart: i,
         phiLength: s
      }, t = Math.floor(t), s = on(s, 0, Math.PI * 2);
      const r = [],
         a = [],
         l = [],
         c = [],
         h = [],
         m = 1 / t,
         g = new ee,
         v = new Fe,
         x = new ee,
         S = new ee,
         E = new ee;
      let T = 0,
         b = 0;
      for (let w = 0; w <= e.length - 1; w++) switch (w) {
         case 0:
            T = e[w + 1].x - e[w].x, b = e[w + 1].y - e[w].y, x.x = b * 1, x.y = -T, x.z = b * 0, E.copy(x), x.normalize(), c.push(x.x, x.y, x.z);
            break;
         case e.length - 1:
            c.push(E.x, E.y, E.z);
            break;
         default:
            T = e[w + 1].x - e[w].x, b = e[w + 1].y - e[w].y, x.x = b * 1, x.y = -T, x.z = b * 0, S.copy(x), x.x += E.x, x.y += E.y, x.z += E.z, x.normalize(), c.push(x.x, x.y, x.z), E.copy(S)
      }
      for (let w = 0; w <= t; w++) {
         const C = i + w * m * s,
            N = Math.sin(C),
            U = Math.cos(C);
         for (let z = 0; z <= e.length - 1; z++) {
            g.x = e[z].x * N, g.y = e[z].y, g.z = e[z].x * U, a.push(g.x, g.y, g.z), v.x = w / t, v.y = z / (e.length - 1), l.push(v.x, v.y);
            const B = c[3 * z + 0] * N,
               I = c[3 * z + 1],
               O = c[3 * z + 0] * U;
            h.push(B, I, O)
         }
      }
      for (let w = 0; w < t; w++)
         for (let C = 0; C < e.length - 1; C++) {
            const N = C + w * e.length,
               U = N,
               z = N + e.length,
               B = N + e.length + 1,
               I = N + 1;
            r.push(U, z, I), r.push(B, I, z)
         }
      this.setIndex(r), this.setAttribute("position", new Ct(a, 3)), this.setAttribute("uv", new Ct(l, 2)), this.setAttribute("normal", new Ct(h, 3))
   }
   copy(e) {
      return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
   }
   static fromJSON(e) {
      return new yx(e.points, e.segments, e.phiStart, e.phiLength)
   }
}
class vT extends yx {
   constructor(e = 1, t = 1, i = 4, s = 8) {
      const r = new Uy;
      r.absarc(0, -t / 2, e, Math.PI * 1.5, 0), r.absarc(0, t / 2, e, 0, Math.PI * .5), super(r.getPoints(i), s), this.type = "CapsuleGeometry", this.parameters = {
         radius: e,
         length: t,
         capSegments: i,
         radialSegments: s
      }
   }
   static fromJSON(e) {
      return new vT(e.radius, e.length, e.capSegments, e.radialSegments)
   }
}
class yT extends pn {
   constructor(e = 1, t = 32, i = 0, s = Math.PI * 2) {
      super(), this.type = "CircleGeometry", this.parameters = {
         radius: e,
         segments: t,
         thetaStart: i,
         thetaLength: s
      }, t = Math.max(3, t);
      const r = [],
         a = [],
         l = [],
         c = [],
         h = new ee,
         m = new Fe;
      a.push(0, 0, 0), l.push(0, 0, 1), c.push(.5, .5);
      for (let g = 0, v = 3; g <= t; g++, v += 3) {
         const x = i + g / t * s;
         h.x = e * Math.cos(x), h.y = e * Math.sin(x), a.push(h.x, h.y, h.z), l.push(0, 0, 1), m.x = (a[v] / e + 1) / 2, m.y = (a[v + 1] / e + 1) / 2, c.push(m.x, m.y)
      }
      for (let g = 1; g <= t; g++) r.push(g, g + 1, 0);
      this.setIndex(r), this.setAttribute("position", new Ct(a, 3)), this.setAttribute("normal", new Ct(l, 3)), this.setAttribute("uv", new Ct(c, 2))
   }
   copy(e) {
      return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
   }
   static fromJSON(e) {
      return new yT(e.radius, e.segments, e.thetaStart, e.thetaLength)
   }
}
class Lg extends pn {
   constructor(e = 1, t = 1, i = 1, s = 32, r = 1, a = !1, l = 0, c = Math.PI * 2) {
      super(), this.type = "CylinderGeometry", this.parameters = {
         radiusTop: e,
         radiusBottom: t,
         height: i,
         radialSegments: s,
         heightSegments: r,
         openEnded: a,
         thetaStart: l,
         thetaLength: c
      };
      const h = this;
      s = Math.floor(s), r = Math.floor(r);
      const m = [],
         g = [],
         v = [],
         x = [];
      let S = 0;
      const E = [],
         T = i / 2;
      let b = 0;
      w(), a === !1 && (e > 0 && C(!0), t > 0 && C(!1)), this.setIndex(m), this.setAttribute("position", new Ct(g, 3)), this.setAttribute("normal", new Ct(v, 3)), this.setAttribute("uv", new Ct(x, 2));

      function w() {
         const N = new ee,
            U = new ee;
         let z = 0;
         const B = (t - e) / i;
         for (let I = 0; I <= r; I++) {
            const O = [],
               P = I / r,
               q = P * (t - e) + e;
            for (let Q = 0; Q <= s; Q++) {
               const $ = Q / s,
                  ae = $ * c + l,
                  fe = Math.sin(ae),
                  k = Math.cos(ae);
               U.x = q * fe, U.y = -P * i + T, U.z = q * k, g.push(U.x, U.y, U.z), N.set(fe, B, k).normalize(), v.push(N.x, N.y, N.z), x.push($, 1 - P), O.push(S++)
            }
            E.push(O)
         }
         for (let I = 0; I < s; I++)
            for (let O = 0; O < r; O++) {
               const P = E[O][I],
                  q = E[O + 1][I],
                  Q = E[O + 1][I + 1],
                  $ = E[O][I + 1];
               (e > 0 || O !== 0) && (m.push(P, q, $), z += 3), (t > 0 || O !== r - 1) && (m.push(q, Q, $), z += 3)
            }
         h.addGroup(b, z, 0), b += z
      }

      function C(N) {
         const U = S,
            z = new Fe,
            B = new ee;
         let I = 0;
         const O = N === !0 ? e : t,
            P = N === !0 ? 1 : -1;
         for (let Q = 1; Q <= s; Q++) g.push(0, T * P, 0), v.push(0, P, 0), x.push(.5, .5), S++;
         const q = S;
         for (let Q = 0; Q <= s; Q++) {
            const ae = Q / s * c + l,
               fe = Math.cos(ae),
               k = Math.sin(ae);
            B.x = O * k, B.y = T * P, B.z = O * fe, g.push(B.x, B.y, B.z), v.push(0, P, 0), z.x = fe * .5 + .5, z.y = k * .5 * P + .5, x.push(z.x, z.y), S++
         }
         for (let Q = 0; Q < s; Q++) {
            const $ = U + Q,
               ae = q + Q;
            N === !0 ? m.push(ae, ae + 1, $) : m.push(ae + 1, ae, $), I += 3
         }
         h.addGroup(b, I, N === !0 ? 1 : 2), b += I
      }
   }
   copy(e) {
      return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
   }
   static fromJSON(e) {
      return new Lg(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength)
   }
}
class xT extends Lg {
   constructor(e = 1, t = 1, i = 32, s = 1, r = !1, a = 0, l = Math.PI * 2) {
      super(0, e, t, i, s, r, a, l), this.type = "ConeGeometry", this.parameters = {
         radius: e,
         height: t,
         radialSegments: i,
         heightSegments: s,
         openEnded: r,
         thetaStart: a,
         thetaLength: l
      }
   }
   static fromJSON(e) {
      return new xT(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength)
   }
}
class hh extends pn {
   constructor(e = [], t = [], i = 1, s = 0) {
      super(), this.type = "PolyhedronGeometry", this.parameters = {
         vertices: e,
         indices: t,
         radius: i,
         detail: s
      };
      const r = [],
         a = [];
      l(s), h(i), m(), this.setAttribute("position", new Ct(r, 3)), this.setAttribute("normal", new Ct(r.slice(), 3)), this.setAttribute("uv", new Ct(a, 2)), s === 0 ? this.computeVertexNormals() : this.normalizeNormals();

      function l(w) {
         const C = new ee,
            N = new ee,
            U = new ee;
         for (let z = 0; z < t.length; z += 3) x(t[z + 0], C), x(t[z + 1], N), x(t[z + 2], U), c(C, N, U, w)
      }

      function c(w, C, N, U) {
         const z = U + 1,
            B = [];
         for (let I = 0; I <= z; I++) {
            B[I] = [];
            const O = w.clone().lerp(N, I / z),
               P = C.clone().lerp(N, I / z),
               q = z - I;
            for (let Q = 0; Q <= q; Q++) Q === 0 && I === z ? B[I][Q] = O : B[I][Q] = O.clone().lerp(P, Q / q)
         }
         for (let I = 0; I < z; I++)
            for (let O = 0; O < 2 * (z - I) - 1; O++) {
               const P = Math.floor(O / 2);
               O % 2 === 0 ? (v(B[I][P + 1]), v(B[I + 1][P]), v(B[I][P])) : (v(B[I][P + 1]), v(B[I + 1][P + 1]), v(B[I + 1][P]))
            }
      }

      function h(w) {
         const C = new ee;
         for (let N = 0; N < r.length; N += 3) C.x = r[N + 0], C.y = r[N + 1], C.z = r[N + 2], C.normalize().multiplyScalar(w), r[N + 0] = C.x, r[N + 1] = C.y, r[N + 2] = C.z
      }

      function m() {
         const w = new ee;
         for (let C = 0; C < r.length; C += 3) {
            w.x = r[C + 0], w.y = r[C + 1], w.z = r[C + 2];
            const N = T(w) / 2 / Math.PI + .5,
               U = b(w) / Math.PI + .5;
            a.push(N, 1 - U)
         }
         S(), g()
      }

      function g() {
         for (let w = 0; w < a.length; w += 6) {
            const C = a[w + 0],
               N = a[w + 2],
               U = a[w + 4],
               z = Math.max(C, N, U),
               B = Math.min(C, N, U);
            z > .9 && B < .1 && (C < .2 && (a[w + 0] += 1), N < .2 && (a[w + 2] += 1), U < .2 && (a[w + 4] += 1))
         }
      }

      function v(w) {
         r.push(w.x, w.y, w.z)
      }

      function x(w, C) {
         const N = w * 3;
         C.x = e[N + 0], C.y = e[N + 1], C.z = e[N + 2]
      }

      function S() {
         const w = new ee,
            C = new ee,
            N = new ee,
            U = new ee,
            z = new Fe,
            B = new Fe,
            I = new Fe;
         for (let O = 0, P = 0; O < r.length; O += 9, P += 6) {
            w.set(r[O + 0], r[O + 1], r[O + 2]), C.set(r[O + 3], r[O + 4], r[O + 5]), N.set(r[O + 6], r[O + 7], r[O + 8]), z.set(a[P + 0], a[P + 1]), B.set(a[P + 2], a[P + 3]), I.set(a[P + 4], a[P + 5]), U.copy(w).add(C).add(N).divideScalar(3);
            const q = T(U);
            E(z, P + 0, w, q), E(B, P + 2, C, q), E(I, P + 4, N, q)
         }
      }

      function E(w, C, N, U) {
         U < 0 && w.x === 1 && (a[C] = w.x - 1), N.x === 0 && N.z === 0 && (a[C] = U / 2 / Math.PI + .5)
      }

      function T(w) {
         return Math.atan2(w.z, -w.x)
      }

      function b(w) {
         return Math.atan2(-w.y, Math.sqrt(w.x * w.x + w.z * w.z))
      }
   }
   copy(e) {
      return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
   }
   static fromJSON(e) {
      return new hh(e.vertices, e.indices, e.radius, e.details)
   }
}
class _T extends hh {
   constructor(e = 1, t = 0) {
      const i = (1 + Math.sqrt(5)) / 2,
         s = 1 / i,
         r = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -s, -i, 0, -s, i, 0, s, -i, 0, s, i, -s, -i, 0, -s, i, 0, s, -i, 0, s, i, 0, -i, 0, -s, i, 0, -s, -i, 0, s, i, 0, s],
         a = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
      super(r, a, e, t), this.type = "DodecahedronGeometry", this.parameters = {
         radius: e,
         detail: t
      }
   }
   static fromJSON(e) {
      return new _T(e.radius, e.detail)
   }
}
const BS = new ee,
   zS = new ee,
   EM = new ee,
   IS = new Pa;
class qL extends pn {
   constructor(e = null, t = 1) {
      if (super(), this.type = "EdgesGeometry", this.parameters = {
            geometry: e,
            thresholdAngle: t
         }, e !== null) {
         const s = Math.pow(10, 4),
            r = Math.cos(Hd * t),
            a = e.getIndex(),
            l = e.getAttribute("position"),
            c = a ? a.count : l.count,
            h = [0, 0, 0],
            m = ["a", "b", "c"],
            g = new Array(3),
            v = {},
            x = [];
         for (let S = 0; S < c; S += 3) {
            a ? (h[0] = a.getX(S), h[1] = a.getX(S + 1), h[2] = a.getX(S + 2)) : (h[0] = S, h[1] = S + 1, h[2] = S + 2);
            const {
               a: E,
               b: T,
               c: b
            } = IS;
            if (E.fromBufferAttribute(l, h[0]), T.fromBufferAttribute(l, h[1]), b.fromBufferAttribute(l, h[2]), IS.getNormal(EM), g[0] = `${Math.round(E.x*s)},${Math.round(E.y*s)},${Math.round(E.z*s)}`, g[1] = `${Math.round(T.x*s)},${Math.round(T.y*s)},${Math.round(T.z*s)}`, g[2] = `${Math.round(b.x*s)},${Math.round(b.y*s)},${Math.round(b.z*s)}`, !(g[0] === g[1] || g[1] === g[2] || g[2] === g[0]))
               for (let w = 0; w < 3; w++) {
                  const C = (w + 1) % 3,
                     N = g[w],
                     U = g[C],
                     z = IS[m[w]],
                     B = IS[m[C]],
                     I = `${N}_${U}`,
                     O = `${U}_${N}`;
                  O in v && v[O] ? (EM.dot(v[O].normal) <= r && (x.push(z.x, z.y, z.z), x.push(B.x, B.y, B.z)), v[O] = null) : I in v || (v[I] = {
                     index0: h[w],
                     index1: h[C],
                     normal: EM.clone()
                  })
               }
         }
         for (const S in v)
            if (v[S]) {
               const {
                  index0: E,
                  index1: T
               } = v[S];
               BS.fromBufferAttribute(l, E), zS.fromBufferAttribute(l, T), x.push(BS.x, BS.y, BS.z), x.push(zS.x, zS.y, zS.z)
            } this.setAttribute("position", new Ct(x, 3))
      }
   }
   copy(e) {
      return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
   }
}
class Vd extends Uy {
   constructor(e) {
      super(e), this.uuid = po(), this.type = "Shape", this.holes = []
   }
   getPointsHoles(e) {
      const t = [];
      for (let i = 0, s = this.holes.length; i < s; i++) t[i] = this.holes[i].getPoints(e);
      return t
   }
   extractPoints(e) {
      return {
         shape: this.getPoints(e),
         holes: this.getPointsHoles(e)
      }
   }
   copy(e) {
      super.copy(e), this.holes = [];
      for (let t = 0, i = e.holes.length; t < i; t++) {
         const s = e.holes[t];
         this.holes.push(s.clone())
      }
      return this
   }
   toJSON() {
      const e = super.toJSON();
      e.uuid = this.uuid, e.holes = [];
      for (let t = 0, i = this.holes.length; t < i; t++) {
         const s = this.holes[t];
         e.holes.push(s.toJSON())
      }
      return e
   }
   fromJSON(e) {
      super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
      for (let t = 0, i = e.holes.length; t < i; t++) {
         const s = e.holes[t];
         this.holes.push(new Uy().fromJSON(s))
      }
      return this
   }
}

function TG(n, e, t = 2) {
   const i = e && e.length,
      s = i ? e[0] * t : n.length;
   let r = XL(n, 0, s, t, !0);
   const a = [];
   if (!r || r.next === r.prev) return a;
   let l, c, h;
   if (i && (r = RG(n, e, r, t)), n.length > 80 * t) {
      l = 1 / 0, c = 1 / 0;
      let m = -1 / 0,
         g = -1 / 0;
      for (let v = t; v < s; v += t) {
         const x = n[v],
            S = n[v + 1];
         x < l && (l = x), S < c && (c = S), x > m && (m = x), S > g && (g = S)
      }
      h = Math.max(m - l, g - c), h = h !== 0 ? 32767 / h : 0
   }
   return Py(r, a, t, l, c, h, 0), a
}

function XL(n, e, t, i, s) {
   let r;
   if (s === FG(n, e, t, i) > 0)
      for (let a = e; a < t; a += i) r = r3(a / i | 0, n[a], n[a + 1], r);
   else
      for (let a = t - i; a >= e; a -= i) r = r3(a / i | 0, n[a], n[a + 1], r);
   return r && vg(r, r.next) && (By(r), r = r.next), r
}

function tp(n, e) {
   if (!n) return n;
   e || (e = n);
   let t = n,
      i;
   do
      if (i = !1, !t.steiner && (vg(t, t.next) || Wi(t.prev, t, t.next) === 0)) {
         if (By(t), t = e = t.prev, t === t.next) break;
         i = !0
      } else t = t.next; while (i || t !== e);
   return e
}

function Py(n, e, t, i, s, r, a) {
   if (!n) return;
   !a && r && UG(n, i, s, r);
   let l = n;
   for (; n.prev !== n.next;) {
      const c = n.prev,
         h = n.next;
      if (r ? MG(n, i, s, r) : EG(n)) {
         e.push(c.i, n.i, h.i), By(n), n = h.next, l = h.next;
         continue
      }
      if (n = h, n === l) {
         a ? a === 1 ? (n = AG(tp(n), e), Py(n, e, t, i, s, r, 2)) : a === 2 && wG(n, e, t, i, s, r) : Py(tp(n), e, t, i, s, r, 1);
         break
      }
   }
}

function EG(n) {
   const e = n.prev,
      t = n,
      i = n.next;
   if (Wi(e, t, i) >= 0) return !1;
   const s = e.x,
      r = t.x,
      a = i.x,
      l = e.y,
      c = t.y,
      h = i.y,
      m = Math.min(s, r, a),
      g = Math.min(l, c, h),
      v = Math.max(s, r, a),
      x = Math.max(l, c, h);
   let S = i.next;
   for (; S !== e;) {
      if (S.x >= m && S.x <= v && S.y >= g && S.y <= x && R0(s, l, r, c, a, h, S.x, S.y) && Wi(S.prev, S, S.next) >= 0) return !1;
      S = S.next
   }
   return !0
}

function MG(n, e, t, i) {
   const s = n.prev,
      r = n,
      a = n.next;
   if (Wi(s, r, a) >= 0) return !1;
   const l = s.x,
      c = r.x,
      h = a.x,
      m = s.y,
      g = r.y,
      v = a.y,
      x = Math.min(l, c, h),
      S = Math.min(m, g, v),
      E = Math.max(l, c, h),
      T = Math.max(m, g, v),
      b = YA(x, S, e, t, i),
      w = YA(E, T, e, t, i);
   let C = n.prevZ,
      N = n.nextZ;
   for (; C && C.z >= b && N && N.z <= w;) {
      if (C.x >= x && C.x <= E && C.y >= S && C.y <= T && C !== s && C !== a && R0(l, m, c, g, h, v, C.x, C.y) && Wi(C.prev, C, C.next) >= 0 || (C = C.prevZ, N.x >= x && N.x <= E && N.y >= S && N.y <= T && N !== s && N !== a && R0(l, m, c, g, h, v, N.x, N.y) && Wi(N.prev, N, N.next) >= 0)) return !1;
      N = N.nextZ
   }
   for (; C && C.z >= b;) {
      if (C.x >= x && C.x <= E && C.y >= S && C.y <= T && C !== s && C !== a && R0(l, m, c, g, h, v, C.x, C.y) && Wi(C.prev, C, C.next) >= 0) return !1;
      C = C.prevZ
   }
   for (; N && N.z <= w;) {
      if (N.x >= x && N.x <= E && N.y >= S && N.y <= T && N !== s && N !== a && R0(l, m, c, g, h, v, N.x, N.y) && Wi(N.prev, N, N.next) >= 0) return !1;
      N = N.nextZ
   }
   return !0
}

function AG(n, e) {
   let t = n;
   do {
      const i = t.prev,
         s = t.next.next;
      !vg(i, s) && YL(i, t, t.next, s) && Ly(i, s) && Ly(s, i) && (e.push(i.i, t.i, s.i), By(t), By(t.next), t = n = s), t = t.next
   } while (t !== n);
   return tp(t)
}

function wG(n, e, t, i, s, r) {
   let a = n;
   do {
      let l = a.next.next;
      for (; l !== a.prev;) {
         if (a.i !== l.i && BG(a, l)) {
            let c = KL(a, l);
            a = tp(a, a.next), c = tp(c, c.next), Py(a, e, t, i, s, r, 0), Py(c, e, t, i, s, r, 0);
            return
         }
         l = l.next
      }
      a = a.next
   } while (a !== n)
}

function RG(n, e, t, i) {
   const s = [];
   for (let r = 0, a = e.length; r < a; r++) {
      const l = e[r] * i,
         c = r < a - 1 ? e[r + 1] * i : n.length,
         h = XL(n, l, c, i, !1);
      h === h.next && (h.steiner = !0), s.push(LG(h))
   }
   s.sort(CG);
   for (let r = 0; r < s.length; r++) t = DG(s[r], t);
   return t
}

function CG(n, e) {
   let t = n.x - e.x;
   if (t === 0 && (t = n.y - e.y, t === 0)) {
      const i = (n.next.y - n.y) / (n.next.x - n.x),
         s = (e.next.y - e.y) / (e.next.x - e.x);
      t = i - s
   }
   return t
}

function DG(n, e) {
   const t = NG(n, e);
   if (!t) return e;
   const i = KL(t, n);
   return tp(i, i.next), tp(t, t.next)
}

function NG(n, e) {
   let t = e;
   const i = n.x,
      s = n.y;
   let r = -1 / 0,
      a;
   if (vg(n, t)) return t;
   do {
      if (vg(n, t.next)) return t.next;
      if (s <= t.y && s >= t.next.y && t.next.y !== t.y) {
         const g = t.x + (s - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
         if (g <= i && g > r && (r = g, a = t.x < t.next.x ? t : t.next, g === i)) return a
      }
      t = t.next
   } while (t !== e);
   if (!a) return null;
   const l = a,
      c = a.x,
      h = a.y;
   let m = 1 / 0;
   t = a;
   do {
      if (i >= t.x && t.x >= c && i !== t.x && WL(s < h ? i : r, s, c, h, s < h ? r : i, s, t.x, t.y)) {
         const g = Math.abs(s - t.y) / (i - t.x);
         Ly(t, n) && (g < m || g === m && (t.x > a.x || t.x === a.x && OG(a, t))) && (a = t, m = g)
      }
      t = t.next
   } while (t !== l);
   return a
}

function OG(n, e) {
   return Wi(n.prev, n, e.prev) < 0 && Wi(e.next, n, n.next) < 0
}

function UG(n, e, t, i) {
   let s = n;
   do s.z === 0 && (s.z = YA(s.x, s.y, e, t, i)), s.prevZ = s.prev, s.nextZ = s.next, s = s.next; while (s !== n);
   s.prevZ.nextZ = null, s.prevZ = null, PG(s)
}

function PG(n) {
   let e, t = 1;
   do {
      let i = n,
         s;
      n = null;
      let r = null;
      for (e = 0; i;) {
         e++;
         let a = i,
            l = 0;
         for (let h = 0; h < t && (l++, a = a.nextZ, !!a); h++);
         let c = t;
         for (; l > 0 || c > 0 && a;) l !== 0 && (c === 0 || !a || i.z <= a.z) ? (s = i, i = i.nextZ, l--) : (s = a, a = a.nextZ, c--), r ? r.nextZ = s : n = s, s.prevZ = r, r = s;
         i = a
      }
      r.nextZ = null, t *= 2
   } while (e > 1);
   return n
}

function YA(n, e, t, i, s) {
   return n = (n - t) * s | 0, e = (e - i) * s | 0, n = (n | n << 8) & 16711935, n = (n | n << 4) & 252645135, n = (n | n << 2) & 858993459, n = (n | n << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, n | e << 1
}

function LG(n) {
   let e = n,
      t = n;
   do(e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next; while (e !== n);
   return t
}

function WL(n, e, t, i, s, r, a, l) {
   return (s - a) * (e - l) >= (n - a) * (r - l) && (n - a) * (i - l) >= (t - a) * (e - l) && (t - a) * (r - l) >= (s - a) * (i - l)
}

function R0(n, e, t, i, s, r, a, l) {
   return !(n === a && e === l) && WL(n, e, t, i, s, r, a, l)
}

function BG(n, e) {
   return n.next.i !== e.i && n.prev.i !== e.i && !zG(n, e) && (Ly(n, e) && Ly(e, n) && IG(n, e) && (Wi(n.prev, n, e.prev) || Wi(n, e.prev, e)) || vg(n, e) && Wi(n.prev, n, n.next) > 0 && Wi(e.prev, e, e.next) > 0)
}

function Wi(n, e, t) {
   return (e.y - n.y) * (t.x - e.x) - (e.x - n.x) * (t.y - e.y)
}

function vg(n, e) {
   return n.x === e.x && n.y === e.y
}

function YL(n, e, t, i) {
   const s = HS(Wi(n, e, t)),
      r = HS(Wi(n, e, i)),
      a = HS(Wi(t, i, n)),
      l = HS(Wi(t, i, e));
   return !!(s !== r && a !== l || s === 0 && FS(n, t, e) || r === 0 && FS(n, i, e) || a === 0 && FS(t, n, i) || l === 0 && FS(t, e, i))
}

function FS(n, e, t) {
   return e.x <= Math.max(n.x, t.x) && e.x >= Math.min(n.x, t.x) && e.y <= Math.max(n.y, t.y) && e.y >= Math.min(n.y, t.y)
}

function HS(n) {
   return n > 0 ? 1 : n < 0 ? -1 : 0
}

function zG(n, e) {
   let t = n;
   do {
      if (t.i !== n.i && t.next.i !== n.i && t.i !== e.i && t.next.i !== e.i && YL(t, t.next, n, e)) return !0;
      t = t.next
   } while (t !== n);
   return !1
}

function Ly(n, e) {
   return Wi(n.prev, n, n.next) < 0 ? Wi(n, e, n.next) >= 0 && Wi(n, n.prev, e) >= 0 : Wi(n, e, n.prev) < 0 || Wi(n, n.next, e) < 0
}

function IG(n, e) {
   let t = n,
      i = !1;
   const s = (n.x + e.x) / 2,
      r = (n.y + e.y) / 2;
   do t.y > r != t.next.y > r && t.next.y !== t.y && s < (t.next.x - t.x) * (r - t.y) / (t.next.y - t.y) + t.x && (i = !i), t = t.next; while (t !== n);
   return i
}

function KL(n, e) {
   const t = KA(n.i, n.x, n.y),
      i = KA(e.i, e.x, e.y),
      s = n.next,
      r = e.prev;
   return n.next = e, e.prev = n, t.next = s, s.prev = t, i.next = t, t.prev = i, r.next = i, i.prev = r, i
}

function r3(n, e, t, i) {
   const s = KA(n, e, t);
   return i ? (s.next = i.next, s.prev = i, i.next.prev = s, i.next = s) : (s.prev = s, s.next = s), s
}

function By(n) {
   n.next.prev = n.prev, n.prev.next = n.next, n.prevZ && (n.prevZ.nextZ = n.nextZ), n.nextZ && (n.nextZ.prevZ = n.prevZ)
}

function KA(n, e, t) {
   return {
      i: n,
      x: e,
      y: t,
      prev: null,
      next: null,
      z: 0,
      prevZ: null,
      nextZ: null,
      steiner: !1
   }
}

function FG(n, e, t, i) {
   let s = 0;
   for (let r = e, a = t - i; r < t; r += i) s += (n[a] - n[r]) * (n[r + 1] + n[a + 1]), a = r;
   return s
}
class HG {
   static triangulate(e, t, i = 2) {
      return TG(e, t, i)
   }
}
class Lu {
   static area(e) {
      const t = e.length;
      let i = 0;
      for (let s = t - 1, r = 0; r < t; s = r++) i += e[s].x * e[r].y - e[r].x * e[s].y;
      return i * .5
   }
   static isClockWise(e) {
      return Lu.area(e) < 0
   }
   static triangulateShape(e, t) {
      const i = [],
         s = [],
         r = [];
      a3(e), o3(i, e);
      let a = e.length;
      t.forEach(a3);
      for (let c = 0; c < t.length; c++) s.push(a), a += t[c].length, o3(i, t[c]);
      const l = HG.triangulate(i, s);
      for (let c = 0; c < l.length; c += 3) r.push(l.slice(c, c + 3));
      return r
   }
}

function a3(n) {
   const e = n.length;
   e > 2 && n[e - 1].equals(n[0]) && n.pop()
}

function o3(n, e) {
   for (let t = 0; t < e.length; t++) n.push(e[t].x), n.push(e[t].y)
}
class ST extends pn {
   constructor(e = new Vd([new Fe(.5, .5), new Fe(-.5, .5), new Fe(-.5, -.5), new Fe(.5, -.5)]), t = {}) {
      super(), this.type = "ExtrudeGeometry", this.parameters = {
         shapes: e,
         options: t
      }, e = Array.isArray(e) ? e : [e];
      const i = this,
         s = [],
         r = [];
      for (let l = 0, c = e.length; l < c; l++) {
         const h = e[l];
         a(h)
      }
      this.setAttribute("position", new Ct(s, 3)), this.setAttribute("uv", new Ct(r, 2)), this.computeVertexNormals();

      function a(l) {
         const c = [],
            h = t.curveSegments !== void 0 ? t.curveSegments : 12,
            m = t.steps !== void 0 ? t.steps : 1,
            g = t.depth !== void 0 ? t.depth : 1;
         let v = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0,
            x = t.bevelThickness !== void 0 ? t.bevelThickness : .2,
            S = t.bevelSize !== void 0 ? t.bevelSize : x - .1,
            E = t.bevelOffset !== void 0 ? t.bevelOffset : 0,
            T = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
         const b = t.extrudePath,
            w = t.UVGenerator !== void 0 ? t.UVGenerator : VG;
         let C, N = !1,
            U, z, B, I;
         b && (C = b.getSpacedPoints(m), N = !0, v = !1, U = b.computeFrenetFrames(m, !1), z = new ee, B = new ee, I = new ee), v || (T = 0, x = 0, S = 0, E = 0);
         const O = l.extractPoints(h);
         let P = O.shape;
         const q = O.holes;
         if (!Lu.isClockWise(P)) {
            P = P.reverse();
            for (let ze = 0, te = q.length; ze < te; ze++) {
               const Be = q[ze];
               Lu.isClockWise(Be) && (q[ze] = Be.reverse())
            }
         }

         function $(ze) {
            const Be = 10000000000000001e-36;
            let Je = ze[0];
            for (let Ue = 1; Ue <= ze.length; Ue++) {
               const K = Ue % ze.length,
                  G = ze[K],
                  me = G.x - Je.x,
                  Ne = G.y - Je.y,
                  Oe = me * me + Ne * Ne,
                  De = Math.max(Math.abs(G.x), Math.abs(G.y), Math.abs(Je.x), Math.abs(Je.y)),
                  Ye = Be * De * De;
               if (Oe <= Ye) {
                  ze.splice(K, 1), Ue--;
                  continue
               }
               Je = G
            }
         }
         $(P), q.forEach($);
         const ae = q.length,
            fe = P;
         for (let ze = 0; ze < ae; ze++) {
            const te = q[ze];
            P = P.concat(te)
         }

         function k(ze, te, Be) {
            return te || console.error("THREE.ExtrudeGeometry: vec does not exist"), ze.clone().addScaledVector(te, Be)
         }
         const Z = P.length;

         function J(ze, te, Be) {
            let Je, Ue, K;
            const G = ze.x - te.x,
               me = ze.y - te.y,
               Ne = Be.x - ze.x,
               Oe = Be.y - ze.y,
               De = G * G + me * me,
               Ye = G * Oe - me * Ne;
            if (Math.abs(Ye) > Number.EPSILON) {
               const We = Math.sqrt(De),
                  Ze = Math.sqrt(Ne * Ne + Oe * Oe),
                  kt = te.x - me / We,
                  Ke = te.y + G / We,
                  et = Be.x - Oe / Ze,
                  xt = Be.y + Ne / Ze,
                  mt = ((et - kt) * Oe - (xt - Ke) * Ne) / (G * Oe - me * Ne);
               Je = kt + G * mt - ze.x, Ue = Ke + me * mt - ze.y;
               const it = Je * Je + Ue * Ue;
               if (it <= 2) return new Fe(Je, Ue);
               K = Math.sqrt(it / 2)
            } else {
               let We = !1;
               G > Number.EPSILON ? Ne > Number.EPSILON && (We = !0) : G < -Number.EPSILON ? Ne < -Number.EPSILON && (We = !0) : Math.sign(me) === Math.sign(Oe) && (We = !0), We ? (Je = -me, Ue = G, K = Math.sqrt(De)) : (Je = G, Ue = me, K = Math.sqrt(De / 2))
            }
            return new Fe(Je / K, Ue / K)
         }
         const pe = [];
         for (let ze = 0, te = fe.length, Be = te - 1, Je = ze + 1; ze < te; ze++, Be++, Je++) Be === te && (Be = 0), Je === te && (Je = 0), pe[ze] = J(fe[ze], fe[Be], fe[Je]);
         const F = [];
         let ie, ye = pe.concat();
         for (let ze = 0, te = ae; ze < te; ze++) {
            const Be = q[ze];
            ie = [];
            for (let Je = 0, Ue = Be.length, K = Ue - 1, G = Je + 1; Je < Ue; Je++, K++, G++) K === Ue && (K = 0), G === Ue && (G = 0), ie[Je] = J(Be[Je], Be[K], Be[G]);
            F.push(ie), ye = ye.concat(ie)
         }
         const we = [],
            oe = [];
         for (let ze = 0; ze < T; ze++) {
            const te = ze / T,
               Be = x * Math.cos(te * Math.PI / 2),
               Je = S * Math.sin(te * Math.PI / 2) + E;
            for (let Ue = 0, K = fe.length; Ue < K; Ue++) {
               const G = k(fe[Ue], pe[Ue], Je);
               Mt(G.x, G.y, -Be), te == 0 && we.push(G)
            }
            for (let Ue = 0, K = ae; Ue < K; Ue++) {
               const G = q[Ue];
               ie = F[Ue];
               const me = [];
               for (let Ne = 0, Oe = G.length; Ne < Oe; Ne++) {
                  const De = k(G[Ne], ie[Ne], Je);
                  Mt(De.x, De.y, -Be), te == 0 && me.push(De)
               }
               te == 0 && oe.push(me)
            }
         }
         const be = Lu.triangulateShape(we, oe),
            Pe = be.length,
            Ge = S + E;
         for (let ze = 0; ze < Z; ze++) {
            const te = v ? k(P[ze], ye[ze], Ge) : P[ze];
            N ? (B.copy(U.normals[0]).multiplyScalar(te.x), z.copy(U.binormals[0]).multiplyScalar(te.y), I.copy(C[0]).add(B).add(z), Mt(I.x, I.y, I.z)) : Mt(te.x, te.y, 0)
         }
         for (let ze = 1; ze <= m; ze++)
            for (let te = 0; te < Z; te++) {
               const Be = v ? k(P[te], ye[te], Ge) : P[te];
               N ? (B.copy(U.normals[ze]).multiplyScalar(Be.x), z.copy(U.binormals[ze]).multiplyScalar(Be.y), I.copy(C[ze]).add(B).add(z), Mt(I.x, I.y, I.z)) : Mt(Be.x, Be.y, g / m * ze)
            }
         for (let ze = T - 1; ze >= 0; ze--) {
            const te = ze / T,
               Be = x * Math.cos(te * Math.PI / 2),
               Je = S * Math.sin(te * Math.PI / 2) + E;
            for (let Ue = 0, K = fe.length; Ue < K; Ue++) {
               const G = k(fe[Ue], pe[Ue], Je);
               Mt(G.x, G.y, g + Be)
            }
            for (let Ue = 0, K = q.length; Ue < K; Ue++) {
               const G = q[Ue];
               ie = F[Ue];
               for (let me = 0, Ne = G.length; me < Ne; me++) {
                  const Oe = k(G[me], ie[me], Je);
                  N ? Mt(Oe.x, Oe.y + C[m - 1].y, C[m - 1].x + Be) : Mt(Oe.x, Oe.y, g + Be)
               }
            }
         }
         Xe(), yt();

         function Xe() {
            const ze = s.length / 3;
            if (v) {
               let te = 0,
                  Be = Z * te;
               for (let Je = 0; Je < Pe; Je++) {
                  const Ue = be[Je];
                  zt(Ue[2] + Be, Ue[1] + Be, Ue[0] + Be)
               }
               te = m + T * 2, Be = Z * te;
               for (let Je = 0; Je < Pe; Je++) {
                  const Ue = be[Je];
                  zt(Ue[0] + Be, Ue[1] + Be, Ue[2] + Be)
               }
            } else {
               for (let te = 0; te < Pe; te++) {
                  const Be = be[te];
                  zt(Be[2], Be[1], Be[0])
               }
               for (let te = 0; te < Pe; te++) {
                  const Be = be[te];
                  zt(Be[0] + Z * m, Be[1] + Z * m, Be[2] + Z * m)
               }
            }
            i.addGroup(ze, s.length / 3 - ze, 0)
         }

         function yt() {
            const ze = s.length / 3;
            let te = 0;
            vt(fe, te), te += fe.length;
            for (let Be = 0, Je = q.length; Be < Je; Be++) {
               const Ue = q[Be];
               vt(Ue, te), te += Ue.length
            }
            i.addGroup(ze, s.length / 3 - ze, 1)
         }

         function vt(ze, te) {
            let Be = ze.length;
            for (; --Be >= 0;) {
               const Je = Be;
               let Ue = Be - 1;
               Ue < 0 && (Ue = ze.length - 1);
               for (let K = 0, G = m + T * 2; K < G; K++) {
                  const me = Z * K,
                     Ne = Z * (K + 1),
                     Oe = te + Je + me,
                     De = te + Ue + me,
                     Ye = te + Ue + Ne,
                     We = te + Je + Ne;
                  lt(Oe, De, Ye, We)
               }
            }
         }

         function Mt(ze, te, Be) {
            c.push(ze), c.push(te), c.push(Be)
         }

         function zt(ze, te, Be) {
            ne(ze), ne(te), ne(Be);
            const Je = s.length / 3,
               Ue = w.generateTopUV(i, s, Je - 3, Je - 2, Je - 1);
            sn(Ue[0]), sn(Ue[1]), sn(Ue[2])
         }

         function lt(ze, te, Be, Je) {
            ne(ze), ne(te), ne(Je), ne(te), ne(Be), ne(Je);
            const Ue = s.length / 3,
               K = w.generateSideWallUV(i, s, Ue - 6, Ue - 3, Ue - 2, Ue - 1);
            sn(K[0]), sn(K[1]), sn(K[3]), sn(K[1]), sn(K[2]), sn(K[3])
         }

         function ne(ze) {
            s.push(c[ze * 3 + 0]), s.push(c[ze * 3 + 1]), s.push(c[ze * 3 + 2])
         }

         function sn(ze) {
            r.push(ze.x), r.push(ze.y)
         }
      }
   }
   copy(e) {
      return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
   }
   toJSON() {
      const e = super.toJSON(),
         t = this.parameters.shapes,
         i = this.parameters.options;
      return GG(t, i, e)
   }
   static fromJSON(e, t) {
      const i = [];
      for (let r = 0, a = e.shapes.length; r < a; r++) {
         const l = t[e.shapes[r]];
         i.push(l)
      }
      const s = e.options.extrudePath;
      return s !== void 0 && (e.options.extrudePath = new b1[s.type]().fromJSON(s)), new ST(i, e.options)
   }
}
const VG = {
   generateTopUV: function (n, e, t, i, s) {
      const r = e[t * 3],
         a = e[t * 3 + 1],
         l = e[i * 3],
         c = e[i * 3 + 1],
         h = e[s * 3],
         m = e[s * 3 + 1];
      return [new Fe(r, a), new Fe(l, c), new Fe(h, m)]
   },
   generateSideWallUV: function (n, e, t, i, s, r) {
      const a = e[t * 3],
         l = e[t * 3 + 1],
         c = e[t * 3 + 2],
         h = e[i * 3],
         m = e[i * 3 + 1],
         g = e[i * 3 + 2],
         v = e[s * 3],
         x = e[s * 3 + 1],
         S = e[s * 3 + 2],
         E = e[r * 3],
         T = e[r * 3 + 1],
         b = e[r * 3 + 2];
      return Math.abs(l - m) < Math.abs(a - h) ? [new Fe(a, 1 - c), new Fe(h, 1 - g), new Fe(v, 1 - S), new Fe(E, 1 - b)] : [new Fe(l, 1 - c), new Fe(m, 1 - g), new Fe(x, 1 - S), new Fe(T, 1 - b)]
   }
};

function GG(n, e, t) {
   if (t.shapes = [], Array.isArray(n))
      for (let i = 0, s = n.length; i < s; i++) {
         const r = n[i];
         t.shapes.push(r.uuid)
      } else t.shapes.push(n.uuid);
   return t.options = Object.assign({}, e), e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()), t
}
class bT extends hh {
   constructor(e = 1, t = 0) {
      const i = (1 + Math.sqrt(5)) / 2,
         s = [-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1],
         r = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
      super(s, r, e, t), this.type = "IcosahedronGeometry", this.parameters = {
         radius: e,
         detail: t
      }
   }
   static fromJSON(e) {
      return new bT(e.radius, e.detail)
   }
}
class xx extends hh {
   constructor(e = 1, t = 0) {
      const i = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
         s = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
      super(i, s, e, t), this.type = "OctahedronGeometry", this.parameters = {
         radius: e,
         detail: t
      }
   }
   static fromJSON(e) {
      return new xx(e.radius, e.detail)
   }
}
class Bg extends pn {
   constructor(e = 1, t = 1, i = 1, s = 1) {
      super(), this.type = "PlaneGeometry", this.parameters = {
         width: e,
         height: t,
         widthSegments: i,
         heightSegments: s
      };
      const r = e / 2,
         a = t / 2,
         l = Math.floor(i),
         c = Math.floor(s),
         h = l + 1,
         m = c + 1,
         g = e / l,
         v = t / c,
         x = [],
         S = [],
         E = [],
         T = [];
      for (let b = 0; b < m; b++) {
         const w = b * v - a;
         for (let C = 0; C < h; C++) {
            const N = C * g - r;
            S.push(N, -w, 0), E.push(0, 0, 1), T.push(C / l), T.push(1 - b / c)
         }
      }
      for (let b = 0; b < c; b++)
         for (let w = 0; w < l; w++) {
            const C = w + h * b,
               N = w + h * (b + 1),
               U = w + 1 + h * (b + 1),
               z = w + 1 + h * b;
            x.push(C, N, z), x.push(N, U, z)
         }
      this.setIndex(x), this.setAttribute("position", new Ct(S, 3)), this.setAttribute("normal", new Ct(E, 3)), this.setAttribute("uv", new Ct(T, 2))
   }
   copy(e) {
      return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
   }
   static fromJSON(e) {
      return new Bg(e.width, e.height, e.widthSegments, e.heightSegments)
   }
}
class TT extends pn {
   constructor(e = .5, t = 1, i = 32, s = 1, r = 0, a = Math.PI * 2) {
      super(), this.type = "RingGeometry", this.parameters = {
         innerRadius: e,
         outerRadius: t,
         thetaSegments: i,
         phiSegments: s,
         thetaStart: r,
         thetaLength: a
      }, i = Math.max(3, i), s = Math.max(1, s);
      const l = [],
         c = [],
         h = [],
         m = [];
      let g = e;
      const v = (t - e) / s,
         x = new ee,
         S = new Fe;
      for (let E = 0; E <= s; E++) {
         for (let T = 0; T <= i; T++) {
            const b = r + T / i * a;
            x.x = g * Math.cos(b), x.y = g * Math.sin(b), c.push(x.x, x.y, x.z), h.push(0, 0, 1), S.x = (x.x / t + 1) / 2, S.y = (x.y / t + 1) / 2, m.push(S.x, S.y)
         }
         g += v
      }
      for (let E = 0; E < s; E++) {
         const T = E * (i + 1);
         for (let b = 0; b < i; b++) {
            const w = b + T,
               C = w,
               N = w + i + 1,
               U = w + i + 2,
               z = w + 1;
            l.push(C, N, z), l.push(N, U, z)
         }
      }
      this.setIndex(l), this.setAttribute("position", new Ct(c, 3)), this.setAttribute("normal", new Ct(h, 3)), this.setAttribute("uv", new Ct(m, 2))
   }
   copy(e) {
      return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
   }
   static fromJSON(e) {
      return new TT(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength)
   }
}
class ET extends pn {
   constructor(e = new Vd([new Fe(0, .5), new Fe(-.5, -.5), new Fe(.5, -.5)]), t = 12) {
      super(), this.type = "ShapeGeometry", this.parameters = {
         shapes: e,
         curveSegments: t
      };
      const i = [],
         s = [],
         r = [],
         a = [];
      let l = 0,
         c = 0;
      if (Array.isArray(e) === !1) h(e);
      else
         for (let m = 0; m < e.length; m++) h(e[m]), this.addGroup(l, c, m), l += c, c = 0;
      this.setIndex(i), this.setAttribute("position", new Ct(s, 3)), this.setAttribute("normal", new Ct(r, 3)), this.setAttribute("uv", new Ct(a, 2));

      function h(m) {
         const g = s.length / 3,
            v = m.extractPoints(t);
         let x = v.shape;
         const S = v.holes;
         Lu.isClockWise(x) === !1 && (x = x.reverse());
         for (let T = 0, b = S.length; T < b; T++) {
            const w = S[T];
            Lu.isClockWise(w) === !0 && (S[T] = w.reverse())
         }
         const E = Lu.triangulateShape(x, S);
         for (let T = 0, b = S.length; T < b; T++) {
            const w = S[T];
            x = x.concat(w)
         }
         for (let T = 0, b = x.length; T < b; T++) {
            const w = x[T];
            s.push(w.x, w.y, 0), r.push(0, 0, 1), a.push(w.x, w.y)
         }
         for (let T = 0, b = E.length; T < b; T++) {
            const w = E[T],
               C = w[0] + g,
               N = w[1] + g,
               U = w[2] + g;
            i.push(C, N, U), c += 3
         }
      }
   }
   copy(e) {
      return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
   }
   toJSON() {
      const e = super.toJSON(),
         t = this.parameters.shapes;
      return kG(t, e)
   }
   static fromJSON(e, t) {
      const i = [];
      for (let s = 0, r = e.shapes.length; s < r; s++) {
         const a = t[e.shapes[s]];
         i.push(a)
      }
      return new ET(i, e.curveSegments)
   }
}

function kG(n, e) {
   if (e.shapes = [], Array.isArray(n))
      for (let t = 0, i = n.length; t < i; t++) {
         const s = n[t];
         e.shapes.push(s.uuid)
      } else e.shapes.push(n.uuid);
   return e
}
class cp extends pn {
   constructor(e = 1, t = 32, i = 16, s = 0, r = Math.PI * 2, a = 0, l = Math.PI) {
      super(), this.type = "SphereGeometry", this.parameters = {
         radius: e,
         widthSegments: t,
         heightSegments: i,
         phiStart: s,
         phiLength: r,
         thetaStart: a,
         thetaLength: l
      }, t = Math.max(3, Math.floor(t)), i = Math.max(2, Math.floor(i));
      const c = Math.min(a + l, Math.PI);
      let h = 0;
      const m = [],
         g = new ee,
         v = new ee,
         x = [],
         S = [],
         E = [],
         T = [];
      for (let b = 0; b <= i; b++) {
         const w = [],
            C = b / i;
         let N = 0;
         b === 0 && a === 0 ? N = .5 / t : b === i && c === Math.PI && (N = -.5 / t);
         for (let U = 0; U <= t; U++) {
            const z = U / t;
            g.x = -e * Math.cos(s + z * r) * Math.sin(a + C * l), g.y = e * Math.cos(a + C * l), g.z = e * Math.sin(s + z * r) * Math.sin(a + C * l), S.push(g.x, g.y, g.z), v.copy(g).normalize(), E.push(v.x, v.y, v.z), T.push(z + N, 1 - C), w.push(h++)
         }
         m.push(w)
      }
      for (let b = 0; b < i; b++)
         for (let w = 0; w < t; w++) {
            const C = m[b][w + 1],
               N = m[b][w],
               U = m[b + 1][w],
               z = m[b + 1][w + 1];
            (b !== 0 || a > 0) && x.push(C, N, z), (b !== i - 1 || c < Math.PI) && x.push(N, U, z)
         }
      this.setIndex(x), this.setAttribute("position", new Ct(S, 3)), this.setAttribute("normal", new Ct(E, 3)), this.setAttribute("uv", new Ct(T, 2))
   }
   copy(e) {
      return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
   }
   static fromJSON(e) {
      return new cp(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength)
   }
}
class MT extends hh {
   constructor(e = 1, t = 0) {
      const i = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
         s = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
      super(i, s, e, t), this.type = "TetrahedronGeometry", this.parameters = {
         radius: e,
         detail: t
      }
   }
   static fromJSON(e) {
      return new MT(e.radius, e.detail)
   }
}
class AT extends pn {
   constructor(e = 1, t = .4, i = 12, s = 48, r = Math.PI * 2) {
      super(), this.type = "TorusGeometry", this.parameters = {
         radius: e,
         tube: t,
         radialSegments: i,
         tubularSegments: s,
         arc: r
      }, i = Math.floor(i), s = Math.floor(s);
      const a = [],
         l = [],
         c = [],
         h = [],
         m = new ee,
         g = new ee,
         v = new ee;
      for (let x = 0; x <= i; x++)
         for (let S = 0; S <= s; S++) {
            const E = S / s * r,
               T = x / i * Math.PI * 2;
            g.x = (e + t * Math.cos(T)) * Math.cos(E), g.y = (e + t * Math.cos(T)) * Math.sin(E), g.z = t * Math.sin(T), l.push(g.x, g.y, g.z), m.x = e * Math.cos(E), m.y = e * Math.sin(E), v.subVectors(g, m).normalize(), c.push(v.x, v.y, v.z), h.push(S / s), h.push(x / i)
         }
      for (let x = 1; x <= i; x++)
         for (let S = 1; S <= s; S++) {
            const E = (s + 1) * x + S - 1,
               T = (s + 1) * (x - 1) + S - 1,
               b = (s + 1) * (x - 1) + S,
               w = (s + 1) * x + S;
            a.push(E, T, w), a.push(T, b, w)
         }
      this.setIndex(a), this.setAttribute("position", new Ct(l, 3)), this.setAttribute("normal", new Ct(c, 3)), this.setAttribute("uv", new Ct(h, 2))
   }
   copy(e) {
      return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
   }
   static fromJSON(e) {
      return new AT(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc)
   }
}
class wT extends pn {
   constructor(e = 1, t = .4, i = 64, s = 8, r = 2, a = 3) {
      super(), this.type = "TorusKnotGeometry", this.parameters = {
         radius: e,
         tube: t,
         tubularSegments: i,
         radialSegments: s,
         p: r,
         q: a
      }, i = Math.floor(i), s = Math.floor(s);
      const l = [],
         c = [],
         h = [],
         m = [],
         g = new ee,
         v = new ee,
         x = new ee,
         S = new ee,
         E = new ee,
         T = new ee,
         b = new ee;
      for (let C = 0; C <= i; ++C) {
         const N = C / i * r * Math.PI * 2;
         w(N, r, a, e, x), w(N + .01, r, a, e, S), T.subVectors(S, x), b.addVectors(S, x), E.crossVectors(T, b), b.crossVectors(E, T), E.normalize(), b.normalize();
         for (let U = 0; U <= s; ++U) {
            const z = U / s * Math.PI * 2,
               B = -t * Math.cos(z),
               I = t * Math.sin(z);
            g.x = x.x + (B * b.x + I * E.x), g.y = x.y + (B * b.y + I * E.y), g.z = x.z + (B * b.z + I * E.z), c.push(g.x, g.y, g.z), v.subVectors(g, x).normalize(), h.push(v.x, v.y, v.z), m.push(C / i), m.push(U / s)
         }
      }
      for (let C = 1; C <= i; C++)
         for (let N = 1; N <= s; N++) {
            const U = (s + 1) * (C - 1) + (N - 1),
               z = (s + 1) * C + (N - 1),
               B = (s + 1) * C + N,
               I = (s + 1) * (C - 1) + N;
            l.push(U, z, I), l.push(z, B, I)
         }
      this.setIndex(l), this.setAttribute("position", new Ct(c, 3)), this.setAttribute("normal", new Ct(h, 3)), this.setAttribute("uv", new Ct(m, 2));

      function w(C, N, U, z, B) {
         const I = Math.cos(C),
            O = Math.sin(C),
            P = U / N * C,
            q = Math.cos(P);
         B.x = z * (2 + q) * .5 * I, B.y = z * (2 + q) * O * .5, B.z = z * Math.sin(P) * .5
      }
   }
   copy(e) {
      return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
   }
   static fromJSON(e) {
      return new wT(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q)
   }
}
class RT extends pn {
   constructor(e = new HR(new ee(-1, -1, 0), new ee(-1, 1, 0), new ee(1, 1, 0)), t = 64, i = 1, s = 8, r = !1) {
      super(), this.type = "TubeGeometry", this.parameters = {
         path: e,
         tubularSegments: t,
         radius: i,
         radialSegments: s,
         closed: r
      };
      const a = e.computeFrenetFrames(t, r);
      this.tangents = a.tangents, this.normals = a.normals, this.binormals = a.binormals;
      const l = new ee,
         c = new ee,
         h = new Fe;
      let m = new ee;
      const g = [],
         v = [],
         x = [],
         S = [];
      E(), this.setIndex(S), this.setAttribute("position", new Ct(g, 3)), this.setAttribute("normal", new Ct(v, 3)), this.setAttribute("uv", new Ct(x, 2));

      function E() {
         for (let C = 0; C < t; C++) T(C);
         T(r === !1 ? t : 0), w(), b()
      }

      function T(C) {
         m = e.getPointAt(C / t, m);
         const N = a.normals[C],
            U = a.binormals[C];
         for (let z = 0; z <= s; z++) {
            const B = z / s * Math.PI * 2,
               I = Math.sin(B),
               O = -Math.cos(B);
            c.x = O * N.x + I * U.x, c.y = O * N.y + I * U.y, c.z = O * N.z + I * U.z, c.normalize(), v.push(c.x, c.y, c.z), l.x = m.x + i * c.x, l.y = m.y + i * c.y, l.z = m.z + i * c.z, g.push(l.x, l.y, l.z)
         }
      }

      function b() {
         for (let C = 1; C <= t; C++)
            for (let N = 1; N <= s; N++) {
               const U = (s + 1) * (C - 1) + (N - 1),
                  z = (s + 1) * C + (N - 1),
                  B = (s + 1) * C + N,
                  I = (s + 1) * (C - 1) + N;
               S.push(U, z, I), S.push(z, B, I)
            }
      }

      function w() {
         for (let C = 0; C <= t; C++)
            for (let N = 0; N <= s; N++) h.x = C / t, h.y = N / s, x.push(h.x, h.y)
      }
   }
   copy(e) {
      return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
   }
   toJSON() {
      const e = super.toJSON();
      return e.path = this.parameters.path.toJSON(), e
   }
   static fromJSON(e) {
      return new RT(new b1[e.path.type]().fromJSON(e.path), e.tubularSegments, e.radius, e.radialSegments, e.closed)
   }
}
class ZL extends pn {
   constructor(e = null) {
      if (super(), this.type = "WireframeGeometry", this.parameters = {
            geometry: e
         }, e !== null) {
         const t = [],
            i = new Set,
            s = new ee,
            r = new ee;
         if (e.index !== null) {
            const a = e.attributes.position,
               l = e.index;
            let c = e.groups;
            c.length === 0 && (c = [{
               start: 0,
               count: l.count,
               materialIndex: 0
            }]);
            for (let h = 0, m = c.length; h < m; ++h) {
               const g = c[h],
                  v = g.start,
                  x = g.count;
               for (let S = v, E = v + x; S < E; S += 3)
                  for (let T = 0; T < 3; T++) {
                     const b = l.getX(S + T),
                        w = l.getX(S + (T + 1) % 3);
                     s.fromBufferAttribute(a, b), r.fromBufferAttribute(a, w), l3(s, r, i) === !0 && (t.push(s.x, s.y, s.z), t.push(r.x, r.y, r.z))
                  }
            }
         } else {
            const a = e.attributes.position;
            for (let l = 0, c = a.count / 3; l < c; l++)
               for (let h = 0; h < 3; h++) {
                  const m = 3 * l + h,
                     g = 3 * l + (h + 1) % 3;
                  s.fromBufferAttribute(a, m), r.fromBufferAttribute(a, g), l3(s, r, i) === !0 && (t.push(s.x, s.y, s.z), t.push(r.x, r.y, r.z))
               }
         }
         this.setAttribute("position", new Ct(t, 3))
      }
   }
   copy(e) {
      return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
   }
}

function l3(n, e, t) {
   const i = `${n.x},${n.y},${n.z}-${e.x},${e.y},${e.z}`,
      s = `${e.x},${e.y},${e.z}-${n.x},${n.y},${n.z}`;
   return t.has(i) === !0 || t.has(s) === !0 ? !1 : (t.add(i), t.add(s), !0)
}
var u3 = Object.freeze({
   __proto__: null,
   BoxGeometry: up,
   CapsuleGeometry: vT,
   CircleGeometry: yT,
   ConeGeometry: xT,
   CylinderGeometry: Lg,
   DodecahedronGeometry: _T,
   EdgesGeometry: qL,
   ExtrudeGeometry: ST,
   IcosahedronGeometry: bT,
   LatheGeometry: yx,
   OctahedronGeometry: xx,
   PlaneGeometry: Bg,
   PolyhedronGeometry: hh,
   RingGeometry: TT,
   ShapeGeometry: ET,
   SphereGeometry: cp,
   TetrahedronGeometry: MT,
   TorusGeometry: AT,
   TorusKnotGeometry: wT,
   TubeGeometry: RT,
   WireframeGeometry: ZL
});
class QL extends sr {
   constructor(e) {
      super(), this.isShadowMaterial = !0, this.type = "ShadowMaterial", this.color = new dt(0), this.transparent = !0, this.fog = !0, this.setValues(e)
   }
   copy(e) {
      return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this
   }
}
class JL extends gs {
   constructor(e) {
      super(e), this.isRawShaderMaterial = !0, this.type = "RawShaderMaterial"
   }
}
class GR extends sr {
   constructor(e) {
      super(), this.isMeshStandardMaterial = !0, this.type = "MeshStandardMaterial", this.defines = {
         STANDARD: ""
      }, this.color = new dt(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new dt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = fh, this.normalScale = new Fe(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new go, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e)
   }
   copy(e) {
      return super.copy(e), this.defines = {
         STANDARD: ""
      }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
   }
}
class $L extends GR {
   constructor(e) {
      super(), this.isMeshPhysicalMaterial = !0, this.defines = {
         STANDARD: "",
         PHYSICAL: ""
      }, this.type = "MeshPhysicalMaterial", this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Fe(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
         get: function () {
            return on(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
         },
         set: function (t) {
            this.ior = (1 + .4 * t) / (1 - .4 * t)
         }
      }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new dt(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new dt(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new dt(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._dispersion = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e)
   }
   get anisotropy() {
      return this._anisotropy
   }
   set anisotropy(e) {
      this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e
   }
   get clearcoat() {
      return this._clearcoat
   }
   set clearcoat(e) {
      this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e
   }
   get iridescence() {
      return this._iridescence
   }
   set iridescence(e) {
      this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e
   }
   get dispersion() {
      return this._dispersion
   }
   set dispersion(e) {
      this._dispersion > 0 != e > 0 && this.version++, this._dispersion = e
   }
   get sheen() {
      return this._sheen
   }
   set sheen(e) {
      this._sheen > 0 != e > 0 && this.version++, this._sheen = e
   }
   get transmission() {
      return this._transmission
   }
   set transmission(e) {
      this._transmission > 0 != e > 0 && this.version++, this._transmission = e
   }
   copy(e) {
      return super.copy(e), this.defines = {
         STANDARD: "",
         PHYSICAL: ""
      }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.dispersion = e.dispersion, this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this
   }
}
class eB extends sr {
   constructor(e) {
      super(), this.isMeshPhongMaterial = !0, this.type = "MeshPhongMaterial", this.color = new dt(16777215), this.specular = new dt(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new dt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = fh, this.normalScale = new Fe(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new go, this.combine = fx, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e)
   }
   copy(e) {
      return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
   }
}
class tB extends sr {
   constructor(e) {
      super(), this.isMeshToonMaterial = !0, this.defines = {
         TOON: ""
      }, this.type = "MeshToonMaterial", this.color = new dt(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new dt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = fh, this.normalScale = new Fe(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e)
   }
   copy(e) {
      return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this
   }
}
class kR extends sr {
   constructor(e) {
      super(), this.isMeshNormalMaterial = !0, this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = fh, this.normalScale = new Fe(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e)
   }
   copy(e) {
      return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this
   }
}
class nB extends sr {
   constructor(e) {
      super(), this.isMeshLambertMaterial = !0, this.type = "MeshLambertMaterial", this.color = new dt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new dt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = fh, this.normalScale = new Fe(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new go, this.combine = fx, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e)
   }
   copy(e) {
      return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
   }
}
class jR extends sr {
   constructor(e) {
      super(), this.isMeshDepthMaterial = !0, this.type = "MeshDepthMaterial", this.depthPacking = Hl, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e)
   }
   copy(e) {
      return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
   }
}
class qR extends sr {
   constructor(e) {
      super(), this.isMeshDistanceMaterial = !0, this.type = "MeshDistanceMaterial", this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e)
   }
   copy(e) {
      return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this
   }
}
class iB extends sr {
   constructor(e) {
      super(), this.isMeshMatcapMaterial = !0, this.defines = {
         MATCAP: ""
      }, this.type = "MeshMatcapMaterial", this.color = new dt(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = fh, this.normalScale = new Fe(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e)
   }
   copy(e) {
      return super.copy(e), this.defines = {
         MATCAP: ""
      }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this
   }
}
class sB extends ma {
   constructor(e) {
      super(), this.isLineDashedMaterial = !0, this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e)
   }
   copy(e) {
      return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this
   }
}

function Od(n, e) {
   return !n || n.constructor === e ? n : typeof e.BYTES_PER_ELEMENT == "number" ? new e(n) : Array.prototype.slice.call(n)
}

function rB(n) {
   return ArrayBuffer.isView(n) && !(n instanceof DataView)
}

function aB(n) {
   function e(s, r) {
      return n[s] - n[r]
   }
   const t = n.length,
      i = new Array(t);
   for (let s = 0; s !== t; ++s) i[s] = s;
   return i.sort(e), i
}

function ZA(n, e, t) {
   const i = n.length,
      s = new n.constructor(i);
   for (let r = 0, a = 0; a !== i; ++r) {
      const l = t[r] * e;
      for (let c = 0; c !== e; ++c) s[a++] = n[l + c]
   }
   return s
}

function XR(n, e, t, i) {
   let s = 1,
      r = n[0];
   for (; r !== void 0 && r[i] === void 0;) r = n[s++];
   if (r === void 0) return;
   let a = r[i];
   if (a !== void 0)
      if (Array.isArray(a))
         do a = r[i], a !== void 0 && (e.push(r.time), t.push(...a)), r = n[s++]; while (r !== void 0);
      else if (a.toArray !== void 0)
      do a = r[i], a !== void 0 && (e.push(r.time), a.toArray(t, t.length)), r = n[s++]; while (r !== void 0);
   else
      do a = r[i], a !== void 0 && (e.push(r.time), t.push(a)), r = n[s++]; while (r !== void 0)
}

function jG(n, e, t, i, s = 30) {
   const r = n.clone();
   r.name = e;
   const a = [];
   for (let c = 0; c < r.tracks.length; ++c) {
      const h = r.tracks[c],
         m = h.getValueSize(),
         g = [],
         v = [];
      for (let x = 0; x < h.times.length; ++x) {
         const S = h.times[x] * s;
         if (!(S < t || S >= i)) {
            g.push(h.times[x]);
            for (let E = 0; E < m; ++E) v.push(h.values[x * m + E])
         }
      }
      g.length !== 0 && (h.times = Od(g, h.times.constructor), h.values = Od(v, h.values.constructor), a.push(h))
   }
   r.tracks = a;
   let l = 1 / 0;
   for (let c = 0; c < r.tracks.length; ++c) l > r.tracks[c].times[0] && (l = r.tracks[c].times[0]);
   for (let c = 0; c < r.tracks.length; ++c) r.tracks[c].shift(-1 * l);
   return r.resetDuration(), r
}

function qG(n, e = 0, t = n, i = 30) {
   i <= 0 && (i = 30);
   const s = t.tracks.length,
      r = e / i;
   for (let a = 0; a < s; ++a) {
      const l = t.tracks[a],
         c = l.ValueTypeName;
      if (c === "bool" || c === "string") continue;
      const h = n.tracks.find(function (b) {
         return b.name === l.name && b.ValueTypeName === c
      });
      if (h === void 0) continue;
      let m = 0;
      const g = l.getValueSize();
      l.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (m = g / 3);
      let v = 0;
      const x = h.getValueSize();
      h.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (v = x / 3);
      const S = l.times.length - 1;
      let E;
      if (r <= l.times[0]) {
         const b = m,
            w = g - m;
         E = l.values.slice(b, w)
      } else if (r >= l.times[S]) {
         const b = S * g + m,
            w = b + g - m;
         E = l.values.slice(b, w)
      } else {
         const b = l.createInterpolant(),
            w = m,
            C = g - m;
         b.evaluate(r), E = b.resultBuffer.slice(w, C)
      }
      c === "quaternion" && new Ba().fromArray(E).normalize().conjugate().toArray(E);
      const T = h.times.length;
      for (let b = 0; b < T; ++b) {
         const w = b * x + v;
         if (c === "quaternion") Ba.multiplyQuaternionsFlat(h.values, w, E, 0, h.values, w);
         else {
            const C = x - v * 2;
            for (let N = 0; N < C; ++N) h.values[w + N] -= E[N]
         }
      }
   }
   return n.blendMode = RR, n
}
class XG {
   static convertArray(e, t) {
      return Od(e, t)
   }
   static isTypedArray(e) {
      return rB(e)
   }
   static getKeyframeOrder(e) {
      return aB(e)
   }
   static sortedArray(e, t, i) {
      return ZA(e, t, i)
   }
   static flattenJSON(e, t, i, s) {
      XR(e, t, i, s)
   }
   static subclip(e, t, i, s, r = 30) {
      return jG(e, t, i, s, r)
   }
   static makeClipAdditive(e, t = 0, i = e, s = 30) {
      return qG(e, t, i, s)
   }
}
class _x {
   constructor(e, t, i, s) {
      this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = s !== void 0 ? s : new t.constructor(i), this.sampleValues = t, this.valueSize = i, this.settings = null, this.DefaultSettings_ = {}
   }
   evaluate(e) {
      const t = this.parameterPositions;
      let i = this._cachedIndex,
         s = t[i],
         r = t[i - 1];
      e: {
         t: {
            let a;n: {
               i: if (!(e < s)) {
                  for (let l = i + 2;;) {
                     if (s === void 0) {
                        if (e < r) break i;
                        return i = t.length, this._cachedIndex = i, this.copySampleValue_(i - 1)
                     }
                     if (i === l) break;
                     if (r = s, s = t[++i], e < s) break t
                  }
                  a = t.length;
                  break n
               }if (!(e >= r)) {
                  const l = t[1];
                  e < l && (i = 2, r = l);
                  for (let c = i - 2;;) {
                     if (r === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
                     if (i === c) break;
                     if (s = r, r = t[--i - 1], e >= r) break t
                  }
                  a = i, i = 0;
                  break n
               }
               break e
            }
            for (; i < a;) {
               const l = i + a >>> 1;
               e < t[l] ? a = l : i = l + 1
            }
            if (s = t[i], r = t[i - 1], r === void 0) return this._cachedIndex = 0,
            this.copySampleValue_(0);
            if (s === void 0) return i = t.length,
            this._cachedIndex = i,
            this.copySampleValue_(i - 1)
         }
         this._cachedIndex = i,
         this.intervalChanged_(i, r, s)
      }
      return this.interpolate_(i, r, e, s)
   }
   getSettings_() {
      return this.settings || this.DefaultSettings_
   }
   copySampleValue_(e) {
      const t = this.resultBuffer,
         i = this.sampleValues,
         s = this.valueSize,
         r = e * s;
      for (let a = 0; a !== s; ++a) t[a] = i[r + a];
      return t
   }
   interpolate_() {
      throw new Error("call to abstract method")
   }
   intervalChanged_() {}
}
class oB extends _x {
   constructor(e, t, i, s) {
      super(e, t, i, s), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
         endingStart: Dd,
         endingEnd: Dd
      }
   }
   intervalChanged_(e, t, i) {
      const s = this.parameterPositions;
      let r = e - 2,
         a = e + 1,
         l = s[r],
         c = s[a];
      if (l === void 0) switch (this.getSettings_().endingStart) {
         case Nd:
            r = e, l = 2 * t - i;
            break;
         case Ry:
            r = s.length - 2, l = t + s[r] - s[r + 1];
            break;
         default:
            r = e, l = i
      }
      if (c === void 0) switch (this.getSettings_().endingEnd) {
         case Nd:
            a = e, c = 2 * i - t;
            break;
         case Ry:
            a = 1, c = i + s[1] - s[0];
            break;
         default:
            a = e - 1, c = t
      }
      const h = (i - t) * .5,
         m = this.valueSize;
      this._weightPrev = h / (t - l), this._weightNext = h / (c - i), this._offsetPrev = r * m, this._offsetNext = a * m
   }
   interpolate_(e, t, i, s) {
      const r = this.resultBuffer,
         a = this.sampleValues,
         l = this.valueSize,
         c = e * l,
         h = c - l,
         m = this._offsetPrev,
         g = this._offsetNext,
         v = this._weightPrev,
         x = this._weightNext,
         S = (i - t) / (s - t),
         E = S * S,
         T = E * S,
         b = -v * T + 2 * v * E - v * S,
         w = (1 + v) * T + (-1.5 - 2 * v) * E + (-.5 + v) * S + 1,
         C = (-1 - x) * T + (1.5 + x) * E + .5 * S,
         N = x * T - x * E;
      for (let U = 0; U !== l; ++U) r[U] = b * a[m + U] + w * a[h + U] + C * a[c + U] + N * a[g + U];
      return r
   }
}
class WR extends _x {
   constructor(e, t, i, s) {
      super(e, t, i, s)
   }
   interpolate_(e, t, i, s) {
      const r = this.resultBuffer,
         a = this.sampleValues,
         l = this.valueSize,
         c = e * l,
         h = c - l,
         m = (i - t) / (s - t),
         g = 1 - m;
      for (let v = 0; v !== l; ++v) r[v] = a[h + v] * g + a[c + v] * m;
      return r
   }
}
class lB extends _x {
   constructor(e, t, i, s) {
      super(e, t, i, s)
   }
   interpolate_(e) {
      return this.copySampleValue_(e - 1)
   }
}
class sl {
   constructor(e, t, i, s) {
      if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
      if (t === void 0 || t.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
      this.name = e, this.times = Od(t, this.TimeBufferType), this.values = Od(i, this.ValueBufferType), this.setInterpolation(s || this.DefaultInterpolation)
   }
   static toJSON(e) {
      const t = e.constructor;
      let i;
      if (t.toJSON !== this.toJSON) i = t.toJSON(e);
      else {
         i = {
            name: e.name,
            times: Od(e.times, Array),
            values: Od(e.values, Array)
         };
         const s = e.getInterpolation();
         s !== e.DefaultInterpolation && (i.interpolation = s)
      }
      return i.type = e.ValueTypeName, i
   }
   InterpolantFactoryMethodDiscrete(e) {
      return new lB(this.times, this.values, this.getValueSize(), e)
   }
   InterpolantFactoryMethodLinear(e) {
      return new WR(this.times, this.values, this.getValueSize(), e)
   }
   InterpolantFactoryMethodSmooth(e) {
      return new oB(this.times, this.values, this.getValueSize(), e)
   }
   setInterpolation(e) {
      let t;
      switch (e) {
         case wy:
            t = this.InterpolantFactoryMethodDiscrete;
            break;
         case x1:
            t = this.InterpolantFactoryMethodLinear;
            break;
         case xb:
            t = this.InterpolantFactoryMethodSmooth;
            break
      }
      if (t === void 0) {
         const i = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
         if (this.createInterpolant === void 0)
            if (e !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
            else throw new Error(i);
         return console.warn("THREE.KeyframeTrack:", i), this
      }
      return this.createInterpolant = t, this
   }
   getInterpolation() {
      switch (this.createInterpolant) {
         case this.InterpolantFactoryMethodDiscrete:
            return wy;
         case this.InterpolantFactoryMethodLinear:
            return x1;
         case this.InterpolantFactoryMethodSmooth:
            return xb
      }
   }
   getValueSize() {
      return this.values.length / this.times.length
   }
   shift(e) {
      if (e !== 0) {
         const t = this.times;
         for (let i = 0, s = t.length; i !== s; ++i) t[i] += e
      }
      return this
   }
   scale(e) {
      if (e !== 1) {
         const t = this.times;
         for (let i = 0, s = t.length; i !== s; ++i) t[i] *= e
      }
      return this
   }
   trim(e, t) {
      const i = this.times,
         s = i.length;
      let r = 0,
         a = s - 1;
      for (; r !== s && i[r] < e;) ++r;
      for (; a !== -1 && i[a] > t;) --a;
      if (++a, r !== 0 || a !== s) {
         r >= a && (a = Math.max(a, 1), r = a - 1);
         const l = this.getValueSize();
         this.times = i.slice(r, a), this.values = this.values.slice(r * l, a * l)
      }
      return this
   }
   validate() {
      let e = !0;
      const t = this.getValueSize();
      t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
      const i = this.times,
         s = this.values,
         r = i.length;
      r === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
      let a = null;
      for (let l = 0; l !== r; l++) {
         const c = i[l];
         if (typeof c == "number" && isNaN(c)) {
            console.error("THREE.KeyframeTrack: Time is not a valid number.", this, l, c), e = !1;
            break
         }
         if (a !== null && a > c) {
            console.error("THREE.KeyframeTrack: Out of order keys.", this, l, c, a), e = !1;
            break
         }
         a = c
      }
      if (s !== void 0 && rB(s))
         for (let l = 0, c = s.length; l !== c; ++l) {
            const h = s[l];
            if (isNaN(h)) {
               console.error("THREE.KeyframeTrack: Value is not a valid number.", this, l, h), e = !1;
               break
            }
         }
      return e
   }
   optimize() {
      const e = this.times.slice(),
         t = this.values.slice(),
         i = this.getValueSize(),
         s = this.getInterpolation() === xb,
         r = e.length - 1;
      let a = 1;
      for (let l = 1; l < r; ++l) {
         let c = !1;
         const h = e[l],
            m = e[l + 1];
         if (h !== m && (l !== 1 || h !== e[0]))
            if (s) c = !0;
            else {
               const g = l * i,
                  v = g - i,
                  x = g + i;
               for (let S = 0; S !== i; ++S) {
                  const E = t[g + S];
                  if (E !== t[v + S] || E !== t[x + S]) {
                     c = !0;
                     break
                  }
               }
            } if (c) {
            if (l !== a) {
               e[a] = e[l];
               const g = l * i,
                  v = a * i;
               for (let x = 0; x !== i; ++x) t[v + x] = t[g + x]
            }++a
         }
      }
      if (r > 0) {
         e[a] = e[r];
         for (let l = r * i, c = a * i, h = 0; h !== i; ++h) t[c + h] = t[l + h];
         ++a
      }
      return a !== e.length ? (this.times = e.slice(0, a), this.values = t.slice(0, a * i)) : (this.times = e, this.values = t), this
   }
   clone() {
      const e = this.times.slice(),
         t = this.values.slice(),
         i = this.constructor,
         s = new i(this.name, e, t);
      return s.createInterpolant = this.createInterpolant, s
   }
}
sl.prototype.ValueTypeName = "";
sl.prototype.TimeBufferType = Float32Array;
sl.prototype.ValueBufferType = Float32Array;
sl.prototype.DefaultInterpolation = x1;
class fp extends sl {
   constructor(e, t, i) {
      super(e, t, i)
   }
}
fp.prototype.ValueTypeName = "bool";
fp.prototype.ValueBufferType = Array;
fp.prototype.DefaultInterpolation = wy;
fp.prototype.InterpolantFactoryMethodLinear = void 0;
fp.prototype.InterpolantFactoryMethodSmooth = void 0;
class YR extends sl {
   constructor(e, t, i, s) {
      super(e, t, i, s)
   }
}
YR.prototype.ValueTypeName = "color";
class zy extends sl {
   constructor(e, t, i, s) {
      super(e, t, i, s)
   }
}
zy.prototype.ValueTypeName = "number";
class uB extends _x {
   constructor(e, t, i, s) {
      super(e, t, i, s)
   }
   interpolate_(e, t, i, s) {
      const r = this.resultBuffer,
         a = this.sampleValues,
         l = this.valueSize,
         c = (i - t) / (s - t);
      let h = e * l;
      for (let m = h + l; h !== m; h += 4) Ba.slerpFlat(r, 0, a, h - l, a, h, c);
      return r
   }
}
class Sx extends sl {
   constructor(e, t, i, s) {
      super(e, t, i, s)
   }
   InterpolantFactoryMethodLinear(e) {
      return new uB(this.times, this.values, this.getValueSize(), e)
   }
}
Sx.prototype.ValueTypeName = "quaternion";
Sx.prototype.InterpolantFactoryMethodSmooth = void 0;
class hp extends sl {
   constructor(e, t, i) {
      super(e, t, i)
   }
}
hp.prototype.ValueTypeName = "string";
hp.prototype.ValueBufferType = Array;
hp.prototype.DefaultInterpolation = wy;
hp.prototype.InterpolantFactoryMethodLinear = void 0;
hp.prototype.InterpolantFactoryMethodSmooth = void 0;
class Iy extends sl {
   constructor(e, t, i, s) {
      super(e, t, i, s)
   }
}
Iy.prototype.ValueTypeName = "vector";
class Fy {
   constructor(e = "", t = -1, i = [], s = lT) {
      this.name = e, this.tracks = i, this.duration = t, this.blendMode = s, this.uuid = po(), this.duration < 0 && this.resetDuration()
   }
   static parse(e) {
      const t = [],
         i = e.tracks,
         s = 1 / (e.fps || 1);
      for (let a = 0, l = i.length; a !== l; ++a) t.push(YG(i[a]).scale(s));
      const r = new this(e.name, e.duration, t, e.blendMode);
      return r.uuid = e.uuid, r
   }
   static toJSON(e) {
      const t = [],
         i = e.tracks,
         s = {
            name: e.name,
            duration: e.duration,
            tracks: t,
            uuid: e.uuid,
            blendMode: e.blendMode
         };
      for (let r = 0, a = i.length; r !== a; ++r) t.push(sl.toJSON(i[r]));
      return s
   }
   static CreateFromMorphTargetSequence(e, t, i, s) {
      const r = t.length,
         a = [];
      for (let l = 0; l < r; l++) {
         let c = [],
            h = [];
         c.push((l + r - 1) % r, l, (l + 1) % r), h.push(0, 1, 0);
         const m = aB(c);
         c = ZA(c, 1, m), h = ZA(h, 1, m), !s && c[0] === 0 && (c.push(r), h.push(h[0])), a.push(new zy(".morphTargetInfluences[" + t[l].name + "]", c, h).scale(1 / i))
      }
      return new this(e, -1, a)
   }
   static findByName(e, t) {
      let i = e;
      if (!Array.isArray(e)) {
         const s = e;
         i = s.geometry && s.geometry.animations || s.animations
      }
      for (let s = 0; s < i.length; s++)
         if (i[s].name === t) return i[s];
      return null
   }
   static CreateClipsFromMorphTargetSequences(e, t, i) {
      const s = {},
         r = /^([\w-]*?)([\d]+)$/;
      for (let l = 0, c = e.length; l < c; l++) {
         const h = e[l],
            m = h.name.match(r);
         if (m && m.length > 1) {
            const g = m[1];
            let v = s[g];
            v || (s[g] = v = []), v.push(h)
         }
      }
      const a = [];
      for (const l in s) a.push(this.CreateFromMorphTargetSequence(l, s[l], t, i));
      return a
   }
   static parseAnimation(e, t) {
      if (console.warn("THREE.AnimationClip: parseAnimation() is deprecated and will be removed with r185"), !e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
      const i = function (g, v, x, S, E) {
            if (x.length !== 0) {
               const T = [],
                  b = [];
               XR(x, T, b, S), T.length !== 0 && E.push(new g(v, T, b))
            }
         },
         s = [],
         r = e.name || "default",
         a = e.fps || 30,
         l = e.blendMode;
      let c = e.length || -1;
      const h = e.hierarchy || [];
      for (let g = 0; g < h.length; g++) {
         const v = h[g].keys;
         if (!(!v || v.length === 0))
            if (v[0].morphTargets) {
               const x = {};
               let S;
               for (S = 0; S < v.length; S++)
                  if (v[S].morphTargets)
                     for (let E = 0; E < v[S].morphTargets.length; E++) x[v[S].morphTargets[E]] = -1;
               for (const E in x) {
                  const T = [],
                     b = [];
                  for (let w = 0; w !== v[S].morphTargets.length; ++w) {
                     const C = v[S];
                     T.push(C.time), b.push(C.morphTarget === E ? 1 : 0)
                  }
                  s.push(new zy(".morphTargetInfluence[" + E + "]", T, b))
               }
               c = x.length * a
            } else {
               const x = ".bones[" + t[g].name + "]";
               i(Iy, x + ".position", v, "pos", s), i(Sx, x + ".quaternion", v, "rot", s), i(Iy, x + ".scale", v, "scl", s)
            }
      }
      return s.length === 0 ? null : new this(r, c, s, l)
   }
   resetDuration() {
      const e = this.tracks;
      let t = 0;
      for (let i = 0, s = e.length; i !== s; ++i) {
         const r = this.tracks[i];
         t = Math.max(t, r.times[r.times.length - 1])
      }
      return this.duration = t, this
   }
   trim() {
      for (let e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
      return this
   }
   validate() {
      let e = !0;
      for (let t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
      return e
   }
   optimize() {
      for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
      return this
   }
   clone() {
      const e = [];
      for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
      return new this.constructor(this.name, this.duration, e, this.blendMode)
   }
   toJSON() {
      return this.constructor.toJSON(this)
   }
}

function WG(n) {
   switch (n.toLowerCase()) {
      case "scalar":
      case "double":
      case "float":
      case "number":
      case "integer":
         return zy;
      case "vector":
      case "vector2":
      case "vector3":
      case "vector4":
         return Iy;
      case "color":
         return YR;
      case "quaternion":
         return Sx;
      case "bool":
      case "boolean":
         return fp;
      case "string":
         return hp
   }
   throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + n)
}

function YG(n) {
   if (n.type === void 0) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
   const e = WG(n.type);
   if (n.times === void 0) {
      const t = [],
         i = [];
      XR(n.keys, t, i, "value"), n.times = t, n.values = i
   }
   return e.parse !== void 0 ? e.parse(n) : new e(n.name, n.times, n.values, n.interpolation)
}
const wc = {
   enabled: !1,
   files: {},
   add: function (n, e) {
      this.enabled !== !1 && (this.files[n] = e)
   },
   get: function (n) {
      if (this.enabled !== !1) return this.files[n]
   },
   remove: function (n) {
      delete this.files[n]
   },
   clear: function () {
      this.files = {}
   }
};
class KR {
   constructor(e, t, i) {
      const s = this;
      let r = !1,
         a = 0,
         l = 0,
         c;
      const h = [];
      this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = i, this.itemStart = function (m) {
         l++, r === !1 && s.onStart !== void 0 && s.onStart(m, a, l), r = !0
      }, this.itemEnd = function (m) {
         a++, s.onProgress !== void 0 && s.onProgress(m, a, l), a === l && (r = !1, s.onLoad !== void 0 && s.onLoad())
      }, this.itemError = function (m) {
         s.onError !== void 0 && s.onError(m)
      }, this.resolveURL = function (m) {
         return c ? c(m) : m
      }, this.setURLModifier = function (m) {
         return c = m, this
      }, this.addHandler = function (m, g) {
         return h.push(m, g), this
      }, this.removeHandler = function (m) {
         const g = h.indexOf(m);
         return g !== -1 && h.splice(g, 2), this
      }, this.getHandler = function (m) {
         for (let g = 0, v = h.length; g < v; g += 2) {
            const x = h[g],
               S = h[g + 1];
            if (x.global && (x.lastIndex = 0), x.test(m)) return S
         }
         return null
      }
   }
}
const qm = new KR;
class ja {
   constructor(e) {
      this.manager = e !== void 0 ? e : qm, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
   }
   load() {}
   loadAsync(e, t) {
      const i = this;
      return new Promise(function (s, r) {
         i.load(e, s, t, r)
      })
   }
   parse() {}
   setCrossOrigin(e) {
      return this.crossOrigin = e, this
   }
   setWithCredentials(e) {
      return this.withCredentials = e, this
   }
   setPath(e) {
      return this.path = e, this
   }
   setResourcePath(e) {
      return this.resourcePath = e, this
   }
   setRequestHeader(e) {
      return this.requestHeader = e, this
   }
}
ja.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const _c = {};
class KG extends Error {
   constructor(e, t) {
      super(e), this.response = t
   }
}
class Pc extends ja {
   constructor(e) {
      super(e), this.mimeType = "", this.responseType = ""
   }
   load(e, t, i, s) {
      e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
      const r = wc.get(e);
      if (r !== void 0) return this.manager.itemStart(e), setTimeout(() => {
         t && t(r), this.manager.itemEnd(e)
      }, 0), r;
      if (_c[e] !== void 0) {
         _c[e].push({
            onLoad: t,
            onProgress: i,
            onError: s
         });
         return
      }
      _c[e] = [], _c[e].push({
         onLoad: t,
         onProgress: i,
         onError: s
      });
      const a = new Request(e, {
            headers: new Headers(this.requestHeader),
            credentials: this.withCredentials ? "include" : "same-origin"
         }),
         l = this.mimeType,
         c = this.responseType;
      fetch(a).then(h => {
         if (h.status === 200 || h.status === 0) {
            if (h.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || h.body === void 0 || h.body.getReader === void 0) return h;
            const m = _c[e],
               g = h.body.getReader(),
               v = h.headers.get("X-File-Size") || h.headers.get("Content-Length"),
               x = v ? parseInt(v) : 0,
               S = x !== 0;
            let E = 0;
            const T = new ReadableStream({
               start(b) {
                  w();

                  function w() {
                     g.read().then(({
                        done: C,
                        value: N
                     }) => {
                        if (C) b.close();
                        else {
                           E += N.byteLength;
                           const U = new ProgressEvent("progress", {
                              lengthComputable: S,
                              loaded: E,
                              total: x
                           });
                           for (let z = 0, B = m.length; z < B; z++) {
                              const I = m[z];
                              I.onProgress && I.onProgress(U)
                           }
                           b.enqueue(N), w()
                        }
                     }, C => {
                        b.error(C)
                     })
                  }
               }
            });
            return new Response(T)
         } else throw new KG(`fetch for "${h.url}" responded with ${h.status}: ${h.statusText}`, h)
      }).then(h => {
         switch (c) {
            case "arraybuffer":
               return h.arrayBuffer();
            case "blob":
               return h.blob();
            case "document":
               return h.text().then(m => new DOMParser().parseFromString(m, l));
            case "json":
               return h.json();
            default:
               if (l === "") return h.text(); {
                  const g = /charset="?([^;"\s]*)"?/i.exec(l),
                     v = g && g[1] ? g[1].toLowerCase() : void 0,
                     x = new TextDecoder(v);
                  return h.arrayBuffer().then(S => x.decode(S))
               }
         }
      }).then(h => {
         wc.add(e, h);
         const m = _c[e];
         delete _c[e];
         for (let g = 0, v = m.length; g < v; g++) {
            const x = m[g];
            x.onLoad && x.onLoad(h)
         }
      }).catch(h => {
         const m = _c[e];
         if (m === void 0) throw this.manager.itemError(e), h;
         delete _c[e];
         for (let g = 0, v = m.length; g < v; g++) {
            const x = m[g];
            x.onError && x.onError(h)
         }
         this.manager.itemError(e)
      }).finally(() => {
         this.manager.itemEnd(e)
      }), this.manager.itemStart(e)
   }
   setResponseType(e) {
      return this.responseType = e, this
   }
   setMimeType(e) {
      return this.mimeType = e, this
   }
}
class ZG extends ja {
   constructor(e) {
      super(e)
   }
   load(e, t, i, s) {
      const r = this,
         a = new Pc(this.manager);
      a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function (l) {
         try {
            t(r.parse(JSON.parse(l)))
         } catch (c) {
            s ? s(c) : console.error(c), r.manager.itemError(e)
         }
      }, i, s)
   }
   parse(e) {
      const t = [];
      for (let i = 0; i < e.length; i++) {
         const s = Fy.parse(e[i]);
         t.push(s)
      }
      return t
   }
}
class QG extends ja {
   constructor(e) {
      super(e)
   }
   load(e, t, i, s) {
      const r = this,
         a = [],
         l = new mT,
         c = new Pc(this.manager);
      c.setPath(this.path), c.setResponseType("arraybuffer"), c.setRequestHeader(this.requestHeader), c.setWithCredentials(r.withCredentials);
      let h = 0;

      function m(g) {
         c.load(e[g], function (v) {
            const x = r.parse(v, !0);
            a[g] = {
               width: x.width,
               height: x.height,
               format: x.format,
               mipmaps: x.mipmaps
            }, h += 1, h === 6 && (x.mipmapCount === 1 && (l.minFilter = Ni), l.image = a, l.format = x.format, l.needsUpdate = !0, t && t(l))
         }, i, s)
      }
      if (Array.isArray(e))
         for (let g = 0, v = e.length; g < v; ++g) m(g);
      else c.load(e, function (g) {
         const v = r.parse(g, !0);
         if (v.isCubemap) {
            const x = v.mipmaps.length / v.mipmapCount;
            for (let S = 0; S < x; S++) {
               a[S] = {
                  mipmaps: []
               };
               for (let E = 0; E < v.mipmapCount; E++) a[S].mipmaps.push(v.mipmaps[S * v.mipmapCount + E]), a[S].format = v.format, a[S].width = v.width, a[S].height = v.height
            }
            l.image = a
         } else l.image.width = v.width, l.image.height = v.height, l.mipmaps = v.mipmaps;
         v.mipmapCount === 1 && (l.minFilter = Ni), l.format = v.format, l.needsUpdate = !0, t && t(l)
      }, i, s);
      return l
   }
}
class Hy extends ja {
   constructor(e) {
      super(e)
   }
   load(e, t, i, s) {
      this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
      const r = this,
         a = wc.get(e);
      if (a !== void 0) return r.manager.itemStart(e), setTimeout(function () {
         t && t(a), r.manager.itemEnd(e)
      }, 0), a;
      const l = Oy("img");

      function c() {
         m(), wc.add(e, this), t && t(this), r.manager.itemEnd(e)
      }

      function h(g) {
         m(), s && s(g), r.manager.itemError(e), r.manager.itemEnd(e)
      }

      function m() {
         l.removeEventListener("load", c, !1), l.removeEventListener("error", h, !1)
      }
      return l.addEventListener("load", c, !1), l.addEventListener("error", h, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (l.crossOrigin = this.crossOrigin), r.manager.itemStart(e), l.src = e, l
   }
}
class JG extends ja {
   constructor(e) {
      super(e)
   }
   load(e, t, i, s) {
      const r = new mx;
      r.colorSpace = En;
      const a = new Hy(this.manager);
      a.setCrossOrigin(this.crossOrigin), a.setPath(this.path);
      let l = 0;

      function c(h) {
         a.load(e[h], function (m) {
            r.images[h] = m, l++, l === 6 && (r.needsUpdate = !0, t && t(r))
         }, void 0, s)
      }
      for (let h = 0; h < e.length; ++h) c(h);
      return r
   }
}
class $G extends ja {
   constructor(e) {
      super(e)
   }
   load(e, t, i, s) {
      const r = this,
         a = new Pu,
         l = new Pc(this.manager);
      return l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setPath(this.path), l.setWithCredentials(r.withCredentials), l.load(e, function (c) {
         let h;
         try {
            h = r.parse(c)
         } catch (m) {
            if (s !== void 0) s(m);
            else {
               console.error(m);
               return
            }
         }
         h.image !== void 0 ? a.image = h.image : h.data !== void 0 && (a.image.width = h.width, a.image.height = h.height, a.image.data = h.data), a.wrapS = h.wrapS !== void 0 ? h.wrapS : Ko, a.wrapT = h.wrapT !== void 0 ? h.wrapT : Ko, a.magFilter = h.magFilter !== void 0 ? h.magFilter : Ni, a.minFilter = h.minFilter !== void 0 ? h.minFilter : Ni, a.anisotropy = h.anisotropy !== void 0 ? h.anisotropy : 1, h.colorSpace !== void 0 && (a.colorSpace = h.colorSpace), h.flipY !== void 0 && (a.flipY = h.flipY), h.format !== void 0 && (a.format = h.format), h.type !== void 0 && (a.type = h.type), h.mipmaps !== void 0 && (a.mipmaps = h.mipmaps, a.minFilter = Du), h.mipmapCount === 1 && (a.minFilter = Ni), h.generateMipmaps !== void 0 && (a.generateMipmaps = h.generateMipmaps), a.needsUpdate = !0, t && t(a, h)
      }, i, s), a
   }
}
class ZR extends ja {
   constructor(e) {
      super(e)
   }
   load(e, t, i, s) {
      const r = new Hi,
         a = new Hy(this.manager);
      return a.setCrossOrigin(this.crossOrigin), a.setPath(this.path), a.load(e, function (l) {
         r.image = l, r.needsUpdate = !0, t !== void 0 && t(r)
      }, i, s), r
   }
}
class dh extends Wn {
   constructor(e, t = 1) {
      super(), this.isLight = !0, this.type = "Light", this.color = new dt(e), this.intensity = t
   }
   dispose() {}
   copy(e, t) {
      return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this
   }
   toJSON(e) {
      const t = super.toJSON(e);
      return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), this.target !== void 0 && (t.object.target = this.target.uuid), t
   }
}
class cB extends dh {
   constructor(e, t, i) {
      super(e, i), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(Wn.DEFAULT_UP), this.updateMatrix(), this.groundColor = new dt(t)
   }
   copy(e, t) {
      return super.copy(e, t), this.groundColor.copy(e.groundColor), this
   }
}
const MM = new Zt,
   c3 = new ee,
   f3 = new ee;
class QR {
   constructor(e) {
      this.camera = e, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Fe(512, 512), this.map = null, this.mapPass = null, this.matrix = new Zt, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new gx, this._frameExtents = new Fe(1, 1), this._viewportCount = 1, this._viewports = [new Gn(0, 0, 1, 1)]
   }
   getViewportCount() {
      return this._viewportCount
   }
   getFrustum() {
      return this._frustum
   }
   updateMatrices(e) {
      const t = this.camera,
         i = this.matrix;
      c3.setFromMatrixPosition(e.matrixWorld), t.position.copy(c3), f3.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(f3), t.updateMatrixWorld(), MM.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(MM), i.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), i.multiply(MM)
   }
   getViewport(e) {
      return this._viewports[e]
   }
   getFrameExtents() {
      return this._frameExtents
   }
   dispose() {
      this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
   }
   copy(e) {
      return this.camera = e.camera.clone(), this.intensity = e.intensity, this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this
   }
   clone() {
      return new this.constructor().copy(this)
   }
   toJSON() {
      const e = {};
      return this.intensity !== 1 && (e.intensity = this.intensity), this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e
   }
}
class ek extends QR {
   constructor() {
      super(new Cs(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1
   }
   updateMatrices(e) {
      const t = this.camera,
         i = hg * 2 * e.angle * this.focus,
         s = this.mapSize.width / this.mapSize.height,
         r = e.distance || t.far;
      (i !== t.fov || s !== t.aspect || r !== t.far) && (t.fov = i, t.aspect = s, t.far = r, t.updateProjectionMatrix()), super.updateMatrices(e)
   }
   copy(e) {
      return super.copy(e), this.focus = e.focus, this
   }
}
class fB extends dh {
   constructor(e, t, i = 0, s = Math.PI / 3, r = 0, a = 2) {
      super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(Wn.DEFAULT_UP), this.updateMatrix(), this.target = new Wn, this.distance = i, this.angle = s, this.penumbra = r, this.decay = a, this.map = null, this.shadow = new ek
   }
   get power() {
      return this.intensity * Math.PI
   }
   set power(e) {
      this.intensity = e / Math.PI
   }
   dispose() {
      this.shadow.dispose()
   }
   copy(e, t) {
      return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
   }
}
const h3 = new Zt,
   y0 = new ee,
   AM = new ee;
class tk extends QR {
   constructor() {
      super(new Cs(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new Fe(4, 2), this._viewportCount = 6, this._viewports = [new Gn(2, 1, 1, 1), new Gn(0, 1, 1, 1), new Gn(3, 1, 1, 1), new Gn(1, 1, 1, 1), new Gn(3, 0, 1, 1), new Gn(1, 0, 1, 1)], this._cubeDirections = [new ee(1, 0, 0), new ee(-1, 0, 0), new ee(0, 0, 1), new ee(0, 0, -1), new ee(0, 1, 0), new ee(0, -1, 0)], this._cubeUps = [new ee(0, 1, 0), new ee(0, 1, 0), new ee(0, 1, 0), new ee(0, 1, 0), new ee(0, 0, 1), new ee(0, 0, -1)]
   }
   updateMatrices(e, t = 0) {
      const i = this.camera,
         s = this.matrix,
         r = e.distance || i.far;
      r !== i.far && (i.far = r, i.updateProjectionMatrix()), y0.setFromMatrixPosition(e.matrixWorld), i.position.copy(y0), AM.copy(i.position), AM.add(this._cubeDirections[t]), i.up.copy(this._cubeUps[t]), i.lookAt(AM), i.updateMatrixWorld(), s.makeTranslation(-y0.x, -y0.y, -y0.z), h3.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), this._frustum.setFromProjectionMatrix(h3)
   }
}
class hB extends dh {
   constructor(e, t, i = 0, s = 2) {
      super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = i, this.decay = s, this.shadow = new tk
   }
   get power() {
      return this.intensity * 4 * Math.PI
   }
   set power(e) {
      this.intensity = e / (4 * Math.PI)
   }
   dispose() {
      this.shadow.dispose()
   }
   copy(e, t) {
      return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
   }
}
class bx extends px {
   constructor(e = -1, t = 1, i = 1, s = -1, r = .1, a = 2e3) {
      super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = i, this.bottom = s, this.near = r, this.far = a, this.updateProjectionMatrix()
   }
   copy(e, t) {
      return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this
   }
   setViewOffset(e, t, i, s, r, a) {
      this.view === null && (this.view = {
         enabled: !0,
         fullWidth: 1,
         fullHeight: 1,
         offsetX: 0,
         offsetY: 0,
         width: 1,
         height: 1
      }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = i, this.view.offsetY = s, this.view.width = r, this.view.height = a, this.updateProjectionMatrix()
   }
   clearViewOffset() {
      this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix()
   }
   updateProjectionMatrix() {
      const e = (this.right - this.left) / (2 * this.zoom),
         t = (this.top - this.bottom) / (2 * this.zoom),
         i = (this.right + this.left) / 2,
         s = (this.top + this.bottom) / 2;
      let r = i - e,
         a = i + e,
         l = s + t,
         c = s - t;
      if (this.view !== null && this.view.enabled) {
         const h = (this.right - this.left) / this.view.fullWidth / this.zoom,
            m = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
         r += h * this.view.offsetX, a = r + h * this.view.width, l -= m * this.view.offsetY, c = l - m * this.view.height
      }
      this.projectionMatrix.makeOrthographic(r, a, l, c, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
   }
   toJSON(e) {
      const t = super.toJSON(e);
      return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t
   }
}
class nk extends QR {
   constructor() {
      super(new bx(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0
   }
}
class dB extends dh {
   constructor(e, t) {
      super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(Wn.DEFAULT_UP), this.updateMatrix(), this.target = new Wn, this.shadow = new nk
   }
   dispose() {
      this.shadow.dispose()
   }
   copy(e) {
      return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
   }
}
class pB extends dh {
   constructor(e, t) {
      super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight"
   }
}
class mB extends dh {
   constructor(e, t, i = 10, s = 10) {
      super(e, t), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = i, this.height = s
   }
   get power() {
      return this.intensity * this.width * this.height * Math.PI
   }
   set power(e) {
      this.intensity = e / (this.width * this.height * Math.PI)
   }
   copy(e) {
      return super.copy(e), this.width = e.width, this.height = e.height, this
   }
   toJSON(e) {
      const t = super.toJSON(e);
      return t.object.width = this.width, t.object.height = this.height, t
   }
}
class gB {
   constructor() {
      this.isSphericalHarmonics3 = !0, this.coefficients = [];
      for (let e = 0; e < 9; e++) this.coefficients.push(new ee)
   }
   set(e) {
      for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
      return this
   }
   zero() {
      for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
      return this
   }
   getAt(e, t) {
      const i = e.x,
         s = e.y,
         r = e.z,
         a = this.coefficients;
      return t.copy(a[0]).multiplyScalar(.282095), t.addScaledVector(a[1], .488603 * s), t.addScaledVector(a[2], .488603 * r), t.addScaledVector(a[3], .488603 * i), t.addScaledVector(a[4], 1.092548 * (i * s)), t.addScaledVector(a[5], 1.092548 * (s * r)), t.addScaledVector(a[6], .315392 * (3 * r * r - 1)), t.addScaledVector(a[7], 1.092548 * (i * r)), t.addScaledVector(a[8], .546274 * (i * i - s * s)), t
   }
   getIrradianceAt(e, t) {
      const i = e.x,
         s = e.y,
         r = e.z,
         a = this.coefficients;
      return t.copy(a[0]).multiplyScalar(.886227), t.addScaledVector(a[1], 2 * .511664 * s), t.addScaledVector(a[2], 2 * .511664 * r), t.addScaledVector(a[3], 2 * .511664 * i), t.addScaledVector(a[4], 2 * .429043 * i * s), t.addScaledVector(a[5], 2 * .429043 * s * r), t.addScaledVector(a[6], .743125 * r * r - .247708), t.addScaledVector(a[7], 2 * .429043 * i * r), t.addScaledVector(a[8], .429043 * (i * i - s * s)), t
   }
   add(e) {
      for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
      return this
   }
   addScaledSH(e, t) {
      for (let i = 0; i < 9; i++) this.coefficients[i].addScaledVector(e.coefficients[i], t);
      return this
   }
   scale(e) {
      for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
      return this
   }
   lerp(e, t) {
      for (let i = 0; i < 9; i++) this.coefficients[i].lerp(e.coefficients[i], t);
      return this
   }
   equals(e) {
      for (let t = 0; t < 9; t++)
         if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
      return !0
   }
   copy(e) {
      return this.set(e.coefficients)
   }
   clone() {
      return new this.constructor().copy(this)
   }
   fromArray(e, t = 0) {
      const i = this.coefficients;
      for (let s = 0; s < 9; s++) i[s].fromArray(e, t + s * 3);
      return this
   }
   toArray(e = [], t = 0) {
      const i = this.coefficients;
      for (let s = 0; s < 9; s++) i[s].toArray(e, t + s * 3);
      return e
   }
   static getBasisAt(e, t) {
      const i = e.x,
         s = e.y,
         r = e.z;
      t[0] = .282095, t[1] = .488603 * s, t[2] = .488603 * r, t[3] = .488603 * i, t[4] = 1.092548 * i * s, t[5] = 1.092548 * s * r, t[6] = .315392 * (3 * r * r - 1), t[7] = 1.092548 * i * r, t[8] = .546274 * (i * i - s * s)
   }
}
class vB extends dh {
   constructor(e = new gB, t = 1) {
      super(void 0, t), this.isLightProbe = !0, this.sh = e
   }
   copy(e) {
      return super.copy(e), this.sh.copy(e.sh), this
   }
   fromJSON(e) {
      return this.intensity = e.intensity, this.sh.fromArray(e.sh), this
   }
   toJSON(e) {
      const t = super.toJSON(e);
      return t.object.sh = this.sh.toArray(), t
   }
}
class CT extends ja {
   constructor(e) {
      super(e), this.textures = {}
   }
   load(e, t, i, s) {
      const r = this,
         a = new Pc(r.manager);
      a.setPath(r.path), a.setRequestHeader(r.requestHeader), a.setWithCredentials(r.withCredentials), a.load(e, function (l) {
         try {
            t(r.parse(JSON.parse(l)))
         } catch (c) {
            s ? s(c) : console.error(c), r.manager.itemError(e)
         }
      }, i, s)
   }
   parse(e) {
      const t = this.textures;

      function i(r) {
         return t[r] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", r), t[r]
      }
      const s = this.createMaterialFromType(e.type);
      if (e.uuid !== void 0 && (s.uuid = e.uuid), e.name !== void 0 && (s.name = e.name), e.color !== void 0 && s.color !== void 0 && s.color.setHex(e.color), e.roughness !== void 0 && (s.roughness = e.roughness), e.metalness !== void 0 && (s.metalness = e.metalness), e.sheen !== void 0 && (s.sheen = e.sheen), e.sheenColor !== void 0 && (s.sheenColor = new dt().setHex(e.sheenColor)), e.sheenRoughness !== void 0 && (s.sheenRoughness = e.sheenRoughness), e.emissive !== void 0 && s.emissive !== void 0 && s.emissive.setHex(e.emissive), e.specular !== void 0 && s.specular !== void 0 && s.specular.setHex(e.specular), e.specularIntensity !== void 0 && (s.specularIntensity = e.specularIntensity), e.specularColor !== void 0 && s.specularColor !== void 0 && s.specularColor.setHex(e.specularColor), e.shininess !== void 0 && (s.shininess = e.shininess), e.clearcoat !== void 0 && (s.clearcoat = e.clearcoat), e.clearcoatRoughness !== void 0 && (s.clearcoatRoughness = e.clearcoatRoughness), e.dispersion !== void 0 && (s.dispersion = e.dispersion), e.iridescence !== void 0 && (s.iridescence = e.iridescence), e.iridescenceIOR !== void 0 && (s.iridescenceIOR = e.iridescenceIOR), e.iridescenceThicknessRange !== void 0 && (s.iridescenceThicknessRange = e.iridescenceThicknessRange), e.transmission !== void 0 && (s.transmission = e.transmission), e.thickness !== void 0 && (s.thickness = e.thickness), e.attenuationDistance !== void 0 && (s.attenuationDistance = e.attenuationDistance), e.attenuationColor !== void 0 && s.attenuationColor !== void 0 && s.attenuationColor.setHex(e.attenuationColor), e.anisotropy !== void 0 && (s.anisotropy = e.anisotropy), e.anisotropyRotation !== void 0 && (s.anisotropyRotation = e.anisotropyRotation), e.fog !== void 0 && (s.fog = e.fog), e.flatShading !== void 0 && (s.flatShading = e.flatShading), e.blending !== void 0 && (s.blending = e.blending), e.combine !== void 0 && (s.combine = e.combine), e.side !== void 0 && (s.side = e.side), e.shadowSide !== void 0 && (s.shadowSide = e.shadowSide), e.opacity !== void 0 && (s.opacity = e.opacity), e.transparent !== void 0 && (s.transparent = e.transparent), e.alphaTest !== void 0 && (s.alphaTest = e.alphaTest), e.alphaHash !== void 0 && (s.alphaHash = e.alphaHash), e.depthFunc !== void 0 && (s.depthFunc = e.depthFunc), e.depthTest !== void 0 && (s.depthTest = e.depthTest), e.depthWrite !== void 0 && (s.depthWrite = e.depthWrite), e.colorWrite !== void 0 && (s.colorWrite = e.colorWrite), e.blendSrc !== void 0 && (s.blendSrc = e.blendSrc), e.blendDst !== void 0 && (s.blendDst = e.blendDst), e.blendEquation !== void 0 && (s.blendEquation = e.blendEquation), e.blendSrcAlpha !== void 0 && (s.blendSrcAlpha = e.blendSrcAlpha), e.blendDstAlpha !== void 0 && (s.blendDstAlpha = e.blendDstAlpha), e.blendEquationAlpha !== void 0 && (s.blendEquationAlpha = e.blendEquationAlpha), e.blendColor !== void 0 && s.blendColor !== void 0 && s.blendColor.setHex(e.blendColor), e.blendAlpha !== void 0 && (s.blendAlpha = e.blendAlpha), e.stencilWriteMask !== void 0 && (s.stencilWriteMask = e.stencilWriteMask), e.stencilFunc !== void 0 && (s.stencilFunc = e.stencilFunc), e.stencilRef !== void 0 && (s.stencilRef = e.stencilRef), e.stencilFuncMask !== void 0 && (s.stencilFuncMask = e.stencilFuncMask), e.stencilFail !== void 0 && (s.stencilFail = e.stencilFail), e.stencilZFail !== void 0 && (s.stencilZFail = e.stencilZFail), e.stencilZPass !== void 0 && (s.stencilZPass = e.stencilZPass), e.stencilWrite !== void 0 && (s.stencilWrite = e.stencilWrite), e.wireframe !== void 0 && (s.wireframe = e.wireframe), e.wireframeLinewidth !== void 0 && (s.wireframeLinewidth = e.wireframeLinewidth), e.wireframeLinecap !== void 0 && (s.wireframeLinecap = e.wireframeLinecap), e.wireframeLinejoin !== void 0 && (s.wireframeLinejoin = e.wireframeLinejoin), e.rotation !== void 0 && (s.rotation = e.rotation), e.linewidth !== void 0 && (s.linewidth = e.linewidth), e.dashSize !== void 0 && (s.dashSize = e.dashSize), e.gapSize !== void 0 && (s.gapSize = e.gapSize), e.scale !== void 0 && (s.scale = e.scale), e.polygonOffset !== void 0 && (s.polygonOffset = e.polygonOffset), e.polygonOffsetFactor !== void 0 && (s.polygonOffsetFactor = e.polygonOffsetFactor), e.polygonOffsetUnits !== void 0 && (s.polygonOffsetUnits = e.polygonOffsetUnits), e.dithering !== void 0 && (s.dithering = e.dithering), e.alphaToCoverage !== void 0 && (s.alphaToCoverage = e.alphaToCoverage), e.premultipliedAlpha !== void 0 && (s.premultipliedAlpha = e.premultipliedAlpha), e.forceSinglePass !== void 0 && (s.forceSinglePass = e.forceSinglePass), e.visible !== void 0 && (s.visible = e.visible), e.toneMapped !== void 0 && (s.toneMapped = e.toneMapped), e.userData !== void 0 && (s.userData = e.userData), e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? s.vertexColors = e.vertexColors > 0 : s.vertexColors = e.vertexColors), e.uniforms !== void 0)
         for (const r in e.uniforms) {
            const a = e.uniforms[r];
            switch (s.uniforms[r] = {}, a.type) {
               case "t":
                  s.uniforms[r].value = i(a.value);
                  break;
               case "c":
                  s.uniforms[r].value = new dt().setHex(a.value);
                  break;
               case "v2":
                  s.uniforms[r].value = new Fe().fromArray(a.value);
                  break;
               case "v3":
                  s.uniforms[r].value = new ee().fromArray(a.value);
                  break;
               case "v4":
                  s.uniforms[r].value = new Gn().fromArray(a.value);
                  break;
               case "m3":
                  s.uniforms[r].value = new un().fromArray(a.value);
                  break;
               case "m4":
                  s.uniforms[r].value = new Zt().fromArray(a.value);
                  break;
               default:
                  s.uniforms[r].value = a.value
            }
         }
      if (e.defines !== void 0 && (s.defines = e.defines), e.vertexShader !== void 0 && (s.vertexShader = e.vertexShader), e.fragmentShader !== void 0 && (s.fragmentShader = e.fragmentShader), e.glslVersion !== void 0 && (s.glslVersion = e.glslVersion), e.extensions !== void 0)
         for (const r in e.extensions) s.extensions[r] = e.extensions[r];
      if (e.lights !== void 0 && (s.lights = e.lights), e.clipping !== void 0 && (s.clipping = e.clipping), e.size !== void 0 && (s.size = e.size), e.sizeAttenuation !== void 0 && (s.sizeAttenuation = e.sizeAttenuation), e.map !== void 0 && (s.map = i(e.map)), e.matcap !== void 0 && (s.matcap = i(e.matcap)), e.alphaMap !== void 0 && (s.alphaMap = i(e.alphaMap)), e.bumpMap !== void 0 && (s.bumpMap = i(e.bumpMap)), e.bumpScale !== void 0 && (s.bumpScale = e.bumpScale), e.normalMap !== void 0 && (s.normalMap = i(e.normalMap)), e.normalMapType !== void 0 && (s.normalMapType = e.normalMapType), e.normalScale !== void 0) {
         let r = e.normalScale;
         Array.isArray(r) === !1 && (r = [r, r]), s.normalScale = new Fe().fromArray(r)
      }
      return e.displacementMap !== void 0 && (s.displacementMap = i(e.displacementMap)), e.displacementScale !== void 0 && (s.displacementScale = e.displacementScale), e.displacementBias !== void 0 && (s.displacementBias = e.displacementBias), e.roughnessMap !== void 0 && (s.roughnessMap = i(e.roughnessMap)), e.metalnessMap !== void 0 && (s.metalnessMap = i(e.metalnessMap)), e.emissiveMap !== void 0 && (s.emissiveMap = i(e.emissiveMap)), e.emissiveIntensity !== void 0 && (s.emissiveIntensity = e.emissiveIntensity), e.specularMap !== void 0 && (s.specularMap = i(e.specularMap)), e.specularIntensityMap !== void 0 && (s.specularIntensityMap = i(e.specularIntensityMap)), e.specularColorMap !== void 0 && (s.specularColorMap = i(e.specularColorMap)), e.envMap !== void 0 && (s.envMap = i(e.envMap)), e.envMapRotation !== void 0 && s.envMapRotation.fromArray(e.envMapRotation), e.envMapIntensity !== void 0 && (s.envMapIntensity = e.envMapIntensity), e.reflectivity !== void 0 && (s.reflectivity = e.reflectivity), e.refractionRatio !== void 0 && (s.refractionRatio = e.refractionRatio), e.lightMap !== void 0 && (s.lightMap = i(e.lightMap)), e.lightMapIntensity !== void 0 && (s.lightMapIntensity = e.lightMapIntensity), e.aoMap !== void 0 && (s.aoMap = i(e.aoMap)), e.aoMapIntensity !== void 0 && (s.aoMapIntensity = e.aoMapIntensity), e.gradientMap !== void 0 && (s.gradientMap = i(e.gradientMap)), e.clearcoatMap !== void 0 && (s.clearcoatMap = i(e.clearcoatMap)), e.clearcoatRoughnessMap !== void 0 && (s.clearcoatRoughnessMap = i(e.clearcoatRoughnessMap)), e.clearcoatNormalMap !== void 0 && (s.clearcoatNormalMap = i(e.clearcoatNormalMap)), e.clearcoatNormalScale !== void 0 && (s.clearcoatNormalScale = new Fe().fromArray(e.clearcoatNormalScale)), e.iridescenceMap !== void 0 && (s.iridescenceMap = i(e.iridescenceMap)), e.iridescenceThicknessMap !== void 0 && (s.iridescenceThicknessMap = i(e.iridescenceThicknessMap)), e.transmissionMap !== void 0 && (s.transmissionMap = i(e.transmissionMap)), e.thicknessMap !== void 0 && (s.thicknessMap = i(e.thicknessMap)), e.anisotropyMap !== void 0 && (s.anisotropyMap = i(e.anisotropyMap)), e.sheenColorMap !== void 0 && (s.sheenColorMap = i(e.sheenColorMap)), e.sheenRoughnessMap !== void 0 && (s.sheenRoughnessMap = i(e.sheenRoughnessMap)), s
   }
   setTextures(e) {
      return this.textures = e, this
   }
   createMaterialFromType(e) {
      return CT.createMaterialFromType(e)
   }
   static createMaterialFromType(e) {
      const t = {
         ShadowMaterial: QL,
         SpriteMaterial: UR,
         RawShaderMaterial: JL,
         ShaderMaterial: gs,
         PointsMaterial: LR,
         MeshPhysicalMaterial: $L,
         MeshStandardMaterial: GR,
         MeshPhongMaterial: eB,
         MeshToonMaterial: tB,
         MeshNormalMaterial: kR,
         MeshLambertMaterial: nB,
         MeshDepthMaterial: jR,
         MeshDistanceMaterial: qR,
         MeshBasicMaterial: Fc,
         MeshMatcapMaterial: iB,
         LineDashedMaterial: sB,
         LineBasicMaterial: ma,
         Material: sr
      };
      return new t[e]
   }
}
class QA {
   static extractUrlBase(e) {
      const t = e.lastIndexOf("/");
      return t === -1 ? "./" : e.slice(0, t + 1)
   }
   static resolveURL(e, t) {
      return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
   }
}
class yB extends pn {
   constructor() {
      super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0
   }
   copy(e) {
      return super.copy(e), this.instanceCount = e.instanceCount, this
   }
   toJSON() {
      const e = super.toJSON();
      return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e
   }
}
class xB extends ja {
   constructor(e) {
      super(e)
   }
   load(e, t, i, s) {
      const r = this,
         a = new Pc(r.manager);
      a.setPath(r.path), a.setRequestHeader(r.requestHeader), a.setWithCredentials(r.withCredentials), a.load(e, function (l) {
         try {
            t(r.parse(JSON.parse(l)))
         } catch (c) {
            s ? s(c) : console.error(c), r.manager.itemError(e)
         }
      }, i, s)
   }
   parse(e) {
      const t = {},
         i = {};

      function s(x, S) {
         if (t[S] !== void 0) return t[S];
         const T = x.interleavedBuffers[S],
            b = r(x, T.buffer),
            w = km(T.type, b),
            C = new dT(w, T.stride);
         return C.uuid = T.uuid, t[S] = C, C
      }

      function r(x, S) {
         if (i[S] !== void 0) return i[S];
         const T = x.arrayBuffers[S],
            b = new Uint32Array(T).buffer;
         return i[S] = b, b
      }
      const a = e.isInstancedBufferGeometry ? new yB : new pn,
         l = e.data.index;
      if (l !== void 0) {
         const x = km(l.type, l.array);
         a.setIndex(new oi(x, 1))
      }
      const c = e.data.attributes;
      for (const x in c) {
         const S = c[x];
         let E;
         if (S.isInterleavedBufferAttribute) {
            const T = s(e.data, S.data);
            E = new ep(T, S.itemSize, S.offset, S.normalized)
         } else {
            const T = km(S.type, S.array),
               b = S.isInstancedBufferAttribute ? gg : oi;
            E = new b(T, S.itemSize, S.normalized)
         }
         S.name !== void 0 && (E.name = S.name), S.usage !== void 0 && E.setUsage(S.usage), a.setAttribute(x, E)
      }
      const h = e.data.morphAttributes;
      if (h)
         for (const x in h) {
            const S = h[x],
               E = [];
            for (let T = 0, b = S.length; T < b; T++) {
               const w = S[T];
               let C;
               if (w.isInterleavedBufferAttribute) {
                  const N = s(e.data, w.data);
                  C = new ep(N, w.itemSize, w.offset, w.normalized)
               } else {
                  const N = km(w.type, w.array);
                  C = new oi(N, w.itemSize, w.normalized)
               }
               w.name !== void 0 && (C.name = w.name), E.push(C)
            }
            a.morphAttributes[x] = E
         }
      e.data.morphTargetsRelative && (a.morphTargetsRelative = !0);
      const g = e.data.groups || e.data.drawcalls || e.data.offsets;
      if (g !== void 0)
         for (let x = 0, S = g.length; x !== S; ++x) {
            const E = g[x];
            a.addGroup(E.start, E.count, E.materialIndex)
         }
      const v = e.data.boundingSphere;
      if (v !== void 0) {
         const x = new ee;
         v.center !== void 0 && x.fromArray(v.center), a.boundingSphere = new zr(x, v.radius)
      }
      return e.name && (a.name = e.name), e.userData && (a.userData = e.userData), a
   }
}
class ik extends ja {
   constructor(e) {
      super(e)
   }
   load(e, t, i, s) {
      const r = this,
         a = this.path === "" ? QA.extractUrlBase(e) : this.path;
      this.resourcePath = this.resourcePath || a;
      const l = new Pc(this.manager);
      l.setPath(this.path), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, function (c) {
         let h = null;
         try {
            h = JSON.parse(c)
         } catch (g) {
            s !== void 0 && s(g), console.error("THREE:ObjectLoader: Can't parse " + e + ".", g.message);
            return
         }
         const m = h.metadata;
         if (m === void 0 || m.type === void 0 || m.type.toLowerCase() === "geometry") {
            s !== void 0 && s(new Error("THREE.ObjectLoader: Can't load " + e)), console.error("THREE.ObjectLoader: Can't load " + e);
            return
         }
         r.parse(h, t)
      }, i, s)
   }
   async loadAsync(e, t) {
      const i = this,
         s = this.path === "" ? QA.extractUrlBase(e) : this.path;
      this.resourcePath = this.resourcePath || s;
      const r = new Pc(this.manager);
      r.setPath(this.path), r.setRequestHeader(this.requestHeader), r.setWithCredentials(this.withCredentials);
      const a = await r.loadAsync(e, t),
         l = JSON.parse(a),
         c = l.metadata;
      if (c === void 0 || c.type === void 0 || c.type.toLowerCase() === "geometry") throw new Error("THREE.ObjectLoader: Can't load " + e);
      return await i.parseAsync(l)
   }
   parse(e, t) {
      const i = this.parseAnimations(e.animations),
         s = this.parseShapes(e.shapes),
         r = this.parseGeometries(e.geometries, s),
         a = this.parseImages(e.images, function () {
            t !== void 0 && t(h)
         }),
         l = this.parseTextures(e.textures, a),
         c = this.parseMaterials(e.materials, l),
         h = this.parseObject(e.object, r, c, l, i),
         m = this.parseSkeletons(e.skeletons, h);
      if (this.bindSkeletons(h, m), this.bindLightTargets(h), t !== void 0) {
         let g = !1;
         for (const v in a)
            if (a[v].data instanceof HTMLImageElement) {
               g = !0;
               break
            } g === !1 && t(h)
      }
      return h
   }
   async parseAsync(e) {
      const t = this.parseAnimations(e.animations),
         i = this.parseShapes(e.shapes),
         s = this.parseGeometries(e.geometries, i),
         r = await this.parseImagesAsync(e.images),
         a = this.parseTextures(e.textures, r),
         l = this.parseMaterials(e.materials, a),
         c = this.parseObject(e.object, s, l, a, t),
         h = this.parseSkeletons(e.skeletons, c);
      return this.bindSkeletons(c, h), this.bindLightTargets(c), c
   }
   parseShapes(e) {
      const t = {};
      if (e !== void 0)
         for (let i = 0, s = e.length; i < s; i++) {
            const r = new Vd().fromJSON(e[i]);
            t[r.uuid] = r
         }
      return t
   }
   parseSkeletons(e, t) {
      const i = {},
         s = {};
      if (t.traverse(function (r) {
            r.isBone && (s[r.uuid] = r)
         }), e !== void 0)
         for (let r = 0, a = e.length; r < a; r++) {
            const l = new pT().fromJSON(e[r], s);
            i[l.uuid] = l
         }
      return i
   }
   parseGeometries(e, t) {
      const i = {};
      if (e !== void 0) {
         const s = new xB;
         for (let r = 0, a = e.length; r < a; r++) {
            let l;
            const c = e[r];
            switch (c.type) {
               case "BufferGeometry":
               case "InstancedBufferGeometry":
                  l = s.parse(c);
                  break;
               default:
                  c.type in u3 ? l = u3[c.type].fromJSON(c, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${c.type}"`)
            }
            l.uuid = c.uuid, c.name !== void 0 && (l.name = c.name), c.userData !== void 0 && (l.userData = c.userData), i[c.uuid] = l
         }
      }
      return i
   }
   parseMaterials(e, t) {
      const i = {},
         s = {};
      if (e !== void 0) {
         const r = new CT;
         r.setTextures(t);
         for (let a = 0, l = e.length; a < l; a++) {
            const c = e[a];
            i[c.uuid] === void 0 && (i[c.uuid] = r.parse(c)), s[c.uuid] = i[c.uuid]
         }
      }
      return s
   }
   parseAnimations(e) {
      const t = {};
      if (e !== void 0)
         for (let i = 0; i < e.length; i++) {
            const s = e[i],
               r = Fy.parse(s);
            t[r.uuid] = r
         }
      return t
   }
   parseImages(e, t) {
      const i = this,
         s = {};
      let r;

      function a(c) {
         return i.manager.itemStart(c), r.load(c, function () {
            i.manager.itemEnd(c)
         }, void 0, function () {
            i.manager.itemError(c), i.manager.itemEnd(c)
         })
      }

      function l(c) {
         if (typeof c == "string") {
            const h = c,
               m = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(h) ? h : i.resourcePath + h;
            return a(m)
         } else return c.data ? {
            data: km(c.type, c.data),
            width: c.width,
            height: c.height
         } : null
      }
      if (e !== void 0 && e.length > 0) {
         const c = new KR(t);
         r = new Hy(c), r.setCrossOrigin(this.crossOrigin);
         for (let h = 0, m = e.length; h < m; h++) {
            const g = e[h],
               v = g.url;
            if (Array.isArray(v)) {
               const x = [];
               for (let S = 0, E = v.length; S < E; S++) {
                  const T = v[S],
                     b = l(T);
                  b !== null && (b instanceof HTMLImageElement ? x.push(b) : x.push(new Pu(b.data, b.width, b.height)))
               }
               s[g.uuid] = new Xf(x)
            } else {
               const x = l(g.url);
               s[g.uuid] = new Xf(x)
            }
         }
      }
      return s
   }
   async parseImagesAsync(e) {
      const t = this,
         i = {};
      let s;
      async function r(a) {
         if (typeof a == "string") {
            const l = a,
               c = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(l) ? l : t.resourcePath + l;
            return await s.loadAsync(c)
         } else return a.data ? {
            data: km(a.type, a.data),
            width: a.width,
            height: a.height
         } : null
      }
      if (e !== void 0 && e.length > 0) {
         s = new Hy(this.manager), s.setCrossOrigin(this.crossOrigin);
         for (let a = 0, l = e.length; a < l; a++) {
            const c = e[a],
               h = c.url;
            if (Array.isArray(h)) {
               const m = [];
               for (let g = 0, v = h.length; g < v; g++) {
                  const x = h[g],
                     S = await r(x);
                  S !== null && (S instanceof HTMLImageElement ? m.push(S) : m.push(new Pu(S.data, S.width, S.height)))
               }
               i[c.uuid] = new Xf(m)
            } else {
               const m = await r(c.url);
               i[c.uuid] = new Xf(m)
            }
         }
      }
      return i
   }
   parseTextures(e, t) {
      function i(r, a) {
         return typeof r == "number" ? r : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", r), a[r])
      }
      const s = {};
      if (e !== void 0)
         for (let r = 0, a = e.length; r < a; r++) {
            const l = e[r];
            l.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', l.uuid), t[l.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", l.image);
            const c = t[l.image],
               h = c.data;
            let m;
            Array.isArray(h) ? (m = new mx, h.length === 6 && (m.needsUpdate = !0)) : (h && h.data ? m = new Pu : m = new Hi, h && (m.needsUpdate = !0)), m.source = c, m.uuid = l.uuid, l.name !== void 0 && (m.name = l.name), l.mapping !== void 0 && (m.mapping = i(l.mapping, sk)), l.channel !== void 0 && (m.channel = l.channel), l.offset !== void 0 && m.offset.fromArray(l.offset), l.repeat !== void 0 && m.repeat.fromArray(l.repeat), l.center !== void 0 && m.center.fromArray(l.center), l.rotation !== void 0 && (m.rotation = l.rotation), l.wrap !== void 0 && (m.wrapS = i(l.wrap[0], d3), m.wrapT = i(l.wrap[1], d3)), l.format !== void 0 && (m.format = l.format), l.internalFormat !== void 0 && (m.internalFormat = l.internalFormat), l.type !== void 0 && (m.type = l.type), l.colorSpace !== void 0 && (m.colorSpace = l.colorSpace), l.minFilter !== void 0 && (m.minFilter = i(l.minFilter, p3)), l.magFilter !== void 0 && (m.magFilter = i(l.magFilter, p3)), l.anisotropy !== void 0 && (m.anisotropy = l.anisotropy), l.flipY !== void 0 && (m.flipY = l.flipY), l.generateMipmaps !== void 0 && (m.generateMipmaps = l.generateMipmaps), l.premultiplyAlpha !== void 0 && (m.premultiplyAlpha = l.premultiplyAlpha), l.unpackAlignment !== void 0 && (m.unpackAlignment = l.unpackAlignment), l.compareFunction !== void 0 && (m.compareFunction = l.compareFunction), l.userData !== void 0 && (m.userData = l.userData), s[l.uuid] = m
         }
      return s
   }
   parseObject(e, t, i, s, r) {
      let a;

      function l(v) {
         return t[v] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", v), t[v]
      }

      function c(v) {
         if (v !== void 0) {
            if (Array.isArray(v)) {
               const x = [];
               for (let S = 0, E = v.length; S < E; S++) {
                  const T = v[S];
                  i[T] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", T), x.push(i[T])
               }
               return x
            }
            return i[v] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", v), i[v]
         }
      }

      function h(v) {
         return s[v] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", v), s[v]
      }
      let m, g;
      switch (e.type) {
         case "Scene":
            a = new mg, e.background !== void 0 && (Number.isInteger(e.background) ? a.background = new dt(e.background) : a.background = h(e.background)), e.environment !== void 0 && (a.environment = h(e.environment)), e.fog !== void 0 && (e.fog.type === "Fog" ? a.fog = new hT(e.fog.color, e.fog.near, e.fog.far) : e.fog.type === "FogExp2" && (a.fog = new fT(e.fog.color, e.fog.density)), e.fog.name !== "" && (a.fog.name = e.fog.name)), e.backgroundBlurriness !== void 0 && (a.backgroundBlurriness = e.backgroundBlurriness), e.backgroundIntensity !== void 0 && (a.backgroundIntensity = e.backgroundIntensity), e.backgroundRotation !== void 0 && a.backgroundRotation.fromArray(e.backgroundRotation), e.environmentIntensity !== void 0 && (a.environmentIntensity = e.environmentIntensity), e.environmentRotation !== void 0 && a.environmentRotation.fromArray(e.environmentRotation);
            break;
         case "PerspectiveCamera":
            a = new Cs(e.fov, e.aspect, e.near, e.far), e.focus !== void 0 && (a.focus = e.focus), e.zoom !== void 0 && (a.zoom = e.zoom), e.filmGauge !== void 0 && (a.filmGauge = e.filmGauge), e.filmOffset !== void 0 && (a.filmOffset = e.filmOffset), e.view !== void 0 && (a.view = Object.assign({}, e.view));
            break;
         case "OrthographicCamera":
            a = new bx(e.left, e.right, e.top, e.bottom, e.near, e.far), e.zoom !== void 0 && (a.zoom = e.zoom), e.view !== void 0 && (a.view = Object.assign({}, e.view));
            break;
         case "AmbientLight":
            a = new pB(e.color, e.intensity);
            break;
         case "DirectionalLight":
            a = new dB(e.color, e.intensity), a.target = e.target || "";
            break;
         case "PointLight":
            a = new hB(e.color, e.intensity, e.distance, e.decay);
            break;
         case "RectAreaLight":
            a = new mB(e.color, e.intensity, e.width, e.height);
            break;
         case "SpotLight":
            a = new fB(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay), a.target = e.target || "";
            break;
         case "HemisphereLight":
            a = new cB(e.color, e.groundColor, e.intensity);
            break;
         case "LightProbe":
            a = new vB().fromJSON(e);
            break;
         case "SkinnedMesh":
            m = l(e.geometry), g = c(e.material), a = new PL(m, g), e.bindMode !== void 0 && (a.bindMode = e.bindMode), e.bindMatrix !== void 0 && a.bindMatrix.fromArray(e.bindMatrix), e.skeleton !== void 0 && (a.skeleton = e.skeleton);
            break;
         case "Mesh":
            m = l(e.geometry), g = c(e.material), a = new ds(m, g);
            break;
         case "InstancedMesh":
            m = l(e.geometry), g = c(e.material);
            const v = e.count,
               x = e.instanceMatrix,
               S = e.instanceColor;
            a = new LL(m, g, v), a.instanceMatrix = new gg(new Float32Array(x.array), 16), S !== void 0 && (a.instanceColor = new gg(new Float32Array(S.array), S.itemSize));
            break;
         case "BatchedMesh":
            m = l(e.geometry), g = c(e.material), a = new BL(e.maxInstanceCount, e.maxVertexCount, e.maxIndexCount, g), a.geometry = m, a.perObjectFrustumCulled = e.perObjectFrustumCulled, a.sortObjects = e.sortObjects, a._drawRanges = e.drawRanges, a._reservedRanges = e.reservedRanges, a._visibility = e.visibility, a._active = e.active, a._bounds = e.bounds.map(E => {
               const T = new pa;
               T.min.fromArray(E.boxMin), T.max.fromArray(E.boxMax);
               const b = new zr;
               return b.radius = E.sphereRadius, b.center.fromArray(E.sphereCenter), {
                  boxInitialized: E.boxInitialized,
                  box: T,
                  sphereInitialized: E.sphereInitialized,
                  sphere: b
               }
            }), a._maxInstanceCount = e.maxInstanceCount, a._maxVertexCount = e.maxVertexCount, a._maxIndexCount = e.maxIndexCount, a._geometryInitialized = e.geometryInitialized, a._geometryCount = e.geometryCount, a._matricesTexture = h(e.matricesTexture.uuid), e.colorsTexture !== void 0 && (a._colorsTexture = h(e.colorsTexture.uuid));
            break;
         case "LOD":
            a = new UL;
            break;
         case "Line":
            a = new rh(l(e.geometry), c(e.material));
            break;
         case "LineLoop":
            a = new zL(l(e.geometry), c(e.material));
            break;
         case "LineSegments":
            a = new qu(l(e.geometry), c(e.material));
            break;
         case "PointCloud":
         case "Points":
            a = new IL(l(e.geometry), c(e.material));
            break;
         case "Sprite":
            a = new OL(c(e.material));
            break;
         case "Group":
            a = new jm;
            break;
         case "Bone":
            a = new PR;
            break;
         default:
            a = new Wn
      }
      if (a.uuid = e.uuid, e.name !== void 0 && (a.name = e.name), e.matrix !== void 0 ? (a.matrix.fromArray(e.matrix), e.matrixAutoUpdate !== void 0 && (a.matrixAutoUpdate = e.matrixAutoUpdate), a.matrixAutoUpdate && a.matrix.decompose(a.position, a.quaternion, a.scale)) : (e.position !== void 0 && a.position.fromArray(e.position), e.rotation !== void 0 && a.rotation.fromArray(e.rotation), e.quaternion !== void 0 && a.quaternion.fromArray(e.quaternion), e.scale !== void 0 && a.scale.fromArray(e.scale)), e.up !== void 0 && a.up.fromArray(e.up), e.castShadow !== void 0 && (a.castShadow = e.castShadow), e.receiveShadow !== void 0 && (a.receiveShadow = e.receiveShadow), e.shadow && (e.shadow.intensity !== void 0 && (a.shadow.intensity = e.shadow.intensity), e.shadow.bias !== void 0 && (a.shadow.bias = e.shadow.bias), e.shadow.normalBias !== void 0 && (a.shadow.normalBias = e.shadow.normalBias), e.shadow.radius !== void 0 && (a.shadow.radius = e.shadow.radius), e.shadow.mapSize !== void 0 && a.shadow.mapSize.fromArray(e.shadow.mapSize), e.shadow.camera !== void 0 && (a.shadow.camera = this.parseObject(e.shadow.camera))), e.visible !== void 0 && (a.visible = e.visible), e.frustumCulled !== void 0 && (a.frustumCulled = e.frustumCulled), e.renderOrder !== void 0 && (a.renderOrder = e.renderOrder), e.userData !== void 0 && (a.userData = e.userData), e.layers !== void 0 && (a.layers.mask = e.layers), e.children !== void 0) {
         const v = e.children;
         for (let x = 0; x < v.length; x++) a.add(this.parseObject(v[x], t, i, s, r))
      }
      if (e.animations !== void 0) {
         const v = e.animations;
         for (let x = 0; x < v.length; x++) {
            const S = v[x];
            a.animations.push(r[S])
         }
      }
      if (e.type === "LOD") {
         e.autoUpdate !== void 0 && (a.autoUpdate = e.autoUpdate);
         const v = e.levels;
         for (let x = 0; x < v.length; x++) {
            const S = v[x],
               E = a.getObjectByProperty("uuid", S.object);
            E !== void 0 && a.addLevel(E, S.distance, S.hysteresis)
         }
      }
      return a
   }
   bindSkeletons(e, t) {
      Object.keys(t).length !== 0 && e.traverse(function (i) {
         if (i.isSkinnedMesh === !0 && i.skeleton !== void 0) {
            const s = t[i.skeleton];
            s === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", i.skeleton) : i.bind(s, i.bindMatrix)
         }
      })
   }
   bindLightTargets(e) {
      e.traverse(function (t) {
         if (t.isDirectionalLight || t.isSpotLight) {
            const i = t.target,
               s = e.getObjectByProperty("uuid", i);
            s !== void 0 ? t.target = s : t.target = new Wn
         }
      })
   }
}
const sk = {
      UVMapping: tT,
      CubeReflectionMapping: Uc,
      CubeRefractionMapping: sh,
      EquirectangularReflectionMapping: Ty,
      EquirectangularRefractionMapping: Ey,
      CubeUVReflectionMapping: Ug
   },
   d3 = {
      RepeatWrapping: My,
      ClampToEdgeWrapping: Ko,
      MirroredRepeatWrapping: Ay
   },
   p3 = {
      NearestFilter: ms,
      NearestMipmapNearestFilter: yR,
      NearestMipmapLinearFilter: Gm,
      LinearFilter: Ni,
      LinearMipmapNearestFilter: F0,
      LinearMipmapLinearFilter: Du
   };
class rk extends ja {
   constructor(e) {
      super(e), this.isImageBitmapLoader = !0, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
         premultiplyAlpha: "none"
      }
   }
   setOptions(e) {
      return this.options = e, this
   }
   load(e, t, i, s) {
      e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
      const r = this,
         a = wc.get(e);
      if (a !== void 0) {
         if (r.manager.itemStart(e), a.then) {
            a.then(h => {
               t && t(h), r.manager.itemEnd(e)
            }).catch(h => {
               s && s(h)
            });
            return
         }
         return setTimeout(function () {
            t && t(a), r.manager.itemEnd(e)
         }, 0), a
      }
      const l = {};
      l.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", l.headers = this.requestHeader;
      const c = fetch(e, l).then(function (h) {
         return h.blob()
      }).then(function (h) {
         return createImageBitmap(h, Object.assign(r.options, {
            colorSpaceConversion: "none"
         }))
      }).then(function (h) {
         return wc.add(e, h), t && t(h), r.manager.itemEnd(e), h
      }).catch(function (h) {
         s && s(h), wc.remove(e), r.manager.itemError(e), r.manager.itemEnd(e)
      });
      wc.add(e, c), r.manager.itemStart(e)
   }
}
let VS;
class JR {
   static getContext() {
      return VS === void 0 && (VS = new(window.AudioContext || window.webkitAudioContext)), VS
   }
   static setContext(e) {
      VS = e
   }
}
class ak extends ja {
   constructor(e) {
      super(e)
   }
   load(e, t, i, s) {
      const r = this,
         a = new Pc(this.manager);
      a.setResponseType("arraybuffer"), a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function (c) {
         try {
            const h = c.slice(0);
            JR.getContext().decodeAudioData(h, function (g) {
               t(g)
            }).catch(l)
         } catch (h) {
            l(h)
         }
      }, i, s);

      function l(c) {
         s ? s(c) : console.error(c), r.manager.itemError(e)
      }
   }
}
const m3 = new Zt,
   g3 = new Zt,
   dd = new Zt;
class ok {
   constructor() {
      this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new Cs, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new Cs, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
         focus: null,
         fov: null,
         aspect: null,
         near: null,
         far: null,
         zoom: null,
         eyeSep: null
      }
   }
   update(e) {
      const t = this._cache;
      if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
         t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep, dd.copy(e.projectionMatrix);
         const s = t.eyeSep / 2,
            r = s * t.near / t.focus,
            a = t.near * Math.tan(Hd * t.fov * .5) / t.zoom;
         let l, c;
         g3.elements[12] = -s, m3.elements[12] = s, l = -a * t.aspect + r, c = a * t.aspect + r, dd.elements[0] = 2 * t.near / (c - l), dd.elements[8] = (c + l) / (c - l), this.cameraL.projectionMatrix.copy(dd), l = -a * t.aspect - r, c = a * t.aspect - r, dd.elements[0] = 2 * t.near / (c - l), dd.elements[8] = (c + l) / (c - l), this.cameraR.projectionMatrix.copy(dd)
      }
      this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(g3), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(m3)
   }
}
class _B extends Cs {
   constructor(e = []) {
      super(), this.isArrayCamera = !0, this.cameras = e, this.index = 0
   }
}
class $R {
   constructor(e = !0) {
      this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
   }
   start() {
      this.startTime = v3(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
   }
   stop() {
      this.getElapsedTime(), this.running = !1, this.autoStart = !1
   }
   getElapsedTime() {
      return this.getDelta(), this.elapsedTime
   }
   getDelta() {
      let e = 0;
      if (this.autoStart && !this.running) return this.start(), 0;
      if (this.running) {
         const t = v3();
         e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e
      }
      return e
   }
}

function v3() {
   return performance.now()
}
const pd = new ee,
   y3 = new Ba,
   lk = new ee,
   md = new ee;
class uk extends Wn {
   constructor() {
      super(), this.type = "AudioListener", this.context = JR.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new $R
   }
   getInput() {
      return this.gain
   }
   removeFilter() {
      return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
   }
   getFilter() {
      return this.filter
   }
   setFilter(e) {
      return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this
   }
   getMasterVolume() {
      return this.gain.gain.value
   }
   setMasterVolume(e) {
      return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
   }
   updateMatrixWorld(e) {
      super.updateMatrixWorld(e);
      const t = this.context.listener,
         i = this.up;
      if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(pd, y3, lk), md.set(0, 0, -1).applyQuaternion(y3), t.positionX) {
         const s = this.context.currentTime + this.timeDelta;
         t.positionX.linearRampToValueAtTime(pd.x, s), t.positionY.linearRampToValueAtTime(pd.y, s), t.positionZ.linearRampToValueAtTime(pd.z, s), t.forwardX.linearRampToValueAtTime(md.x, s), t.forwardY.linearRampToValueAtTime(md.y, s), t.forwardZ.linearRampToValueAtTime(md.z, s), t.upX.linearRampToValueAtTime(i.x, s), t.upY.linearRampToValueAtTime(i.y, s), t.upZ.linearRampToValueAtTime(i.z, s)
      } else t.setPosition(pd.x, pd.y, pd.z), t.setOrientation(md.x, md.y, md.z, i.x, i.y, i.z)
   }
}
let SB = class extends Wn {
   constructor(e) {
      super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = []
   }
   getOutput() {
      return this.gain
   }
   setNodeSource(e) {
      return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this
   }
   setMediaElementSource(e) {
      return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this
   }
   setMediaStreamSource(e) {
      return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this
   }
   setBuffer(e) {
      return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this
   }
   play(e = 0) {
      if (this.isPlaying === !0) {
         console.warn("THREE.Audio: Audio is already playing.");
         return
      }
      if (this.hasPlaybackControl === !1) {
         console.warn("THREE.Audio: this Audio has no playback control.");
         return
      }
      this._startedAt = this.context.currentTime + e;
      const t = this.context.createBufferSource();
      return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
   }
   pause() {
      if (this.hasPlaybackControl === !1) {
         console.warn("THREE.Audio: this Audio has no playback control.");
         return
      }
      return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this
   }
   stop(e = 0) {
      if (this.hasPlaybackControl === !1) {
         console.warn("THREE.Audio: this Audio has no playback control.");
         return
      }
      return this._progress = 0, this.source !== null && (this.source.stop(this.context.currentTime + e), this.source.onended = null), this.isPlaying = !1, this
   }
   connect() {
      if (this.filters.length > 0) {
         this.source.connect(this.filters[0]);
         for (let e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].connect(this.filters[e]);
         this.filters[this.filters.length - 1].connect(this.getOutput())
      } else this.source.connect(this.getOutput());
      return this._connected = !0, this
   }
   disconnect() {
      if (this._connected !== !1) {
         if (this.filters.length > 0) {
            this.source.disconnect(this.filters[0]);
            for (let e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].disconnect(this.filters[e]);
            this.filters[this.filters.length - 1].disconnect(this.getOutput())
         } else this.source.disconnect(this.getOutput());
         return this._connected = !1, this
      }
   }
   getFilters() {
      return this.filters
   }
   setFilters(e) {
      return e || (e = []), this._connected === !0 ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this
   }
   setDetune(e) {
      return this.detune = e, this.isPlaying === !0 && this.source.detune !== void 0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
   }
   getDetune() {
      return this.detune
   }
   getFilter() {
      return this.getFilters()[0]
   }
   setFilter(e) {
      return this.setFilters(e ? [e] : [])
   }
   setPlaybackRate(e) {
      if (this.hasPlaybackControl === !1) {
         console.warn("THREE.Audio: this Audio has no playback control.");
         return
      }
      return this.playbackRate = e, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this
   }
   getPlaybackRate() {
      return this.playbackRate
   }
   onEnded() {
      this.isPlaying = !1, this._progress = 0
   }
   getLoop() {
      return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
   }
   setLoop(e) {
      if (this.hasPlaybackControl === !1) {
         console.warn("THREE.Audio: this Audio has no playback control.");
         return
      }
      return this.loop = e, this.isPlaying === !0 && (this.source.loop = this.loop), this
   }
   setLoopStart(e) {
      return this.loopStart = e, this
   }
   setLoopEnd(e) {
      return this.loopEnd = e, this
   }
   getVolume() {
      return this.gain.gain.value
   }
   setVolume(e) {
      return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
   }
   copy(e, t) {
      return super.copy(e, t), e.sourceType !== "buffer" ? (console.warn("THREE.Audio: Audio source type cannot be copied."), this) : (this.autoplay = e.autoplay, this.buffer = e.buffer, this.detune = e.detune, this.loop = e.loop, this.loopStart = e.loopStart, this.loopEnd = e.loopEnd, this.offset = e.offset, this.duration = e.duration, this.playbackRate = e.playbackRate, this.hasPlaybackControl = e.hasPlaybackControl, this.sourceType = e.sourceType, this.filters = e.filters.slice(), this)
   }
   clone(e) {
      return new this.constructor(this.listener).copy(this, e)
   }
};
const gd = new ee,
   x3 = new Ba,
   ck = new ee,
   vd = new ee;
class fk extends SB {
   constructor(e) {
      super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain)
   }
   connect() {
      return super.connect(), this.panner.connect(this.gain), this
   }
   disconnect() {
      return super.disconnect(), this.panner.disconnect(this.gain), this
   }
   getOutput() {
      return this.panner
   }
   getRefDistance() {
      return this.panner.refDistance
   }
   setRefDistance(e) {
      return this.panner.refDistance = e, this
   }
   getRolloffFactor() {
      return this.panner.rolloffFactor
   }
   setRolloffFactor(e) {
      return this.panner.rolloffFactor = e, this
   }
   getDistanceModel() {
      return this.panner.distanceModel
   }
   setDistanceModel(e) {
      return this.panner.distanceModel = e, this
   }
   getMaxDistance() {
      return this.panner.maxDistance
   }
   setMaxDistance(e) {
      return this.panner.maxDistance = e, this
   }
   setDirectionalCone(e, t, i) {
      return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = i, this
   }
   updateMatrixWorld(e) {
      if (super.updateMatrixWorld(e), this.hasPlaybackControl === !0 && this.isPlaying === !1) return;
      this.matrixWorld.decompose(gd, x3, ck), vd.set(0, 0, 1).applyQuaternion(x3);
      const t = this.panner;
      if (t.positionX) {
         const i = this.context.currentTime + this.listener.timeDelta;
         t.positionX.linearRampToValueAtTime(gd.x, i), t.positionY.linearRampToValueAtTime(gd.y, i), t.positionZ.linearRampToValueAtTime(gd.z, i), t.orientationX.linearRampToValueAtTime(vd.x, i), t.orientationY.linearRampToValueAtTime(vd.y, i), t.orientationZ.linearRampToValueAtTime(vd.z, i)
      } else t.setPosition(gd.x, gd.y, gd.z), t.setOrientation(vd.x, vd.y, vd.z)
   }
}
class hk {
   constructor(e, t = 2048) {
      this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser)
   }
   getFrequencyData() {
      return this.analyser.getByteFrequencyData(this.data), this.data
   }
   getAverageFrequency() {
      let e = 0;
      const t = this.getFrequencyData();
      for (let i = 0; i < t.length; i++) e += t[i];
      return e / t.length
   }
}
class bB {
   constructor(e, t, i) {
      this.binding = e, this.valueSize = i;
      let s, r, a;
      switch (t) {
         case "quaternion":
            s = this._slerp, r = this._slerpAdditive, a = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(i * 6), this._workIndex = 5;
            break;
         case "string":
         case "bool":
            s = this._select, r = this._select, a = this._setAdditiveIdentityOther, this.buffer = new Array(i * 5);
            break;
         default:
            s = this._lerp, r = this._lerpAdditive, a = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(i * 5)
      }
      this._mixBufferRegion = s, this._mixBufferRegionAdditive = r, this._setIdentity = a, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0
   }
   accumulate(e, t) {
      const i = this.buffer,
         s = this.valueSize,
         r = e * s + s;
      let a = this.cumulativeWeight;
      if (a === 0) {
         for (let l = 0; l !== s; ++l) i[r + l] = i[l];
         a = t
      } else {
         a += t;
         const l = t / a;
         this._mixBufferRegion(i, r, 0, l, s)
      }
      this.cumulativeWeight = a
   }
   accumulateAdditive(e) {
      const t = this.buffer,
         i = this.valueSize,
         s = i * this._addIndex;
      this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(t, s, 0, e, i), this.cumulativeWeightAdditive += e
   }
   apply(e) {
      const t = this.valueSize,
         i = this.buffer,
         s = e * t + t,
         r = this.cumulativeWeight,
         a = this.cumulativeWeightAdditive,
         l = this.binding;
      if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, r < 1) {
         const c = t * this._origIndex;
         this._mixBufferRegion(i, s, c, 1 - r, t)
      }
      a > 0 && this._mixBufferRegionAdditive(i, s, this._addIndex * t, 1, t);
      for (let c = t, h = t + t; c !== h; ++c)
         if (i[c] !== i[c + t]) {
            l.setValue(i, s);
            break
         }
   }
   saveOriginalState() {
      const e = this.binding,
         t = this.buffer,
         i = this.valueSize,
         s = i * this._origIndex;
      e.getValue(t, s);
      for (let r = i, a = s; r !== a; ++r) t[r] = t[s + r % i];
      this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0
   }
   restoreOriginalState() {
      const e = this.valueSize * 3;
      this.binding.setValue(this.buffer, e)
   }
   _setAdditiveIdentityNumeric() {
      const e = this._addIndex * this.valueSize,
         t = e + this.valueSize;
      for (let i = e; i < t; i++) this.buffer[i] = 0
   }
   _setAdditiveIdentityQuaternion() {
      this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1
   }
   _setAdditiveIdentityOther() {
      const e = this._origIndex * this.valueSize,
         t = this._addIndex * this.valueSize;
      for (let i = 0; i < this.valueSize; i++) this.buffer[t + i] = this.buffer[e + i]
   }
   _select(e, t, i, s, r) {
      if (s >= .5)
         for (let a = 0; a !== r; ++a) e[t + a] = e[i + a]
   }
   _slerp(e, t, i, s) {
      Ba.slerpFlat(e, t, e, t, e, i, s)
   }
   _slerpAdditive(e, t, i, s, r) {
      const a = this._workIndex * r;
      Ba.multiplyQuaternionsFlat(e, a, e, t, e, i), Ba.slerpFlat(e, t, e, t, e, a, s)
   }
   _lerp(e, t, i, s, r) {
      const a = 1 - s;
      for (let l = 0; l !== r; ++l) {
         const c = t + l;
         e[c] = e[c] * a + e[i + l] * s
      }
   }
   _lerpAdditive(e, t, i, s, r) {
      for (let a = 0; a !== r; ++a) {
         const l = t + a;
         e[l] = e[l] + e[i + a] * s
      }
   }
}
const e2 = "\\[\\]\\.:\\/",
   dk = new RegExp("[" + e2 + "]", "g"),
   t2 = "[^" + e2 + "]",
   pk = "[^" + e2.replace("\\.", "") + "]",
   mk = /((?:WC+[\/:])*)/.source.replace("WC", t2),
   gk = /(WCOD+)?/.source.replace("WCOD", pk),
   vk = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", t2),
   yk = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", t2),
   xk = new RegExp("^" + mk + gk + vk + yk + "$"),
   _k = ["material", "materials", "bones", "map"];
class Sk {
   constructor(e, t, i) {
      const s = i || Xn.parseTrackName(t);
      this._targetGroup = e, this._bindings = e.subscribe_(t, s)
   }
   getValue(e, t) {
      this.bind();
      const i = this._targetGroup.nCachedObjects_,
         s = this._bindings[i];
      s !== void 0 && s.getValue(e, t)
   }
   setValue(e, t) {
      const i = this._bindings;
      for (let s = this._targetGroup.nCachedObjects_, r = i.length; s !== r; ++s) i[s].setValue(e, t)
   }
   bind() {
      const e = this._bindings;
      for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t) e[t].bind()
   }
   unbind() {
      const e = this._bindings;
      for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t) e[t].unbind()
   }
}
class Xn {
   constructor(e, t, i) {
      this.path = t, this.parsedPath = i || Xn.parseTrackName(t), this.node = Xn.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
   }
   static create(e, t, i) {
      return e && e.isAnimationObjectGroup ? new Xn.Composite(e, t, i) : new Xn(e, t, i)
   }
   static sanitizeNodeName(e) {
      return e.replace(/\s/g, "_").replace(dk, "")
   }
   static parseTrackName(e) {
      const t = xk.exec(e);
      if (t === null) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
      const i = {
            nodeName: t[2],
            objectName: t[3],
            objectIndex: t[4],
            propertyName: t[5],
            propertyIndex: t[6]
         },
         s = i.nodeName && i.nodeName.lastIndexOf(".");
      if (s !== void 0 && s !== -1) {
         const r = i.nodeName.substring(s + 1);
         _k.indexOf(r) !== -1 && (i.nodeName = i.nodeName.substring(0, s), i.objectName = r)
      }
      if (i.propertyName === null || i.propertyName.length === 0) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
      return i
   }
   static findNode(e, t) {
      if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid) return e;
      if (e.skeleton) {
         const i = e.skeleton.getBoneByName(t);
         if (i !== void 0) return i
      }
      if (e.children) {
         const i = function (r) {
               for (let a = 0; a < r.length; a++) {
                  const l = r[a];
                  if (l.name === t || l.uuid === t) return l;
                  const c = i(l.children);
                  if (c) return c
               }
               return null
            },
            s = i(e.children);
         if (s) return s
      }
      return null
   }
   _getValue_unavailable() {}
   _setValue_unavailable() {}
   _getValue_direct(e, t) {
      e[t] = this.targetObject[this.propertyName]
   }
   _getValue_array(e, t) {
      const i = this.resolvedProperty;
      for (let s = 0, r = i.length; s !== r; ++s) e[t++] = i[s]
   }
   _getValue_arrayElement(e, t) {
      e[t] = this.resolvedProperty[this.propertyIndex]
   }
   _getValue_toArray(e, t) {
      this.resolvedProperty.toArray(e, t)
   }
   _setValue_direct(e, t) {
      this.targetObject[this.propertyName] = e[t]
   }
   _setValue_direct_setNeedsUpdate(e, t) {
      this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0
   }
   _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
      this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
   }
   _setValue_array(e, t) {
      const i = this.resolvedProperty;
      for (let s = 0, r = i.length; s !== r; ++s) i[s] = e[t++]
   }
   _setValue_array_setNeedsUpdate(e, t) {
      const i = this.resolvedProperty;
      for (let s = 0, r = i.length; s !== r; ++s) i[s] = e[t++];
      this.targetObject.needsUpdate = !0
   }
   _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
      const i = this.resolvedProperty;
      for (let s = 0, r = i.length; s !== r; ++s) i[s] = e[t++];
      this.targetObject.matrixWorldNeedsUpdate = !0
   }
   _setValue_arrayElement(e, t) {
      this.resolvedProperty[this.propertyIndex] = e[t]
   }
   _setValue_arrayElement_setNeedsUpdate(e, t) {
      this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0
   }
   _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
      this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
   }
   _setValue_fromArray(e, t) {
      this.resolvedProperty.fromArray(e, t)
   }
   _setValue_fromArray_setNeedsUpdate(e, t) {
      this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0
   }
   _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
      this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0
   }
   _getValue_unbound(e, t) {
      this.bind(), this.getValue(e, t)
   }
   _setValue_unbound(e, t) {
      this.bind(), this.setValue(e, t)
   }
   bind() {
      let e = this.node;
      const t = this.parsedPath,
         i = t.objectName,
         s = t.propertyName;
      let r = t.propertyIndex;
      if (e || (e = Xn.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
         console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
         return
      }
      if (i) {
         let h = t.objectIndex;
         switch (i) {
            case "materials":
               if (!e.material) {
                  console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                  return
               }
               if (!e.material.materials) {
                  console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                  return
               }
               e = e.material.materials;
               break;
            case "bones":
               if (!e.skeleton) {
                  console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                  return
               }
               e = e.skeleton.bones;
               for (let m = 0; m < e.length; m++)
                  if (e[m].name === h) {
                     h = m;
                     break
                  } break;
            case "map":
               if ("map" in e) {
                  e = e.map;
                  break
               }
               if (!e.material) {
                  console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                  return
               }
               if (!e.material.map) {
                  console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                  return
               }
               e = e.material.map;
               break;
            default:
               if (e[i] === void 0) {
                  console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                  return
               }
               e = e[i]
         }
         if (h !== void 0) {
            if (e[h] === void 0) {
               console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
               return
            }
            e = e[h]
         }
      }
      const a = e[s];
      if (a === void 0) {
         const h = t.nodeName;
         console.error("THREE.PropertyBinding: Trying to update property for track: " + h + "." + s + " but it wasn't found.", e);
         return
      }
      let l = this.Versioning.None;
      this.targetObject = e, e.isMaterial === !0 ? l = this.Versioning.NeedsUpdate : e.isObject3D === !0 && (l = this.Versioning.MatrixWorldNeedsUpdate);
      let c = this.BindingType.Direct;
      if (r !== void 0) {
         if (s === "morphTargetInfluences") {
            if (!e.geometry) {
               console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
               return
            }
            if (!e.geometry.morphAttributes) {
               console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
               return
            }
            e.morphTargetDictionary[r] !== void 0 && (r = e.morphTargetDictionary[r])
         }
         c = this.BindingType.ArrayElement, this.resolvedProperty = a, this.propertyIndex = r
      } else a.fromArray !== void 0 && a.toArray !== void 0 ? (c = this.BindingType.HasFromToArray, this.resolvedProperty = a) : Array.isArray(a) ? (c = this.BindingType.EntireArray, this.resolvedProperty = a) : this.propertyName = s;
      this.getValue = this.GetterByBindingType[c], this.setValue = this.SetterByBindingTypeAndVersioning[c][l]
   }
   unbind() {
      this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
   }
}
Xn.Composite = Sk;
Xn.prototype.BindingType = {
   Direct: 0,
   EntireArray: 1,
   ArrayElement: 2,
   HasFromToArray: 3
};
Xn.prototype.Versioning = {
   None: 0,
   NeedsUpdate: 1,
   MatrixWorldNeedsUpdate: 2
};
Xn.prototype.GetterByBindingType = [Xn.prototype._getValue_direct, Xn.prototype._getValue_array, Xn.prototype._getValue_arrayElement, Xn.prototype._getValue_toArray];
Xn.prototype.SetterByBindingTypeAndVersioning = [
   [Xn.prototype._setValue_direct, Xn.prototype._setValue_direct_setNeedsUpdate, Xn.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
   [Xn.prototype._setValue_array, Xn.prototype._setValue_array_setNeedsUpdate, Xn.prototype._setValue_array_setMatrixWorldNeedsUpdate],
   [Xn.prototype._setValue_arrayElement, Xn.prototype._setValue_arrayElement_setNeedsUpdate, Xn.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
   [Xn.prototype._setValue_fromArray, Xn.prototype._setValue_fromArray_setNeedsUpdate, Xn.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
];
class bk {
   constructor() {
      this.isAnimationObjectGroup = !0, this.uuid = po(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
      const e = {};
      this._indicesByUUID = e;
      for (let i = 0, s = arguments.length; i !== s; ++i) e[arguments[i].uuid] = i;
      this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
      const t = this;
      this.stats = {
         objects: {
            get total() {
               return t._objects.length
            },
            get inUse() {
               return this.total - t.nCachedObjects_
            }
         },
         get bindingsPerObject() {
            return t._bindings.length
         }
      }
   }
   add() {
      const e = this._objects,
         t = this._indicesByUUID,
         i = this._paths,
         s = this._parsedPaths,
         r = this._bindings,
         a = r.length;
      let l, c = e.length,
         h = this.nCachedObjects_;
      for (let m = 0, g = arguments.length; m !== g; ++m) {
         const v = arguments[m],
            x = v.uuid;
         let S = t[x];
         if (S === void 0) {
            S = c++, t[x] = S, e.push(v);
            for (let E = 0, T = a; E !== T; ++E) r[E].push(new Xn(v, i[E], s[E]))
         } else if (S < h) {
            l = e[S];
            const E = --h,
               T = e[E];
            t[T.uuid] = S, e[S] = T, t[x] = E, e[E] = v;
            for (let b = 0, w = a; b !== w; ++b) {
               const C = r[b],
                  N = C[E];
               let U = C[S];
               C[S] = N, U === void 0 && (U = new Xn(v, i[b], s[b])), C[E] = U
            }
         } else e[S] !== l && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
      }
      this.nCachedObjects_ = h
   }
   remove() {
      const e = this._objects,
         t = this._indicesByUUID,
         i = this._bindings,
         s = i.length;
      let r = this.nCachedObjects_;
      for (let a = 0, l = arguments.length; a !== l; ++a) {
         const c = arguments[a],
            h = c.uuid,
            m = t[h];
         if (m !== void 0 && m >= r) {
            const g = r++,
               v = e[g];
            t[v.uuid] = m, e[m] = v, t[h] = g, e[g] = c;
            for (let x = 0, S = s; x !== S; ++x) {
               const E = i[x],
                  T = E[g],
                  b = E[m];
               E[m] = T, E[g] = b
            }
         }
      }
      this.nCachedObjects_ = r
   }
   uncache() {
      const e = this._objects,
         t = this._indicesByUUID,
         i = this._bindings,
         s = i.length;
      let r = this.nCachedObjects_,
         a = e.length;
      for (let l = 0, c = arguments.length; l !== c; ++l) {
         const h = arguments[l],
            m = h.uuid,
            g = t[m];
         if (g !== void 0)
            if (delete t[m], g < r) {
               const v = --r,
                  x = e[v],
                  S = --a,
                  E = e[S];
               t[x.uuid] = g, e[g] = x, t[E.uuid] = v, e[v] = E, e.pop();
               for (let T = 0, b = s; T !== b; ++T) {
                  const w = i[T],
                     C = w[v],
                     N = w[S];
                  w[g] = C, w[v] = N, w.pop()
               }
            } else {
               const v = --a,
                  x = e[v];
               v > 0 && (t[x.uuid] = g), e[g] = x, e.pop();
               for (let S = 0, E = s; S !== E; ++S) {
                  const T = i[S];
                  T[g] = T[v], T.pop()
               }
            }
      }
      this.nCachedObjects_ = r
   }
   subscribe_(e, t) {
      const i = this._bindingsIndicesByPath;
      let s = i[e];
      const r = this._bindings;
      if (s !== void 0) return r[s];
      const a = this._paths,
         l = this._parsedPaths,
         c = this._objects,
         h = c.length,
         m = this.nCachedObjects_,
         g = new Array(h);
      s = r.length, i[e] = s, a.push(e), l.push(t), r.push(g);
      for (let v = m, x = c.length; v !== x; ++v) {
         const S = c[v];
         g[v] = new Xn(S, e, t)
      }
      return g
   }
   unsubscribe_(e) {
      const t = this._bindingsIndicesByPath,
         i = t[e];
      if (i !== void 0) {
         const s = this._paths,
            r = this._parsedPaths,
            a = this._bindings,
            l = a.length - 1,
            c = a[l],
            h = e[l];
         t[h] = i, a[i] = c, a.pop(), r[i] = r[l], r.pop(), s[i] = s[l], s.pop()
      }
   }
}
class TB {
   constructor(e, t, i = null, s = t.blendMode) {
      this._mixer = e, this._clip = t, this._localRoot = i, this.blendMode = s;
      const r = t.tracks,
         a = r.length,
         l = new Array(a),
         c = {
            endingStart: Dd,
            endingEnd: Dd
         };
      for (let h = 0; h !== a; ++h) {
         const m = r[h].createInterpolant(null);
         l[h] = m, m.settings = c
      }
      this._interpolantSettings = c, this._interpolants = l, this._propertyBindings = new Array(a), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = fL, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
   }
   play() {
      return this._mixer._activateAction(this), this
   }
   stop() {
      return this._mixer._deactivateAction(this), this.reset()
   }
   reset() {
      return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
   }
   isRunning() {
      return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this)
   }
   isScheduled() {
      return this._mixer._isActiveAction(this)
   }
   startAt(e) {
      return this._startTime = e, this
   }
   setLoop(e, t) {
      return this.loop = e, this.repetitions = t, this
   }
   setEffectiveWeight(e) {
      return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading()
   }
   getEffectiveWeight() {
      return this._effectiveWeight
   }
   fadeIn(e) {
      return this._scheduleFading(e, 0, 1)
   }
   fadeOut(e) {
      return this._scheduleFading(e, 1, 0)
   }
   crossFadeFrom(e, t, i = !1) {
      if (e.fadeOut(t), this.fadeIn(t), i === !0) {
         const s = this._clip.duration,
            r = e._clip.duration,
            a = r / s,
            l = s / r;
         e.warp(1, a, t), this.warp(l, 1, t)
      }
      return this
   }
   crossFadeTo(e, t, i = !1) {
      return e.crossFadeFrom(this, t, i)
   }
   stopFading() {
      const e = this._weightInterpolant;
      return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
   }
   setEffectiveTimeScale(e) {
      return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping()
   }
   getEffectiveTimeScale() {
      return this._effectiveTimeScale
   }
   setDuration(e) {
      return this.timeScale = this._clip.duration / e, this.stopWarping()
   }
   syncWith(e) {
      return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping()
   }
   halt(e) {
      return this.warp(this._effectiveTimeScale, 0, e)
   }
   warp(e, t, i) {
      const s = this._mixer,
         r = s.time,
         a = this.timeScale;
      let l = this._timeScaleInterpolant;
      l === null && (l = s._lendControlInterpolant(), this._timeScaleInterpolant = l);
      const c = l.parameterPositions,
         h = l.sampleValues;
      return c[0] = r, c[1] = r + i, h[0] = e / a, h[1] = t / a, this
   }
   stopWarping() {
      const e = this._timeScaleInterpolant;
      return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
   }
   getMixer() {
      return this._mixer
   }
   getClip() {
      return this._clip
   }
   getRoot() {
      return this._localRoot || this._mixer._root
   }
   _update(e, t, i, s) {
      if (!this.enabled) {
         this._updateWeight(e);
         return
      }
      const r = this._startTime;
      if (r !== null) {
         const c = (e - r) * i;
         c < 0 || i === 0 ? t = 0 : (this._startTime = null, t = i * c)
      }
      t *= this._updateTimeScale(e);
      const a = this._updateTime(t),
         l = this._updateWeight(e);
      if (l > 0) {
         const c = this._interpolants,
            h = this._propertyBindings;
         switch (this.blendMode) {
            case RR:
               for (let m = 0, g = c.length; m !== g; ++m) c[m].evaluate(a), h[m].accumulateAdditive(l);
               break;
            case lT:
            default:
               for (let m = 0, g = c.length; m !== g; ++m) c[m].evaluate(a), h[m].accumulate(s, l)
         }
      }
   }
   _updateWeight(e) {
      let t = 0;
      if (this.enabled) {
         t = this.weight;
         const i = this._weightInterpolant;
         if (i !== null) {
            const s = i.evaluate(e)[0];
            t *= s, e > i.parameterPositions[1] && (this.stopFading(), s === 0 && (this.enabled = !1))
         }
      }
      return this._effectiveWeight = t, t
   }
   _updateTimeScale(e) {
      let t = 0;
      if (!this.paused) {
         t = this.timeScale;
         const i = this._timeScaleInterpolant;
         if (i !== null) {
            const s = i.evaluate(e)[0];
            t *= s, e > i.parameterPositions[1] && (this.stopWarping(), t === 0 ? this.paused = !0 : this.timeScale = t)
         }
      }
      return this._effectiveTimeScale = t, t
   }
   _updateTime(e) {
      const t = this._clip.duration,
         i = this.loop;
      let s = this.time + e,
         r = this._loopCount;
      const a = i === hL;
      if (e === 0) return r === -1 ? s : a && (r & 1) === 1 ? t - s : s;
      if (i === cL) {
         r === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
         e: {
            if (s >= t) s = t;
            else if (s < 0) s = 0;
            else {
               this.time = s;
               break e
            }
            this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
            this.time = s,
            this._mixer.dispatchEvent({
               type: "finished",
               action: this,
               direction: e < 0 ? -1 : 1
            })
         }
      } else {
         if (r === -1 && (e >= 0 ? (r = 0, this._setEndings(!0, this.repetitions === 0, a)) : this._setEndings(this.repetitions === 0, !0, a)), s >= t || s < 0) {
            const l = Math.floor(s / t);
            s -= t * l, r += Math.abs(l);
            const c = this.repetitions - r;
            if (c <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, s = e > 0 ? t : 0, this.time = s, this._mixer.dispatchEvent({
               type: "finished",
               action: this,
               direction: e > 0 ? 1 : -1
            });
            else {
               if (c === 1) {
                  const h = e < 0;
                  this._setEndings(h, !h, a)
               } else this._setEndings(!1, !1, a);
               this._loopCount = r, this.time = s, this._mixer.dispatchEvent({
                  type: "loop",
                  action: this,
                  loopDelta: l
               })
            }
         } else this.time = s;
         if (a && (r & 1) === 1) return t - s
      }
      return s
   }
   _setEndings(e, t, i) {
      const s = this._interpolantSettings;
      i ? (s.endingStart = Nd, s.endingEnd = Nd) : (e ? s.endingStart = this.zeroSlopeAtStart ? Nd : Dd : s.endingStart = Ry, t ? s.endingEnd = this.zeroSlopeAtEnd ? Nd : Dd : s.endingEnd = Ry)
   }
   _scheduleFading(e, t, i) {
      const s = this._mixer,
         r = s.time;
      let a = this._weightInterpolant;
      a === null && (a = s._lendControlInterpolant(), this._weightInterpolant = a);
      const l = a.parameterPositions,
         c = a.sampleValues;
      return l[0] = r, c[0] = t, l[1] = r + e, c[1] = i, this
   }
}
const Tk = new Float32Array(1);
class Ek extends xo {
   constructor(e) {
      super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
   }
   _bindAction(e, t) {
      const i = e._localRoot || this._root,
         s = e._clip.tracks,
         r = s.length,
         a = e._propertyBindings,
         l = e._interpolants,
         c = i.uuid,
         h = this._bindingsByRootAndName;
      let m = h[c];
      m === void 0 && (m = {}, h[c] = m);
      for (let g = 0; g !== r; ++g) {
         const v = s[g],
            x = v.name;
         let S = m[x];
         if (S !== void 0) ++S.referenceCount, a[g] = S;
         else {
            if (S = a[g], S !== void 0) {
               S._cacheIndex === null && (++S.referenceCount, this._addInactiveBinding(S, c, x));
               continue
            }
            const E = t && t._propertyBindings[g].binding.parsedPath;
            S = new bB(Xn.create(i, x, E), v.ValueTypeName, v.getValueSize()), ++S.referenceCount, this._addInactiveBinding(S, c, x), a[g] = S
         }
         l[g].resultBuffer = S.buffer
      }
   }
   _activateAction(e) {
      if (!this._isActiveAction(e)) {
         if (e._cacheIndex === null) {
            const i = (e._localRoot || this._root).uuid,
               s = e._clip.uuid,
               r = this._actionsByClip[s];
            this._bindAction(e, r && r.knownActions[0]), this._addInactiveAction(e, s, i)
         }
         const t = e._propertyBindings;
         for (let i = 0, s = t.length; i !== s; ++i) {
            const r = t[i];
            r.useCount++ === 0 && (this._lendBinding(r), r.saveOriginalState())
         }
         this._lendAction(e)
      }
   }
   _deactivateAction(e) {
      if (this._isActiveAction(e)) {
         const t = e._propertyBindings;
         for (let i = 0, s = t.length; i !== s; ++i) {
            const r = t[i];
            --r.useCount === 0 && (r.restoreOriginalState(), this._takeBackBinding(r))
         }
         this._takeBackAction(e)
      }
   }
   _initMemoryManager() {
      this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
      const e = this;
      this.stats = {
         actions: {
            get total() {
               return e._actions.length
            },
            get inUse() {
               return e._nActiveActions
            }
         },
         bindings: {
            get total() {
               return e._bindings.length
            },
            get inUse() {
               return e._nActiveBindings
            }
         },
         controlInterpolants: {
            get total() {
               return e._controlInterpolants.length
            },
            get inUse() {
               return e._nActiveControlInterpolants
            }
         }
      }
   }
   _isActiveAction(e) {
      const t = e._cacheIndex;
      return t !== null && t < this._nActiveActions
   }
   _addInactiveAction(e, t, i) {
      const s = this._actions,
         r = this._actionsByClip;
      let a = r[t];
      if (a === void 0) a = {
         knownActions: [e],
         actionByRoot: {}
      }, e._byClipCacheIndex = 0, r[t] = a;
      else {
         const l = a.knownActions;
         e._byClipCacheIndex = l.length, l.push(e)
      }
      e._cacheIndex = s.length, s.push(e), a.actionByRoot[i] = e
   }
   _removeInactiveAction(e) {
      const t = this._actions,
         i = t[t.length - 1],
         s = e._cacheIndex;
      i._cacheIndex = s, t[s] = i, t.pop(), e._cacheIndex = null;
      const r = e._clip.uuid,
         a = this._actionsByClip,
         l = a[r],
         c = l.knownActions,
         h = c[c.length - 1],
         m = e._byClipCacheIndex;
      h._byClipCacheIndex = m, c[m] = h, c.pop(), e._byClipCacheIndex = null;
      const g = l.actionByRoot,
         v = (e._localRoot || this._root).uuid;
      delete g[v], c.length === 0 && delete a[r], this._removeInactiveBindingsForAction(e)
   }
   _removeInactiveBindingsForAction(e) {
      const t = e._propertyBindings;
      for (let i = 0, s = t.length; i !== s; ++i) {
         const r = t[i];
         --r.referenceCount === 0 && this._removeInactiveBinding(r)
      }
   }
   _lendAction(e) {
      const t = this._actions,
         i = e._cacheIndex,
         s = this._nActiveActions++,
         r = t[s];
      e._cacheIndex = s, t[s] = e, r._cacheIndex = i, t[i] = r
   }
   _takeBackAction(e) {
      const t = this._actions,
         i = e._cacheIndex,
         s = --this._nActiveActions,
         r = t[s];
      e._cacheIndex = s, t[s] = e, r._cacheIndex = i, t[i] = r
   }
   _addInactiveBinding(e, t, i) {
      const s = this._bindingsByRootAndName,
         r = this._bindings;
      let a = s[t];
      a === void 0 && (a = {}, s[t] = a), a[i] = e, e._cacheIndex = r.length, r.push(e)
   }
   _removeInactiveBinding(e) {
      const t = this._bindings,
         i = e.binding,
         s = i.rootNode.uuid,
         r = i.path,
         a = this._bindingsByRootAndName,
         l = a[s],
         c = t[t.length - 1],
         h = e._cacheIndex;
      c._cacheIndex = h, t[h] = c, t.pop(), delete l[r], Object.keys(l).length === 0 && delete a[s]
   }
   _lendBinding(e) {
      const t = this._bindings,
         i = e._cacheIndex,
         s = this._nActiveBindings++,
         r = t[s];
      e._cacheIndex = s, t[s] = e, r._cacheIndex = i, t[i] = r
   }
   _takeBackBinding(e) {
      const t = this._bindings,
         i = e._cacheIndex,
         s = --this._nActiveBindings,
         r = t[s];
      e._cacheIndex = s, t[s] = e, r._cacheIndex = i, t[i] = r
   }
   _lendControlInterpolant() {
      const e = this._controlInterpolants,
         t = this._nActiveControlInterpolants++;
      let i = e[t];
      return i === void 0 && (i = new WR(new Float32Array(2), new Float32Array(2), 1, Tk), i.__cacheIndex = t, e[t] = i), i
   }
   _takeBackControlInterpolant(e) {
      const t = this._controlInterpolants,
         i = e.__cacheIndex,
         s = --this._nActiveControlInterpolants,
         r = t[s];
      e.__cacheIndex = s, t[s] = e, r.__cacheIndex = i, t[i] = r
   }
   clipAction(e, t, i) {
      const s = t || this._root,
         r = s.uuid;
      let a = typeof e == "string" ? Fy.findByName(s, e) : e;
      const l = a !== null ? a.uuid : e,
         c = this._actionsByClip[l];
      let h = null;
      if (i === void 0 && (a !== null ? i = a.blendMode : i = lT), c !== void 0) {
         const g = c.actionByRoot[r];
         if (g !== void 0 && g.blendMode === i) return g;
         h = c.knownActions[0], a === null && (a = h._clip)
      }
      if (a === null) return null;
      const m = new TB(this, a, t, i);
      return this._bindAction(m, h), this._addInactiveAction(m, l, r), m
   }
   existingAction(e, t) {
      const i = t || this._root,
         s = i.uuid,
         r = typeof e == "string" ? Fy.findByName(i, e) : e,
         a = r ? r.uuid : e,
         l = this._actionsByClip[a];
      return l !== void 0 && l.actionByRoot[s] || null
   }
   stopAllAction() {
      const e = this._actions,
         t = this._nActiveActions;
      for (let i = t - 1; i >= 0; --i) e[i].stop();
      return this
   }
   update(e) {
      e *= this.timeScale;
      const t = this._actions,
         i = this._nActiveActions,
         s = this.time += e,
         r = Math.sign(e),
         a = this._accuIndex ^= 1;
      for (let h = 0; h !== i; ++h) t[h]._update(s, e, r, a);
      const l = this._bindings,
         c = this._nActiveBindings;
      for (let h = 0; h !== c; ++h) l[h].apply(a);
      return this
   }
   setTime(e) {
      this.time = 0;
      for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
      return this.update(e)
   }
   getRoot() {
      return this._root
   }
   uncacheClip(e) {
      const t = this._actions,
         i = e.uuid,
         s = this._actionsByClip,
         r = s[i];
      if (r !== void 0) {
         const a = r.knownActions;
         for (let l = 0, c = a.length; l !== c; ++l) {
            const h = a[l];
            this._deactivateAction(h);
            const m = h._cacheIndex,
               g = t[t.length - 1];
            h._cacheIndex = null, h._byClipCacheIndex = null, g._cacheIndex = m, t[m] = g, t.pop(), this._removeInactiveBindingsForAction(h)
         }
         delete s[i]
      }
   }
   uncacheRoot(e) {
      const t = e.uuid,
         i = this._actionsByClip;
      for (const a in i) {
         const l = i[a].actionByRoot,
            c = l[t];
         c !== void 0 && (this._deactivateAction(c), this._removeInactiveAction(c))
      }
      const s = this._bindingsByRootAndName,
         r = s[t];
      if (r !== void 0)
         for (const a in r) {
            const l = r[a];
            l.restoreOriginalState(), this._removeInactiveBinding(l)
         }
   }
   uncacheAction(e, t) {
      const i = this.existingAction(e, t);
      i !== null && (this._deactivateAction(i), this._removeInactiveAction(i))
   }
}
class Mk extends uT {
   constructor(e = 1, t = 1, i = 1, s = {}) {
      super(e, t, s), this.isRenderTarget3D = !0, this.depth = i, this.texture = new cT(null, e, t, i), this.texture.isRenderTargetTexture = !0
   }
}
class Ak extends uT {
   constructor(e = 1, t = 1, i = 1, s = {}) {
      super(e, t, s), this.isRenderTargetArray = !0, this.depth = i, this.texture = new dx(null, e, t, i), this.texture.isRenderTargetTexture = !0
   }
}
class nn {
   constructor(e) {
      this.value = e
   }
   clone() {
      return new nn(this.value.clone === void 0 ? this.value : this.value.clone())
   }
}
let wk = 0;
class Rk extends xo {
   constructor() {
      super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", {
         value: wk++
      }), this.name = "", this.usage = Dy, this.uniforms = []
   }
   add(e) {
      return this.uniforms.push(e), this
   }
   remove(e) {
      const t = this.uniforms.indexOf(e);
      return t !== -1 && this.uniforms.splice(t, 1), this
   }
   setName(e) {
      return this.name = e, this
   }
   setUsage(e) {
      return this.usage = e, this
   }
   dispose() {
      this.dispatchEvent({
         type: "dispose"
      })
   }
   copy(e) {
      this.name = e.name, this.usage = e.usage;
      const t = e.uniforms;
      this.uniforms.length = 0;
      for (let i = 0, s = t.length; i < s; i++) {
         const r = Array.isArray(t[i]) ? t[i] : [t[i]];
         for (let a = 0; a < r.length; a++) this.uniforms.push(r[a].clone())
      }
      return this
   }
   clone() {
      return new this.constructor().copy(this)
   }
}
class Ck extends dT {
   constructor(e, t, i = 1) {
      super(e, t), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = i
   }
   copy(e) {
      return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this
   }
   clone(e) {
      const t = super.clone(e);
      return t.meshPerAttribute = this.meshPerAttribute, t
   }
   toJSON(e) {
      const t = super.toJSON(e);
      return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t
   }
}
class Dk {
   constructor(e, t, i, s, r) {
      this.isGLBufferAttribute = !0, this.name = "", this.buffer = e, this.type = t, this.itemSize = i, this.elementSize = s, this.count = r, this.version = 0
   }
   set needsUpdate(e) {
      e === !0 && this.version++
   }
   setBuffer(e) {
      return this.buffer = e, this
   }
   setType(e, t) {
      return this.type = e, this.elementSize = t, this
   }
   setItemSize(e) {
      return this.itemSize = e, this
   }
   setCount(e) {
      return this.count = e, this
   }
}
const _3 = new Zt;
class EB {
   constructor(e, t, i = 0, s = 1 / 0) {
      this.ray = new Pg(e, t), this.near = i, this.far = s, this.camera = null, this.layers = new dg, this.params = {
         Mesh: {},
         Line: {
            threshold: 1
         },
         LOD: {},
         Points: {
            threshold: 1
         },
         Sprite: {}
      }
   }
   set(e, t) {
      this.ray.set(e, t)
   }
   setFromCamera(e, t) {
      t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type)
   }
   setFromXRController(e) {
      return _3.identity().extractRotation(e.matrixWorld), this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(_3), this
   }
   intersectObject(e, t = !0, i = []) {
      return JA(e, this, i, t), i.sort(S3), i
   }
   intersectObjects(e, t = !0, i = []) {
      for (let s = 0, r = e.length; s < r; s++) JA(e[s], this, i, t);
      return i.sort(S3), i
   }
}

function S3(n, e) {
   return n.distance - e.distance
}

function JA(n, e, t, i) {
   let s = !0;
   if (n.layers.test(e.layers) && n.raycast(e, t) === !1 && (s = !1), s === !0 && i === !0) {
      const r = n.children;
      for (let a = 0, l = r.length; a < l; a++) JA(r[a], e, t, !0)
   }
}
class Nk {
   constructor(e = 1, t = 0, i = 0) {
      this.radius = e, this.phi = t, this.theta = i
   }
   set(e, t, i) {
      return this.radius = e, this.phi = t, this.theta = i, this
   }
   copy(e) {
      return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this
   }
   makeSafe() {
      return this.phi = on(this.phi, 1e-6, Math.PI - 1e-6), this
   }
   setFromVector3(e) {
      return this.setFromCartesianCoords(e.x, e.y, e.z)
   }
   setFromCartesianCoords(e, t, i) {
      return this.radius = Math.sqrt(e * e + t * t + i * i), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, i), this.phi = Math.acos(on(t / this.radius, -1, 1))), this
   }
   clone() {
      return new this.constructor().copy(this)
   }
}
class Ok {
   constructor(e = 1, t = 0, i = 0) {
      this.radius = e, this.theta = t, this.y = i
   }
   set(e, t, i) {
      return this.radius = e, this.theta = t, this.y = i, this
   }
   copy(e) {
      return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this
   }
   setFromVector3(e) {
      return this.setFromCartesianCoords(e.x, e.y, e.z)
   }
   setFromCartesianCoords(e, t, i) {
      return this.radius = Math.sqrt(e * e + i * i), this.theta = Math.atan2(e, i), this.y = t, this
   }
   clone() {
      return new this.constructor().copy(this)
   }
}
class n2 {
   constructor(e, t, i, s) {
      n2.prototype.isMatrix2 = !0, this.elements = [1, 0, 0, 1], e !== void 0 && this.set(e, t, i, s)
   }
   identity() {
      return this.set(1, 0, 0, 1), this
   }
   fromArray(e, t = 0) {
      for (let i = 0; i < 4; i++) this.elements[i] = e[i + t];
      return this
   }
   set(e, t, i, s) {
      const r = this.elements;
      return r[0] = e, r[2] = t, r[1] = i, r[3] = s, this
   }
}
const b3 = new Fe;
class Uk {
   constructor(e = new Fe(1 / 0, 1 / 0), t = new Fe(-1 / 0, -1 / 0)) {
      this.isBox2 = !0, this.min = e, this.max = t
   }
   set(e, t) {
      return this.min.copy(e), this.max.copy(t), this
   }
   setFromPoints(e) {
      this.makeEmpty();
      for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
      return this
   }
   setFromCenterAndSize(e, t) {
      const i = b3.copy(t).multiplyScalar(.5);
      return this.min.copy(e).sub(i), this.max.copy(e).add(i), this
   }
   clone() {
      return new this.constructor().copy(this)
   }
   copy(e) {
      return this.min.copy(e.min), this.max.copy(e.max), this
   }
   makeEmpty() {
      return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
   }
   isEmpty() {
      return this.max.x < this.min.x || this.max.y < this.min.y
   }
   getCenter(e) {
      return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
   }
   getSize(e) {
      return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
   }
   expandByPoint(e) {
      return this.min.min(e), this.max.max(e), this
   }
   expandByVector(e) {
      return this.min.sub(e), this.max.add(e), this
   }
   expandByScalar(e) {
      return this.min.addScalar(-e), this.max.addScalar(e), this
   }
   containsPoint(e) {
      return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y
   }
   containsBox(e) {
      return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
   }
   getParameter(e, t) {
      return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
   }
   intersectsBox(e) {
      return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y
   }
   clampPoint(e, t) {
      return t.copy(e).clamp(this.min, this.max)
   }
   distanceToPoint(e) {
      return this.clampPoint(e, b3).distanceTo(e)
   }
   intersect(e) {
      return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
   }
   union(e) {
      return this.min.min(e.min), this.max.max(e.max), this
   }
   translate(e) {
      return this.min.add(e), this.max.add(e), this
   }
   equals(e) {
      return e.min.equals(this.min) && e.max.equals(this.max)
   }
}
const T3 = new ee,
   GS = new ee;
class Pk {
   constructor(e = new ee, t = new ee) {
      this.start = e, this.end = t
   }
   set(e, t) {
      return this.start.copy(e), this.end.copy(t), this
   }
   copy(e) {
      return this.start.copy(e.start), this.end.copy(e.end), this
   }
   getCenter(e) {
      return e.addVectors(this.start, this.end).multiplyScalar(.5)
   }
   delta(e) {
      return e.subVectors(this.end, this.start)
   }
   distanceSq() {
      return this.start.distanceToSquared(this.end)
   }
   distance() {
      return this.start.distanceTo(this.end)
   }
   at(e, t) {
      return this.delta(t).multiplyScalar(e).add(this.start)
   }
   closestPointToPointParameter(e, t) {
      T3.subVectors(e, this.start), GS.subVectors(this.end, this.start);
      const i = GS.dot(GS);
      let r = GS.dot(T3) / i;
      return t && (r = on(r, 0, 1)), r
   }
   closestPointToPoint(e, t, i) {
      const s = this.closestPointToPointParameter(e, t);
      return this.delta(i).multiplyScalar(s).add(this.start)
   }
   applyMatrix4(e) {
      return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this
   }
   equals(e) {
      return e.start.equals(this.start) && e.end.equals(this.end)
   }
   clone() {
      return new this.constructor().copy(this)
   }
}
const E3 = new ee;
class Lk extends Wn {
   constructor(e, t) {
      super(), this.light = e, this.matrixAutoUpdate = !1, this.color = t, this.type = "SpotLightHelper";
      const i = new pn,
         s = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
      for (let a = 0, l = 1, c = 32; a < c; a++, l++) {
         const h = a / c * Math.PI * 2,
            m = l / c * Math.PI * 2;
         s.push(Math.cos(h), Math.sin(h), 1, Math.cos(m), Math.sin(m), 1)
      }
      i.setAttribute("position", new Ct(s, 3));
      const r = new ma({
         fog: !1,
         toneMapped: !1
      });
      this.cone = new qu(i, r), this.add(this.cone), this.update()
   }
   dispose() {
      this.cone.geometry.dispose(), this.cone.material.dispose()
   }
   update() {
      this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), this.parent ? (this.parent.updateWorldMatrix(!0), this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)) : this.matrix.copy(this.light.matrixWorld), this.matrixWorld.copy(this.light.matrixWorld);
      const e = this.light.distance ? this.light.distance : 1e3,
         t = e * Math.tan(this.light.angle);
      this.cone.scale.set(t, t, e), E3.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(E3), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
   }
}
const If = new ee,
   kS = new Zt,
   wM = new Zt;
class Bk extends qu {
   constructor(e) {
      const t = MB(e),
         i = new pn,
         s = [],
         r = [],
         a = new dt(0, 0, 1),
         l = new dt(0, 1, 0);
      for (let h = 0; h < t.length; h++) {
         const m = t[h];
         m.parent && m.parent.isBone && (s.push(0, 0, 0), s.push(0, 0, 0), r.push(a.r, a.g, a.b), r.push(l.r, l.g, l.b))
      }
      i.setAttribute("position", new Ct(s, 3)), i.setAttribute("color", new Ct(r, 3));
      const c = new ma({
         vertexColors: !0,
         depthTest: !1,
         depthWrite: !1,
         toneMapped: !1,
         transparent: !0
      });
      super(i, c), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1
   }
   updateMatrixWorld(e) {
      const t = this.bones,
         i = this.geometry,
         s = i.getAttribute("position");
      wM.copy(this.root.matrixWorld).invert();
      for (let r = 0, a = 0; r < t.length; r++) {
         const l = t[r];
         l.parent && l.parent.isBone && (kS.multiplyMatrices(wM, l.matrixWorld), If.setFromMatrixPosition(kS), s.setXYZ(a, If.x, If.y, If.z), kS.multiplyMatrices(wM, l.parent.matrixWorld), If.setFromMatrixPosition(kS), s.setXYZ(a + 1, If.x, If.y, If.z), a += 2)
      }
      i.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e)
   }
   dispose() {
      this.geometry.dispose(), this.material.dispose()
   }
}

function MB(n) {
   const e = [];
   n.isBone === !0 && e.push(n);
   for (let t = 0; t < n.children.length; t++) e.push(...MB(n.children[t]));
   return e
}
class zk extends ds {
   constructor(e, t, i) {
      const s = new cp(t, 4, 2),
         r = new Fc({
            wireframe: !0,
            fog: !1,
            toneMapped: !1
         });
      super(s, r), this.light = e, this.color = i, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
   }
   dispose() {
      this.geometry.dispose(), this.material.dispose()
   }
   update() {
      this.light.updateWorldMatrix(!0, !1), this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
   }
}
const Ik = new ee,
   M3 = new dt,
   A3 = new dt;
class Fk extends Wn {
   constructor(e, t, i) {
      super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, this.type = "HemisphereLightHelper";
      const s = new xx(t);
      s.rotateY(Math.PI * .5), this.material = new Fc({
         wireframe: !0,
         fog: !1,
         toneMapped: !1
      }), this.color === void 0 && (this.material.vertexColors = !0);
      const r = s.getAttribute("position"),
         a = new Float32Array(r.count * 3);
      s.setAttribute("color", new oi(a, 3)), this.add(new ds(s, this.material)), this.update()
   }
   dispose() {
      this.children[0].geometry.dispose(), this.children[0].material.dispose()
   }
   update() {
      const e = this.children[0];
      if (this.color !== void 0) this.material.color.set(this.color);
      else {
         const t = e.geometry.getAttribute("color");
         M3.copy(this.light.color), A3.copy(this.light.groundColor);
         for (let i = 0, s = t.count; i < s; i++) {
            const r = i < s / 2 ? M3 : A3;
            t.setXYZ(i, r.r, r.g, r.b)
         }
         t.needsUpdate = !0
      }
      this.light.updateWorldMatrix(!0, !1), e.lookAt(Ik.setFromMatrixPosition(this.light.matrixWorld).negate())
   }
}
class Hk extends qu {
   constructor(e = 10, t = 10, i = 4473924, s = 8947848) {
      i = new dt(i), s = new dt(s);
      const r = t / 2,
         a = e / t,
         l = e / 2,
         c = [],
         h = [];
      for (let v = 0, x = 0, S = -l; v <= t; v++, S += a) {
         c.push(-l, 0, S, l, 0, S), c.push(S, 0, -l, S, 0, l);
         const E = v === r ? i : s;
         E.toArray(h, x), x += 3, E.toArray(h, x), x += 3, E.toArray(h, x), x += 3, E.toArray(h, x), x += 3
      }
      const m = new pn;
      m.setAttribute("position", new Ct(c, 3)), m.setAttribute("color", new Ct(h, 3));
      const g = new ma({
         vertexColors: !0,
         toneMapped: !1
      });
      super(m, g), this.type = "GridHelper"
   }
   dispose() {
      this.geometry.dispose(), this.material.dispose()
   }
}
class Vk extends qu {
   constructor(e = 10, t = 16, i = 8, s = 64, r = 4473924, a = 8947848) {
      r = new dt(r), a = new dt(a);
      const l = [],
         c = [];
      if (t > 1)
         for (let g = 0; g < t; g++) {
            const v = g / t * (Math.PI * 2),
               x = Math.sin(v) * e,
               S = Math.cos(v) * e;
            l.push(0, 0, 0), l.push(x, 0, S);
            const E = g & 1 ? r : a;
            c.push(E.r, E.g, E.b), c.push(E.r, E.g, E.b)
         }
      for (let g = 0; g < i; g++) {
         const v = g & 1 ? r : a,
            x = e - e / i * g;
         for (let S = 0; S < s; S++) {
            let E = S / s * (Math.PI * 2),
               T = Math.sin(E) * x,
               b = Math.cos(E) * x;
            l.push(T, 0, b), c.push(v.r, v.g, v.b), E = (S + 1) / s * (Math.PI * 2), T = Math.sin(E) * x, b = Math.cos(E) * x, l.push(T, 0, b), c.push(v.r, v.g, v.b)
         }
      }
      const h = new pn;
      h.setAttribute("position", new Ct(l, 3)), h.setAttribute("color", new Ct(c, 3));
      const m = new ma({
         vertexColors: !0,
         toneMapped: !1
      });
      super(h, m), this.type = "PolarGridHelper"
   }
   dispose() {
      this.geometry.dispose(), this.material.dispose()
   }
}
const w3 = new ee,
   jS = new ee,
   R3 = new ee;
class Gk extends Wn {
   constructor(e, t, i) {
      super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, this.type = "DirectionalLightHelper", t === void 0 && (t = 1);
      let s = new pn;
      s.setAttribute("position", new Ct([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3));
      const r = new ma({
         fog: !1,
         toneMapped: !1
      });
      this.lightPlane = new rh(s, r), this.add(this.lightPlane), s = new pn, s.setAttribute("position", new Ct([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new rh(s, r), this.add(this.targetLine), this.update()
   }
   dispose() {
      this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
   }
   update() {
      this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), w3.setFromMatrixPosition(this.light.matrixWorld), jS.setFromMatrixPosition(this.light.target.matrixWorld), R3.subVectors(jS, w3), this.lightPlane.lookAt(jS), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(jS), this.targetLine.scale.z = R3.length()
   }
}
const qS = new ee,
   ts = new px;
class kk extends qu {
   constructor(e) {
      const t = new pn,
         i = new ma({
            color: 16777215,
            vertexColors: !0,
            toneMapped: !1
         }),
         s = [],
         r = [],
         a = {};
      l("n1", "n2"), l("n2", "n4"), l("n4", "n3"), l("n3", "n1"), l("f1", "f2"), l("f2", "f4"), l("f4", "f3"), l("f3", "f1"), l("n1", "f1"), l("n2", "f2"), l("n3", "f3"), l("n4", "f4"), l("p", "n1"), l("p", "n2"), l("p", "n3"), l("p", "n4"), l("u1", "u2"), l("u2", "u3"), l("u3", "u1"), l("c", "t"), l("p", "c"), l("cn1", "cn2"), l("cn3", "cn4"), l("cf1", "cf2"), l("cf3", "cf4");

      function l(S, E) {
         c(S), c(E)
      }

      function c(S) {
         s.push(0, 0, 0), r.push(0, 0, 0), a[S] === void 0 && (a[S] = []), a[S].push(s.length / 3 - 1)
      }
      t.setAttribute("position", new Ct(s, 3)), t.setAttribute("color", new Ct(r, 3)), super(t, i), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = a, this.update();
      const h = new dt(16755200),
         m = new dt(16711680),
         g = new dt(43775),
         v = new dt(16777215),
         x = new dt(3355443);
      this.setColors(h, m, g, v, x)
   }
   setColors(e, t, i, s, r) {
      const l = this.geometry.getAttribute("color");
      l.setXYZ(0, e.r, e.g, e.b), l.setXYZ(1, e.r, e.g, e.b), l.setXYZ(2, e.r, e.g, e.b), l.setXYZ(3, e.r, e.g, e.b), l.setXYZ(4, e.r, e.g, e.b), l.setXYZ(5, e.r, e.g, e.b), l.setXYZ(6, e.r, e.g, e.b), l.setXYZ(7, e.r, e.g, e.b), l.setXYZ(8, e.r, e.g, e.b), l.setXYZ(9, e.r, e.g, e.b), l.setXYZ(10, e.r, e.g, e.b), l.setXYZ(11, e.r, e.g, e.b), l.setXYZ(12, e.r, e.g, e.b), l.setXYZ(13, e.r, e.g, e.b), l.setXYZ(14, e.r, e.g, e.b), l.setXYZ(15, e.r, e.g, e.b), l.setXYZ(16, e.r, e.g, e.b), l.setXYZ(17, e.r, e.g, e.b), l.setXYZ(18, e.r, e.g, e.b), l.setXYZ(19, e.r, e.g, e.b), l.setXYZ(20, e.r, e.g, e.b), l.setXYZ(21, e.r, e.g, e.b), l.setXYZ(22, e.r, e.g, e.b), l.setXYZ(23, e.r, e.g, e.b), l.setXYZ(24, t.r, t.g, t.b), l.setXYZ(25, t.r, t.g, t.b), l.setXYZ(26, t.r, t.g, t.b), l.setXYZ(27, t.r, t.g, t.b), l.setXYZ(28, t.r, t.g, t.b), l.setXYZ(29, t.r, t.g, t.b), l.setXYZ(30, t.r, t.g, t.b), l.setXYZ(31, t.r, t.g, t.b), l.setXYZ(32, i.r, i.g, i.b), l.setXYZ(33, i.r, i.g, i.b), l.setXYZ(34, i.r, i.g, i.b), l.setXYZ(35, i.r, i.g, i.b), l.setXYZ(36, i.r, i.g, i.b), l.setXYZ(37, i.r, i.g, i.b), l.setXYZ(38, s.r, s.g, s.b), l.setXYZ(39, s.r, s.g, s.b), l.setXYZ(40, r.r, r.g, r.b), l.setXYZ(41, r.r, r.g, r.b), l.setXYZ(42, r.r, r.g, r.b), l.setXYZ(43, r.r, r.g, r.b), l.setXYZ(44, r.r, r.g, r.b), l.setXYZ(45, r.r, r.g, r.b), l.setXYZ(46, r.r, r.g, r.b), l.setXYZ(47, r.r, r.g, r.b), l.setXYZ(48, r.r, r.g, r.b), l.setXYZ(49, r.r, r.g, r.b), l.needsUpdate = !0
   }
   update() {
      const e = this.geometry,
         t = this.pointMap,
         i = 1,
         s = 1;
      ts.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);
      const r = this.camera.coordinateSystem === zl ? -1 : 0;
      cs("c", t, e, ts, 0, 0, r), cs("t", t, e, ts, 0, 0, 1), cs("n1", t, e, ts, -1, -1, r), cs("n2", t, e, ts, i, -1, r), cs("n3", t, e, ts, -1, s, r), cs("n4", t, e, ts, i, s, r), cs("f1", t, e, ts, -1, -1, 1), cs("f2", t, e, ts, i, -1, 1), cs("f3", t, e, ts, -1, s, 1), cs("f4", t, e, ts, i, s, 1), cs("u1", t, e, ts, i * .7, s * 1.1, r), cs("u2", t, e, ts, -1 * .7, s * 1.1, r), cs("u3", t, e, ts, 0, s * 2, r), cs("cf1", t, e, ts, -1, 0, 1), cs("cf2", t, e, ts, i, 0, 1), cs("cf3", t, e, ts, 0, -1, 1), cs("cf4", t, e, ts, 0, s, 1), cs("cn1", t, e, ts, -1, 0, r), cs("cn2", t, e, ts, i, 0, r), cs("cn3", t, e, ts, 0, -1, r), cs("cn4", t, e, ts, 0, s, r), e.getAttribute("position").needsUpdate = !0
   }
   dispose() {
      this.geometry.dispose(), this.material.dispose()
   }
}

function cs(n, e, t, i, s, r, a) {
   qS.set(s, r, a).unproject(i);
   const l = e[n];
   if (l !== void 0) {
      const c = t.getAttribute("position");
      for (let h = 0, m = l.length; h < m; h++) c.setXYZ(l[h], qS.x, qS.y, qS.z)
   }
}
const XS = new pa;
class jk extends qu {
   constructor(e, t = 16776960) {
      const i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
         s = new Float32Array(8 * 3),
         r = new pn;
      r.setIndex(new oi(i, 1)), r.setAttribute("position", new oi(s, 3)), super(r, new ma({
         color: t,
         toneMapped: !1
      })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update()
   }
   update() {
      if (this.object !== void 0 && XS.setFromObject(this.object), XS.isEmpty()) return;
      const e = XS.min,
         t = XS.max,
         i = this.geometry.attributes.position,
         s = i.array;
      s[0] = t.x, s[1] = t.y, s[2] = t.z, s[3] = e.x, s[4] = t.y, s[5] = t.z, s[6] = e.x, s[7] = e.y, s[8] = t.z, s[9] = t.x, s[10] = e.y, s[11] = t.z, s[12] = t.x, s[13] = t.y, s[14] = e.z, s[15] = e.x, s[16] = t.y, s[17] = e.z, s[18] = e.x, s[19] = e.y, s[20] = e.z, s[21] = t.x, s[22] = e.y, s[23] = e.z, i.needsUpdate = !0, this.geometry.computeBoundingSphere()
   }
   setFromObject(e) {
      return this.object = e, this.update(), this
   }
   copy(e, t) {
      return super.copy(e, t), this.object = e.object, this
   }
   dispose() {
      this.geometry.dispose(), this.material.dispose()
   }
}
class qk extends qu {
   constructor(e, t = 16776960) {
      const i = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
         s = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1],
         r = new pn;
      r.setIndex(new oi(i, 1)), r.setAttribute("position", new Ct(s, 3)), super(r, new ma({
         color: t,
         toneMapped: !1
      })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere()
   }
   updateMatrixWorld(e) {
      const t = this.box;
      t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(.5), super.updateMatrixWorld(e))
   }
   dispose() {
      this.geometry.dispose(), this.material.dispose()
   }
}
class Xk extends rh {
   constructor(e, t = 1, i = 16776960) {
      const s = i,
         r = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0],
         a = new pn;
      a.setAttribute("position", new Ct(r, 3)), a.computeBoundingSphere(), super(a, new ma({
         color: s,
         toneMapped: !1
      })), this.type = "PlaneHelper", this.plane = e, this.size = t;
      const l = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],
         c = new pn;
      c.setAttribute("position", new Ct(l, 3)), c.computeBoundingSphere(), this.add(new ds(c, new Fc({
         color: s,
         opacity: .2,
         transparent: !0,
         depthWrite: !1,
         toneMapped: !1
      })))
   }
   updateMatrixWorld(e) {
      this.position.set(0, 0, 0), this.scale.set(.5 * this.size, .5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(e)
   }
   dispose() {
      this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose()
   }
}
const C3 = new ee;
let WS, RM;
class Wk extends Wn {
   constructor(e = new ee(0, 0, 1), t = new ee(0, 0, 0), i = 1, s = 16776960, r = i * .2, a = r * .2) {
      super(), this.type = "ArrowHelper", WS === void 0 && (WS = new pn, WS.setAttribute("position", new Ct([0, 0, 0, 0, 1, 0], 3)), RM = new Lg(0, .5, 1, 5, 1), RM.translate(0, -.5, 0)), this.position.copy(t), this.line = new rh(WS, new ma({
         color: s,
         toneMapped: !1
      })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new ds(RM, new Fc({
         color: s,
         toneMapped: !1
      })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(i, r, a)
   }
   setDirection(e) {
      if (e.y > .99999) this.quaternion.set(0, 0, 0, 1);
      else if (e.y < -.99999) this.quaternion.set(1, 0, 0, 0);
      else {
         C3.set(e.z, 0, -e.x).normalize();
         const t = Math.acos(e.y);
         this.quaternion.setFromAxisAngle(C3, t)
      }
   }
   setLength(e, t = e * .2, i = t * .2) {
      this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(i, t, i), this.cone.position.y = e, this.cone.updateMatrix()
   }
   setColor(e) {
      this.line.material.color.set(e), this.cone.material.color.set(e)
   }
   copy(e) {
      return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this
   }
   dispose() {
      this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose()
   }
}
class Yk extends qu {
   constructor(e = 1) {
      const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
         i = [1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1],
         s = new pn;
      s.setAttribute("position", new Ct(t, 3)), s.setAttribute("color", new Ct(i, 3));
      const r = new ma({
         vertexColors: !0,
         toneMapped: !1
      });
      super(s, r), this.type = "AxesHelper"
   }
   setColors(e, t, i) {
      const s = new dt,
         r = this.geometry.attributes.color.array;
      return s.set(e), s.toArray(r, 0), s.toArray(r, 3), s.set(t), s.toArray(r, 6), s.toArray(r, 9), s.set(i), s.toArray(r, 12), s.toArray(r, 15), this.geometry.attributes.color.needsUpdate = !0, this
   }
   dispose() {
      this.geometry.dispose(), this.material.dispose()
   }
}
class Kk {
   constructor() {
      this.type = "ShapePath", this.color = new dt, this.subPaths = [], this.currentPath = null
   }
   moveTo(e, t) {
      return this.currentPath = new Uy, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this
   }
   lineTo(e, t) {
      return this.currentPath.lineTo(e, t), this
   }
   quadraticCurveTo(e, t, i, s) {
      return this.currentPath.quadraticCurveTo(e, t, i, s), this
   }
   bezierCurveTo(e, t, i, s, r, a) {
      return this.currentPath.bezierCurveTo(e, t, i, s, r, a), this
   }
   splineThru(e) {
      return this.currentPath.splineThru(e), this
   }
   toShapes(e) {
      function t(b) {
         const w = [];
         for (let C = 0, N = b.length; C < N; C++) {
            const U = b[C],
               z = new Vd;
            z.curves = U.curves, w.push(z)
         }
         return w
      }

      function i(b, w) {
         const C = w.length;
         let N = !1;
         for (let U = C - 1, z = 0; z < C; U = z++) {
            let B = w[U],
               I = w[z],
               O = I.x - B.x,
               P = I.y - B.y;
            if (Math.abs(P) > Number.EPSILON) {
               if (P < 0 && (B = w[z], O = -O, I = w[U], P = -P), b.y < B.y || b.y > I.y) continue;
               if (b.y === B.y) {
                  if (b.x === B.x) return !0
               } else {
                  const q = P * (b.x - B.x) - O * (b.y - B.y);
                  if (q === 0) return !0;
                  if (q < 0) continue;
                  N = !N
               }
            } else {
               if (b.y !== B.y) continue;
               if (I.x <= b.x && b.x <= B.x || B.x <= b.x && b.x <= I.x) return !0
            }
         }
         return N
      }
      const s = Lu.isClockWise,
         r = this.subPaths;
      if (r.length === 0) return [];
      let a, l, c;
      const h = [];
      if (r.length === 1) return l = r[0], c = new Vd, c.curves = l.curves, h.push(c), h;
      let m = !s(r[0].getPoints());
      m = e ? !m : m;
      const g = [],
         v = [];
      let x = [],
         S = 0,
         E;
      v[S] = void 0, x[S] = [];
      for (let b = 0, w = r.length; b < w; b++) l = r[b], E = l.getPoints(), a = s(E), a = e ? !a : a, a ? (!m && v[S] && S++, v[S] = {
         s: new Vd,
         p: E
      }, v[S].s.curves = l.curves, m && S++, x[S] = []) : x[S].push({
         h: l,
         p: E[0]
      });
      if (!v[0]) return t(r);
      if (v.length > 1) {
         let b = !1,
            w = 0;
         for (let C = 0, N = v.length; C < N; C++) g[C] = [];
         for (let C = 0, N = v.length; C < N; C++) {
            const U = x[C];
            for (let z = 0; z < U.length; z++) {
               const B = U[z];
               let I = !0;
               for (let O = 0; O < v.length; O++) i(B.p, v[O].p) && (C !== O && w++, I ? (I = !1, g[O].push(B)) : b = !0);
               I && g[C].push(B)
            }
         }
         w > 0 && b === !1 && (x = g)
      }
      let T;
      for (let b = 0, w = v.length; b < w; b++) {
         c = v[b].s, h.push(c), T = x[b];
         for (let C = 0, N = T.length; C < N; C++) c.holes.push(T[C].h)
      }
      return h
   }
}
class Zk extends xo {
   constructor(e, t = null) {
      super(), this.object = e, this.domElement = t, this.enabled = !0, this.state = -1, this.keys = {}, this.mouseButtons = {
         LEFT: null,
         MIDDLE: null,
         RIGHT: null
      }, this.touches = {
         ONE: null,
         TWO: null
      }
   }
   connect(e) {
      if (e === void 0) {
         console.warn("THREE.Controls: connect() now requires an element.");
         return
      }
      this.domElement !== null && this.disconnect(), this.domElement = e
   }
   disconnect() {}
   dispose() {}
   update() {}
}

function Qk(n, e) {
   const t = n.image && n.image.width ? n.image.width / n.image.height : 1;
   return t > e ? (n.repeat.x = 1, n.repeat.y = t / e, n.offset.x = 0, n.offset.y = (1 - n.repeat.y) / 2) : (n.repeat.x = e / t, n.repeat.y = 1, n.offset.x = (1 - n.repeat.x) / 2, n.offset.y = 0), n
}

function Jk(n, e) {
   const t = n.image && n.image.width ? n.image.width / n.image.height : 1;
   return t > e ? (n.repeat.x = e / t, n.repeat.y = 1, n.offset.x = (1 - n.repeat.x) / 2, n.offset.y = 0) : (n.repeat.x = 1, n.repeat.y = t / e, n.offset.x = 0, n.offset.y = (1 - n.repeat.y) / 2), n
}

function $k(n) {
   return n.repeat.x = 1, n.repeat.y = 1, n.offset.x = 0, n.offset.y = 0, n
}

function $A(n, e, t, i) {
   const s = e8(i);
   switch (t) {
      case bR:
         return n * e;
      case ER:
         return n * e;
      case MR:
         return n * e * 2;
      case rT:
         return n * e / s.components * s.byteLength;
      case hx:
         return n * e / s.components * s.byteLength;
      case AR:
         return n * e * 2 / s.components * s.byteLength;
      case aT:
         return n * e * 2 / s.components * s.byteLength;
      case TR:
         return n * e * 3 / s.components * s.byteLength;
      case Lr:
         return n * e * 4 / s.components * s.byteLength;
      case oT:
         return n * e * 4 / s.components * s.byteLength;
      case H0:
      case V0:
         return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 8;
      case G0:
      case k0:
         return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16;
      case Yb:
      case Zb:
         return Math.max(n, 16) * Math.max(e, 8) / 4;
      case Wb:
      case Kb:
         return Math.max(n, 8) * Math.max(e, 8) / 2;
      case Qb:
      case Jb:
         return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 8;
      case $b:
         return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16;
      case e1:
         return Math.floor((n + 3) / 4) * Math.floor((e + 3) / 4) * 16;
      case t1:
         return Math.floor((n + 4) / 5) * Math.floor((e + 3) / 4) * 16;
      case n1:
         return Math.floor((n + 4) / 5) * Math.floor((e + 4) / 5) * 16;
      case i1:
         return Math.floor((n + 5) / 6) * Math.floor((e + 4) / 5) * 16;
      case s1:
         return Math.floor((n + 5) / 6) * Math.floor((e + 5) / 6) * 16;
      case r1:
         return Math.floor((n + 7) / 8) * Math.floor((e + 4) / 5) * 16;
      case a1:
         return Math.floor((n + 7) / 8) * Math.floor((e + 5) / 6) * 16;
      case o1:
         return Math.floor((n + 7) / 8) * Math.floor((e + 7) / 8) * 16;
      case l1:
         return Math.floor((n + 9) / 10) * Math.floor((e + 4) / 5) * 16;
      case u1:
         return Math.floor((n + 9) / 10) * Math.floor((e + 5) / 6) * 16;
      case c1:
         return Math.floor((n + 9) / 10) * Math.floor((e + 7) / 8) * 16;
      case f1:
         return Math.floor((n + 9) / 10) * Math.floor((e + 9) / 10) * 16;
      case h1:
         return Math.floor((n + 11) / 12) * Math.floor((e + 9) / 10) * 16;
      case d1:
         return Math.floor((n + 11) / 12) * Math.floor((e + 11) / 12) * 16;
      case j0:
      case p1:
      case m1:
         return Math.ceil(n / 4) * Math.ceil(e / 4) * 16;
      case wR:
      case g1:
         return Math.ceil(n / 4) * Math.ceil(e / 4) * 8;
      case v1:
      case y1:
         return Math.ceil(n / 4) * Math.ceil(e / 4) * 16
   }
   throw new Error(`Unable to determine texture byte length for ${t} format.`)
}

function e8(n) {
   switch (n) {
      case qs:
      case xR:
         return {
            byteLength: 1, components: 1
         };
      case cg:
      case _R:
      case lp:
         return {
            byteLength: 2, components: 1
         };
      case iT:
      case sT:
         return {
            byteLength: 2, components: 4
         };
      case Vu:
      case nT:
      case ha:
         return {
            byteLength: 4, components: 1
         };
      case SR:
         return {
            byteLength: 4, components: 3
         }
   }
   throw new Error(`Unknown texture type ${n}.`)
}
class t8 {
   static contain(e, t) {
      return Qk(e, t)
   }
   static cover(e, t) {
      return Jk(e, t)
   }
   static fill(e) {
      return $k(e)
   }
   static getByteLength(e, t, i, s) {
      return $A(e, t, i, s)
   }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
   detail: {
      revision: Og
   }
}));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = Og);
/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
function AB() {
   let n = null,
      e = !1,
      t = null,
      i = null;

   function s(r, a) {
      t(r, a), i = n.requestAnimationFrame(s)
   }
   return {
      start: function () {
         e !== !0 && t !== null && (i = n.requestAnimationFrame(s), e = !0)
      },
      stop: function () {
         n.cancelAnimationFrame(i), e = !1
      },
      setAnimationLoop: function (r) {
         t = r
      },
      setContext: function (r) {
         n = r
      }
   }
}

function n8(n) {
   const e = new WeakMap;

   function t(l, c) {
      const h = l.array,
         m = l.usage,
         g = h.byteLength,
         v = n.createBuffer();
      n.bindBuffer(c, v), n.bufferData(c, h, m), l.onUploadCallback();
      let x;
      if (h instanceof Float32Array) x = n.FLOAT;
      else if (h instanceof Uint16Array) l.isFloat16BufferAttribute ? x = n.HALF_FLOAT : x = n.UNSIGNED_SHORT;
      else if (h instanceof Int16Array) x = n.SHORT;
      else if (h instanceof Uint32Array) x = n.UNSIGNED_INT;
      else if (h instanceof Int32Array) x = n.INT;
      else if (h instanceof Int8Array) x = n.BYTE;
      else if (h instanceof Uint8Array) x = n.UNSIGNED_BYTE;
      else if (h instanceof Uint8ClampedArray) x = n.UNSIGNED_BYTE;
      else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + h);
      return {
         buffer: v,
         type: x,
         bytesPerElement: h.BYTES_PER_ELEMENT,
         version: l.version,
         size: g
      }
   }

   function i(l, c, h) {
      const m = c.array,
         g = c.updateRanges;
      if (n.bindBuffer(h, l), g.length === 0) n.bufferSubData(h, 0, m);
      else {
         g.sort((x, S) => x.start - S.start);
         let v = 0;
         for (let x = 1; x < g.length; x++) {
            const S = g[v],
               E = g[x];
            E.start <= S.start + S.count + 1 ? S.count = Math.max(S.count, E.start + E.count - S.start) : (++v, g[v] = E)
         }
         g.length = v + 1;
         for (let x = 0, S = g.length; x < S; x++) {
            const E = g[x];
            n.bufferSubData(h, E.start * m.BYTES_PER_ELEMENT, m, E.start, E.count)
         }
         c.clearUpdateRanges()
      }
      c.onUploadCallback()
   }

   function s(l) {
      return l.isInterleavedBufferAttribute && (l = l.data), e.get(l)
   }

   function r(l) {
      l.isInterleavedBufferAttribute && (l = l.data);
      const c = e.get(l);
      c && (n.deleteBuffer(c.buffer), e.delete(l))
   }

   function a(l, c) {
      if (l.isInterleavedBufferAttribute && (l = l.data), l.isGLBufferAttribute) {
         const m = e.get(l);
         (!m || m.version < l.version) && e.set(l, {
            buffer: l.buffer,
            type: l.type,
            bytesPerElement: l.elementSize,
            version: l.version
         });
         return
      }
      const h = e.get(l);
      if (h === void 0) e.set(l, t(l, c));
      else if (h.version < l.version) {
         if (h.size !== l.array.byteLength) throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
         i(h.buffer, l, c), h.version = l.version
      }
   }
   return {
      get: s,
      remove: r,
      update: a
   }
}
var i8 = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
   s8 = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
   r8 = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
   a8 = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
   o8 = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,
   l8 = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
   u8 = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
   c8 = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
   f8 = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,
   h8 = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,
   d8 = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
   p8 = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
   m8 = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
   g8 = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
   v8 = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
   y8 = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,
   x8 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
   _8 = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
   S8 = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
   b8 = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
   T8 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
   E8 = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,
   M8 = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,
   A8 = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
   w8 = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
   R8 = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
   C8 = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
   D8 = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
   N8 = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
   O8 = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
   U8 = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
   P8 = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
   L8 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
   B8 = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
   z8 = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
   I8 = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
   F8 = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
   H8 = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
   V8 = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
   G8 = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
   k8 = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
   j8 = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
   q8 = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
   X8 = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
   W8 = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
   Y8 = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
   K8 = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
   Z8 = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
   Q8 = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
   J8 = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
   $8 = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
   ej = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,
   tj = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
   nj = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
   ij = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
   sj = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,
   rj = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
   aj = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
   oj = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
   lj = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,
   uj = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
   cj = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
   fj = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
   hj = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
   dj = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
   pj = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
   mj = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,
   gj = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
   vj = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
   yj = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,
   xj = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
   _j = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,
   Sj = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
   bj = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
   Tj = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
   Ej = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
   Mj = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
   Aj = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,
   wj = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
   Rj = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
   Cj = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
   Dj = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
   Nj = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
   Oj = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
   Uj = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
   Pj = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
   Lj = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
   Bj = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
   zj = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
   Ij = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`,
   Fj = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
   Hj = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
   Vj = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
   Gj = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
   kj = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
   jj = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
   qj = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
   Xj = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
   Wj = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
   Yj = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
   Kj = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
   Zj = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
   Qj = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		#else
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
   Jj = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
   $j = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
   e7 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
   t7 = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const n7 = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
   i7 = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
   s7 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
   r7 = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
   a7 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
   o7 = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
   l7 = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
   u7 = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`,
   c7 = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
   f7 = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
   h7 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
   d7 = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
   p7 = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
   m7 = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
   g7 = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
   v7 = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
   y7 = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
   x7 = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
   _7 = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
   S7 = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
   b7 = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
   T7 = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
   E7 = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
   M7 = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
   A7 = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
   w7 = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
   R7 = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
   C7 = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
   D7 = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
   N7 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
   O7 = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
   U7 = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
   P7 = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
   L7 = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
   yn = {
      alphahash_fragment: i8,
      alphahash_pars_fragment: s8,
      alphamap_fragment: r8,
      alphamap_pars_fragment: a8,
      alphatest_fragment: o8,
      alphatest_pars_fragment: l8,
      aomap_fragment: u8,
      aomap_pars_fragment: c8,
      batching_pars_vertex: f8,
      batching_vertex: h8,
      begin_vertex: d8,
      beginnormal_vertex: p8,
      bsdfs: m8,
      iridescence_fragment: g8,
      bumpmap_pars_fragment: v8,
      clipping_planes_fragment: y8,
      clipping_planes_pars_fragment: x8,
      clipping_planes_pars_vertex: _8,
      clipping_planes_vertex: S8,
      color_fragment: b8,
      color_pars_fragment: T8,
      color_pars_vertex: E8,
      color_vertex: M8,
      common: A8,
      cube_uv_reflection_fragment: w8,
      defaultnormal_vertex: R8,
      displacementmap_pars_vertex: C8,
      displacementmap_vertex: D8,
      emissivemap_fragment: N8,
      emissivemap_pars_fragment: O8,
      colorspace_fragment: U8,
      colorspace_pars_fragment: P8,
      envmap_fragment: L8,
      envmap_common_pars_fragment: B8,
      envmap_pars_fragment: z8,
      envmap_pars_vertex: I8,
      envmap_physical_pars_fragment: K8,
      envmap_vertex: F8,
      fog_vertex: H8,
      fog_pars_vertex: V8,
      fog_fragment: G8,
      fog_pars_fragment: k8,
      gradientmap_pars_fragment: j8,
      lightmap_pars_fragment: q8,
      lights_lambert_fragment: X8,
      lights_lambert_pars_fragment: W8,
      lights_pars_begin: Y8,
      lights_toon_fragment: Z8,
      lights_toon_pars_fragment: Q8,
      lights_phong_fragment: J8,
      lights_phong_pars_fragment: $8,
      lights_physical_fragment: ej,
      lights_physical_pars_fragment: tj,
      lights_fragment_begin: nj,
      lights_fragment_maps: ij,
      lights_fragment_end: sj,
      logdepthbuf_fragment: rj,
      logdepthbuf_pars_fragment: aj,
      logdepthbuf_pars_vertex: oj,
      logdepthbuf_vertex: lj,
      map_fragment: uj,
      map_pars_fragment: cj,
      map_particle_fragment: fj,
      map_particle_pars_fragment: hj,
      metalnessmap_fragment: dj,
      metalnessmap_pars_fragment: pj,
      morphinstance_vertex: mj,
      morphcolor_vertex: gj,
      morphnormal_vertex: vj,
      morphtarget_pars_vertex: yj,
      morphtarget_vertex: xj,
      normal_fragment_begin: _j,
      normal_fragment_maps: Sj,
      normal_pars_fragment: bj,
      normal_pars_vertex: Tj,
      normal_vertex: Ej,
      normalmap_pars_fragment: Mj,
      clearcoat_normal_fragment_begin: Aj,
      clearcoat_normal_fragment_maps: wj,
      clearcoat_pars_fragment: Rj,
      iridescence_pars_fragment: Cj,
      opaque_fragment: Dj,
      packing: Nj,
      premultiplied_alpha_fragment: Oj,
      project_vertex: Uj,
      dithering_fragment: Pj,
      dithering_pars_fragment: Lj,
      roughnessmap_fragment: Bj,
      roughnessmap_pars_fragment: zj,
      shadowmap_pars_fragment: Ij,
      shadowmap_pars_vertex: Fj,
      shadowmap_vertex: Hj,
      shadowmask_pars_fragment: Vj,
      skinbase_vertex: Gj,
      skinning_pars_vertex: kj,
      skinning_vertex: jj,
      skinnormal_vertex: qj,
      specularmap_fragment: Xj,
      specularmap_pars_fragment: Wj,
      tonemapping_fragment: Yj,
      tonemapping_pars_fragment: Kj,
      transmission_fragment: Zj,
      transmission_pars_fragment: Qj,
      uv_pars_fragment: Jj,
      uv_pars_vertex: $j,
      uv_vertex: e7,
      worldpos_vertex: t7,
      background_vert: n7,
      background_frag: i7,
      backgroundCube_vert: s7,
      backgroundCube_frag: r7,
      cube_vert: a7,
      cube_frag: o7,
      depth_vert: l7,
      depth_frag: u7,
      distanceRGBA_vert: c7,
      distanceRGBA_frag: f7,
      equirect_vert: h7,
      equirect_frag: d7,
      linedashed_vert: p7,
      linedashed_frag: m7,
      meshbasic_vert: g7,
      meshbasic_frag: v7,
      meshlambert_vert: y7,
      meshlambert_frag: x7,
      meshmatcap_vert: _7,
      meshmatcap_frag: S7,
      meshnormal_vert: b7,
      meshnormal_frag: T7,
      meshphong_vert: E7,
      meshphong_frag: M7,
      meshphysical_vert: A7,
      meshphysical_frag: w7,
      meshtoon_vert: R7,
      meshtoon_frag: C7,
      points_vert: D7,
      points_frag: N7,
      shadow_vert: O7,
      shadow_frag: U7,
      sprite_vert: P7,
      sprite_frag: L7
   },
   ht = {
      common: {
         diffuse: {
            value: new dt(16777215)
         },
         opacity: {
            value: 1
         },
         map: {
            value: null
         },
         mapTransform: {
            value: new un
         },
         alphaMap: {
            value: null
         },
         alphaMapTransform: {
            value: new un
         },
         alphaTest: {
            value: 0
         }
      },
      specularmap: {
         specularMap: {
            value: null
         },
         specularMapTransform: {
            value: new un
         }
      },
      envmap: {
         envMap: {
            value: null
         },
         envMapRotation: {
            value: new un
         },
         flipEnvMap: {
            value: -1
         },
         reflectivity: {
            value: 1
         },
         ior: {
            value: 1.5
         },
         refractionRatio: {
            value: .98
         }
      },
      aomap: {
         aoMap: {
            value: null
         },
         aoMapIntensity: {
            value: 1
         },
         aoMapTransform: {
            value: new un
         }
      },
      lightmap: {
         lightMap: {
            value: null
         },
         lightMapIntensity: {
            value: 1
         },
         lightMapTransform: {
            value: new un
         }
      },
      bumpmap: {
         bumpMap: {
            value: null
         },
         bumpMapTransform: {
            value: new un
         },
         bumpScale: {
            value: 1
         }
      },
      normalmap: {
         normalMap: {
            value: null
         },
         normalMapTransform: {
            value: new un
         },
         normalScale: {
            value: new Fe(1, 1)
         }
      },
      displacementmap: {
         displacementMap: {
            value: null
         },
         displacementMapTransform: {
            value: new un
         },
         displacementScale: {
            value: 1
         },
         displacementBias: {
            value: 0
         }
      },
      emissivemap: {
         emissiveMap: {
            value: null
         },
         emissiveMapTransform: {
            value: new un
         }
      },
      metalnessmap: {
         metalnessMap: {
            value: null
         },
         metalnessMapTransform: {
            value: new un
         }
      },
      roughnessmap: {
         roughnessMap: {
            value: null
         },
         roughnessMapTransform: {
            value: new un
         }
      },
      gradientmap: {
         gradientMap: {
            value: null
         }
      },
      fog: {
         fogDensity: {
            value: 25e-5
         },
         fogNear: {
            value: 1
         },
         fogFar: {
            value: 2e3
         },
         fogColor: {
            value: new dt(16777215)
         }
      },
      lights: {
         ambientLightColor: {
            value: []
         },
         lightProbe: {
            value: []
         },
         directionalLights: {
            value: [],
            properties: {
               direction: {},
               color: {}
            }
         },
         directionalLightShadows: {
            value: [],
            properties: {
               shadowIntensity: 1,
               shadowBias: {},
               shadowNormalBias: {},
               shadowRadius: {},
               shadowMapSize: {}
            }
         },
         directionalShadowMap: {
            value: []
         },
         directionalShadowMatrix: {
            value: []
         },
         spotLights: {
            value: [],
            properties: {
               color: {},
               position: {},
               direction: {},
               distance: {},
               coneCos: {},
               penumbraCos: {},
               decay: {}
            }
         },
         spotLightShadows: {
            value: [],
            properties: {
               shadowIntensity: 1,
               shadowBias: {},
               shadowNormalBias: {},
               shadowRadius: {},
               shadowMapSize: {}
            }
         },
         spotLightMap: {
            value: []
         },
         spotShadowMap: {
            value: []
         },
         spotLightMatrix: {
            value: []
         },
         pointLights: {
            value: [],
            properties: {
               color: {},
               position: {},
               decay: {},
               distance: {}
            }
         },
         pointLightShadows: {
            value: [],
            properties: {
               shadowIntensity: 1,
               shadowBias: {},
               shadowNormalBias: {},
               shadowRadius: {},
               shadowMapSize: {},
               shadowCameraNear: {},
               shadowCameraFar: {}
            }
         },
         pointShadowMap: {
            value: []
         },
         pointShadowMatrix: {
            value: []
         },
         hemisphereLights: {
            value: [],
            properties: {
               direction: {},
               skyColor: {},
               groundColor: {}
            }
         },
         rectAreaLights: {
            value: [],
            properties: {
               color: {},
               position: {},
               width: {},
               height: {}
            }
         },
         ltc_1: {
            value: null
         },
         ltc_2: {
            value: null
         }
      },
      points: {
         diffuse: {
            value: new dt(16777215)
         },
         opacity: {
            value: 1
         },
         size: {
            value: 1
         },
         scale: {
            value: 1
         },
         map: {
            value: null
         },
         alphaMap: {
            value: null
         },
         alphaMapTransform: {
            value: new un
         },
         alphaTest: {
            value: 0
         },
         uvTransform: {
            value: new un
         }
      },
      sprite: {
         diffuse: {
            value: new dt(16777215)
         },
         opacity: {
            value: 1
         },
         center: {
            value: new Fe(.5, .5)
         },
         rotation: {
            value: 0
         },
         map: {
            value: null
         },
         mapTransform: {
            value: new un
         },
         alphaMap: {
            value: null
         },
         alphaMapTransform: {
            value: new un
         },
         alphaTest: {
            value: 0
         }
      }
   },
   Ll = {
      basic: {
         uniforms: sa([ht.common, ht.specularmap, ht.envmap, ht.aomap, ht.lightmap, ht.fog]),
         vertexShader: yn.meshbasic_vert,
         fragmentShader: yn.meshbasic_frag
      },
      lambert: {
         uniforms: sa([ht.common, ht.specularmap, ht.envmap, ht.aomap, ht.lightmap, ht.emissivemap, ht.bumpmap, ht.normalmap, ht.displacementmap, ht.fog, ht.lights, {
            emissive: {
               value: new dt(0)
            }
         }]),
         vertexShader: yn.meshlambert_vert,
         fragmentShader: yn.meshlambert_frag
      },
      phong: {
         uniforms: sa([ht.common, ht.specularmap, ht.envmap, ht.aomap, ht.lightmap, ht.emissivemap, ht.bumpmap, ht.normalmap, ht.displacementmap, ht.fog, ht.lights, {
            emissive: {
               value: new dt(0)
            },
            specular: {
               value: new dt(1118481)
            },
            shininess: {
               value: 30
            }
         }]),
         vertexShader: yn.meshphong_vert,
         fragmentShader: yn.meshphong_frag
      },
      standard: {
         uniforms: sa([ht.common, ht.envmap, ht.aomap, ht.lightmap, ht.emissivemap, ht.bumpmap, ht.normalmap, ht.displacementmap, ht.roughnessmap, ht.metalnessmap, ht.fog, ht.lights, {
            emissive: {
               value: new dt(0)
            },
            roughness: {
               value: 1
            },
            metalness: {
               value: 0
            },
            envMapIntensity: {
               value: 1
            }
         }]),
         vertexShader: yn.meshphysical_vert,
         fragmentShader: yn.meshphysical_frag
      },
      toon: {
         uniforms: sa([ht.common, ht.aomap, ht.lightmap, ht.emissivemap, ht.bumpmap, ht.normalmap, ht.displacementmap, ht.gradientmap, ht.fog, ht.lights, {
            emissive: {
               value: new dt(0)
            }
         }]),
         vertexShader: yn.meshtoon_vert,
         fragmentShader: yn.meshtoon_frag
      },
      matcap: {
         uniforms: sa([ht.common, ht.bumpmap, ht.normalmap, ht.displacementmap, ht.fog, {
            matcap: {
               value: null
            }
         }]),
         vertexShader: yn.meshmatcap_vert,
         fragmentShader: yn.meshmatcap_frag
      },
      points: {
         uniforms: sa([ht.points, ht.fog]),
         vertexShader: yn.points_vert,
         fragmentShader: yn.points_frag
      },
      dashed: {
         uniforms: sa([ht.common, ht.fog, {
            scale: {
               value: 1
            },
            dashSize: {
               value: 1
            },
            totalSize: {
               value: 2
            }
         }]),
         vertexShader: yn.linedashed_vert,
         fragmentShader: yn.linedashed_frag
      },
      depth: {
         uniforms: sa([ht.common, ht.displacementmap]),
         vertexShader: yn.depth_vert,
         fragmentShader: yn.depth_frag
      },
      normal: {
         uniforms: sa([ht.common, ht.bumpmap, ht.normalmap, ht.displacementmap, {
            opacity: {
               value: 1
            }
         }]),
         vertexShader: yn.meshnormal_vert,
         fragmentShader: yn.meshnormal_frag
      },
      sprite: {
         uniforms: sa([ht.sprite, ht.fog]),
         vertexShader: yn.sprite_vert,
         fragmentShader: yn.sprite_frag
      },
      background: {
         uniforms: {
            uvTransform: {
               value: new un
            },
            t2D: {
               value: null
            },
            backgroundIntensity: {
               value: 1
            }
         },
         vertexShader: yn.background_vert,
         fragmentShader: yn.background_frag
      },
      backgroundCube: {
         uniforms: {
            envMap: {
               value: null
            },
            flipEnvMap: {
               value: -1
            },
            backgroundBlurriness: {
               value: 0
            },
            backgroundIntensity: {
               value: 1
            },
            backgroundRotation: {
               value: new un
            }
         },
         vertexShader: yn.backgroundCube_vert,
         fragmentShader: yn.backgroundCube_frag
      },
      cube: {
         uniforms: {
            tCube: {
               value: null
            },
            tFlip: {
               value: -1
            },
            opacity: {
               value: 1
            }
         },
         vertexShader: yn.cube_vert,
         fragmentShader: yn.cube_frag
      },
      equirect: {
         uniforms: {
            tEquirect: {
               value: null
            }
         },
         vertexShader: yn.equirect_vert,
         fragmentShader: yn.equirect_frag
      },
      distanceRGBA: {
         uniforms: sa([ht.common, ht.displacementmap, {
            referencePosition: {
               value: new ee
            },
            nearDistance: {
               value: 1
            },
            farDistance: {
               value: 1e3
            }
         }]),
         vertexShader: yn.distanceRGBA_vert,
         fragmentShader: yn.distanceRGBA_frag
      },
      shadow: {
         uniforms: sa([ht.lights, ht.fog, {
            color: {
               value: new dt(0)
            },
            opacity: {
               value: 1
            }
         }]),
         vertexShader: yn.shadow_vert,
         fragmentShader: yn.shadow_frag
      }
   };
Ll.physical = {
   uniforms: sa([Ll.standard.uniforms, {
      clearcoat: {
         value: 0
      },
      clearcoatMap: {
         value: null
      },
      clearcoatMapTransform: {
         value: new un
      },
      clearcoatNormalMap: {
         value: null
      },
      clearcoatNormalMapTransform: {
         value: new un
      },
      clearcoatNormalScale: {
         value: new Fe(1, 1)
      },
      clearcoatRoughness: {
         value: 0
      },
      clearcoatRoughnessMap: {
         value: null
      },
      clearcoatRoughnessMapTransform: {
         value: new un
      },
      dispersion: {
         value: 0
      },
      iridescence: {
         value: 0
      },
      iridescenceMap: {
         value: null
      },
      iridescenceMapTransform: {
         value: new un
      },
      iridescenceIOR: {
         value: 1.3
      },
      iridescenceThicknessMinimum: {
         value: 100
      },
      iridescenceThicknessMaximum: {
         value: 400
      },
      iridescenceThicknessMap: {
         value: null
      },
      iridescenceThicknessMapTransform: {
         value: new un
      },
      sheen: {
         value: 0
      },
      sheenColor: {
         value: new dt(0)
      },
      sheenColorMap: {
         value: null
      },
      sheenColorMapTransform: {
         value: new un
      },
      sheenRoughness: {
         value: 1
      },
      sheenRoughnessMap: {
         value: null
      },
      sheenRoughnessMapTransform: {
         value: new un
      },
      transmission: {
         value: 0
      },
      transmissionMap: {
         value: null
      },
      transmissionMapTransform: {
         value: new un
      },
      transmissionSamplerSize: {
         value: new Fe
      },
      transmissionSamplerMap: {
         value: null
      },
      thickness: {
         value: 0
      },
      thicknessMap: {
         value: null
      },
      thicknessMapTransform: {
         value: new un
      },
      attenuationDistance: {
         value: 0
      },
      attenuationColor: {
         value: new dt(0)
      },
      specularColor: {
         value: new dt(1, 1, 1)
      },
      specularColorMap: {
         value: null
      },
      specularColorMapTransform: {
         value: new un
      },
      specularIntensity: {
         value: 1
      },
      specularIntensityMap: {
         value: null
      },
      specularIntensityMapTransform: {
         value: new un
      },
      anisotropyVector: {
         value: new Fe
      },
      anisotropyMap: {
         value: null
      },
      anisotropyMapTransform: {
         value: new un
      }
   }]),
   vertexShader: yn.meshphysical_vert,
   fragmentShader: yn.meshphysical_frag
};
const YS = {
      r: 0,
      b: 0,
      g: 0
   },
   yd = new go,
   B7 = new Zt;

function z7(n, e, t, i, s, r, a) {
   const l = new dt(0);
   let c = r === !0 ? 0 : 1,
      h, m, g = null,
      v = 0,
      x = null;

   function S(C) {
      let N = C.isScene === !0 ? C.background : null;
      return N && N.isTexture && (N = (C.backgroundBlurriness > 0 ? t : e).get(N)), N
   }

   function E(C) {
      let N = !1;
      const U = S(C);
      U === null ? b(l, c) : U && U.isColor && (b(U, 1), N = !0);
      const z = n.xr.getEnvironmentBlendMode();
      z === "additive" ? i.buffers.color.setClear(0, 0, 0, 1, a) : z === "alpha-blend" && i.buffers.color.setClear(0, 0, 0, 0, a), (n.autoClear || N) && (i.buffers.depth.setTest(!0), i.buffers.depth.setMask(!0), i.buffers.color.setMask(!0), n.clear(n.autoClearColor, n.autoClearDepth, n.autoClearStencil))
   }

   function T(C, N) {
      const U = S(N);
      U && (U.isCubeTexture || U.mapping === Ug) ? (m === void 0 && (m = new ds(new up(1, 1, 1), new gs({
         name: "BackgroundCubeMaterial",
         uniforms: pg(Ll.backgroundCube.uniforms),
         vertexShader: Ll.backgroundCube.vertexShader,
         fragmentShader: Ll.backgroundCube.fragmentShader,
         side: Ds,
         depthTest: !1,
         depthWrite: !1,
         fog: !1,
         allowOverride: !1
      })), m.geometry.deleteAttribute("normal"), m.geometry.deleteAttribute("uv"), m.onBeforeRender = function (z, B, I) {
         this.matrixWorld.copyPosition(I.matrixWorld)
      }, Object.defineProperty(m.material, "envMap", {
         get: function () {
            return this.uniforms.envMap.value
         }
      }), s.update(m)), yd.copy(N.backgroundRotation), yd.x *= -1, yd.y *= -1, yd.z *= -1, U.isCubeTexture && U.isRenderTargetTexture === !1 && (yd.y *= -1, yd.z *= -1), m.material.uniforms.envMap.value = U, m.material.uniforms.flipEnvMap.value = U.isCubeTexture && U.isRenderTargetTexture === !1 ? -1 : 1, m.material.uniforms.backgroundBlurriness.value = N.backgroundBlurriness, m.material.uniforms.backgroundIntensity.value = N.backgroundIntensity, m.material.uniforms.backgroundRotation.value.setFromMatrix4(B7.makeRotationFromEuler(yd)), m.material.toneMapped = Vn.getTransfer(U.colorSpace) !== di, (g !== U || v !== U.version || x !== n.toneMapping) && (m.material.needsUpdate = !0, g = U, v = U.version, x = n.toneMapping), m.layers.enableAll(), C.unshift(m, m.geometry, m.material, 0, 0, null)) : U && U.isTexture && (h === void 0 && (h = new ds(new Bg(2, 2), new gs({
         name: "BackgroundMaterial",
         uniforms: pg(Ll.background.uniforms),
         vertexShader: Ll.background.vertexShader,
         fragmentShader: Ll.background.fragmentShader,
         side: Hu,
         depthTest: !1,
         depthWrite: !1,
         fog: !1,
         allowOverride: !1
      })), h.geometry.deleteAttribute("normal"), Object.defineProperty(h.material, "map", {
         get: function () {
            return this.uniforms.t2D.value
         }
      }), s.update(h)), h.material.uniforms.t2D.value = U, h.material.uniforms.backgroundIntensity.value = N.backgroundIntensity, h.material.toneMapped = Vn.getTransfer(U.colorSpace) !== di, U.matrixAutoUpdate === !0 && U.updateMatrix(), h.material.uniforms.uvTransform.value.copy(U.matrix), (g !== U || v !== U.version || x !== n.toneMapping) && (h.material.needsUpdate = !0, g = U, v = U.version, x = n.toneMapping), h.layers.enableAll(), C.unshift(h, h.geometry, h.material, 0, 0, null))
   }

   function b(C, N) {
      C.getRGB(YS, wL(n)), i.buffers.color.setClear(YS.r, YS.g, YS.b, N, a)
   }

   function w() {
      m !== void 0 && (m.geometry.dispose(), m.material.dispose(), m = void 0), h !== void 0 && (h.geometry.dispose(), h.material.dispose(), h = void 0)
   }
   return {
      getClearColor: function () {
         return l
      },
      setClearColor: function (C, N = 1) {
         l.set(C), c = N, b(l, c)
      },
      getClearAlpha: function () {
         return c
      },
      setClearAlpha: function (C) {
         c = C, b(l, c)
      },
      render: E,
      addToRenderList: T,
      dispose: w
   }
}

function I7(n, e) {
   const t = n.getParameter(n.MAX_VERTEX_ATTRIBS),
      i = {},
      s = v(null);
   let r = s,
      a = !1;

   function l(P, q, Q, $, ae) {
      let fe = !1;
      const k = g($, Q, q);
      r !== k && (r = k, h(r.object)), fe = x(P, $, Q, ae), fe && S(P, $, Q, ae), ae !== null && e.update(ae, n.ELEMENT_ARRAY_BUFFER), (fe || a) && (a = !1, N(P, q, Q, $), ae !== null && n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, e.get(ae).buffer))
   }

   function c() {
      return n.createVertexArray()
   }

   function h(P) {
      return n.bindVertexArray(P)
   }

   function m(P) {
      return n.deleteVertexArray(P)
   }

   function g(P, q, Q) {
      const $ = Q.wireframe === !0;
      let ae = i[P.id];
      ae === void 0 && (ae = {}, i[P.id] = ae);
      let fe = ae[q.id];
      fe === void 0 && (fe = {}, ae[q.id] = fe);
      let k = fe[$];
      return k === void 0 && (k = v(c()), fe[$] = k), k
   }

   function v(P) {
      const q = [],
         Q = [],
         $ = [];
      for (let ae = 0; ae < t; ae++) q[ae] = 0, Q[ae] = 0, $[ae] = 0;
      return {
         geometry: null,
         program: null,
         wireframe: !1,
         newAttributes: q,
         enabledAttributes: Q,
         attributeDivisors: $,
         object: P,
         attributes: {},
         index: null
      }
   }

   function x(P, q, Q, $) {
      const ae = r.attributes,
         fe = q.attributes;
      let k = 0;
      const Z = Q.getAttributes();
      for (const J in Z)
         if (Z[J].location >= 0) {
            const F = ae[J];
            let ie = fe[J];
            if (ie === void 0 && (J === "instanceMatrix" && P.instanceMatrix && (ie = P.instanceMatrix), J === "instanceColor" && P.instanceColor && (ie = P.instanceColor)), F === void 0 || F.attribute !== ie || ie && F.data !== ie.data) return !0;
            k++
         } return r.attributesNum !== k || r.index !== $
   }

   function S(P, q, Q, $) {
      const ae = {},
         fe = q.attributes;
      let k = 0;
      const Z = Q.getAttributes();
      for (const J in Z)
         if (Z[J].location >= 0) {
            let F = fe[J];
            F === void 0 && (J === "instanceMatrix" && P.instanceMatrix && (F = P.instanceMatrix), J === "instanceColor" && P.instanceColor && (F = P.instanceColor));
            const ie = {};
            ie.attribute = F, F && F.data && (ie.data = F.data), ae[J] = ie, k++
         } r.attributes = ae, r.attributesNum = k, r.index = $
   }

   function E() {
      const P = r.newAttributes;
      for (let q = 0, Q = P.length; q < Q; q++) P[q] = 0
   }

   function T(P) {
      b(P, 0)
   }

   function b(P, q) {
      const Q = r.newAttributes,
         $ = r.enabledAttributes,
         ae = r.attributeDivisors;
      Q[P] = 1, $[P] === 0 && (n.enableVertexAttribArray(P), $[P] = 1), ae[P] !== q && (n.vertexAttribDivisor(P, q), ae[P] = q)
   }

   function w() {
      const P = r.newAttributes,
         q = r.enabledAttributes;
      for (let Q = 0, $ = q.length; Q < $; Q++) q[Q] !== P[Q] && (n.disableVertexAttribArray(Q), q[Q] = 0)
   }

   function C(P, q, Q, $, ae, fe, k) {
      k === !0 ? n.vertexAttribIPointer(P, q, Q, ae, fe) : n.vertexAttribPointer(P, q, Q, $, ae, fe)
   }

   function N(P, q, Q, $) {
      E();
      const ae = $.attributes,
         fe = Q.getAttributes(),
         k = q.defaultAttributeValues;
      for (const Z in fe) {
         const J = fe[Z];
         if (J.location >= 0) {
            let pe = ae[Z];
            if (pe === void 0 && (Z === "instanceMatrix" && P.instanceMatrix && (pe = P.instanceMatrix), Z === "instanceColor" && P.instanceColor && (pe = P.instanceColor)), pe !== void 0) {
               const F = pe.normalized,
                  ie = pe.itemSize,
                  ye = e.get(pe);
               if (ye === void 0) continue;
               const we = ye.buffer,
                  oe = ye.type,
                  be = ye.bytesPerElement,
                  Pe = oe === n.INT || oe === n.UNSIGNED_INT || pe.gpuType === nT;
               if (pe.isInterleavedBufferAttribute) {
                  const Ge = pe.data,
                     Xe = Ge.stride,
                     yt = pe.offset;
                  if (Ge.isInstancedInterleavedBuffer) {
                     for (let vt = 0; vt < J.locationSize; vt++) b(J.location + vt, Ge.meshPerAttribute);
                     P.isInstancedMesh !== !0 && $._maxInstanceCount === void 0 && ($._maxInstanceCount = Ge.meshPerAttribute * Ge.count)
                  } else
                     for (let vt = 0; vt < J.locationSize; vt++) T(J.location + vt);
                  n.bindBuffer(n.ARRAY_BUFFER, we);
                  for (let vt = 0; vt < J.locationSize; vt++) C(J.location + vt, ie / J.locationSize, oe, F, Xe * be, (yt + ie / J.locationSize * vt) * be, Pe)
               } else {
                  if (pe.isInstancedBufferAttribute) {
                     for (let Ge = 0; Ge < J.locationSize; Ge++) b(J.location + Ge, pe.meshPerAttribute);
                     P.isInstancedMesh !== !0 && $._maxInstanceCount === void 0 && ($._maxInstanceCount = pe.meshPerAttribute * pe.count)
                  } else
                     for (let Ge = 0; Ge < J.locationSize; Ge++) T(J.location + Ge);
                  n.bindBuffer(n.ARRAY_BUFFER, we);
                  for (let Ge = 0; Ge < J.locationSize; Ge++) C(J.location + Ge, ie / J.locationSize, oe, F, ie * be, ie / J.locationSize * Ge * be, Pe)
               }
            } else if (k !== void 0) {
               const F = k[Z];
               if (F !== void 0) switch (F.length) {
                  case 2:
                     n.vertexAttrib2fv(J.location, F);
                     break;
                  case 3:
                     n.vertexAttrib3fv(J.location, F);
                     break;
                  case 4:
                     n.vertexAttrib4fv(J.location, F);
                     break;
                  default:
                     n.vertexAttrib1fv(J.location, F)
               }
            }
         }
      }
      w()
   }

   function U() {
      I();
      for (const P in i) {
         const q = i[P];
         for (const Q in q) {
            const $ = q[Q];
            for (const ae in $) m($[ae].object), delete $[ae];
            delete q[Q]
         }
         delete i[P]
      }
   }

   function z(P) {
      if (i[P.id] === void 0) return;
      const q = i[P.id];
      for (const Q in q) {
         const $ = q[Q];
         for (const ae in $) m($[ae].object), delete $[ae];
         delete q[Q]
      }
      delete i[P.id]
   }

   function B(P) {
      for (const q in i) {
         const Q = i[q];
         if (Q[P.id] === void 0) continue;
         const $ = Q[P.id];
         for (const ae in $) m($[ae].object), delete $[ae];
         delete Q[P.id]
      }
   }

   function I() {
      O(), a = !0, r !== s && (r = s, h(r.object))
   }

   function O() {
      s.geometry = null, s.program = null, s.wireframe = !1
   }
   return {
      setup: l,
      reset: I,
      resetDefaultState: O,
      dispose: U,
      releaseStatesOfGeometry: z,
      releaseStatesOfProgram: B,
      initAttributes: E,
      enableAttribute: T,
      disableUnusedAttributes: w
   }
}

function F7(n, e, t) {
   let i;

   function s(h) {
      i = h
   }

   function r(h, m) {
      n.drawArrays(i, h, m), t.update(m, i, 1)
   }

   function a(h, m, g) {
      g !== 0 && (n.drawArraysInstanced(i, h, m, g), t.update(m, i, g))
   }

   function l(h, m, g) {
      if (g === 0) return;
      e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(i, h, 0, m, 0, g);
      let x = 0;
      for (let S = 0; S < g; S++) x += m[S];
      t.update(x, i, 1)
   }

   function c(h, m, g, v) {
      if (g === 0) return;
      const x = e.get("WEBGL_multi_draw");
      if (x === null)
         for (let S = 0; S < h.length; S++) a(h[S], m[S], v[S]);
      else {
         x.multiDrawArraysInstancedWEBGL(i, h, 0, m, 0, v, 0, g);
         let S = 0;
         for (let E = 0; E < g; E++) S += m[E] * v[E];
         t.update(S, i, 1)
      }
   }
   this.setMode = s, this.render = r, this.renderInstances = a, this.renderMultiDraw = l, this.renderMultiDrawInstances = c
}

function H7(n, e, t, i) {
   let s;

   function r() {
      if (s !== void 0) return s;
      if (e.has("EXT_texture_filter_anisotropic") === !0) {
         const B = e.get("EXT_texture_filter_anisotropic");
         s = n.getParameter(B.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
      } else s = 0;
      return s
   }

   function a(B) {
      return !(B !== Lr && i.convert(B) !== n.getParameter(n.IMPLEMENTATION_COLOR_READ_FORMAT))
   }

   function l(B) {
      const I = B === lp && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
      return !(B !== qs && i.convert(B) !== n.getParameter(n.IMPLEMENTATION_COLOR_READ_TYPE) && B !== ha && !I)
   }

   function c(B) {
      if (B === "highp") {
         if (n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.HIGH_FLOAT).precision > 0 && n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.HIGH_FLOAT).precision > 0) return "highp";
         B = "mediump"
      }
      return B === "mediump" && n.getShaderPrecisionFormat(n.VERTEX_SHADER, n.MEDIUM_FLOAT).precision > 0 && n.getShaderPrecisionFormat(n.FRAGMENT_SHADER, n.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
   }
   let h = t.precision !== void 0 ? t.precision : "highp";
   const m = c(h);
   m !== h && (console.warn("THREE.WebGLRenderer:", h, "not supported, using", m, "instead."), h = m);
   const g = t.logarithmicDepthBuffer === !0,
      v = t.reverseDepthBuffer === !0 && e.has("EXT_clip_control"),
      x = n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS),
      S = n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
      E = n.getParameter(n.MAX_TEXTURE_SIZE),
      T = n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE),
      b = n.getParameter(n.MAX_VERTEX_ATTRIBS),
      w = n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS),
      C = n.getParameter(n.MAX_VARYING_VECTORS),
      N = n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS),
      U = S > 0,
      z = n.getParameter(n.MAX_SAMPLES);
   return {
      isWebGL2: !0,
      getMaxAnisotropy: r,
      getMaxPrecision: c,
      textureFormatReadable: a,
      textureTypeReadable: l,
      precision: h,
      logarithmicDepthBuffer: g,
      reverseDepthBuffer: v,
      maxTextures: x,
      maxVertexTextures: S,
      maxTextureSize: E,
      maxCubemapSize: T,
      maxAttributes: b,
      maxVertexUniforms: w,
      maxVaryings: C,
      maxFragmentUniforms: N,
      vertexTextures: U,
      maxSamples: z
   }
}

function V7(n) {
   const e = this;
   let t = null,
      i = 0,
      s = !1,
      r = !1;
   const a = new kf,
      l = new un,
      c = {
         value: null,
         needsUpdate: !1
      };
   this.uniform = c, this.numPlanes = 0, this.numIntersection = 0, this.init = function (g, v) {
      const x = g.length !== 0 || v || i !== 0 || s;
      return s = v, i = g.length, x
   }, this.beginShadows = function () {
      r = !0, m(null)
   }, this.endShadows = function () {
      r = !1
   }, this.setGlobalState = function (g, v) {
      t = m(g, v, 0)
   }, this.setState = function (g, v, x) {
      const S = g.clippingPlanes,
         E = g.clipIntersection,
         T = g.clipShadows,
         b = n.get(g);
      if (!s || S === null || S.length === 0 || r && !T) r ? m(null) : h();
      else {
         const w = r ? 0 : i,
            C = w * 4;
         let N = b.clippingState || null;
         c.value = N, N = m(S, v, C, x);
         for (let U = 0; U !== C; ++U) N[U] = t[U];
         b.clippingState = N, this.numIntersection = E ? this.numPlanes : 0, this.numPlanes += w
      }
   };

   function h() {
      c.value !== t && (c.value = t, c.needsUpdate = i > 0), e.numPlanes = i, e.numIntersection = 0
   }

   function m(g, v, x, S) {
      const E = g !== null ? g.length : 0;
      let T = null;
      if (E !== 0) {
         if (T = c.value, S !== !0 || T === null) {
            const b = x + E * 4,
               w = v.matrixWorldInverse;
            l.getNormalMatrix(w), (T === null || T.length < b) && (T = new Float32Array(b));
            for (let C = 0, N = x; C !== E; ++C, N += 4) a.copy(g[C]).applyMatrix4(w, l), a.normal.toArray(T, N), T[N + 3] = a.constant
         }
         c.value = T, c.needsUpdate = !0
      }
      return e.numPlanes = E, e.numIntersection = 0, T
   }
}

function G7(n) {
   let e = new WeakMap;

   function t(a, l) {
      return l === Ty ? a.mapping = Uc : l === Ey && (a.mapping = sh), a
   }

   function i(a) {
      if (a && a.isTexture) {
         const l = a.mapping;
         if (l === Ty || l === Ey)
            if (e.has(a)) {
               const c = e.get(a).texture;
               return t(c, a.mapping)
            } else {
               const c = a.image;
               if (c && c.height > 0) {
                  const h = new DL(c.height);
                  return h.fromEquirectangularTexture(n, a), e.set(a, h), a.addEventListener("dispose", s), t(h.texture, a.mapping)
               } else return null
            }
      }
      return a
   }

   function s(a) {
      const l = a.target;
      l.removeEventListener("dispose", s);
      const c = e.get(l);
      c !== void 0 && (e.delete(l), c.dispose())
   }

   function r() {
      e = new WeakMap
   }
   return {
      get: i,
      dispose: r
   }
}
const Xm = 4,
   D3 = [.125, .215, .35, .446, .526, .582],
   Cd = 20,
   CM = new bx,
   N3 = new dt;
let DM = null,
   NM = 0,
   OM = 0,
   UM = !1;
const Ed = (1 + Math.sqrt(5)) / 2,
   Om = 1 / Ed,
   O3 = [new ee(-Ed, Om, 0), new ee(Ed, Om, 0), new ee(-Om, 0, Ed), new ee(Om, 0, Ed), new ee(0, Ed, -Om), new ee(0, Ed, Om), new ee(-1, 1, -1), new ee(1, 1, -1), new ee(-1, 1, 1), new ee(1, 1, 1)],
   k7 = new ee;
class ew {
   constructor(e) {
      this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial)
   }
   fromScene(e, t = 0, i = .1, s = 100, r = {}) {
      const {
         size: a = 256,
         position: l = k7
      } = r;
      DM = this._renderer.getRenderTarget(), NM = this._renderer.getActiveCubeFace(), OM = this._renderer.getActiveMipmapLevel(), UM = this._renderer.xr.enabled, this._renderer.xr.enabled = !1, this._setSize(a);
      const c = this._allocateTargets();
      return c.depthBuffer = !0, this._sceneToCubeUV(e, i, s, c, l), t > 0 && this._blur(c, 0, 0, t), this._applyPMREM(c), this._cleanup(c), c
   }
   fromEquirectangular(e, t = null) {
      return this._fromTexture(e, t)
   }
   fromCubemap(e, t = null) {
      return this._fromTexture(e, t)
   }
   compileCubemapShader() {
      this._cubemapMaterial === null && (this._cubemapMaterial = L3(), this._compileMaterial(this._cubemapMaterial))
   }
   compileEquirectangularShader() {
      this._equirectMaterial === null && (this._equirectMaterial = P3(), this._compileMaterial(this._equirectMaterial))
   }
   dispose() {
      this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose()
   }
   _setSize(e) {
      this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax)
   }
   _dispose() {
      this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
      for (let e = 0; e < this._lodPlanes.length; e++) this._lodPlanes[e].dispose()
   }
   _cleanup(e) {
      this._renderer.setRenderTarget(DM, NM, OM), this._renderer.xr.enabled = UM, e.scissorTest = !1, KS(e, 0, 0, e.width, e.height)
   }
   _fromTexture(e, t) {
      e.mapping === Uc || e.mapping === sh ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), DM = this._renderer.getRenderTarget(), NM = this._renderer.getActiveCubeFace(), OM = this._renderer.getActiveMipmapLevel(), UM = this._renderer.xr.enabled, this._renderer.xr.enabled = !1;
      const i = t || this._allocateTargets();
      return this._textureToCubeUV(e, i), this._applyPMREM(i), this._cleanup(i), i
   }
   _allocateTargets() {
      const e = 3 * Math.max(this._cubeSize, 112),
         t = 4 * this._cubeSize,
         i = {
            magFilter: Ni,
            minFilter: Ni,
            generateMipmaps: !1,
            type: lp,
            format: Lr,
            colorSpace: Gu,
            depthBuffer: !1
         },
         s = U3(e, t, i);
      if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
         this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = U3(e, t, i);
         const {
            _lodMax: r
         } = this;
         ({
            sizeLods: this._sizeLods,
            lodPlanes: this._lodPlanes,
            sigmas: this._sigmas
         } = j7(r)), this._blurMaterial = q7(r, e, t)
      }
      return s
   }
   _compileMaterial(e) {
      const t = new ds(this._lodPlanes[0], e);
      this._renderer.compile(t, CM)
   }
   _sceneToCubeUV(e, t, i, s, r) {
      const c = new Cs(90, 1, t, i),
         h = [1, -1, 1, 1, 1, 1],
         m = [1, 1, 1, -1, -1, -1],
         g = this._renderer,
         v = g.autoClear,
         x = g.toneMapping;
      g.getClearColor(N3), g.toneMapping = ho, g.autoClear = !1;
      const S = new Fc({
            name: "PMREM.Background",
            side: Ds,
            depthWrite: !1,
            depthTest: !1
         }),
         E = new ds(new up, S);
      let T = !1;
      const b = e.background;
      b ? b.isColor && (S.color.copy(b), e.background = null, T = !0) : (S.color.copy(N3), T = !0);
      for (let w = 0; w < 6; w++) {
         const C = w % 3;
         C === 0 ? (c.up.set(0, h[w], 0), c.position.set(r.x, r.y, r.z), c.lookAt(r.x + m[w], r.y, r.z)) : C === 1 ? (c.up.set(0, 0, h[w]), c.position.set(r.x, r.y, r.z), c.lookAt(r.x, r.y + m[w], r.z)) : (c.up.set(0, h[w], 0), c.position.set(r.x, r.y, r.z), c.lookAt(r.x, r.y, r.z + m[w]));
         const N = this._cubeSize;
         KS(s, C * N, w > 2 ? N : 0, N, N), g.setRenderTarget(s), T && g.render(E, c), g.render(e, c)
      }
      E.geometry.dispose(), E.material.dispose(), g.toneMapping = x, g.autoClear = v, e.background = b
   }
   _textureToCubeUV(e, t) {
      const i = this._renderer,
         s = e.mapping === Uc || e.mapping === sh;
      s ? (this._cubemapMaterial === null && (this._cubemapMaterial = L3()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = P3());
      const r = s ? this._cubemapMaterial : this._equirectMaterial,
         a = new ds(this._lodPlanes[0], r),
         l = r.uniforms;
      l.envMap.value = e;
      const c = this._cubeSize;
      KS(t, 0, 0, 3 * c, 2 * c), i.setRenderTarget(t), i.render(a, CM)
   }
   _applyPMREM(e) {
      const t = this._renderer,
         i = t.autoClear;
      t.autoClear = !1;
      const s = this._lodPlanes.length;
      for (let r = 1; r < s; r++) {
         const a = Math.sqrt(this._sigmas[r] * this._sigmas[r] - this._sigmas[r - 1] * this._sigmas[r - 1]),
            l = O3[(s - r - 1) % O3.length];
         this._blur(e, r - 1, r, a, l)
      }
      t.autoClear = i
   }
   _blur(e, t, i, s, r) {
      const a = this._pingPongRenderTarget;
      this._halfBlur(e, a, t, i, s, "latitudinal", r), this._halfBlur(a, e, i, i, s, "longitudinal", r)
   }
   _halfBlur(e, t, i, s, r, a, l) {
      const c = this._renderer,
         h = this._blurMaterial;
      a !== "latitudinal" && a !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
      const m = 3,
         g = new ds(this._lodPlanes[s], h),
         v = h.uniforms,
         x = this._sizeLods[i] - 1,
         S = isFinite(r) ? Math.PI / (2 * x) : 2 * Math.PI / (2 * Cd - 1),
         E = r / S,
         T = isFinite(r) ? 1 + Math.floor(m * E) : Cd;
      T > Cd && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${T} samples when the maximum is set to ${Cd}`);
      const b = [];
      let w = 0;
      for (let B = 0; B < Cd; ++B) {
         const I = B / E,
            O = Math.exp(-I * I / 2);
         b.push(O), B === 0 ? w += O : B < T && (w += 2 * O)
      }
      for (let B = 0; B < b.length; B++) b[B] = b[B] / w;
      v.envMap.value = e.texture, v.samples.value = T, v.weights.value = b, v.latitudinal.value = a === "latitudinal", l && (v.poleAxis.value = l);
      const {
         _lodMax: C
      } = this;
      v.dTheta.value = S, v.mipInt.value = C - i;
      const N = this._sizeLods[s],
         U = 3 * N * (s > C - Xm ? s - C + Xm : 0),
         z = 4 * (this._cubeSize - N);
      KS(t, U, z, 3 * N, 2 * N), c.setRenderTarget(t), c.render(g, CM)
   }
}

function j7(n) {
   const e = [],
      t = [],
      i = [];
   let s = n;
   const r = n - Xm + 1 + D3.length;
   for (let a = 0; a < r; a++) {
      const l = Math.pow(2, s);
      t.push(l);
      let c = 1 / l;
      a > n - Xm ? c = D3[a - n + Xm - 1] : a === 0 && (c = 0), i.push(c);
      const h = 1 / (l - 2),
         m = -h,
         g = 1 + h,
         v = [m, m, g, m, g, g, m, m, g, g, m, g],
         x = 6,
         S = 6,
         E = 3,
         T = 2,
         b = 1,
         w = new Float32Array(E * S * x),
         C = new Float32Array(T * S * x),
         N = new Float32Array(b * S * x);
      for (let z = 0; z < x; z++) {
         const B = z % 3 * 2 / 3 - 1,
            I = z > 2 ? 0 : -1,
            O = [B, I, 0, B + 2 / 3, I, 0, B + 2 / 3, I + 1, 0, B, I, 0, B + 2 / 3, I + 1, 0, B, I + 1, 0];
         w.set(O, E * S * z), C.set(v, T * S * z);
         const P = [z, z, z, z, z, z];
         N.set(P, b * S * z)
      }
      const U = new pn;
      U.setAttribute("position", new oi(w, E)), U.setAttribute("uv", new oi(C, T)), U.setAttribute("faceIndex", new oi(N, b)), e.push(U), s > Xm && s--
   }
   return {
      lodPlanes: e,
      sizeLods: t,
      sigmas: i
   }
}

function U3(n, e, t) {
   const i = new ss(n, e, t);
   return i.texture.mapping = Ug, i.texture.name = "PMREM.cubeUv", i.scissorTest = !0, i
}

function KS(n, e, t, i, s) {
   n.viewport.set(e, t, i, s), n.scissor.set(e, t, i, s)
}

function q7(n, e, t) {
   const i = new Float32Array(Cd),
      s = new ee(0, 1, 0);
   return new gs({
      name: "SphericalGaussianBlur",
      defines: {
         n: Cd,
         CUBEUV_TEXEL_WIDTH: 1 / e,
         CUBEUV_TEXEL_HEIGHT: 1 / t,
         CUBEUV_MAX_MIP: `${n}.0`
      },
      uniforms: {
         envMap: {
            value: null
         },
         samples: {
            value: 1
         },
         weights: {
            value: i
         },
         latitudinal: {
            value: !1
         },
         dTheta: {
            value: 0
         },
         mipInt: {
            value: 0
         },
         poleAxis: {
            value: s
         }
      },
      vertexShader: i2(),
      fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
      blending: nr,
      depthTest: !1,
      depthWrite: !1
   })
}

function P3() {
   return new gs({
      name: "EquirectangularToCubeUV",
      uniforms: {
         envMap: {
            value: null
         }
      },
      vertexShader: i2(),
      fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
      blending: nr,
      depthTest: !1,
      depthWrite: !1
   })
}

function L3() {
   return new gs({
      name: "CubemapToCubeUV",
      uniforms: {
         envMap: {
            value: null
         },
         flipEnvMap: {
            value: -1
         }
      },
      vertexShader: i2(),
      fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
      blending: nr,
      depthTest: !1,
      depthWrite: !1
   })
}

function i2() {
   return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
}

function X7(n) {
   let e = new WeakMap,
      t = null;

   function i(l) {
      if (l && l.isTexture) {
         const c = l.mapping,
            h = c === Ty || c === Ey,
            m = c === Uc || c === sh;
         if (h || m) {
            let g = e.get(l);
            const v = g !== void 0 ? g.texture.pmremVersion : 0;
            if (l.isRenderTargetTexture && l.pmremVersion !== v) return t === null && (t = new ew(n)), g = h ? t.fromEquirectangular(l, g) : t.fromCubemap(l, g), g.texture.pmremVersion = l.pmremVersion, e.set(l, g), g.texture;
            if (g !== void 0) return g.texture; {
               const x = l.image;
               return h && x && x.height > 0 || m && x && s(x) ? (t === null && (t = new ew(n)), g = h ? t.fromEquirectangular(l) : t.fromCubemap(l), g.texture.pmremVersion = l.pmremVersion, e.set(l, g), l.addEventListener("dispose", r), g.texture) : null
            }
         }
      }
      return l
   }

   function s(l) {
      let c = 0;
      const h = 6;
      for (let m = 0; m < h; m++) l[m] !== void 0 && c++;
      return c === h
   }

   function r(l) {
      const c = l.target;
      c.removeEventListener("dispose", r);
      const h = e.get(c);
      h !== void 0 && (e.delete(c), h.dispose())
   }

   function a() {
      e = new WeakMap, t !== null && (t.dispose(), t = null)
   }
   return {
      get: i,
      dispose: a
   }
}

function W7(n) {
   const e = {};

   function t(i) {
      if (e[i] !== void 0) return e[i];
      let s;
      switch (i) {
         case "WEBGL_depth_texture":
            s = n.getExtension("WEBGL_depth_texture") || n.getExtension("MOZ_WEBGL_depth_texture") || n.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
         case "EXT_texture_filter_anisotropic":
            s = n.getExtension("EXT_texture_filter_anisotropic") || n.getExtension("MOZ_EXT_texture_filter_anisotropic") || n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
         case "WEBGL_compressed_texture_s3tc":
            s = n.getExtension("WEBGL_compressed_texture_s3tc") || n.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
         case "WEBGL_compressed_texture_pvrtc":
            s = n.getExtension("WEBGL_compressed_texture_pvrtc") || n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
         default:
            s = n.getExtension(i)
      }
      return e[i] = s, s
   }
   return {
      has: function (i) {
         return t(i) !== null
      },
      init: function () {
         t("EXT_color_buffer_float"), t("WEBGL_clip_cull_distance"), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture"), t("WEBGL_render_shared_exponent")
      },
      get: function (i) {
         const s = t(i);
         return s === null && _b("THREE.WebGLRenderer: " + i + " extension not supported."), s
      }
   }
}

function Y7(n, e, t, i) {
   const s = {},
      r = new WeakMap;

   function a(g) {
      const v = g.target;
      v.index !== null && e.remove(v.index);
      for (const S in v.attributes) e.remove(v.attributes[S]);
      v.removeEventListener("dispose", a), delete s[v.id];
      const x = r.get(v);
      x && (e.remove(x), r.delete(v)), i.releaseStatesOfGeometry(v), v.isInstancedBufferGeometry === !0 && delete v._maxInstanceCount, t.memory.geometries--
   }

   function l(g, v) {
      return s[v.id] === !0 || (v.addEventListener("dispose", a), s[v.id] = !0, t.memory.geometries++), v
   }

   function c(g) {
      const v = g.attributes;
      for (const x in v) e.update(v[x], n.ARRAY_BUFFER)
   }

   function h(g) {
      const v = [],
         x = g.index,
         S = g.attributes.position;
      let E = 0;
      if (x !== null) {
         const w = x.array;
         E = x.version;
         for (let C = 0, N = w.length; C < N; C += 3) {
            const U = w[C + 0],
               z = w[C + 1],
               B = w[C + 2];
            v.push(U, z, z, B, B, U)
         }
      } else if (S !== void 0) {
         const w = S.array;
         E = S.version;
         for (let C = 0, N = w.length / 3 - 1; C < N; C += 3) {
            const U = C + 0,
               z = C + 1,
               B = C + 2;
            v.push(U, z, z, B, B, U)
         }
      } else return;
      const T = new(TL(v) ? OR : NR)(v, 1);
      T.version = E;
      const b = r.get(g);
      b && e.remove(b), r.set(g, T)
   }

   function m(g) {
      const v = r.get(g);
      if (v) {
         const x = g.index;
         x !== null && v.version < x.version && h(g)
      } else h(g);
      return r.get(g)
   }
   return {
      get: l,
      update: c,
      getWireframeAttribute: m
   }
}

function K7(n, e, t) {
   let i;

   function s(v) {
      i = v
   }
   let r, a;

   function l(v) {
      r = v.type, a = v.bytesPerElement
   }

   function c(v, x) {
      n.drawElements(i, x, r, v * a), t.update(x, i, 1)
   }

   function h(v, x, S) {
      S !== 0 && (n.drawElementsInstanced(i, x, r, v * a, S), t.update(x, i, S))
   }

   function m(v, x, S) {
      if (S === 0) return;
      e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(i, x, 0, r, v, 0, S);
      let T = 0;
      for (let b = 0; b < S; b++) T += x[b];
      t.update(T, i, 1)
   }

   function g(v, x, S, E) {
      if (S === 0) return;
      const T = e.get("WEBGL_multi_draw");
      if (T === null)
         for (let b = 0; b < v.length; b++) h(v[b] / a, x[b], E[b]);
      else {
         T.multiDrawElementsInstancedWEBGL(i, x, 0, r, v, 0, E, 0, S);
         let b = 0;
         for (let w = 0; w < S; w++) b += x[w] * E[w];
         t.update(b, i, 1)
      }
   }
   this.setMode = s, this.setIndex = l, this.render = c, this.renderInstances = h, this.renderMultiDraw = m, this.renderMultiDrawInstances = g
}

function Z7(n) {
   const e = {
         geometries: 0,
         textures: 0
      },
      t = {
         frame: 0,
         calls: 0,
         triangles: 0,
         points: 0,
         lines: 0
      };

   function i(r, a, l) {
      switch (t.calls++, a) {
         case n.TRIANGLES:
            t.triangles += l * (r / 3);
            break;
         case n.LINES:
            t.lines += l * (r / 2);
            break;
         case n.LINE_STRIP:
            t.lines += l * (r - 1);
            break;
         case n.LINE_LOOP:
            t.lines += l * r;
            break;
         case n.POINTS:
            t.points += l * r;
            break;
         default:
            console.error("THREE.WebGLInfo: Unknown draw mode:", a);
            break
      }
   }

   function s() {
      t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0
   }
   return {
      memory: e,
      render: t,
      programs: null,
      autoReset: !0,
      reset: s,
      update: i
   }
}

function Q7(n, e, t) {
   const i = new WeakMap,
      s = new Gn;

   function r(a, l, c) {
      const h = a.morphTargetInfluences,
         m = l.morphAttributes.position || l.morphAttributes.normal || l.morphAttributes.color,
         g = m !== void 0 ? m.length : 0;
      let v = i.get(l);
      if (v === void 0 || v.count !== g) {
         let P = function () {
            I.dispose(), i.delete(l), l.removeEventListener("dispose", P)
         };
         var x = P;
         v !== void 0 && v.texture.dispose();
         const S = l.morphAttributes.position !== void 0,
            E = l.morphAttributes.normal !== void 0,
            T = l.morphAttributes.color !== void 0,
            b = l.morphAttributes.position || [],
            w = l.morphAttributes.normal || [],
            C = l.morphAttributes.color || [];
         let N = 0;
         S === !0 && (N = 1), E === !0 && (N = 2), T === !0 && (N = 3);
         let U = l.attributes.position.count * N,
            z = 1;
         U > e.maxTextureSize && (z = Math.ceil(U / e.maxTextureSize), U = e.maxTextureSize);
         const B = new Float32Array(U * z * 4 * g),
            I = new dx(B, U, z, g);
         I.type = ha, I.needsUpdate = !0;
         const O = N * 4;
         for (let q = 0; q < g; q++) {
            const Q = b[q],
               $ = w[q],
               ae = C[q],
               fe = U * z * 4 * q;
            for (let k = 0; k < Q.count; k++) {
               const Z = k * O;
               S === !0 && (s.fromBufferAttribute(Q, k), B[fe + Z + 0] = s.x, B[fe + Z + 1] = s.y, B[fe + Z + 2] = s.z, B[fe + Z + 3] = 0), E === !0 && (s.fromBufferAttribute($, k), B[fe + Z + 4] = s.x, B[fe + Z + 5] = s.y, B[fe + Z + 6] = s.z, B[fe + Z + 7] = 0), T === !0 && (s.fromBufferAttribute(ae, k), B[fe + Z + 8] = s.x, B[fe + Z + 9] = s.y, B[fe + Z + 10] = s.z, B[fe + Z + 11] = ae.itemSize === 4 ? s.w : 1)
            }
         }
         v = {
            count: g,
            texture: I,
            size: new Fe(U, z)
         }, i.set(l, v), l.addEventListener("dispose", P)
      }
      if (a.isInstancedMesh === !0 && a.morphTexture !== null) c.getUniforms().setValue(n, "morphTexture", a.morphTexture, t);
      else {
         let S = 0;
         for (let T = 0; T < h.length; T++) S += h[T];
         const E = l.morphTargetsRelative ? 1 : 1 - S;
         c.getUniforms().setValue(n, "morphTargetBaseInfluence", E), c.getUniforms().setValue(n, "morphTargetInfluences", h)
      }
      c.getUniforms().setValue(n, "morphTargetsTexture", v.texture, t), c.getUniforms().setValue(n, "morphTargetsTextureSize", v.size)
   }
   return {
      update: r
   }
}

function J7(n, e, t, i) {
   let s = new WeakMap;

   function r(c) {
      const h = i.render.frame,
         m = c.geometry,
         g = e.get(c, m);
      if (s.get(g) !== h && (e.update(g), s.set(g, h)), c.isInstancedMesh && (c.hasEventListener("dispose", l) === !1 && c.addEventListener("dispose", l), s.get(c) !== h && (t.update(c.instanceMatrix, n.ARRAY_BUFFER), c.instanceColor !== null && t.update(c.instanceColor, n.ARRAY_BUFFER), s.set(c, h))), c.isSkinnedMesh) {
         const v = c.skeleton;
         s.get(v) !== h && (v.update(), s.set(v, h))
      }
      return g
   }

   function a() {
      s = new WeakMap
   }

   function l(c) {
      const h = c.target;
      h.removeEventListener("dispose", l), t.remove(h.instanceMatrix), h.instanceColor !== null && t.remove(h.instanceColor)
   }
   return {
      update: r,
      dispose: a
   }
}
const wB = new Hi,
   B3 = new vx(1, 1),
   RB = new dx,
   CB = new cT,
   DB = new mx,
   z3 = [],
   I3 = [],
   F3 = new Float32Array(16),
   H3 = new Float32Array(9),
   V3 = new Float32Array(4);

function zg(n, e, t) {
   const i = n[0];
   if (i <= 0 || i > 0) return n;
   const s = e * t;
   let r = z3[s];
   if (r === void 0 && (r = new Float32Array(s), z3[s] = r), e !== 0) {
      i.toArray(r, 0);
      for (let a = 1, l = 0; a !== e; ++a) l += t, n[a].toArray(r, l)
   }
   return r
}

function Xs(n, e) {
   if (n.length !== e.length) return !1;
   for (let t = 0, i = n.length; t < i; t++)
      if (n[t] !== e[t]) return !1;
   return !0
}

function Ws(n, e) {
   for (let t = 0, i = e.length; t < i; t++) n[t] = e[t]
}

function DT(n, e) {
   let t = I3[e];
   t === void 0 && (t = new Int32Array(e), I3[e] = t);
   for (let i = 0; i !== e; ++i) t[i] = n.allocateTextureUnit();
   return t
}

function $7(n, e) {
   const t = this.cache;
   t[0] !== e && (n.uniform1f(this.addr, e), t[0] = e)
}

function e9(n, e) {
   const t = this.cache;
   if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y) && (n.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
   else {
      if (Xs(t, e)) return;
      n.uniform2fv(this.addr, e), Ws(t, e)
   }
}

function t9(n, e) {
   const t = this.cache;
   if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
   else if (e.r !== void 0)(t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (n.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
   else {
      if (Xs(t, e)) return;
      n.uniform3fv(this.addr, e), Ws(t, e)
   }
}

function n9(n, e) {
   const t = this.cache;
   if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
   else {
      if (Xs(t, e)) return;
      n.uniform4fv(this.addr, e), Ws(t, e)
   }
}

function i9(n, e) {
   const t = this.cache,
      i = e.elements;
   if (i === void 0) {
      if (Xs(t, e)) return;
      n.uniformMatrix2fv(this.addr, !1, e), Ws(t, e)
   } else {
      if (Xs(t, i)) return;
      V3.set(i), n.uniformMatrix2fv(this.addr, !1, V3), Ws(t, i)
   }
}

function s9(n, e) {
   const t = this.cache,
      i = e.elements;
   if (i === void 0) {
      if (Xs(t, e)) return;
      n.uniformMatrix3fv(this.addr, !1, e), Ws(t, e)
   } else {
      if (Xs(t, i)) return;
      H3.set(i), n.uniformMatrix3fv(this.addr, !1, H3), Ws(t, i)
   }
}

function r9(n, e) {
   const t = this.cache,
      i = e.elements;
   if (i === void 0) {
      if (Xs(t, e)) return;
      n.uniformMatrix4fv(this.addr, !1, e), Ws(t, e)
   } else {
      if (Xs(t, i)) return;
      F3.set(i), n.uniformMatrix4fv(this.addr, !1, F3), Ws(t, i)
   }
}

function a9(n, e) {
   const t = this.cache;
   t[0] !== e && (n.uniform1i(this.addr, e), t[0] = e)
}

function o9(n, e) {
   const t = this.cache;
   if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y) && (n.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
   else {
      if (Xs(t, e)) return;
      n.uniform2iv(this.addr, e), Ws(t, e)
   }
}

function l9(n, e) {
   const t = this.cache;
   if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3i(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
   else {
      if (Xs(t, e)) return;
      n.uniform3iv(this.addr, e), Ws(t, e)
   }
}

function u9(n, e) {
   const t = this.cache;
   if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4i(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
   else {
      if (Xs(t, e)) return;
      n.uniform4iv(this.addr, e), Ws(t, e)
   }
}

function c9(n, e) {
   const t = this.cache;
   t[0] !== e && (n.uniform1ui(this.addr, e), t[0] = e)
}

function f9(n, e) {
   const t = this.cache;
   if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y) && (n.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
   else {
      if (Xs(t, e)) return;
      n.uniform2uiv(this.addr, e), Ws(t, e)
   }
}

function h9(n, e) {
   const t = this.cache;
   if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (n.uniform3ui(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
   else {
      if (Xs(t, e)) return;
      n.uniform3uiv(this.addr, e), Ws(t, e)
   }
}

function d9(n, e) {
   const t = this.cache;
   if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (n.uniform4ui(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
   else {
      if (Xs(t, e)) return;
      n.uniform4uiv(this.addr, e), Ws(t, e)
   }
}

function p9(n, e, t) {
   const i = this.cache,
      s = t.allocateTextureUnit();
   i[0] !== s && (n.uniform1i(this.addr, s), i[0] = s);
   let r;
   this.type === n.SAMPLER_2D_SHADOW ? (B3.compareFunction = CR, r = B3) : r = wB, t.setTexture2D(e || r, s)
}

function m9(n, e, t) {
   const i = this.cache,
      s = t.allocateTextureUnit();
   i[0] !== s && (n.uniform1i(this.addr, s), i[0] = s), t.setTexture3D(e || CB, s)
}

function g9(n, e, t) {
   const i = this.cache,
      s = t.allocateTextureUnit();
   i[0] !== s && (n.uniform1i(this.addr, s), i[0] = s), t.setTextureCube(e || DB, s)
}

function v9(n, e, t) {
   const i = this.cache,
      s = t.allocateTextureUnit();
   i[0] !== s && (n.uniform1i(this.addr, s), i[0] = s), t.setTexture2DArray(e || RB, s)
}

function y9(n) {
   switch (n) {
      case 5126:
         return $7;
      case 35664:
         return e9;
      case 35665:
         return t9;
      case 35666:
         return n9;
      case 35674:
         return i9;
      case 35675:
         return s9;
      case 35676:
         return r9;
      case 5124:
      case 35670:
         return a9;
      case 35667:
      case 35671:
         return o9;
      case 35668:
      case 35672:
         return l9;
      case 35669:
      case 35673:
         return u9;
      case 5125:
         return c9;
      case 36294:
         return f9;
      case 36295:
         return h9;
      case 36296:
         return d9;
      case 35678:
      case 36198:
      case 36298:
      case 36306:
      case 35682:
         return p9;
      case 35679:
      case 36299:
      case 36307:
         return m9;
      case 35680:
      case 36300:
      case 36308:
      case 36293:
         return g9;
      case 36289:
      case 36303:
      case 36311:
      case 36292:
         return v9
   }
}

function x9(n, e) {
   n.uniform1fv(this.addr, e)
}

function _9(n, e) {
   const t = zg(e, this.size, 2);
   n.uniform2fv(this.addr, t)
}

function S9(n, e) {
   const t = zg(e, this.size, 3);
   n.uniform3fv(this.addr, t)
}

function b9(n, e) {
   const t = zg(e, this.size, 4);
   n.uniform4fv(this.addr, t)
}

function T9(n, e) {
   const t = zg(e, this.size, 4);
   n.uniformMatrix2fv(this.addr, !1, t)
}

function E9(n, e) {
   const t = zg(e, this.size, 9);
   n.uniformMatrix3fv(this.addr, !1, t)
}

function M9(n, e) {
   const t = zg(e, this.size, 16);
   n.uniformMatrix4fv(this.addr, !1, t)
}

function A9(n, e) {
   n.uniform1iv(this.addr, e)
}

function w9(n, e) {
   n.uniform2iv(this.addr, e)
}

function R9(n, e) {
   n.uniform3iv(this.addr, e)
}

function C9(n, e) {
   n.uniform4iv(this.addr, e)
}

function D9(n, e) {
   n.uniform1uiv(this.addr, e)
}

function N9(n, e) {
   n.uniform2uiv(this.addr, e)
}

function O9(n, e) {
   n.uniform3uiv(this.addr, e)
}

function U9(n, e) {
   n.uniform4uiv(this.addr, e)
}

function P9(n, e, t) {
   const i = this.cache,
      s = e.length,
      r = DT(t, s);
   Xs(i, r) || (n.uniform1iv(this.addr, r), Ws(i, r));
   for (let a = 0; a !== s; ++a) t.setTexture2D(e[a] || wB, r[a])
}

function L9(n, e, t) {
   const i = this.cache,
      s = e.length,
      r = DT(t, s);
   Xs(i, r) || (n.uniform1iv(this.addr, r), Ws(i, r));
   for (let a = 0; a !== s; ++a) t.setTexture3D(e[a] || CB, r[a])
}

function B9(n, e, t) {
   const i = this.cache,
      s = e.length,
      r = DT(t, s);
   Xs(i, r) || (n.uniform1iv(this.addr, r), Ws(i, r));
   for (let a = 0; a !== s; ++a) t.setTextureCube(e[a] || DB, r[a])
}

function z9(n, e, t) {
   const i = this.cache,
      s = e.length,
      r = DT(t, s);
   Xs(i, r) || (n.uniform1iv(this.addr, r), Ws(i, r));
   for (let a = 0; a !== s; ++a) t.setTexture2DArray(e[a] || RB, r[a])
}

function I9(n) {
   switch (n) {
      case 5126:
         return x9;
      case 35664:
         return _9;
      case 35665:
         return S9;
      case 35666:
         return b9;
      case 35674:
         return T9;
      case 35675:
         return E9;
      case 35676:
         return M9;
      case 5124:
      case 35670:
         return A9;
      case 35667:
      case 35671:
         return w9;
      case 35668:
      case 35672:
         return R9;
      case 35669:
      case 35673:
         return C9;
      case 5125:
         return D9;
      case 36294:
         return N9;
      case 36295:
         return O9;
      case 36296:
         return U9;
      case 35678:
      case 36198:
      case 36298:
      case 36306:
      case 35682:
         return P9;
      case 35679:
      case 36299:
      case 36307:
         return L9;
      case 35680:
      case 36300:
      case 36308:
      case 36293:
         return B9;
      case 36289:
      case 36303:
      case 36311:
      case 36292:
         return z9
   }
}
class F9 {
   constructor(e, t, i) {
      this.id = e, this.addr = i, this.cache = [], this.type = t.type, this.setValue = y9(t.type)
   }
}
class H9 {
   constructor(e, t, i) {
      this.id = e, this.addr = i, this.cache = [], this.type = t.type, this.size = t.size, this.setValue = I9(t.type)
   }
}
class V9 {
   constructor(e) {
      this.id = e, this.seq = [], this.map = {}
   }
   setValue(e, t, i) {
      const s = this.seq;
      for (let r = 0, a = s.length; r !== a; ++r) {
         const l = s[r];
         l.setValue(e, t[l.id], i)
      }
   }
}
const PM = /(\w+)(\])?(\[|\.)?/g;

function G3(n, e) {
   n.seq.push(e), n.map[e.id] = e
}

function G9(n, e, t) {
   const i = n.name,
      s = i.length;
   for (PM.lastIndex = 0;;) {
      const r = PM.exec(i),
         a = PM.lastIndex;
      let l = r[1];
      const c = r[2] === "]",
         h = r[3];
      if (c && (l = l | 0), h === void 0 || h === "[" && a + 2 === s) {
         G3(t, h === void 0 ? new F9(l, n, e) : new H9(l, n, e));
         break
      } else {
         let g = t.map[l];
         g === void 0 && (g = new V9(l), G3(t, g)), t = g
      }
   }
}
class bb {
   constructor(e, t) {
      this.seq = [], this.map = {};
      const i = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
      for (let s = 0; s < i; ++s) {
         const r = e.getActiveUniform(t, s),
            a = e.getUniformLocation(t, r.name);
         G9(r, a, this)
      }
   }
   setValue(e, t, i, s) {
      const r = this.map[t];
      r !== void 0 && r.setValue(e, i, s)
   }
   setOptional(e, t, i) {
      const s = t[i];
      s !== void 0 && this.setValue(e, i, s)
   }
   static upload(e, t, i, s) {
      for (let r = 0, a = t.length; r !== a; ++r) {
         const l = t[r],
            c = i[l.id];
         c.needsUpdate !== !1 && l.setValue(e, c.value, s)
      }
   }
   static seqWithValue(e, t) {
      const i = [];
      for (let s = 0, r = e.length; s !== r; ++s) {
         const a = e[s];
         a.id in t && i.push(a)
      }
      return i
   }
}

function k3(n, e, t) {
   const i = n.createShader(e);
   return n.shaderSource(i, t), n.compileShader(i), i
}
const k9 = 37297;
let j9 = 0;

function q9(n, e) {
   const t = n.split(`
`),
      i = [],
      s = Math.max(e - 6, 0),
      r = Math.min(e + 6, t.length);
   for (let a = s; a < r; a++) {
      const l = a + 1;
      i.push(`${l===e?">":" "} ${l}: ${t[a]}`)
   }
   return i.join(`
`)
}
const j3 = new un;

function X9(n) {
   Vn._getMatrix(j3, Vn.workingColorSpace, n);
   const e = `mat3( ${j3.elements.map(t=>t.toFixed(4))} )`;
   switch (Vn.getTransfer(n)) {
      case Cy:
         return [e, "LinearTransferOETF"];
      case di:
         return [e, "sRGBTransferOETF"];
      default:
         return console.warn("THREE.WebGLProgram: Unsupported color space: ", n), [e, "LinearTransferOETF"]
   }
}

function q3(n, e, t) {
   const i = n.getShaderParameter(e, n.COMPILE_STATUS),
      s = n.getShaderInfoLog(e).trim();
   if (i && s === "") return "";
   const r = /ERROR: 0:(\d+)/.exec(s);
   if (r) {
      const a = parseInt(r[1]);
      return t.toUpperCase() + `

` + s + `

` + q9(n.getShaderSource(e), a)
   } else return s
}

function W9(n, e) {
   const t = X9(e);
   return [`vec4 ${n}( vec4 value ) {`, `	return ${t[1]}( vec4( value.rgb * ${t[0]}, value.a ) );`, "}"].join(`
`)
}

function Y9(n, e) {
   let t;
   switch (e) {
      case iL:
         t = "Linear";
         break;
      case sL:
         t = "Reinhard";
         break;
      case rL:
         t = "Cineon";
         break;
      case vR:
         t = "ACESFilmic";
         break;
      case oL:
         t = "AgX";
         break;
      case lL:
         t = "Neutral";
         break;
      case aL:
         t = "Custom";
         break;
      default:
         console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear"
   }
   return "vec3 " + n + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
}
const ZS = new ee;

function K9() {
   Vn.getLuminanceCoefficients(ZS);
   const n = ZS.x.toFixed(4),
      e = ZS.y.toFixed(4),
      t = ZS.z.toFixed(4);
   return ["float luminance( const in vec3 rgb ) {", `	const vec3 weights = vec3( ${n}, ${e}, ${t} );`, "	return dot( weights, rgb );", "}"].join(`
`)
}

function Z9(n) {
   return [n.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", n.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(C0).join(`
`)
}

function Q9(n) {
   const e = [];
   for (const t in n) {
      const i = n[t];
      i !== !1 && e.push("#define " + t + " " + i)
   }
   return e.join(`
`)
}

function J9(n, e) {
   const t = {},
      i = n.getProgramParameter(e, n.ACTIVE_ATTRIBUTES);
   for (let s = 0; s < i; s++) {
      const r = n.getActiveAttrib(e, s),
         a = r.name;
      let l = 1;
      r.type === n.FLOAT_MAT2 && (l = 2), r.type === n.FLOAT_MAT3 && (l = 3), r.type === n.FLOAT_MAT4 && (l = 4), t[a] = {
         type: r.type,
         location: n.getAttribLocation(e, a),
         locationSize: l
      }
   }
   return t
}

function C0(n) {
   return n !== ""
}

function X3(n, e) {
   const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
   return n.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
}

function W3(n, e) {
   return n.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
}
const $9 = /^[ \t]*#include +<([\w\d./]+)>/gm;

function tw(n) {
   return n.replace($9, tq)
}
const eq = new Map;

function tq(n, e) {
   let t = yn[e];
   if (t === void 0) {
      const i = eq.get(e);
      if (i !== void 0) t = yn[i], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, i);
      else throw new Error("Can not resolve #include <" + e + ">")
   }
   return tw(t)
}
const nq = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

function Y3(n) {
   return n.replace(nq, iq)
}

function iq(n, e, t, i) {
   let s = "";
   for (let r = parseInt(e); r < parseInt(t); r++) s += i.replace(/\[\s*i\s*\]/g, "[ " + r + " ]").replace(/UNROLLED_LOOP_INDEX/g, r);
   return s
}

function K3(n) {
   let e = `precision ${n.precision} float;
	precision ${n.precision} int;
	precision ${n.precision} sampler2D;
	precision ${n.precision} samplerCube;
	precision ${n.precision} sampler3D;
	precision ${n.precision} sampler2DArray;
	precision ${n.precision} sampler2DShadow;
	precision ${n.precision} samplerCubeShadow;
	precision ${n.precision} sampler2DArrayShadow;
	precision ${n.precision} isampler2D;
	precision ${n.precision} isampler3D;
	precision ${n.precision} isamplerCube;
	precision ${n.precision} isampler2DArray;
	precision ${n.precision} usampler2D;
	precision ${n.precision} usampler3D;
	precision ${n.precision} usamplerCube;
	precision ${n.precision} usampler2DArray;
	`;
   return n.precision === "highp" ? e += `
#define HIGH_PRECISION` : n.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : n.precision === "lowp" && (e += `
#define LOW_PRECISION`), e
}

function sq(n) {
   let e = "SHADOWMAP_TYPE_BASIC";
   return n.shadowMapType === eT ? e = "SHADOWMAP_TYPE_PCF" : n.shadowMapType === I0 ? e = "SHADOWMAP_TYPE_PCF_SOFT" : n.shadowMapType === Pl && (e = "SHADOWMAP_TYPE_VSM"), e
}

function rq(n) {
   let e = "ENVMAP_TYPE_CUBE";
   if (n.envMap) switch (n.envMapMode) {
      case Uc:
      case sh:
         e = "ENVMAP_TYPE_CUBE";
         break;
      case Ug:
         e = "ENVMAP_TYPE_CUBE_UV";
         break
   }
   return e
}

function aq(n) {
   let e = "ENVMAP_MODE_REFLECTION";
   if (n.envMap) switch (n.envMapMode) {
      case sh:
         e = "ENVMAP_MODE_REFRACTION";
         break
   }
   return e
}

function oq(n) {
   let e = "ENVMAP_BLENDING_NONE";
   if (n.envMap) switch (n.combine) {
      case fx:
         e = "ENVMAP_BLENDING_MULTIPLY";
         break;
      case tL:
         e = "ENVMAP_BLENDING_MIX";
         break;
      case nL:
         e = "ENVMAP_BLENDING_ADD";
         break
   }
   return e
}

function lq(n) {
   const e = n.envMapCubeUVHeight;
   if (e === null) return null;
   const t = Math.log2(e) - 2,
      i = 1 / e;
   return {
      texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
      texelHeight: i,
      maxMip: t
   }
}

function uq(n, e, t, i) {
   const s = n.getContext(),
      r = t.defines;
   let a = t.vertexShader,
      l = t.fragmentShader;
   const c = sq(t),
      h = rq(t),
      m = aq(t),
      g = oq(t),
      v = lq(t),
      x = Z9(t),
      S = Q9(r),
      E = s.createProgram();
   let T, b, w = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
   t.isRawShaderMaterial ? (T = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, S].filter(C0).join(`
`), T.length > 0 && (T += `
`), b = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, S].filter(C0).join(`
`), b.length > 0 && (b += `
`)) : (T = [K3(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, S, t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", t.batching ? "#define USE_BATCHING" : "", t.batchingColor ? "#define USE_BATCHING_COLOR" : "", t.instancing ? "#define USE_INSTANCING" : "", t.instancingColor ? "#define USE_INSTANCING_COLOR" : "", t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + m : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.mapUv ? "#define MAP_UV " + t.mapUv : "", t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "", t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "", t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "", t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "", t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "", t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "", t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "", t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "", t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "", t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "", t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "", t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "", t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "", t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "", t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "", t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "", t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "", t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "", t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "", t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "", t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "", t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.skinning ? "#define USE_SKINNING" : "", t.morphTargets ? "#define USE_MORPHTARGETS" : "", t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", t.morphColors ? "#define USE_MORPHCOLORS" : "", t.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "", t.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + c : "", t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "	uniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(C0).join(`
`), b = [K3(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, S, t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", t.map ? "#define USE_MAP" : "", t.matcap ? "#define USE_MATCAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + h : "", t.envMap ? "#define " + m : "", t.envMap ? "#define " + g : "", v ? "#define CUBEUV_TEXEL_WIDTH " + v.texelWidth : "", v ? "#define CUBEUV_TEXEL_HEIGHT " + v.texelHeight : "", v ? "#define CUBEUV_MAX_MIP " + v.maxMip + ".0" : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoat ? "#define USE_CLEARCOAT" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.dispersion ? "#define USE_DISPERSION" : "", t.iridescence ? "#define USE_IRIDESCENCE" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaTest ? "#define USE_ALPHATEST" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.sheen ? "#define USE_SHEEN" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors || t.instancingColor || t.batchingColor ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.gradientMap ? "#define USE_GRADIENTMAP" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + c : "", t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", t.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", t.toneMapping !== ho ? "#define TONE_MAPPING" : "", t.toneMapping !== ho ? yn.tonemapping_pars_fragment : "", t.toneMapping !== ho ? Y9("toneMapping", t.toneMapping) : "", t.dithering ? "#define DITHERING" : "", t.opaque ? "#define OPAQUE" : "", yn.colorspace_pars_fragment, W9("linearToOutputTexel", t.outputColorSpace), K9(), t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "", `
`].filter(C0).join(`
`)), a = tw(a), a = X3(a, t), a = W3(a, t), l = tw(l), l = X3(l, t), l = W3(l, t), a = Y3(a), l = Y3(l), t.isRawShaderMaterial !== !0 && (w = `#version 300 es
`, T = [x, "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + T, b = ["#define varying in", t.glslVersion === XA ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", t.glslVersion === XA ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + b);
   const C = w + T + a,
      N = w + b + l,
      U = k3(s, s.VERTEX_SHADER, C),
      z = k3(s, s.FRAGMENT_SHADER, N);
   s.attachShader(E, U), s.attachShader(E, z), t.index0AttributeName !== void 0 ? s.bindAttribLocation(E, 0, t.index0AttributeName) : t.morphTargets === !0 && s.bindAttribLocation(E, 0, "position"), s.linkProgram(E);

   function B(q) {
      if (n.debug.checkShaderErrors) {
         const Q = s.getProgramInfoLog(E).trim(),
            $ = s.getShaderInfoLog(U).trim(),
            ae = s.getShaderInfoLog(z).trim();
         let fe = !0,
            k = !0;
         if (s.getProgramParameter(E, s.LINK_STATUS) === !1)
            if (fe = !1, typeof n.debug.onShaderError == "function") n.debug.onShaderError(s, E, U, z);
            else {
               const Z = q3(s, U, "vertex"),
                  J = q3(s, z, "fragment");
               console.error("THREE.WebGLProgram: Shader Error " + s.getError() + " - VALIDATE_STATUS " + s.getProgramParameter(E, s.VALIDATE_STATUS) + `

Material Name: ` + q.name + `
Material Type: ` + q.type + `

Program Info Log: ` + Q + `
` + Z + `
` + J)
            }
         else Q !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", Q) : ($ === "" || ae === "") && (k = !1);
         k && (q.diagnostics = {
            runnable: fe,
            programLog: Q,
            vertexShader: {
               log: $,
               prefix: T
            },
            fragmentShader: {
               log: ae,
               prefix: b
            }
         })
      }
      s.deleteShader(U), s.deleteShader(z), I = new bb(s, E), O = J9(s, E)
   }
   let I;
   this.getUniforms = function () {
      return I === void 0 && B(this), I
   };
   let O;
   this.getAttributes = function () {
      return O === void 0 && B(this), O
   };
   let P = t.rendererExtensionParallelShaderCompile === !1;
   return this.isReady = function () {
      return P === !1 && (P = s.getProgramParameter(E, k9)), P
   }, this.destroy = function () {
      i.releaseStatesOfProgram(this), s.deleteProgram(E), this.program = void 0
   }, this.type = t.shaderType, this.name = t.shaderName, this.id = j9++, this.cacheKey = e, this.usedTimes = 1, this.program = E, this.vertexShader = U, this.fragmentShader = z, this
}
let cq = 0;
class fq {
   constructor() {
      this.shaderCache = new Map, this.materialCache = new Map
   }
   update(e) {
      const t = e.vertexShader,
         i = e.fragmentShader,
         s = this._getShaderStage(t),
         r = this._getShaderStage(i),
         a = this._getShaderCacheForMaterial(e);
      return a.has(s) === !1 && (a.add(s), s.usedTimes++), a.has(r) === !1 && (a.add(r), r.usedTimes++), this
   }
   remove(e) {
      const t = this.materialCache.get(e);
      for (const i of t) i.usedTimes--, i.usedTimes === 0 && this.shaderCache.delete(i.code);
      return this.materialCache.delete(e), this
   }
   getVertexShaderID(e) {
      return this._getShaderStage(e.vertexShader).id
   }
   getFragmentShaderID(e) {
      return this._getShaderStage(e.fragmentShader).id
   }
   dispose() {
      this.shaderCache.clear(), this.materialCache.clear()
   }
   _getShaderCacheForMaterial(e) {
      const t = this.materialCache;
      let i = t.get(e);
      return i === void 0 && (i = new Set, t.set(e, i)), i
   }
   _getShaderStage(e) {
      const t = this.shaderCache;
      let i = t.get(e);
      return i === void 0 && (i = new hq(e), t.set(e, i)), i
   }
}
class hq {
   constructor(e) {
      this.id = cq++, this.code = e, this.usedTimes = 0
   }
}

function dq(n, e, t, i, s, r, a) {
   const l = new dg,
      c = new fq,
      h = new Set,
      m = [],
      g = s.logarithmicDepthBuffer,
      v = s.vertexTextures;
   let x = s.precision;
   const S = {
      MeshDepthMaterial: "depth",
      MeshDistanceMaterial: "distanceRGBA",
      MeshNormalMaterial: "normal",
      MeshBasicMaterial: "basic",
      MeshLambertMaterial: "lambert",
      MeshPhongMaterial: "phong",
      MeshToonMaterial: "toon",
      MeshStandardMaterial: "physical",
      MeshPhysicalMaterial: "physical",
      MeshMatcapMaterial: "matcap",
      LineBasicMaterial: "basic",
      LineDashedMaterial: "dashed",
      PointsMaterial: "points",
      ShadowMaterial: "shadow",
      SpriteMaterial: "sprite"
   };

   function E(O) {
      return h.add(O), O === 0 ? "uv" : `uv${O}`
   }

   function T(O, P, q, Q, $) {
      const ae = Q.fog,
         fe = $.geometry,
         k = O.isMeshStandardMaterial ? Q.environment : null,
         Z = (O.isMeshStandardMaterial ? t : e).get(O.envMap || k),
         J = Z && Z.mapping === Ug ? Z.image.height : null,
         pe = S[O.type];
      O.precision !== null && (x = s.getMaxPrecision(O.precision), x !== O.precision && console.warn("THREE.WebGLProgram.getParameters:", O.precision, "not supported, using", x, "instead."));
      const F = fe.morphAttributes.position || fe.morphAttributes.normal || fe.morphAttributes.color,
         ie = F !== void 0 ? F.length : 0;
      let ye = 0;
      fe.morphAttributes.position !== void 0 && (ye = 1), fe.morphAttributes.normal !== void 0 && (ye = 2), fe.morphAttributes.color !== void 0 && (ye = 3);
      let we, oe, be, Pe;
      if (pe) {
         const ut = Ll[pe];
         we = ut.vertexShader, oe = ut.fragmentShader
      } else we = O.vertexShader, oe = O.fragmentShader, c.update(O), be = c.getVertexShaderID(O), Pe = c.getFragmentShaderID(O);
      const Ge = n.getRenderTarget(),
         Xe = n.state.buffers.depth.getReversed(),
         yt = $.isInstancedMesh === !0,
         vt = $.isBatchedMesh === !0,
         Mt = !!O.map,
         zt = !!O.matcap,
         lt = !!Z,
         ne = !!O.aoMap,
         sn = !!O.lightMap,
         ze = !!O.bumpMap,
         te = !!O.normalMap,
         Be = !!O.displacementMap,
         Je = !!O.emissiveMap,
         Ue = !!O.metalnessMap,
         K = !!O.roughnessMap,
         G = O.anisotropy > 0,
         me = O.clearcoat > 0,
         Ne = O.dispersion > 0,
         Oe = O.iridescence > 0,
         De = O.sheen > 0,
         Ye = O.transmission > 0,
         We = G && !!O.anisotropyMap,
         Ze = me && !!O.clearcoatMap,
         kt = me && !!O.clearcoatNormalMap,
         Ke = me && !!O.clearcoatRoughnessMap,
         et = Oe && !!O.iridescenceMap,
         xt = Oe && !!O.iridescenceThicknessMap,
         mt = De && !!O.sheenColorMap,
         it = De && !!O.sheenRoughnessMap,
         jt = !!O.specularMap,
         Rt = !!O.specularColorMap,
         cn = !!O.specularIntensityMap,
         le = Ye && !!O.transmissionMap,
         rt = Ye && !!O.thicknessMap,
         Re = !!O.gradientMap,
         Ie = !!O.alphaMap,
         nt = O.alphaTest > 0,
         at = !!O.alphaHash,
         Bt = !!O.extensions;
      let mn = ho;
      O.toneMapped && (Ge === null || Ge.isXRRenderTarget === !0) && (mn = n.toneMapping);
      const Yn = {
         shaderID: pe,
         shaderType: O.type,
         shaderName: O.name,
         vertexShader: we,
         fragmentShader: oe,
         defines: O.defines,
         customVertexShaderID: be,
         customFragmentShaderID: Pe,
         isRawShaderMaterial: O.isRawShaderMaterial === !0,
         glslVersion: O.glslVersion,
         precision: x,
         batching: vt,
         batchingColor: vt && $._colorsTexture !== null,
         instancing: yt,
         instancingColor: yt && $.instanceColor !== null,
         instancingMorph: yt && $.morphTexture !== null,
         supportsVertexTextures: v,
         outputColorSpace: Ge === null ? n.outputColorSpace : Ge.isXRRenderTarget === !0 ? Ge.texture.colorSpace : Gu,
         alphaToCoverage: !!O.alphaToCoverage,
         map: Mt,
         matcap: zt,
         envMap: lt,
         envMapMode: lt && Z.mapping,
         envMapCubeUVHeight: J,
         aoMap: ne,
         lightMap: sn,
         bumpMap: ze,
         normalMap: te,
         displacementMap: v && Be,
         emissiveMap: Je,
         normalMapObjectSpace: te && O.normalMapType === pL,
         normalMapTangentSpace: te && O.normalMapType === fh,
         metalnessMap: Ue,
         roughnessMap: K,
         anisotropy: G,
         anisotropyMap: We,
         clearcoat: me,
         clearcoatMap: Ze,
         clearcoatNormalMap: kt,
         clearcoatRoughnessMap: Ke,
         dispersion: Ne,
         iridescence: Oe,
         iridescenceMap: et,
         iridescenceThicknessMap: xt,
         sheen: De,
         sheenColorMap: mt,
         sheenRoughnessMap: it,
         specularMap: jt,
         specularColorMap: Rt,
         specularIntensityMap: cn,
         transmission: Ye,
         transmissionMap: le,
         thicknessMap: rt,
         gradientMap: Re,
         opaque: O.transparent === !1 && O.blending === Fd && O.alphaToCoverage === !1,
         alphaMap: Ie,
         alphaTest: nt,
         alphaHash: at,
         combine: O.combine,
         mapUv: Mt && E(O.map.channel),
         aoMapUv: ne && E(O.aoMap.channel),
         lightMapUv: sn && E(O.lightMap.channel),
         bumpMapUv: ze && E(O.bumpMap.channel),
         normalMapUv: te && E(O.normalMap.channel),
         displacementMapUv: Be && E(O.displacementMap.channel),
         emissiveMapUv: Je && E(O.emissiveMap.channel),
         metalnessMapUv: Ue && E(O.metalnessMap.channel),
         roughnessMapUv: K && E(O.roughnessMap.channel),
         anisotropyMapUv: We && E(O.anisotropyMap.channel),
         clearcoatMapUv: Ze && E(O.clearcoatMap.channel),
         clearcoatNormalMapUv: kt && E(O.clearcoatNormalMap.channel),
         clearcoatRoughnessMapUv: Ke && E(O.clearcoatRoughnessMap.channel),
         iridescenceMapUv: et && E(O.iridescenceMap.channel),
         iridescenceThicknessMapUv: xt && E(O.iridescenceThicknessMap.channel),
         sheenColorMapUv: mt && E(O.sheenColorMap.channel),
         sheenRoughnessMapUv: it && E(O.sheenRoughnessMap.channel),
         specularMapUv: jt && E(O.specularMap.channel),
         specularColorMapUv: Rt && E(O.specularColorMap.channel),
         specularIntensityMapUv: cn && E(O.specularIntensityMap.channel),
         transmissionMapUv: le && E(O.transmissionMap.channel),
         thicknessMapUv: rt && E(O.thicknessMap.channel),
         alphaMapUv: Ie && E(O.alphaMap.channel),
         vertexTangents: !!fe.attributes.tangent && (te || G),
         vertexColors: O.vertexColors,
         vertexAlphas: O.vertexColors === !0 && !!fe.attributes.color && fe.attributes.color.itemSize === 4,
         pointsUvs: $.isPoints === !0 && !!fe.attributes.uv && (Mt || Ie),
         fog: !!ae,
         useFog: O.fog === !0,
         fogExp2: !!ae && ae.isFogExp2,
         flatShading: O.flatShading === !0,
         sizeAttenuation: O.sizeAttenuation === !0,
         logarithmicDepthBuffer: g,
         reverseDepthBuffer: Xe,
         skinning: $.isSkinnedMesh === !0,
         morphTargets: fe.morphAttributes.position !== void 0,
         morphNormals: fe.morphAttributes.normal !== void 0,
         morphColors: fe.morphAttributes.color !== void 0,
         morphTargetsCount: ie,
         morphTextureStride: ye,
         numDirLights: P.directional.length,
         numPointLights: P.point.length,
         numSpotLights: P.spot.length,
         numSpotLightMaps: P.spotLightMap.length,
         numRectAreaLights: P.rectArea.length,
         numHemiLights: P.hemi.length,
         numDirLightShadows: P.directionalShadowMap.length,
         numPointLightShadows: P.pointShadowMap.length,
         numSpotLightShadows: P.spotShadowMap.length,
         numSpotLightShadowsWithMaps: P.numSpotLightShadowsWithMaps,
         numLightProbes: P.numLightProbes,
         numClippingPlanes: a.numPlanes,
         numClipIntersection: a.numIntersection,
         dithering: O.dithering,
         shadowMapEnabled: n.shadowMap.enabled && q.length > 0,
         shadowMapType: n.shadowMap.type,
         toneMapping: mn,
         decodeVideoTexture: Mt && O.map.isVideoTexture === !0 && Vn.getTransfer(O.map.colorSpace) === di,
         decodeVideoTextureEmissive: Je && O.emissiveMap.isVideoTexture === !0 && Vn.getTransfer(O.emissiveMap.colorSpace) === di,
         premultipliedAlpha: O.premultipliedAlpha,
         doubleSided: O.side === Ua,
         flipSided: O.side === Ds,
         useDepthPacking: O.depthPacking >= 0,
         depthPacking: O.depthPacking || 0,
         index0AttributeName: O.index0AttributeName,
         extensionClipCullDistance: Bt && O.extensions.clipCullDistance === !0 && i.has("WEBGL_clip_cull_distance"),
         extensionMultiDraw: (Bt && O.extensions.multiDraw === !0 || vt) && i.has("WEBGL_multi_draw"),
         rendererExtensionParallelShaderCompile: i.has("KHR_parallel_shader_compile"),
         customProgramCacheKey: O.customProgramCacheKey()
      };
      return Yn.vertexUv1s = h.has(1), Yn.vertexUv2s = h.has(2), Yn.vertexUv3s = h.has(3), h.clear(), Yn
   }

   function b(O) {
      const P = [];
      if (O.shaderID ? P.push(O.shaderID) : (P.push(O.customVertexShaderID), P.push(O.customFragmentShaderID)), O.defines !== void 0)
         for (const q in O.defines) P.push(q), P.push(O.defines[q]);
      return O.isRawShaderMaterial === !1 && (w(P, O), C(P, O), P.push(n.outputColorSpace)), P.push(O.customProgramCacheKey), P.join()
   }

   function w(O, P) {
      O.push(P.precision), O.push(P.outputColorSpace), O.push(P.envMapMode), O.push(P.envMapCubeUVHeight), O.push(P.mapUv), O.push(P.alphaMapUv), O.push(P.lightMapUv), O.push(P.aoMapUv), O.push(P.bumpMapUv), O.push(P.normalMapUv), O.push(P.displacementMapUv), O.push(P.emissiveMapUv), O.push(P.metalnessMapUv), O.push(P.roughnessMapUv), O.push(P.anisotropyMapUv), O.push(P.clearcoatMapUv), O.push(P.clearcoatNormalMapUv), O.push(P.clearcoatRoughnessMapUv), O.push(P.iridescenceMapUv), O.push(P.iridescenceThicknessMapUv), O.push(P.sheenColorMapUv), O.push(P.sheenRoughnessMapUv), O.push(P.specularMapUv), O.push(P.specularColorMapUv), O.push(P.specularIntensityMapUv), O.push(P.transmissionMapUv), O.push(P.thicknessMapUv), O.push(P.combine), O.push(P.fogExp2), O.push(P.sizeAttenuation), O.push(P.morphTargetsCount), O.push(P.morphAttributeCount), O.push(P.numDirLights), O.push(P.numPointLights), O.push(P.numSpotLights), O.push(P.numSpotLightMaps), O.push(P.numHemiLights), O.push(P.numRectAreaLights), O.push(P.numDirLightShadows), O.push(P.numPointLightShadows), O.push(P.numSpotLightShadows), O.push(P.numSpotLightShadowsWithMaps), O.push(P.numLightProbes), O.push(P.shadowMapType), O.push(P.toneMapping), O.push(P.numClippingPlanes), O.push(P.numClipIntersection), O.push(P.depthPacking)
   }

   function C(O, P) {
      l.disableAll(), P.supportsVertexTextures && l.enable(0), P.instancing && l.enable(1), P.instancingColor && l.enable(2), P.instancingMorph && l.enable(3), P.matcap && l.enable(4), P.envMap && l.enable(5), P.normalMapObjectSpace && l.enable(6), P.normalMapTangentSpace && l.enable(7), P.clearcoat && l.enable(8), P.iridescence && l.enable(9), P.alphaTest && l.enable(10), P.vertexColors && l.enable(11), P.vertexAlphas && l.enable(12), P.vertexUv1s && l.enable(13), P.vertexUv2s && l.enable(14), P.vertexUv3s && l.enable(15), P.vertexTangents && l.enable(16), P.anisotropy && l.enable(17), P.alphaHash && l.enable(18), P.batching && l.enable(19), P.dispersion && l.enable(20), P.batchingColor && l.enable(21), O.push(l.mask), l.disableAll(), P.fog && l.enable(0), P.useFog && l.enable(1), P.flatShading && l.enable(2), P.logarithmicDepthBuffer && l.enable(3), P.reverseDepthBuffer && l.enable(4), P.skinning && l.enable(5), P.morphTargets && l.enable(6), P.morphNormals && l.enable(7), P.morphColors && l.enable(8), P.premultipliedAlpha && l.enable(9), P.shadowMapEnabled && l.enable(10), P.doubleSided && l.enable(11), P.flipSided && l.enable(12), P.useDepthPacking && l.enable(13), P.dithering && l.enable(14), P.transmission && l.enable(15), P.sheen && l.enable(16), P.opaque && l.enable(17), P.pointsUvs && l.enable(18), P.decodeVideoTexture && l.enable(19), P.decodeVideoTextureEmissive && l.enable(20), P.alphaToCoverage && l.enable(21), O.push(l.mask)
   }

   function N(O) {
      const P = S[O.type];
      let q;
      if (P) {
         const Q = Ll[P];
         q = RL.clone(Q.uniforms)
      } else q = O.uniforms;
      return q
   }

   function U(O, P) {
      let q;
      for (let Q = 0, $ = m.length; Q < $; Q++) {
         const ae = m[Q];
         if (ae.cacheKey === P) {
            q = ae, ++q.usedTimes;
            break
         }
      }
      return q === void 0 && (q = new uq(n, P, O, r), m.push(q)), q
   }

   function z(O) {
      if (--O.usedTimes === 0) {
         const P = m.indexOf(O);
         m[P] = m[m.length - 1], m.pop(), O.destroy()
      }
   }

   function B(O) {
      c.remove(O)
   }

   function I() {
      c.dispose()
   }
   return {
      getParameters: T,
      getProgramCacheKey: b,
      getUniforms: N,
      acquireProgram: U,
      releaseProgram: z,
      releaseShaderCache: B,
      programs: m,
      dispose: I
   }
}

function pq() {
   let n = new WeakMap;

   function e(a) {
      return n.has(a)
   }

   function t(a) {
      let l = n.get(a);
      return l === void 0 && (l = {}, n.set(a, l)), l
   }

   function i(a) {
      n.delete(a)
   }

   function s(a, l, c) {
      n.get(a)[l] = c
   }

   function r() {
      n = new WeakMap
   }
   return {
      has: e,
      get: t,
      remove: i,
      update: s,
      dispose: r
   }
}

function mq(n, e) {
   return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.material.id !== e.material.id ? n.material.id - e.material.id : n.z !== e.z ? n.z - e.z : n.id - e.id
}

function Z3(n, e) {
   return n.groupOrder !== e.groupOrder ? n.groupOrder - e.groupOrder : n.renderOrder !== e.renderOrder ? n.renderOrder - e.renderOrder : n.z !== e.z ? e.z - n.z : n.id - e.id
}

function Q3() {
   const n = [];
   let e = 0;
   const t = [],
      i = [],
      s = [];

   function r() {
      e = 0, t.length = 0, i.length = 0, s.length = 0
   }

   function a(g, v, x, S, E, T) {
      let b = n[e];
      return b === void 0 ? (b = {
         id: g.id,
         object: g,
         geometry: v,
         material: x,
         groupOrder: S,
         renderOrder: g.renderOrder,
         z: E,
         group: T
      }, n[e] = b) : (b.id = g.id, b.object = g, b.geometry = v, b.material = x, b.groupOrder = S, b.renderOrder = g.renderOrder, b.z = E, b.group = T), e++, b
   }

   function l(g, v, x, S, E, T) {
      const b = a(g, v, x, S, E, T);
      x.transmission > 0 ? i.push(b) : x.transparent === !0 ? s.push(b) : t.push(b)
   }

   function c(g, v, x, S, E, T) {
      const b = a(g, v, x, S, E, T);
      x.transmission > 0 ? i.unshift(b) : x.transparent === !0 ? s.unshift(b) : t.unshift(b)
   }

   function h(g, v) {
      t.length > 1 && t.sort(g || mq), i.length > 1 && i.sort(v || Z3), s.length > 1 && s.sort(v || Z3)
   }

   function m() {
      for (let g = e, v = n.length; g < v; g++) {
         const x = n[g];
         if (x.id === null) break;
         x.id = null, x.object = null, x.geometry = null, x.material = null, x.group = null
      }
   }
   return {
      opaque: t,
      transmissive: i,
      transparent: s,
      init: r,
      push: l,
      unshift: c,
      finish: m,
      sort: h
   }
}

function gq() {
   let n = new WeakMap;

   function e(i, s) {
      const r = n.get(i);
      let a;
      return r === void 0 ? (a = new Q3, n.set(i, [a])) : s >= r.length ? (a = new Q3, r.push(a)) : a = r[s], a
   }

   function t() {
      n = new WeakMap
   }
   return {
      get: e,
      dispose: t
   }
}

function vq() {
   const n = {};
   return {
      get: function (e) {
         if (n[e.id] !== void 0) return n[e.id];
         let t;
         switch (e.type) {
            case "DirectionalLight":
               t = {
                  direction: new ee,
                  color: new dt
               };
               break;
            case "SpotLight":
               t = {
                  position: new ee,
                  direction: new ee,
                  color: new dt,
                  distance: 0,
                  coneCos: 0,
                  penumbraCos: 0,
                  decay: 0
               };
               break;
            case "PointLight":
               t = {
                  position: new ee,
                  color: new dt,
                  distance: 0,
                  decay: 0
               };
               break;
            case "HemisphereLight":
               t = {
                  direction: new ee,
                  skyColor: new dt,
                  groundColor: new dt
               };
               break;
            case "RectAreaLight":
               t = {
                  color: new dt,
                  position: new ee,
                  halfWidth: new ee,
                  halfHeight: new ee
               };
               break
         }
         return n[e.id] = t, t
      }
   }
}

function yq() {
   const n = {};
   return {
      get: function (e) {
         if (n[e.id] !== void 0) return n[e.id];
         let t;
         switch (e.type) {
            case "DirectionalLight":
               t = {
                  shadowIntensity: 1,
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new Fe
               };
               break;
            case "SpotLight":
               t = {
                  shadowIntensity: 1,
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new Fe
               };
               break;
            case "PointLight":
               t = {
                  shadowIntensity: 1,
                  shadowBias: 0,
                  shadowNormalBias: 0,
                  shadowRadius: 1,
                  shadowMapSize: new Fe,
                  shadowCameraNear: 1,
                  shadowCameraFar: 1e3
               };
               break
         }
         return n[e.id] = t, t
      }
   }
}
let xq = 0;

function _q(n, e) {
   return (e.castShadow ? 2 : 0) - (n.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (n.map ? 1 : 0)
}

function Sq(n) {
   const e = new vq,
      t = yq(),
      i = {
         version: 0,
         hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1,
            numSpotMaps: -1,
            numLightProbes: -1
         },
         ambient: [0, 0, 0],
         probe: [],
         directional: [],
         directionalShadow: [],
         directionalShadowMap: [],
         directionalShadowMatrix: [],
         spot: [],
         spotLightMap: [],
         spotShadow: [],
         spotShadowMap: [],
         spotLightMatrix: [],
         rectArea: [],
         rectAreaLTC1: null,
         rectAreaLTC2: null,
         point: [],
         pointShadow: [],
         pointShadowMap: [],
         pointShadowMatrix: [],
         hemi: [],
         numSpotLightShadowsWithMaps: 0,
         numLightProbes: 0
      };
   for (let h = 0; h < 9; h++) i.probe.push(new ee);
   const s = new ee,
      r = new Zt,
      a = new Zt;

   function l(h) {
      let m = 0,
         g = 0,
         v = 0;
      for (let O = 0; O < 9; O++) i.probe[O].set(0, 0, 0);
      let x = 0,
         S = 0,
         E = 0,
         T = 0,
         b = 0,
         w = 0,
         C = 0,
         N = 0,
         U = 0,
         z = 0,
         B = 0;
      h.sort(_q);
      for (let O = 0, P = h.length; O < P; O++) {
         const q = h[O],
            Q = q.color,
            $ = q.intensity,
            ae = q.distance,
            fe = q.shadow && q.shadow.map ? q.shadow.map.texture : null;
         if (q.isAmbientLight) m += Q.r * $, g += Q.g * $, v += Q.b * $;
         else if (q.isLightProbe) {
            for (let k = 0; k < 9; k++) i.probe[k].addScaledVector(q.sh.coefficients[k], $);
            B++
         } else if (q.isDirectionalLight) {
            const k = e.get(q);
            if (k.color.copy(q.color).multiplyScalar(q.intensity), q.castShadow) {
               const Z = q.shadow,
                  J = t.get(q);
               J.shadowIntensity = Z.intensity, J.shadowBias = Z.bias, J.shadowNormalBias = Z.normalBias, J.shadowRadius = Z.radius, J.shadowMapSize = Z.mapSize, i.directionalShadow[x] = J, i.directionalShadowMap[x] = fe, i.directionalShadowMatrix[x] = q.shadow.matrix, w++
            }
            i.directional[x] = k, x++
         } else if (q.isSpotLight) {
            const k = e.get(q);
            k.position.setFromMatrixPosition(q.matrixWorld), k.color.copy(Q).multiplyScalar($), k.distance = ae, k.coneCos = Math.cos(q.angle), k.penumbraCos = Math.cos(q.angle * (1 - q.penumbra)), k.decay = q.decay, i.spot[E] = k;
            const Z = q.shadow;
            if (q.map && (i.spotLightMap[U] = q.map, U++, Z.updateMatrices(q), q.castShadow && z++), i.spotLightMatrix[E] = Z.matrix, q.castShadow) {
               const J = t.get(q);
               J.shadowIntensity = Z.intensity, J.shadowBias = Z.bias, J.shadowNormalBias = Z.normalBias, J.shadowRadius = Z.radius, J.shadowMapSize = Z.mapSize, i.spotShadow[E] = J, i.spotShadowMap[E] = fe, N++
            }
            E++
         } else if (q.isRectAreaLight) {
            const k = e.get(q);
            k.color.copy(Q).multiplyScalar($), k.halfWidth.set(q.width * .5, 0, 0), k.halfHeight.set(0, q.height * .5, 0), i.rectArea[T] = k, T++
         } else if (q.isPointLight) {
            const k = e.get(q);
            if (k.color.copy(q.color).multiplyScalar(q.intensity), k.distance = q.distance, k.decay = q.decay, q.castShadow) {
               const Z = q.shadow,
                  J = t.get(q);
               J.shadowIntensity = Z.intensity, J.shadowBias = Z.bias, J.shadowNormalBias = Z.normalBias, J.shadowRadius = Z.radius, J.shadowMapSize = Z.mapSize, J.shadowCameraNear = Z.camera.near, J.shadowCameraFar = Z.camera.far, i.pointShadow[S] = J, i.pointShadowMap[S] = fe, i.pointShadowMatrix[S] = q.shadow.matrix, C++
            }
            i.point[S] = k, S++
         } else if (q.isHemisphereLight) {
            const k = e.get(q);
            k.skyColor.copy(q.color).multiplyScalar($), k.groundColor.copy(q.groundColor).multiplyScalar($), i.hemi[b] = k, b++
         }
      }
      T > 0 && (n.has("OES_texture_float_linear") === !0 ? (i.rectAreaLTC1 = ht.LTC_FLOAT_1, i.rectAreaLTC2 = ht.LTC_FLOAT_2) : (i.rectAreaLTC1 = ht.LTC_HALF_1, i.rectAreaLTC2 = ht.LTC_HALF_2)), i.ambient[0] = m, i.ambient[1] = g, i.ambient[2] = v;
      const I = i.hash;
      (I.directionalLength !== x || I.pointLength !== S || I.spotLength !== E || I.rectAreaLength !== T || I.hemiLength !== b || I.numDirectionalShadows !== w || I.numPointShadows !== C || I.numSpotShadows !== N || I.numSpotMaps !== U || I.numLightProbes !== B) && (i.directional.length = x, i.spot.length = E, i.rectArea.length = T, i.point.length = S, i.hemi.length = b, i.directionalShadow.length = w, i.directionalShadowMap.length = w, i.pointShadow.length = C, i.pointShadowMap.length = C, i.spotShadow.length = N, i.spotShadowMap.length = N, i.directionalShadowMatrix.length = w, i.pointShadowMatrix.length = C, i.spotLightMatrix.length = N + U - z, i.spotLightMap.length = U, i.numSpotLightShadowsWithMaps = z, i.numLightProbes = B, I.directionalLength = x, I.pointLength = S, I.spotLength = E, I.rectAreaLength = T, I.hemiLength = b, I.numDirectionalShadows = w, I.numPointShadows = C, I.numSpotShadows = N, I.numSpotMaps = U, I.numLightProbes = B, i.version = xq++)
   }

   function c(h, m) {
      let g = 0,
         v = 0,
         x = 0,
         S = 0,
         E = 0;
      const T = m.matrixWorldInverse;
      for (let b = 0, w = h.length; b < w; b++) {
         const C = h[b];
         if (C.isDirectionalLight) {
            const N = i.directional[g];
            N.direction.setFromMatrixPosition(C.matrixWorld), s.setFromMatrixPosition(C.target.matrixWorld), N.direction.sub(s), N.direction.transformDirection(T), g++
         } else if (C.isSpotLight) {
            const N = i.spot[x];
            N.position.setFromMatrixPosition(C.matrixWorld), N.position.applyMatrix4(T), N.direction.setFromMatrixPosition(C.matrixWorld), s.setFromMatrixPosition(C.target.matrixWorld), N.direction.sub(s), N.direction.transformDirection(T), x++
         } else if (C.isRectAreaLight) {
            const N = i.rectArea[S];
            N.position.setFromMatrixPosition(C.matrixWorld), N.position.applyMatrix4(T), a.identity(), r.copy(C.matrixWorld), r.premultiply(T), a.extractRotation(r), N.halfWidth.set(C.width * .5, 0, 0), N.halfHeight.set(0, C.height * .5, 0), N.halfWidth.applyMatrix4(a), N.halfHeight.applyMatrix4(a), S++
         } else if (C.isPointLight) {
            const N = i.point[v];
            N.position.setFromMatrixPosition(C.matrixWorld), N.position.applyMatrix4(T), v++
         } else if (C.isHemisphereLight) {
            const N = i.hemi[E];
            N.direction.setFromMatrixPosition(C.matrixWorld), N.direction.transformDirection(T), E++
         }
      }
   }
   return {
      setup: l,
      setupView: c,
      state: i
   }
}

function J3(n) {
   const e = new Sq(n),
      t = [],
      i = [];

   function s(m) {
      h.camera = m, t.length = 0, i.length = 0
   }

   function r(m) {
      t.push(m)
   }

   function a(m) {
      i.push(m)
   }

   function l() {
      e.setup(t)
   }

   function c(m) {
      e.setupView(t, m)
   }
   const h = {
      lightsArray: t,
      shadowsArray: i,
      camera: null,
      lights: e,
      transmissionRenderTarget: {}
   };
   return {
      init: s,
      state: h,
      setupLights: l,
      setupLightsView: c,
      pushLight: r,
      pushShadow: a
   }
}

function bq(n) {
   let e = new WeakMap;

   function t(s, r = 0) {
      const a = e.get(s);
      let l;
      return a === void 0 ? (l = new J3(n), e.set(s, [l])) : r >= a.length ? (l = new J3(n), a.push(l)) : l = a[r], l
   }

   function i() {
      e = new WeakMap
   }
   return {
      get: t,
      dispose: i
   }
}
const Tq = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
   Eq = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;

function Mq(n, e, t) {
   let i = new gx;
   const s = new Fe,
      r = new Fe,
      a = new Gn,
      l = new jR({
         depthPacking: dL
      }),
      c = new qR,
      h = {},
      m = t.maxTextureSize,
      g = {
         [Hu]: Ds,
         [Ds]: Hu,
         [Ua]: Ua
      },
      v = new gs({
         defines: {
            VSM_SAMPLES: 8
         },
         uniforms: {
            shadow_pass: {
               value: null
            },
            resolution: {
               value: new Fe
            },
            radius: {
               value: 4
            }
         },
         vertexShader: Tq,
         fragmentShader: Eq
      }),
      x = v.clone();
   x.defines.HORIZONTAL_PASS = 1;
   const S = new pn;
   S.setAttribute("position", new oi(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
   const E = new ds(S, v),
      T = this;
   this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = eT;
   let b = this.type;
   this.render = function (z, B, I) {
      if (T.enabled === !1 || T.autoUpdate === !1 && T.needsUpdate === !1 || z.length === 0) return;
      const O = n.getRenderTarget(),
         P = n.getActiveCubeFace(),
         q = n.getActiveMipmapLevel(),
         Q = n.state;
      Q.setBlending(nr), Q.buffers.color.setClear(1, 1, 1, 1), Q.buffers.depth.setTest(!0), Q.setScissorTest(!1);
      const $ = b !== Pl && this.type === Pl,
         ae = b === Pl && this.type !== Pl;
      for (let fe = 0, k = z.length; fe < k; fe++) {
         const Z = z[fe],
            J = Z.shadow;
         if (J === void 0) {
            console.warn("THREE.WebGLShadowMap:", Z, "has no shadow.");
            continue
         }
         if (J.autoUpdate === !1 && J.needsUpdate === !1) continue;
         s.copy(J.mapSize);
         const pe = J.getFrameExtents();
         if (s.multiply(pe), r.copy(J.mapSize), (s.x > m || s.y > m) && (s.x > m && (r.x = Math.floor(m / pe.x), s.x = r.x * pe.x, J.mapSize.x = r.x), s.y > m && (r.y = Math.floor(m / pe.y), s.y = r.y * pe.y, J.mapSize.y = r.y)), J.map === null || $ === !0 || ae === !0) {
            const ie = this.type !== Pl ? {
               minFilter: ms,
               magFilter: ms
            } : {};
            J.map !== null && J.map.dispose(), J.map = new ss(s.x, s.y, ie), J.map.texture.name = Z.name + ".shadowMap", J.camera.updateProjectionMatrix()
         }
         n.setRenderTarget(J.map), n.clear();
         const F = J.getViewportCount();
         for (let ie = 0; ie < F; ie++) {
            const ye = J.getViewport(ie);
            a.set(r.x * ye.x, r.y * ye.y, r.x * ye.z, r.y * ye.w), Q.viewport(a), J.updateMatrices(Z, ie), i = J.getFrustum(), N(B, I, J.camera, Z, this.type)
         }
         J.isPointLightShadow !== !0 && this.type === Pl && w(J, I), J.needsUpdate = !1
      }
      b = this.type, T.needsUpdate = !1, n.setRenderTarget(O, P, q)
   };

   function w(z, B) {
      const I = e.update(E);
      v.defines.VSM_SAMPLES !== z.blurSamples && (v.defines.VSM_SAMPLES = z.blurSamples, x.defines.VSM_SAMPLES = z.blurSamples, v.needsUpdate = !0, x.needsUpdate = !0), z.mapPass === null && (z.mapPass = new ss(s.x, s.y)), v.uniforms.shadow_pass.value = z.map.texture, v.uniforms.resolution.value = z.mapSize, v.uniforms.radius.value = z.radius, n.setRenderTarget(z.mapPass), n.clear(), n.renderBufferDirect(B, null, I, v, E, null), x.uniforms.shadow_pass.value = z.mapPass.texture, x.uniforms.resolution.value = z.mapSize, x.uniforms.radius.value = z.radius, n.setRenderTarget(z.map), n.clear(), n.renderBufferDirect(B, null, I, x, E, null)
   }

   function C(z, B, I, O) {
      let P = null;
      const q = I.isPointLight === !0 ? z.customDistanceMaterial : z.customDepthMaterial;
      if (q !== void 0) P = q;
      else if (P = I.isPointLight === !0 ? c : l, n.localClippingEnabled && B.clipShadows === !0 && Array.isArray(B.clippingPlanes) && B.clippingPlanes.length !== 0 || B.displacementMap && B.displacementScale !== 0 || B.alphaMap && B.alphaTest > 0 || B.map && B.alphaTest > 0) {
         const Q = P.uuid,
            $ = B.uuid;
         let ae = h[Q];
         ae === void 0 && (ae = {}, h[Q] = ae);
         let fe = ae[$];
         fe === void 0 && (fe = P.clone(), ae[$] = fe, B.addEventListener("dispose", U)), P = fe
      }
      if (P.visible = B.visible, P.wireframe = B.wireframe, O === Pl ? P.side = B.shadowSide !== null ? B.shadowSide : B.side : P.side = B.shadowSide !== null ? B.shadowSide : g[B.side], P.alphaMap = B.alphaMap, P.alphaTest = B.alphaTest, P.map = B.map, P.clipShadows = B.clipShadows, P.clippingPlanes = B.clippingPlanes, P.clipIntersection = B.clipIntersection, P.displacementMap = B.displacementMap, P.displacementScale = B.displacementScale, P.displacementBias = B.displacementBias, P.wireframeLinewidth = B.wireframeLinewidth, P.linewidth = B.linewidth, I.isPointLight === !0 && P.isMeshDistanceMaterial === !0) {
         const Q = n.properties.get(P);
         Q.light = I
      }
      return P
   }

   function N(z, B, I, O, P) {
      if (z.visible === !1) return;
      if (z.layers.test(B.layers) && (z.isMesh || z.isLine || z.isPoints) && (z.castShadow || z.receiveShadow && P === Pl) && (!z.frustumCulled || i.intersectsObject(z))) {
         z.modelViewMatrix.multiplyMatrices(I.matrixWorldInverse, z.matrixWorld);
         const $ = e.update(z),
            ae = z.material;
         if (Array.isArray(ae)) {
            const fe = $.groups;
            for (let k = 0, Z = fe.length; k < Z; k++) {
               const J = fe[k],
                  pe = ae[J.materialIndex];
               if (pe && pe.visible) {
                  const F = C(z, pe, O, P);
                  z.onBeforeShadow(n, z, B, I, $, F, J), n.renderBufferDirect(I, null, $, F, z, J), z.onAfterShadow(n, z, B, I, $, F, J)
               }
            }
         } else if (ae.visible) {
            const fe = C(z, ae, O, P);
            z.onBeforeShadow(n, z, B, I, $, fe, null), n.renderBufferDirect(I, null, $, fe, z, null), z.onAfterShadow(n, z, B, I, $, fe, null)
         }
      }
      const Q = z.children;
      for (let $ = 0, ae = Q.length; $ < ae; $++) N(Q[$], B, I, O, P)
   }

   function U(z) {
      z.target.removeEventListener("dispose", U);
      for (const I in h) {
         const O = h[I],
            P = z.target.uuid;
         P in O && (O[P].dispose(), delete O[P])
      }
   }
}
const Aq = {
   [vy]: yy,
   [ug]: Sy,
   [xy]: by,
   [ih]: _y,
   [yy]: vy,
   [Sy]: ug,
   [by]: xy,
   [_y]: ih
};

function wq(n, e) {
   function t() {
      let le = !1;
      const rt = new Gn;
      let Re = null;
      const Ie = new Gn(0, 0, 0, 0);
      return {
         setMask: function (nt) {
            Re !== nt && !le && (n.colorMask(nt, nt, nt, nt), Re = nt)
         },
         setLocked: function (nt) {
            le = nt
         },
         setClear: function (nt, at, Bt, mn, Yn) {
            Yn === !0 && (nt *= mn, at *= mn, Bt *= mn), rt.set(nt, at, Bt, mn), Ie.equals(rt) === !1 && (n.clearColor(nt, at, Bt, mn), Ie.copy(rt))
         },
         reset: function () {
            le = !1, Re = null, Ie.set(-1, 0, 0, 0)
         }
      }
   }

   function i() {
      let le = !1,
         rt = !1,
         Re = null,
         Ie = null,
         nt = null;
      return {
         setReversed: function (at) {
            if (rt !== at) {
               const Bt = e.get("EXT_clip_control");
               at ? Bt.clipControlEXT(Bt.LOWER_LEFT_EXT, Bt.ZERO_TO_ONE_EXT) : Bt.clipControlEXT(Bt.LOWER_LEFT_EXT, Bt.NEGATIVE_ONE_TO_ONE_EXT), rt = at;
               const mn = nt;
               nt = null, this.setClear(mn)
            }
         },
         getReversed: function () {
            return rt
         },
         setTest: function (at) {
            at ? Ge(n.DEPTH_TEST) : Xe(n.DEPTH_TEST)
         },
         setMask: function (at) {
            Re !== at && !le && (n.depthMask(at), Re = at)
         },
         setFunc: function (at) {
            if (rt && (at = Aq[at]), Ie !== at) {
               switch (at) {
                  case vy:
                     n.depthFunc(n.NEVER);
                     break;
                  case yy:
                     n.depthFunc(n.ALWAYS);
                     break;
                  case ug:
                     n.depthFunc(n.LESS);
                     break;
                  case ih:
                     n.depthFunc(n.LEQUAL);
                     break;
                  case xy:
                     n.depthFunc(n.EQUAL);
                     break;
                  case _y:
                     n.depthFunc(n.GEQUAL);
                     break;
                  case Sy:
                     n.depthFunc(n.GREATER);
                     break;
                  case by:
                     n.depthFunc(n.NOTEQUAL);
                     break;
                  default:
                     n.depthFunc(n.LEQUAL)
               }
               Ie = at
            }
         },
         setLocked: function (at) {
            le = at
         },
         setClear: function (at) {
            nt !== at && (rt && (at = 1 - at), n.clearDepth(at), nt = at)
         },
         reset: function () {
            le = !1, Re = null, Ie = null, nt = null, rt = !1
         }
      }
   }

   function s() {
      let le = !1,
         rt = null,
         Re = null,
         Ie = null,
         nt = null,
         at = null,
         Bt = null,
         mn = null,
         Yn = null;
      return {
         setTest: function (ut) {
            le || (ut ? Ge(n.STENCIL_TEST) : Xe(n.STENCIL_TEST))
         },
         setMask: function (ut) {
            rt !== ut && !le && (n.stencilMask(ut), rt = ut)
         },
         setFunc: function (ut, _t, It) {
            (Re !== ut || Ie !== _t || nt !== It) && (n.stencilFunc(ut, _t, It), Re = ut, Ie = _t, nt = It)
         },
         setOp: function (ut, _t, It) {
            (at !== ut || Bt !== _t || mn !== It) && (n.stencilOp(ut, _t, It), at = ut, Bt = _t, mn = It)
         },
         setLocked: function (ut) {
            le = ut
         },
         setClear: function (ut) {
            Yn !== ut && (n.clearStencil(ut), Yn = ut)
         },
         reset: function () {
            le = !1, rt = null, Re = null, Ie = null, nt = null, at = null, Bt = null, mn = null, Yn = null
         }
      }
   }
   const r = new t,
      a = new i,
      l = new s,
      c = new WeakMap,
      h = new WeakMap;
   let m = {},
      g = {},
      v = new WeakMap,
      x = [],
      S = null,
      E = !1,
      T = null,
      b = null,
      w = null,
      C = null,
      N = null,
      U = null,
      z = null,
      B = new dt(0, 0, 0),
      I = 0,
      O = !1,
      P = null,
      q = null,
      Q = null,
      $ = null,
      ae = null;
   const fe = n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
   let k = !1,
      Z = 0;
   const J = n.getParameter(n.VERSION);
   J.indexOf("WebGL") !== -1 ? (Z = parseFloat(/^WebGL (\d)/.exec(J)[1]), k = Z >= 1) : J.indexOf("OpenGL ES") !== -1 && (Z = parseFloat(/^OpenGL ES (\d)/.exec(J)[1]), k = Z >= 2);
   let pe = null,
      F = {};
   const ie = n.getParameter(n.SCISSOR_BOX),
      ye = n.getParameter(n.VIEWPORT),
      we = new Gn().fromArray(ie),
      oe = new Gn().fromArray(ye);

   function be(le, rt, Re, Ie) {
      const nt = new Uint8Array(4),
         at = n.createTexture();
      n.bindTexture(le, at), n.texParameteri(le, n.TEXTURE_MIN_FILTER, n.NEAREST), n.texParameteri(le, n.TEXTURE_MAG_FILTER, n.NEAREST);
      for (let Bt = 0; Bt < Re; Bt++) le === n.TEXTURE_3D || le === n.TEXTURE_2D_ARRAY ? n.texImage3D(rt, 0, n.RGBA, 1, 1, Ie, 0, n.RGBA, n.UNSIGNED_BYTE, nt) : n.texImage2D(rt + Bt, 0, n.RGBA, 1, 1, 0, n.RGBA, n.UNSIGNED_BYTE, nt);
      return at
   }
   const Pe = {};
   Pe[n.TEXTURE_2D] = be(n.TEXTURE_2D, n.TEXTURE_2D, 1), Pe[n.TEXTURE_CUBE_MAP] = be(n.TEXTURE_CUBE_MAP, n.TEXTURE_CUBE_MAP_POSITIVE_X, 6), Pe[n.TEXTURE_2D_ARRAY] = be(n.TEXTURE_2D_ARRAY, n.TEXTURE_2D_ARRAY, 1, 1), Pe[n.TEXTURE_3D] = be(n.TEXTURE_3D, n.TEXTURE_3D, 1, 1), r.setClear(0, 0, 0, 1), a.setClear(1), l.setClear(0), Ge(n.DEPTH_TEST), a.setFunc(ih), ze(!1), te(HA), Ge(n.CULL_FACE), ne(nr);

   function Ge(le) {
      m[le] !== !0 && (n.enable(le), m[le] = !0)
   }

   function Xe(le) {
      m[le] !== !1 && (n.disable(le), m[le] = !1)
   }

   function yt(le, rt) {
      return g[le] !== rt ? (n.bindFramebuffer(le, rt), g[le] = rt, le === n.DRAW_FRAMEBUFFER && (g[n.FRAMEBUFFER] = rt), le === n.FRAMEBUFFER && (g[n.DRAW_FRAMEBUFFER] = rt), !0) : !1
   }

   function vt(le, rt) {
      let Re = x,
         Ie = !1;
      if (le) {
         Re = v.get(rt), Re === void 0 && (Re = [], v.set(rt, Re));
         const nt = le.textures;
         if (Re.length !== nt.length || Re[0] !== n.COLOR_ATTACHMENT0) {
            for (let at = 0, Bt = nt.length; at < Bt; at++) Re[at] = n.COLOR_ATTACHMENT0 + at;
            Re.length = nt.length, Ie = !0
         }
      } else Re[0] !== n.BACK && (Re[0] = n.BACK, Ie = !0);
      Ie && n.drawBuffers(Re)
   }

   function Mt(le) {
      return S !== le ? (n.useProgram(le), S = le, !0) : !1
   }
   const zt = {
      [jf]: n.FUNC_ADD,
      [IP]: n.FUNC_SUBTRACT,
      [FP]: n.FUNC_REVERSE_SUBTRACT
   };
   zt[HP] = n.MIN, zt[VP] = n.MAX;
   const lt = {
      [GP]: n.ZERO,
      [kP]: n.ONE,
      [jP]: n.SRC_COLOR,
      [qb]: n.SRC_ALPHA,
      [ZP]: n.SRC_ALPHA_SATURATE,
      [YP]: n.DST_COLOR,
      [XP]: n.DST_ALPHA,
      [qP]: n.ONE_MINUS_SRC_COLOR,
      [Xb]: n.ONE_MINUS_SRC_ALPHA,
      [KP]: n.ONE_MINUS_DST_COLOR,
      [WP]: n.ONE_MINUS_DST_ALPHA,
      [QP]: n.CONSTANT_COLOR,
      [JP]: n.ONE_MINUS_CONSTANT_COLOR,
      [$P]: n.CONSTANT_ALPHA,
      [eL]: n.ONE_MINUS_CONSTANT_ALPHA
   };

   function ne(le, rt, Re, Ie, nt, at, Bt, mn, Yn, ut) {
      if (le === nr) {
         E === !0 && (Xe(n.BLEND), E = !1);
         return
      }
      if (E === !1 && (Ge(n.BLEND), E = !0), le !== zP) {
         if (le !== T || ut !== O) {
            if ((b !== jf || N !== jf) && (n.blendEquation(n.FUNC_ADD), b = jf, N = jf), ut) switch (le) {
               case Fd:
                  n.blendFuncSeparate(n.ONE, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA);
                  break;
               case VA:
                  n.blendFunc(n.ONE, n.ONE);
                  break;
               case GA:
                  n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
                  break;
               case kA:
                  n.blendFuncSeparate(n.ZERO, n.SRC_COLOR, n.ZERO, n.SRC_ALPHA);
                  break;
               default:
                  console.error("THREE.WebGLState: Invalid blending: ", le);
                  break
            } else switch (le) {
               case Fd:
                  n.blendFuncSeparate(n.SRC_ALPHA, n.ONE_MINUS_SRC_ALPHA, n.ONE, n.ONE_MINUS_SRC_ALPHA);
                  break;
               case VA:
                  n.blendFunc(n.SRC_ALPHA, n.ONE);
                  break;
               case GA:
                  n.blendFuncSeparate(n.ZERO, n.ONE_MINUS_SRC_COLOR, n.ZERO, n.ONE);
                  break;
               case kA:
                  n.blendFunc(n.ZERO, n.SRC_COLOR);
                  break;
               default:
                  console.error("THREE.WebGLState: Invalid blending: ", le);
                  break
            }
            w = null, C = null, U = null, z = null, B.set(0, 0, 0), I = 0, T = le, O = ut
         }
         return
      }
      nt = nt || rt, at = at || Re, Bt = Bt || Ie, (rt !== b || nt !== N) && (n.blendEquationSeparate(zt[rt], zt[nt]), b = rt, N = nt), (Re !== w || Ie !== C || at !== U || Bt !== z) && (n.blendFuncSeparate(lt[Re], lt[Ie], lt[at], lt[Bt]), w = Re, C = Ie, U = at, z = Bt), (mn.equals(B) === !1 || Yn !== I) && (n.blendColor(mn.r, mn.g, mn.b, Yn), B.copy(mn), I = Yn), T = le, O = !1
   }

   function sn(le, rt) {
      le.side === Ua ? Xe(n.CULL_FACE) : Ge(n.CULL_FACE);
      let Re = le.side === Ds;
      rt && (Re = !Re), ze(Re), le.blending === Fd && le.transparent === !1 ? ne(nr) : ne(le.blending, le.blendEquation, le.blendSrc, le.blendDst, le.blendEquationAlpha, le.blendSrcAlpha, le.blendDstAlpha, le.blendColor, le.blendAlpha, le.premultipliedAlpha), a.setFunc(le.depthFunc), a.setTest(le.depthTest), a.setMask(le.depthWrite), r.setMask(le.colorWrite);
      const Ie = le.stencilWrite;
      l.setTest(Ie), Ie && (l.setMask(le.stencilWriteMask), l.setFunc(le.stencilFunc, le.stencilRef, le.stencilFuncMask), l.setOp(le.stencilFail, le.stencilZFail, le.stencilZPass)), Je(le.polygonOffset, le.polygonOffsetFactor, le.polygonOffsetUnits), le.alphaToCoverage === !0 ? Ge(n.SAMPLE_ALPHA_TO_COVERAGE) : Xe(n.SAMPLE_ALPHA_TO_COVERAGE)
   }

   function ze(le) {
      P !== le && (le ? n.frontFace(n.CW) : n.frontFace(n.CCW), P = le)
   }

   function te(le) {
      le !== PP ? (Ge(n.CULL_FACE), le !== q && (le === HA ? n.cullFace(n.BACK) : le === LP ? n.cullFace(n.FRONT) : n.cullFace(n.FRONT_AND_BACK))) : Xe(n.CULL_FACE), q = le
   }

   function Be(le) {
      le !== Q && (k && n.lineWidth(le), Q = le)
   }

   function Je(le, rt, Re) {
      le ? (Ge(n.POLYGON_OFFSET_FILL), ($ !== rt || ae !== Re) && (n.polygonOffset(rt, Re), $ = rt, ae = Re)) : Xe(n.POLYGON_OFFSET_FILL)
   }

   function Ue(le) {
      le ? Ge(n.SCISSOR_TEST) : Xe(n.SCISSOR_TEST)
   }

   function K(le) {
      le === void 0 && (le = n.TEXTURE0 + fe - 1), pe !== le && (n.activeTexture(le), pe = le)
   }

   function G(le, rt, Re) {
      Re === void 0 && (pe === null ? Re = n.TEXTURE0 + fe - 1 : Re = pe);
      let Ie = F[Re];
      Ie === void 0 && (Ie = {
         type: void 0,
         texture: void 0
      }, F[Re] = Ie), (Ie.type !== le || Ie.texture !== rt) && (pe !== Re && (n.activeTexture(Re), pe = Re), n.bindTexture(le, rt || Pe[le]), Ie.type = le, Ie.texture = rt)
   }

   function me() {
      const le = F[pe];
      le !== void 0 && le.type !== void 0 && (n.bindTexture(le.type, null), le.type = void 0, le.texture = void 0)
   }

   function Ne() {
      try {
         n.compressedTexImage2D(...arguments)
      } catch (le) {
         console.error("THREE.WebGLState:", le)
      }
   }

   function Oe() {
      try {
         n.compressedTexImage3D(...arguments)
      } catch (le) {
         console.error("THREE.WebGLState:", le)
      }
   }

   function De() {
      try {
         n.texSubImage2D(...arguments)
      } catch (le) {
         console.error("THREE.WebGLState:", le)
      }
   }

   function Ye() {
      try {
         n.texSubImage3D(...arguments)
      } catch (le) {
         console.error("THREE.WebGLState:", le)
      }
   }

   function We() {
      try {
         n.compressedTexSubImage2D(...arguments)
      } catch (le) {
         console.error("THREE.WebGLState:", le)
      }
   }

   function Ze() {
      try {
         n.compressedTexSubImage3D(...arguments)
      } catch (le) {
         console.error("THREE.WebGLState:", le)
      }
   }

   function kt() {
      try {
         n.texStorage2D(...arguments)
      } catch (le) {
         console.error("THREE.WebGLState:", le)
      }
   }

   function Ke() {
      try {
         n.texStorage3D(...arguments)
      } catch (le) {
         console.error("THREE.WebGLState:", le)
      }
   }

   function et() {
      try {
         n.texImage2D(...arguments)
      } catch (le) {
         console.error("THREE.WebGLState:", le)
      }
   }

   function xt() {
      try {
         n.texImage3D(...arguments)
      } catch (le) {
         console.error("THREE.WebGLState:", le)
      }
   }

   function mt(le) {
      we.equals(le) === !1 && (n.scissor(le.x, le.y, le.z, le.w), we.copy(le))
   }

   function it(le) {
      oe.equals(le) === !1 && (n.viewport(le.x, le.y, le.z, le.w), oe.copy(le))
   }

   function jt(le, rt) {
      let Re = h.get(rt);
      Re === void 0 && (Re = new WeakMap, h.set(rt, Re));
      let Ie = Re.get(le);
      Ie === void 0 && (Ie = n.getUniformBlockIndex(rt, le.name), Re.set(le, Ie))
   }

   function Rt(le, rt) {
      const Ie = h.get(rt).get(le);
      c.get(rt) !== Ie && (n.uniformBlockBinding(rt, Ie, le.__bindingPointIndex), c.set(rt, Ie))
   }

   function cn() {
      n.disable(n.BLEND), n.disable(n.CULL_FACE), n.disable(n.DEPTH_TEST), n.disable(n.POLYGON_OFFSET_FILL), n.disable(n.SCISSOR_TEST), n.disable(n.STENCIL_TEST), n.disable(n.SAMPLE_ALPHA_TO_COVERAGE), n.blendEquation(n.FUNC_ADD), n.blendFunc(n.ONE, n.ZERO), n.blendFuncSeparate(n.ONE, n.ZERO, n.ONE, n.ZERO), n.blendColor(0, 0, 0, 0), n.colorMask(!0, !0, !0, !0), n.clearColor(0, 0, 0, 0), n.depthMask(!0), n.depthFunc(n.LESS), a.setReversed(!1), n.clearDepth(1), n.stencilMask(4294967295), n.stencilFunc(n.ALWAYS, 0, 4294967295), n.stencilOp(n.KEEP, n.KEEP, n.KEEP), n.clearStencil(0), n.cullFace(n.BACK), n.frontFace(n.CCW), n.polygonOffset(0, 0), n.activeTexture(n.TEXTURE0), n.bindFramebuffer(n.FRAMEBUFFER, null), n.bindFramebuffer(n.DRAW_FRAMEBUFFER, null), n.bindFramebuffer(n.READ_FRAMEBUFFER, null), n.useProgram(null), n.lineWidth(1), n.scissor(0, 0, n.canvas.width, n.canvas.height), n.viewport(0, 0, n.canvas.width, n.canvas.height), m = {}, pe = null, F = {}, g = {}, v = new WeakMap, x = [], S = null, E = !1, T = null, b = null, w = null, C = null, N = null, U = null, z = null, B = new dt(0, 0, 0), I = 0, O = !1, P = null, q = null, Q = null, $ = null, ae = null, we.set(0, 0, n.canvas.width, n.canvas.height), oe.set(0, 0, n.canvas.width, n.canvas.height), r.reset(), a.reset(), l.reset()
   }
   return {
      buffers: {
         color: r,
         depth: a,
         stencil: l
      },
      enable: Ge,
      disable: Xe,
      bindFramebuffer: yt,
      drawBuffers: vt,
      useProgram: Mt,
      setBlending: ne,
      setMaterial: sn,
      setFlipSided: ze,
      setCullFace: te,
      setLineWidth: Be,
      setPolygonOffset: Je,
      setScissorTest: Ue,
      activeTexture: K,
      bindTexture: G,
      unbindTexture: me,
      compressedTexImage2D: Ne,
      compressedTexImage3D: Oe,
      texImage2D: et,
      texImage3D: xt,
      updateUBOMapping: jt,
      uniformBlockBinding: Rt,
      texStorage2D: kt,
      texStorage3D: Ke,
      texSubImage2D: De,
      texSubImage3D: Ye,
      compressedTexSubImage2D: We,
      compressedTexSubImage3D: Ze,
      scissor: mt,
      viewport: it,
      reset: cn
   }
}

function Rq(n, e, t, i, s, r, a) {
   const l = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null,
      c = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
      h = new Fe,
      m = new WeakMap;
   let g;
   const v = new WeakMap;
   let x = !1;
   try {
      x = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null
   } catch {}

   function S(K, G) {
      return x ? new OffscreenCanvas(K, G) : Oy("canvas")
   }

   function E(K, G, me) {
      let Ne = 1;
      const Oe = Ue(K);
      if ((Oe.width > me || Oe.height > me) && (Ne = me / Math.max(Oe.width, Oe.height)), Ne < 1)
         if (typeof HTMLImageElement < "u" && K instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && K instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && K instanceof ImageBitmap || typeof VideoFrame < "u" && K instanceof VideoFrame) {
            const De = Math.floor(Ne * Oe.width),
               Ye = Math.floor(Ne * Oe.height);
            g === void 0 && (g = S(De, Ye));
            const We = G ? S(De, Ye) : g;
            return We.width = De, We.height = Ye, We.getContext("2d").drawImage(K, 0, 0, De, Ye), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + Oe.width + "x" + Oe.height + ") to (" + De + "x" + Ye + ")."), We
         } else return "data" in K && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + Oe.width + "x" + Oe.height + ")."), K;
      return K
   }

   function T(K) {
      return K.generateMipmaps
   }

   function b(K) {
      n.generateMipmap(K)
   }

   function w(K) {
      return K.isWebGLCubeRenderTarget ? n.TEXTURE_CUBE_MAP : K.isWebGL3DRenderTarget ? n.TEXTURE_3D : K.isWebGLArrayRenderTarget || K.isCompressedArrayTexture ? n.TEXTURE_2D_ARRAY : n.TEXTURE_2D
   }

   function C(K, G, me, Ne, Oe = !1) {
      if (K !== null) {
         if (n[K] !== void 0) return n[K];
         console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + K + "'")
      }
      let De = G;
      if (G === n.RED && (me === n.FLOAT && (De = n.R32F), me === n.HALF_FLOAT && (De = n.R16F), me === n.UNSIGNED_BYTE && (De = n.R8)), G === n.RED_INTEGER && (me === n.UNSIGNED_BYTE && (De = n.R8UI), me === n.UNSIGNED_SHORT && (De = n.R16UI), me === n.UNSIGNED_INT && (De = n.R32UI), me === n.BYTE && (De = n.R8I), me === n.SHORT && (De = n.R16I), me === n.INT && (De = n.R32I)), G === n.RG && (me === n.FLOAT && (De = n.RG32F), me === n.HALF_FLOAT && (De = n.RG16F), me === n.UNSIGNED_BYTE && (De = n.RG8)), G === n.RG_INTEGER && (me === n.UNSIGNED_BYTE && (De = n.RG8UI), me === n.UNSIGNED_SHORT && (De = n.RG16UI), me === n.UNSIGNED_INT && (De = n.RG32UI), me === n.BYTE && (De = n.RG8I), me === n.SHORT && (De = n.RG16I), me === n.INT && (De = n.RG32I)), G === n.RGB_INTEGER && (me === n.UNSIGNED_BYTE && (De = n.RGB8UI), me === n.UNSIGNED_SHORT && (De = n.RGB16UI), me === n.UNSIGNED_INT && (De = n.RGB32UI), me === n.BYTE && (De = n.RGB8I), me === n.SHORT && (De = n.RGB16I), me === n.INT && (De = n.RGB32I)), G === n.RGBA_INTEGER && (me === n.UNSIGNED_BYTE && (De = n.RGBA8UI), me === n.UNSIGNED_SHORT && (De = n.RGBA16UI), me === n.UNSIGNED_INT && (De = n.RGBA32UI), me === n.BYTE && (De = n.RGBA8I), me === n.SHORT && (De = n.RGBA16I), me === n.INT && (De = n.RGBA32I)), G === n.RGB && me === n.UNSIGNED_INT_5_9_9_9_REV && (De = n.RGB9_E5), G === n.RGBA) {
         const Ye = Oe ? Cy : Vn.getTransfer(Ne);
         me === n.FLOAT && (De = n.RGBA32F), me === n.HALF_FLOAT && (De = n.RGBA16F), me === n.UNSIGNED_BYTE && (De = Ye === di ? n.SRGB8_ALPHA8 : n.RGBA8), me === n.UNSIGNED_SHORT_4_4_4_4 && (De = n.RGBA4), me === n.UNSIGNED_SHORT_5_5_5_1 && (De = n.RGB5_A1)
      }
      return (De === n.R16F || De === n.R32F || De === n.RG16F || De === n.RG32F || De === n.RGBA16F || De === n.RGBA32F) && e.get("EXT_color_buffer_float"), De
   }

   function N(K, G) {
      let me;
      return K ? G === null || G === Vu || G === Jd ? me = n.DEPTH24_STENCIL8 : G === ha ? me = n.DEPTH32F_STENCIL8 : G === cg && (me = n.DEPTH24_STENCIL8, console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : G === null || G === Vu || G === Jd ? me = n.DEPTH_COMPONENT24 : G === ha ? me = n.DEPTH_COMPONENT32F : G === cg && (me = n.DEPTH_COMPONENT16), me
   }

   function U(K, G) {
      return T(K) === !0 || K.isFramebufferTexture && K.minFilter !== ms && K.minFilter !== Ni ? Math.log2(Math.max(G.width, G.height)) + 1 : K.mipmaps !== void 0 && K.mipmaps.length > 0 ? K.mipmaps.length : K.isCompressedTexture && Array.isArray(K.image) ? G.mipmaps.length : 1
   }

   function z(K) {
      const G = K.target;
      G.removeEventListener("dispose", z), I(G), G.isVideoTexture && m.delete(G)
   }

   function B(K) {
      const G = K.target;
      G.removeEventListener("dispose", B), P(G)
   }

   function I(K) {
      const G = i.get(K);
      if (G.__webglInit === void 0) return;
      const me = K.source,
         Ne = v.get(me);
      if (Ne) {
         const Oe = Ne[G.__cacheKey];
         Oe.usedTimes--, Oe.usedTimes === 0 && O(K), Object.keys(Ne).length === 0 && v.delete(me)
      }
      i.remove(K)
   }

   function O(K) {
      const G = i.get(K);
      n.deleteTexture(G.__webglTexture);
      const me = K.source,
         Ne = v.get(me);
      delete Ne[G.__cacheKey], a.memory.textures--
   }

   function P(K) {
      const G = i.get(K);
      if (K.depthTexture && (K.depthTexture.dispose(), i.remove(K.depthTexture)), K.isWebGLCubeRenderTarget)
         for (let Ne = 0; Ne < 6; Ne++) {
            if (Array.isArray(G.__webglFramebuffer[Ne]))
               for (let Oe = 0; Oe < G.__webglFramebuffer[Ne].length; Oe++) n.deleteFramebuffer(G.__webglFramebuffer[Ne][Oe]);
            else n.deleteFramebuffer(G.__webglFramebuffer[Ne]);
            G.__webglDepthbuffer && n.deleteRenderbuffer(G.__webglDepthbuffer[Ne])
         } else {
            if (Array.isArray(G.__webglFramebuffer))
               for (let Ne = 0; Ne < G.__webglFramebuffer.length; Ne++) n.deleteFramebuffer(G.__webglFramebuffer[Ne]);
            else n.deleteFramebuffer(G.__webglFramebuffer);
            if (G.__webglDepthbuffer && n.deleteRenderbuffer(G.__webglDepthbuffer), G.__webglMultisampledFramebuffer && n.deleteFramebuffer(G.__webglMultisampledFramebuffer), G.__webglColorRenderbuffer)
               for (let Ne = 0; Ne < G.__webglColorRenderbuffer.length; Ne++) G.__webglColorRenderbuffer[Ne] && n.deleteRenderbuffer(G.__webglColorRenderbuffer[Ne]);
            G.__webglDepthRenderbuffer && n.deleteRenderbuffer(G.__webglDepthRenderbuffer)
         }
      const me = K.textures;
      for (let Ne = 0, Oe = me.length; Ne < Oe; Ne++) {
         const De = i.get(me[Ne]);
         De.__webglTexture && (n.deleteTexture(De.__webglTexture), a.memory.textures--), i.remove(me[Ne])
      }
      i.remove(K)
   }
   let q = 0;

   function Q() {
      q = 0
   }

   function $() {
      const K = q;
      return K >= s.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + K + " texture units while this GPU supports only " + s.maxTextures), q += 1, K
   }

   function ae(K) {
      const G = [];
      return G.push(K.wrapS), G.push(K.wrapT), G.push(K.wrapR || 0), G.push(K.magFilter), G.push(K.minFilter), G.push(K.anisotropy), G.push(K.internalFormat), G.push(K.format), G.push(K.type), G.push(K.generateMipmaps), G.push(K.premultiplyAlpha), G.push(K.flipY), G.push(K.unpackAlignment), G.push(K.colorSpace), G.join()
   }

   function fe(K, G) {
      const me = i.get(K);
      if (K.isVideoTexture && Be(K), K.isRenderTargetTexture === !1 && K.version > 0 && me.__version !== K.version) {
         const Ne = K.image;
         if (Ne === null) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
         else if (Ne.complete === !1) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
         else {
            oe(me, K, G);
            return
         }
      }
      t.bindTexture(n.TEXTURE_2D, me.__webglTexture, n.TEXTURE0 + G)
   }

   function k(K, G) {
      const me = i.get(K);
      if (K.version > 0 && me.__version !== K.version) {
         oe(me, K, G);
         return
      }
      t.bindTexture(n.TEXTURE_2D_ARRAY, me.__webglTexture, n.TEXTURE0 + G)
   }

   function Z(K, G) {
      const me = i.get(K);
      if (K.version > 0 && me.__version !== K.version) {
         oe(me, K, G);
         return
      }
      t.bindTexture(n.TEXTURE_3D, me.__webglTexture, n.TEXTURE0 + G)
   }

   function J(K, G) {
      const me = i.get(K);
      if (K.version > 0 && me.__version !== K.version) {
         be(me, K, G);
         return
      }
      t.bindTexture(n.TEXTURE_CUBE_MAP, me.__webglTexture, n.TEXTURE0 + G)
   }
   const pe = {
         [My]: n.REPEAT,
         [Ko]: n.CLAMP_TO_EDGE,
         [Ay]: n.MIRRORED_REPEAT
      },
      F = {
         [ms]: n.NEAREST,
         [yR]: n.NEAREST_MIPMAP_NEAREST,
         [Gm]: n.NEAREST_MIPMAP_LINEAR,
         [Ni]: n.LINEAR,
         [F0]: n.LINEAR_MIPMAP_NEAREST,
         [Du]: n.LINEAR_MIPMAP_LINEAR
      },
      ie = {
         [mL]: n.NEVER,
         [SL]: n.ALWAYS,
         [gL]: n.LESS,
         [CR]: n.LEQUAL,
         [vL]: n.EQUAL,
         [_L]: n.GEQUAL,
         [yL]: n.GREATER,
         [xL]: n.NOTEQUAL
      };

   function ye(K, G) {
      if (G.type === ha && e.has("OES_texture_float_linear") === !1 && (G.magFilter === Ni || G.magFilter === F0 || G.magFilter === Gm || G.magFilter === Du || G.minFilter === Ni || G.minFilter === F0 || G.minFilter === Gm || G.minFilter === Du) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), n.texParameteri(K, n.TEXTURE_WRAP_S, pe[G.wrapS]), n.texParameteri(K, n.TEXTURE_WRAP_T, pe[G.wrapT]), (K === n.TEXTURE_3D || K === n.TEXTURE_2D_ARRAY) && n.texParameteri(K, n.TEXTURE_WRAP_R, pe[G.wrapR]), n.texParameteri(K, n.TEXTURE_MAG_FILTER, F[G.magFilter]), n.texParameteri(K, n.TEXTURE_MIN_FILTER, F[G.minFilter]), G.compareFunction && (n.texParameteri(K, n.TEXTURE_COMPARE_MODE, n.COMPARE_REF_TO_TEXTURE), n.texParameteri(K, n.TEXTURE_COMPARE_FUNC, ie[G.compareFunction])), e.has("EXT_texture_filter_anisotropic") === !0) {
         if (G.magFilter === ms || G.minFilter !== Gm && G.minFilter !== Du || G.type === ha && e.has("OES_texture_float_linear") === !1) return;
         if (G.anisotropy > 1 || i.get(G).__currentAnisotropy) {
            const me = e.get("EXT_texture_filter_anisotropic");
            n.texParameterf(K, me.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(G.anisotropy, s.getMaxAnisotropy())), i.get(G).__currentAnisotropy = G.anisotropy
         }
      }
   }

   function we(K, G) {
      let me = !1;
      K.__webglInit === void 0 && (K.__webglInit = !0, G.addEventListener("dispose", z));
      const Ne = G.source;
      let Oe = v.get(Ne);
      Oe === void 0 && (Oe = {}, v.set(Ne, Oe));
      const De = ae(G);
      if (De !== K.__cacheKey) {
         Oe[De] === void 0 && (Oe[De] = {
            texture: n.createTexture(),
            usedTimes: 0
         }, a.memory.textures++, me = !0), Oe[De].usedTimes++;
         const Ye = Oe[K.__cacheKey];
         Ye !== void 0 && (Oe[K.__cacheKey].usedTimes--, Ye.usedTimes === 0 && O(G)), K.__cacheKey = De, K.__webglTexture = Oe[De].texture
      }
      return me
   }

   function oe(K, G, me) {
      let Ne = n.TEXTURE_2D;
      (G.isDataArrayTexture || G.isCompressedArrayTexture) && (Ne = n.TEXTURE_2D_ARRAY), G.isData3DTexture && (Ne = n.TEXTURE_3D);
      const Oe = we(K, G),
         De = G.source;
      t.bindTexture(Ne, K.__webglTexture, n.TEXTURE0 + me);
      const Ye = i.get(De);
      if (De.version !== Ye.__version || Oe === !0) {
         t.activeTexture(n.TEXTURE0 + me);
         const We = Vn.getPrimaries(Vn.workingColorSpace),
            Ze = G.colorSpace === Bl ? null : Vn.getPrimaries(G.colorSpace),
            kt = G.colorSpace === Bl || We === Ze ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
         n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, G.flipY), n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, G.premultiplyAlpha), n.pixelStorei(n.UNPACK_ALIGNMENT, G.unpackAlignment), n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, kt);
         let Ke = E(G.image, !1, s.maxTextureSize);
         Ke = Je(G, Ke);
         const et = r.convert(G.format, G.colorSpace),
            xt = r.convert(G.type);
         let mt = C(G.internalFormat, et, xt, G.colorSpace, G.isVideoTexture);
         ye(Ne, G);
         let it;
         const jt = G.mipmaps,
            Rt = G.isVideoTexture !== !0,
            cn = Ye.__version === void 0 || Oe === !0,
            le = De.dataReady,
            rt = U(G, Ke);
         if (G.isDepthTexture) mt = N(G.format === $d, G.type), cn && (Rt ? t.texStorage2D(n.TEXTURE_2D, 1, mt, Ke.width, Ke.height) : t.texImage2D(n.TEXTURE_2D, 0, mt, Ke.width, Ke.height, 0, et, xt, null));
         else if (G.isDataTexture)
            if (jt.length > 0) {
               Rt && cn && t.texStorage2D(n.TEXTURE_2D, rt, mt, jt[0].width, jt[0].height);
               for (let Re = 0, Ie = jt.length; Re < Ie; Re++) it = jt[Re], Rt ? le && t.texSubImage2D(n.TEXTURE_2D, Re, 0, 0, it.width, it.height, et, xt, it.data) : t.texImage2D(n.TEXTURE_2D, Re, mt, it.width, it.height, 0, et, xt, it.data);
               G.generateMipmaps = !1
            } else Rt ? (cn && t.texStorage2D(n.TEXTURE_2D, rt, mt, Ke.width, Ke.height), le && t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, Ke.width, Ke.height, et, xt, Ke.data)) : t.texImage2D(n.TEXTURE_2D, 0, mt, Ke.width, Ke.height, 0, et, xt, Ke.data);
         else if (G.isCompressedTexture)
            if (G.isCompressedArrayTexture) {
               Rt && cn && t.texStorage3D(n.TEXTURE_2D_ARRAY, rt, mt, jt[0].width, jt[0].height, Ke.depth);
               for (let Re = 0, Ie = jt.length; Re < Ie; Re++)
                  if (it = jt[Re], G.format !== Lr)
                     if (et !== null)
                        if (Rt) {
                           if (le)
                              if (G.layerUpdates.size > 0) {
                                 const nt = $A(it.width, it.height, G.format, G.type);
                                 for (const at of G.layerUpdates) {
                                    const Bt = it.data.subarray(at * nt / it.data.BYTES_PER_ELEMENT, (at + 1) * nt / it.data.BYTES_PER_ELEMENT);
                                    t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY, Re, 0, 0, at, it.width, it.height, 1, et, Bt)
                                 }
                                 G.clearLayerUpdates()
                              } else t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY, Re, 0, 0, 0, it.width, it.height, Ke.depth, et, it.data)
                        } else t.compressedTexImage3D(n.TEXTURE_2D_ARRAY, Re, mt, it.width, it.height, Ke.depth, 0, it.data, 0, 0);
               else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
               else Rt ? le && t.texSubImage3D(n.TEXTURE_2D_ARRAY, Re, 0, 0, 0, it.width, it.height, Ke.depth, et, xt, it.data) : t.texImage3D(n.TEXTURE_2D_ARRAY, Re, mt, it.width, it.height, Ke.depth, 0, et, xt, it.data)
            } else {
               Rt && cn && t.texStorage2D(n.TEXTURE_2D, rt, mt, jt[0].width, jt[0].height);
               for (let Re = 0, Ie = jt.length; Re < Ie; Re++) it = jt[Re], G.format !== Lr ? et !== null ? Rt ? le && t.compressedTexSubImage2D(n.TEXTURE_2D, Re, 0, 0, it.width, it.height, et, it.data) : t.compressedTexImage2D(n.TEXTURE_2D, Re, mt, it.width, it.height, 0, it.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Rt ? le && t.texSubImage2D(n.TEXTURE_2D, Re, 0, 0, it.width, it.height, et, xt, it.data) : t.texImage2D(n.TEXTURE_2D, Re, mt, it.width, it.height, 0, et, xt, it.data)
            }
         else if (G.isDataArrayTexture)
            if (Rt) {
               if (cn && t.texStorage3D(n.TEXTURE_2D_ARRAY, rt, mt, Ke.width, Ke.height, Ke.depth), le)
                  if (G.layerUpdates.size > 0) {
                     const Re = $A(Ke.width, Ke.height, G.format, G.type);
                     for (const Ie of G.layerUpdates) {
                        const nt = Ke.data.subarray(Ie * Re / Ke.data.BYTES_PER_ELEMENT, (Ie + 1) * Re / Ke.data.BYTES_PER_ELEMENT);
                        t.texSubImage3D(n.TEXTURE_2D_ARRAY, 0, 0, 0, Ie, Ke.width, Ke.height, 1, et, xt, nt)
                     }
                     G.clearLayerUpdates()
                  } else t.texSubImage3D(n.TEXTURE_2D_ARRAY, 0, 0, 0, 0, Ke.width, Ke.height, Ke.depth, et, xt, Ke.data)
            } else t.texImage3D(n.TEXTURE_2D_ARRAY, 0, mt, Ke.width, Ke.height, Ke.depth, 0, et, xt, Ke.data);
         else if (G.isData3DTexture) Rt ? (cn && t.texStorage3D(n.TEXTURE_3D, rt, mt, Ke.width, Ke.height, Ke.depth), le && t.texSubImage3D(n.TEXTURE_3D, 0, 0, 0, 0, Ke.width, Ke.height, Ke.depth, et, xt, Ke.data)) : t.texImage3D(n.TEXTURE_3D, 0, mt, Ke.width, Ke.height, Ke.depth, 0, et, xt, Ke.data);
         else if (G.isFramebufferTexture) {
            if (cn)
               if (Rt) t.texStorage2D(n.TEXTURE_2D, rt, mt, Ke.width, Ke.height);
               else {
                  let Re = Ke.width,
                     Ie = Ke.height;
                  for (let nt = 0; nt < rt; nt++) t.texImage2D(n.TEXTURE_2D, nt, mt, Re, Ie, 0, et, xt, null), Re >>= 1, Ie >>= 1
               }
         } else if (jt.length > 0) {
            if (Rt && cn) {
               const Re = Ue(jt[0]);
               t.texStorage2D(n.TEXTURE_2D, rt, mt, Re.width, Re.height)
            }
            for (let Re = 0, Ie = jt.length; Re < Ie; Re++) it = jt[Re], Rt ? le && t.texSubImage2D(n.TEXTURE_2D, Re, 0, 0, et, xt, it) : t.texImage2D(n.TEXTURE_2D, Re, mt, et, xt, it);
            G.generateMipmaps = !1
         } else if (Rt) {
            if (cn) {
               const Re = Ue(Ke);
               t.texStorage2D(n.TEXTURE_2D, rt, mt, Re.width, Re.height)
            }
            le && t.texSubImage2D(n.TEXTURE_2D, 0, 0, 0, et, xt, Ke)
         } else t.texImage2D(n.TEXTURE_2D, 0, mt, et, xt, Ke);
         T(G) && b(Ne), Ye.__version = De.version, G.onUpdate && G.onUpdate(G)
      }
      K.__version = G.version
   }

   function be(K, G, me) {
      if (G.image.length !== 6) return;
      const Ne = we(K, G),
         Oe = G.source;
      t.bindTexture(n.TEXTURE_CUBE_MAP, K.__webglTexture, n.TEXTURE0 + me);
      const De = i.get(Oe);
      if (Oe.version !== De.__version || Ne === !0) {
         t.activeTexture(n.TEXTURE0 + me);
         const Ye = Vn.getPrimaries(Vn.workingColorSpace),
            We = G.colorSpace === Bl ? null : Vn.getPrimaries(G.colorSpace),
            Ze = G.colorSpace === Bl || Ye === We ? n.NONE : n.BROWSER_DEFAULT_WEBGL;
         n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, G.flipY), n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, G.premultiplyAlpha), n.pixelStorei(n.UNPACK_ALIGNMENT, G.unpackAlignment), n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL, Ze);
         const kt = G.isCompressedTexture || G.image[0].isCompressedTexture,
            Ke = G.image[0] && G.image[0].isDataTexture,
            et = [];
         for (let Ie = 0; Ie < 6; Ie++) !kt && !Ke ? et[Ie] = E(G.image[Ie], !0, s.maxCubemapSize) : et[Ie] = Ke ? G.image[Ie].image : G.image[Ie], et[Ie] = Je(G, et[Ie]);
         const xt = et[0],
            mt = r.convert(G.format, G.colorSpace),
            it = r.convert(G.type),
            jt = C(G.internalFormat, mt, it, G.colorSpace),
            Rt = G.isVideoTexture !== !0,
            cn = De.__version === void 0 || Ne === !0,
            le = Oe.dataReady;
         let rt = U(G, xt);
         ye(n.TEXTURE_CUBE_MAP, G);
         let Re;
         if (kt) {
            Rt && cn && t.texStorage2D(n.TEXTURE_CUBE_MAP, rt, jt, xt.width, xt.height);
            for (let Ie = 0; Ie < 6; Ie++) {
               Re = et[Ie].mipmaps;
               for (let nt = 0; nt < Re.length; nt++) {
                  const at = Re[nt];
                  G.format !== Lr ? mt !== null ? Rt ? le && t.compressedTexSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Ie, nt, 0, 0, at.width, at.height, mt, at.data) : t.compressedTexImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Ie, nt, jt, at.width, at.height, 0, at.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Rt ? le && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Ie, nt, 0, 0, at.width, at.height, mt, it, at.data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Ie, nt, jt, at.width, at.height, 0, mt, it, at.data)
               }
            }
         } else {
            if (Re = G.mipmaps, Rt && cn) {
               Re.length > 0 && rt++;
               const Ie = Ue(et[0]);
               t.texStorage2D(n.TEXTURE_CUBE_MAP, rt, jt, Ie.width, Ie.height)
            }
            for (let Ie = 0; Ie < 6; Ie++)
               if (Ke) {
                  Rt ? le && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Ie, 0, 0, 0, et[Ie].width, et[Ie].height, mt, it, et[Ie].data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Ie, 0, jt, et[Ie].width, et[Ie].height, 0, mt, it, et[Ie].data);
                  for (let nt = 0; nt < Re.length; nt++) {
                     const Bt = Re[nt].image[Ie].image;
                     Rt ? le && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Ie, nt + 1, 0, 0, Bt.width, Bt.height, mt, it, Bt.data) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Ie, nt + 1, jt, Bt.width, Bt.height, 0, mt, it, Bt.data)
                  }
               } else {
                  Rt ? le && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Ie, 0, 0, 0, mt, it, et[Ie]) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Ie, 0, jt, mt, it, et[Ie]);
                  for (let nt = 0; nt < Re.length; nt++) {
                     const at = Re[nt];
                     Rt ? le && t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Ie, nt + 1, 0, 0, mt, it, at.image[Ie]) : t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X + Ie, nt + 1, jt, mt, it, at.image[Ie])
                  }
               }
         }
         T(G) && b(n.TEXTURE_CUBE_MAP), De.__version = Oe.version, G.onUpdate && G.onUpdate(G)
      }
      K.__version = G.version
   }

   function Pe(K, G, me, Ne, Oe, De) {
      const Ye = r.convert(me.format, me.colorSpace),
         We = r.convert(me.type),
         Ze = C(me.internalFormat, Ye, We, me.colorSpace),
         kt = i.get(G),
         Ke = i.get(me);
      if (Ke.__renderTarget = G, !kt.__hasExternalTextures) {
         const et = Math.max(1, G.width >> De),
            xt = Math.max(1, G.height >> De);
         Oe === n.TEXTURE_3D || Oe === n.TEXTURE_2D_ARRAY ? t.texImage3D(Oe, De, Ze, et, xt, G.depth, 0, Ye, We, null) : t.texImage2D(Oe, De, Ze, et, xt, 0, Ye, We, null)
      }
      t.bindFramebuffer(n.FRAMEBUFFER, K), te(G) ? l.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, Ne, Oe, Ke.__webglTexture, 0, ze(G)) : (Oe === n.TEXTURE_2D || Oe >= n.TEXTURE_CUBE_MAP_POSITIVE_X && Oe <= n.TEXTURE_CUBE_MAP_NEGATIVE_Z) && n.framebufferTexture2D(n.FRAMEBUFFER, Ne, Oe, Ke.__webglTexture, De), t.bindFramebuffer(n.FRAMEBUFFER, null)
   }

   function Ge(K, G, me) {
      if (n.bindRenderbuffer(n.RENDERBUFFER, K), G.depthBuffer) {
         const Ne = G.depthTexture,
            Oe = Ne && Ne.isDepthTexture ? Ne.type : null,
            De = N(G.stencilBuffer, Oe),
            Ye = G.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT,
            We = ze(G);
         te(G) ? l.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, We, De, G.width, G.height) : me ? n.renderbufferStorageMultisample(n.RENDERBUFFER, We, De, G.width, G.height) : n.renderbufferStorage(n.RENDERBUFFER, De, G.width, G.height), n.framebufferRenderbuffer(n.FRAMEBUFFER, Ye, n.RENDERBUFFER, K)
      } else {
         const Ne = G.textures;
         for (let Oe = 0; Oe < Ne.length; Oe++) {
            const De = Ne[Oe],
               Ye = r.convert(De.format, De.colorSpace),
               We = r.convert(De.type),
               Ze = C(De.internalFormat, Ye, We, De.colorSpace),
               kt = ze(G);
            me && te(G) === !1 ? n.renderbufferStorageMultisample(n.RENDERBUFFER, kt, Ze, G.width, G.height) : te(G) ? l.renderbufferStorageMultisampleEXT(n.RENDERBUFFER, kt, Ze, G.width, G.height) : n.renderbufferStorage(n.RENDERBUFFER, Ze, G.width, G.height)
         }
      }
      n.bindRenderbuffer(n.RENDERBUFFER, null)
   }

   function Xe(K, G) {
      if (G && G.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
      if (t.bindFramebuffer(n.FRAMEBUFFER, K), !(G.depthTexture && G.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
      const Ne = i.get(G.depthTexture);
      Ne.__renderTarget = G, (!Ne.__webglTexture || G.depthTexture.image.width !== G.width || G.depthTexture.image.height !== G.height) && (G.depthTexture.image.width = G.width, G.depthTexture.image.height = G.height, G.depthTexture.needsUpdate = !0), fe(G.depthTexture, 0);
      const Oe = Ne.__webglTexture,
         De = ze(G);
      if (G.depthTexture.format === fg) te(G) ? l.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, Oe, 0, De) : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_ATTACHMENT, n.TEXTURE_2D, Oe, 0);
      else if (G.depthTexture.format === $d) te(G) ? l.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, Oe, 0, De) : n.framebufferTexture2D(n.FRAMEBUFFER, n.DEPTH_STENCIL_ATTACHMENT, n.TEXTURE_2D, Oe, 0);
      else throw new Error("Unknown depthTexture format")
   }

   function yt(K) {
      const G = i.get(K),
         me = K.isWebGLCubeRenderTarget === !0;
      if (G.__boundDepthTexture !== K.depthTexture) {
         const Ne = K.depthTexture;
         if (G.__depthDisposeCallback && G.__depthDisposeCallback(), Ne) {
            const Oe = () => {
               delete G.__boundDepthTexture, delete G.__depthDisposeCallback, Ne.removeEventListener("dispose", Oe)
            };
            Ne.addEventListener("dispose", Oe), G.__depthDisposeCallback = Oe
         }
         G.__boundDepthTexture = Ne
      }
      if (K.depthTexture && !G.__autoAllocateDepthBuffer) {
         if (me) throw new Error("target.depthTexture not supported in Cube render targets");
         Xe(G.__webglFramebuffer, K)
      } else if (me) {
         G.__webglDepthbuffer = [];
         for (let Ne = 0; Ne < 6; Ne++)
            if (t.bindFramebuffer(n.FRAMEBUFFER, G.__webglFramebuffer[Ne]), G.__webglDepthbuffer[Ne] === void 0) G.__webglDepthbuffer[Ne] = n.createRenderbuffer(), Ge(G.__webglDepthbuffer[Ne], K, !1);
            else {
               const Oe = K.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT,
                  De = G.__webglDepthbuffer[Ne];
               n.bindRenderbuffer(n.RENDERBUFFER, De), n.framebufferRenderbuffer(n.FRAMEBUFFER, Oe, n.RENDERBUFFER, De)
            }
      } else if (t.bindFramebuffer(n.FRAMEBUFFER, G.__webglFramebuffer), G.__webglDepthbuffer === void 0) G.__webglDepthbuffer = n.createRenderbuffer(), Ge(G.__webglDepthbuffer, K, !1);
      else {
         const Ne = K.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT,
            Oe = G.__webglDepthbuffer;
         n.bindRenderbuffer(n.RENDERBUFFER, Oe), n.framebufferRenderbuffer(n.FRAMEBUFFER, Ne, n.RENDERBUFFER, Oe)
      }
      t.bindFramebuffer(n.FRAMEBUFFER, null)
   }

   function vt(K, G, me) {
      const Ne = i.get(K);
      G !== void 0 && Pe(Ne.__webglFramebuffer, K, K.texture, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, 0), me !== void 0 && yt(K)
   }

   function Mt(K) {
      const G = K.texture,
         me = i.get(K),
         Ne = i.get(G);
      K.addEventListener("dispose", B);
      const Oe = K.textures,
         De = K.isWebGLCubeRenderTarget === !0,
         Ye = Oe.length > 1;
      if (Ye || (Ne.__webglTexture === void 0 && (Ne.__webglTexture = n.createTexture()), Ne.__version = G.version, a.memory.textures++), De) {
         me.__webglFramebuffer = [];
         for (let We = 0; We < 6; We++)
            if (G.mipmaps && G.mipmaps.length > 0) {
               me.__webglFramebuffer[We] = [];
               for (let Ze = 0; Ze < G.mipmaps.length; Ze++) me.__webglFramebuffer[We][Ze] = n.createFramebuffer()
            } else me.__webglFramebuffer[We] = n.createFramebuffer()
      } else {
         if (G.mipmaps && G.mipmaps.length > 0) {
            me.__webglFramebuffer = [];
            for (let We = 0; We < G.mipmaps.length; We++) me.__webglFramebuffer[We] = n.createFramebuffer()
         } else me.__webglFramebuffer = n.createFramebuffer();
         if (Ye)
            for (let We = 0, Ze = Oe.length; We < Ze; We++) {
               const kt = i.get(Oe[We]);
               kt.__webglTexture === void 0 && (kt.__webglTexture = n.createTexture(), a.memory.textures++)
            }
         if (K.samples > 0 && te(K) === !1) {
            me.__webglMultisampledFramebuffer = n.createFramebuffer(), me.__webglColorRenderbuffer = [], t.bindFramebuffer(n.FRAMEBUFFER, me.__webglMultisampledFramebuffer);
            for (let We = 0; We < Oe.length; We++) {
               const Ze = Oe[We];
               me.__webglColorRenderbuffer[We] = n.createRenderbuffer(), n.bindRenderbuffer(n.RENDERBUFFER, me.__webglColorRenderbuffer[We]);
               const kt = r.convert(Ze.format, Ze.colorSpace),
                  Ke = r.convert(Ze.type),
                  et = C(Ze.internalFormat, kt, Ke, Ze.colorSpace, K.isXRRenderTarget === !0),
                  xt = ze(K);
               n.renderbufferStorageMultisample(n.RENDERBUFFER, xt, et, K.width, K.height), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + We, n.RENDERBUFFER, me.__webglColorRenderbuffer[We])
            }
            n.bindRenderbuffer(n.RENDERBUFFER, null), K.depthBuffer && (me.__webglDepthRenderbuffer = n.createRenderbuffer(), Ge(me.__webglDepthRenderbuffer, K, !0)), t.bindFramebuffer(n.FRAMEBUFFER, null)
         }
      }
      if (De) {
         t.bindTexture(n.TEXTURE_CUBE_MAP, Ne.__webglTexture), ye(n.TEXTURE_CUBE_MAP, G);
         for (let We = 0; We < 6; We++)
            if (G.mipmaps && G.mipmaps.length > 0)
               for (let Ze = 0; Ze < G.mipmaps.length; Ze++) Pe(me.__webglFramebuffer[We][Ze], K, G, n.COLOR_ATTACHMENT0, n.TEXTURE_CUBE_MAP_POSITIVE_X + We, Ze);
            else Pe(me.__webglFramebuffer[We], K, G, n.COLOR_ATTACHMENT0, n.TEXTURE_CUBE_MAP_POSITIVE_X + We, 0);
         T(G) && b(n.TEXTURE_CUBE_MAP), t.unbindTexture()
      } else if (Ye) {
         for (let We = 0, Ze = Oe.length; We < Ze; We++) {
            const kt = Oe[We],
               Ke = i.get(kt);
            t.bindTexture(n.TEXTURE_2D, Ke.__webglTexture), ye(n.TEXTURE_2D, kt), Pe(me.__webglFramebuffer, K, kt, n.COLOR_ATTACHMENT0 + We, n.TEXTURE_2D, 0), T(kt) && b(n.TEXTURE_2D)
         }
         t.unbindTexture()
      } else {
         let We = n.TEXTURE_2D;
         if ((K.isWebGL3DRenderTarget || K.isWebGLArrayRenderTarget) && (We = K.isWebGL3DRenderTarget ? n.TEXTURE_3D : n.TEXTURE_2D_ARRAY), t.bindTexture(We, Ne.__webglTexture), ye(We, G), G.mipmaps && G.mipmaps.length > 0)
            for (let Ze = 0; Ze < G.mipmaps.length; Ze++) Pe(me.__webglFramebuffer[Ze], K, G, n.COLOR_ATTACHMENT0, We, Ze);
         else Pe(me.__webglFramebuffer, K, G, n.COLOR_ATTACHMENT0, We, 0);
         T(G) && b(We), t.unbindTexture()
      }
      K.depthBuffer && yt(K)
   }

   function zt(K) {
      const G = K.textures;
      for (let me = 0, Ne = G.length; me < Ne; me++) {
         const Oe = G[me];
         if (T(Oe)) {
            const De = w(K),
               Ye = i.get(Oe).__webglTexture;
            t.bindTexture(De, Ye), b(De), t.unbindTexture()
         }
      }
   }
   const lt = [],
      ne = [];

   function sn(K) {
      if (K.samples > 0) {
         if (te(K) === !1) {
            const G = K.textures,
               me = K.width,
               Ne = K.height;
            let Oe = n.COLOR_BUFFER_BIT;
            const De = K.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT,
               Ye = i.get(K),
               We = G.length > 1;
            if (We)
               for (let Ze = 0; Ze < G.length; Ze++) t.bindFramebuffer(n.FRAMEBUFFER, Ye.__webglMultisampledFramebuffer), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Ze, n.RENDERBUFFER, null), t.bindFramebuffer(n.FRAMEBUFFER, Ye.__webglFramebuffer), n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Ze, n.TEXTURE_2D, null, 0);
            t.bindFramebuffer(n.READ_FRAMEBUFFER, Ye.__webglMultisampledFramebuffer), t.bindFramebuffer(n.DRAW_FRAMEBUFFER, Ye.__webglFramebuffer);
            for (let Ze = 0; Ze < G.length; Ze++) {
               if (K.resolveDepthBuffer && (K.depthBuffer && (Oe |= n.DEPTH_BUFFER_BIT), K.stencilBuffer && K.resolveStencilBuffer && (Oe |= n.STENCIL_BUFFER_BIT)), We) {
                  n.framebufferRenderbuffer(n.READ_FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.RENDERBUFFER, Ye.__webglColorRenderbuffer[Ze]);
                  const kt = i.get(G[Ze]).__webglTexture;
                  n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0, n.TEXTURE_2D, kt, 0)
               }
               n.blitFramebuffer(0, 0, me, Ne, 0, 0, me, Ne, Oe, n.NEAREST), c === !0 && (lt.length = 0, ne.length = 0, lt.push(n.COLOR_ATTACHMENT0 + Ze), K.depthBuffer && K.resolveDepthBuffer === !1 && (lt.push(De), ne.push(De), n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, ne)), n.invalidateFramebuffer(n.READ_FRAMEBUFFER, lt))
            }
            if (t.bindFramebuffer(n.READ_FRAMEBUFFER, null), t.bindFramebuffer(n.DRAW_FRAMEBUFFER, null), We)
               for (let Ze = 0; Ze < G.length; Ze++) {
                  t.bindFramebuffer(n.FRAMEBUFFER, Ye.__webglMultisampledFramebuffer), n.framebufferRenderbuffer(n.FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Ze, n.RENDERBUFFER, Ye.__webglColorRenderbuffer[Ze]);
                  const kt = i.get(G[Ze]).__webglTexture;
                  t.bindFramebuffer(n.FRAMEBUFFER, Ye.__webglFramebuffer), n.framebufferTexture2D(n.DRAW_FRAMEBUFFER, n.COLOR_ATTACHMENT0 + Ze, n.TEXTURE_2D, kt, 0)
               }
            t.bindFramebuffer(n.DRAW_FRAMEBUFFER, Ye.__webglMultisampledFramebuffer)
         } else if (K.depthBuffer && K.resolveDepthBuffer === !1 && c) {
            const G = K.stencilBuffer ? n.DEPTH_STENCIL_ATTACHMENT : n.DEPTH_ATTACHMENT;
            n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER, [G])
         }
      }
   }

   function ze(K) {
      return Math.min(s.maxSamples, K.samples)
   }

   function te(K) {
      const G = i.get(K);
      return K.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && G.__useRenderToTexture !== !1
   }

   function Be(K) {
      const G = a.render.frame;
      m.get(K) !== G && (m.set(K, G), K.update())
   }

   function Je(K, G) {
      const me = K.colorSpace,
         Ne = K.format,
         Oe = K.type;
      return K.isCompressedTexture === !0 || K.isVideoTexture === !0 || me !== Gu && me !== Bl && (Vn.getTransfer(me) === di ? (Ne !== Lr || Oe !== qs) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", me)), G
   }

   function Ue(K) {
      return typeof HTMLImageElement < "u" && K instanceof HTMLImageElement ? (h.width = K.naturalWidth || K.width, h.height = K.naturalHeight || K.height) : typeof VideoFrame < "u" && K instanceof VideoFrame ? (h.width = K.displayWidth, h.height = K.displayHeight) : (h.width = K.width, h.height = K.height), h
   }
   this.allocateTextureUnit = $, this.resetTextureUnits = Q, this.setTexture2D = fe, this.setTexture2DArray = k, this.setTexture3D = Z, this.setTextureCube = J, this.rebindTextures = vt, this.setupRenderTarget = Mt, this.updateRenderTargetMipmap = zt, this.updateMultisampleRenderTarget = sn, this.setupDepthRenderbuffer = yt, this.setupFrameBufferTexture = Pe, this.useMultisampledRTT = te
}

function NB(n, e) {
   function t(i, s = Bl) {
      let r;
      const a = Vn.getTransfer(s);
      if (i === qs) return n.UNSIGNED_BYTE;
      if (i === iT) return n.UNSIGNED_SHORT_4_4_4_4;
      if (i === sT) return n.UNSIGNED_SHORT_5_5_5_1;
      if (i === SR) return n.UNSIGNED_INT_5_9_9_9_REV;
      if (i === xR) return n.BYTE;
      if (i === _R) return n.SHORT;
      if (i === cg) return n.UNSIGNED_SHORT;
      if (i === nT) return n.INT;
      if (i === Vu) return n.UNSIGNED_INT;
      if (i === ha) return n.FLOAT;
      if (i === lp) return n.HALF_FLOAT;
      if (i === bR) return n.ALPHA;
      if (i === TR) return n.RGB;
      if (i === Lr) return n.RGBA;
      if (i === ER) return n.LUMINANCE;
      if (i === MR) return n.LUMINANCE_ALPHA;
      if (i === fg) return n.DEPTH_COMPONENT;
      if (i === $d) return n.DEPTH_STENCIL;
      if (i === rT) return n.RED;
      if (i === hx) return n.RED_INTEGER;
      if (i === AR) return n.RG;
      if (i === aT) return n.RG_INTEGER;
      if (i === oT) return n.RGBA_INTEGER;
      if (i === H0 || i === V0 || i === G0 || i === k0)
         if (a === di)
            if (r = e.get("WEBGL_compressed_texture_s3tc_srgb"), r !== null) {
               if (i === H0) return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
               if (i === V0) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
               if (i === G0) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
               if (i === k0) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
            } else return null;
      else if (r = e.get("WEBGL_compressed_texture_s3tc"), r !== null) {
         if (i === H0) return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
         if (i === V0) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
         if (i === G0) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
         if (i === k0) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT
      } else return null;
      if (i === Wb || i === Yb || i === Kb || i === Zb)
         if (r = e.get("WEBGL_compressed_texture_pvrtc"), r !== null) {
            if (i === Wb) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            if (i === Yb) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            if (i === Kb) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            if (i === Zb) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
         } else return null;
      if (i === Qb || i === Jb || i === $b)
         if (r = e.get("WEBGL_compressed_texture_etc"), r !== null) {
            if (i === Qb || i === Jb) return a === di ? r.COMPRESSED_SRGB8_ETC2 : r.COMPRESSED_RGB8_ETC2;
            if (i === $b) return a === di ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : r.COMPRESSED_RGBA8_ETC2_EAC
         } else return null;
      if (i === e1 || i === t1 || i === n1 || i === i1 || i === s1 || i === r1 || i === a1 || i === o1 || i === l1 || i === u1 || i === c1 || i === f1 || i === h1 || i === d1)
         if (r = e.get("WEBGL_compressed_texture_astc"), r !== null) {
            if (i === e1) return a === di ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
            if (i === t1) return a === di ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
            if (i === n1) return a === di ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
            if (i === i1) return a === di ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
            if (i === s1) return a === di ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
            if (i === r1) return a === di ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
            if (i === a1) return a === di ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
            if (i === o1) return a === di ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
            if (i === l1) return a === di ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
            if (i === u1) return a === di ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
            if (i === c1) return a === di ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
            if (i === f1) return a === di ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
            if (i === h1) return a === di ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
            if (i === d1) return a === di ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : r.COMPRESSED_RGBA_ASTC_12x12_KHR
         } else return null;
      if (i === j0 || i === p1 || i === m1)
         if (r = e.get("EXT_texture_compression_bptc"), r !== null) {
            if (i === j0) return a === di ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : r.COMPRESSED_RGBA_BPTC_UNORM_EXT;
            if (i === p1) return r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
            if (i === m1) return r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
         } else return null;
      if (i === wR || i === g1 || i === v1 || i === y1)
         if (r = e.get("EXT_texture_compression_rgtc"), r !== null) {
            if (i === j0) return r.COMPRESSED_RED_RGTC1_EXT;
            if (i === g1) return r.COMPRESSED_SIGNED_RED_RGTC1_EXT;
            if (i === v1) return r.COMPRESSED_RED_GREEN_RGTC2_EXT;
            if (i === y1) return r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
         } else return null;
      return i === Jd ? n.UNSIGNED_INT_24_8 : n[i] !== void 0 ? n[i] : null
   }
   return {
      convert: t
   }
}
const Cq = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`,
   Dq = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class Nq {
   constructor() {
      this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0
   }
   init(e, t, i) {
      if (this.texture === null) {
         const s = new Hi,
            r = e.properties.get(s);
         r.__webglTexture = t.texture, (t.depthNear !== i.depthNear || t.depthFar !== i.depthFar) && (this.depthNear = t.depthNear, this.depthFar = t.depthFar), this.texture = s
      }
   }
   getMesh(e) {
      if (this.texture !== null && this.mesh === null) {
         const t = e.cameras[0].viewport,
            i = new gs({
               vertexShader: Cq,
               fragmentShader: Dq,
               uniforms: {
                  depthColor: {
                     value: this.texture
                  },
                  depthWidth: {
                     value: t.z
                  },
                  depthHeight: {
                     value: t.w
                  }
               }
            });
         this.mesh = new ds(new Bg(20, 20), i)
      }
      return this.mesh
   }
   reset() {
      this.texture = null, this.mesh = null
   }
   getDepthTexture() {
      return this.texture
   }
}
class Oq extends xo {
   constructor(e, t) {
      super();
      const i = this;
      let s = null,
         r = 1,
         a = null,
         l = "local-floor",
         c = 1,
         h = null,
         m = null,
         g = null,
         v = null,
         x = null,
         S = null;
      const E = new Nq,
         T = t.getContextAttributes();
      let b = null,
         w = null;
      const C = [],
         N = [],
         U = new Fe;
      let z = null;
      const B = new Cs;
      B.viewport = new Gn;
      const I = new Cs;
      I.viewport = new Gn;
      const O = [B, I],
         P = new _B;
      let q = null,
         Q = null;
      this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function (oe) {
         let be = C[oe];
         return be === void 0 && (be = new Sb, C[oe] = be), be.getTargetRaySpace()
      }, this.getControllerGrip = function (oe) {
         let be = C[oe];
         return be === void 0 && (be = new Sb, C[oe] = be), be.getGripSpace()
      }, this.getHand = function (oe) {
         let be = C[oe];
         return be === void 0 && (be = new Sb, C[oe] = be), be.getHandSpace()
      };

      function $(oe) {
         const be = N.indexOf(oe.inputSource);
         if (be === -1) return;
         const Pe = C[be];
         Pe !== void 0 && (Pe.update(oe.inputSource, oe.frame, h || a), Pe.dispatchEvent({
            type: oe.type,
            data: oe.inputSource
         }))
      }

      function ae() {
         s.removeEventListener("select", $), s.removeEventListener("selectstart", $), s.removeEventListener("selectend", $), s.removeEventListener("squeeze", $), s.removeEventListener("squeezestart", $), s.removeEventListener("squeezeend", $), s.removeEventListener("end", ae), s.removeEventListener("inputsourceschange", fe);
         for (let oe = 0; oe < C.length; oe++) {
            const be = N[oe];
            be !== null && (N[oe] = null, C[oe].disconnect(be))
         }
         q = null, Q = null, E.reset(), e.setRenderTarget(b), x = null, v = null, g = null, s = null, w = null, we.stop(), i.isPresenting = !1, e.setPixelRatio(z), e.setSize(U.width, U.height, !1), i.dispatchEvent({
            type: "sessionend"
         })
      }
      this.setFramebufferScaleFactor = function (oe) {
         r = oe, i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
      }, this.setReferenceSpaceType = function (oe) {
         l = oe, i.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
      }, this.getReferenceSpace = function () {
         return h || a
      }, this.setReferenceSpace = function (oe) {
         h = oe
      }, this.getBaseLayer = function () {
         return v !== null ? v : x
      }, this.getBinding = function () {
         return g
      }, this.getFrame = function () {
         return S
      }, this.getSession = function () {
         return s
      }, this.setSession = async function (oe) {
         if (s = oe, s !== null) {
            if (b = e.getRenderTarget(), s.addEventListener("select", $), s.addEventListener("selectstart", $), s.addEventListener("selectend", $), s.addEventListener("squeeze", $), s.addEventListener("squeezestart", $), s.addEventListener("squeezeend", $), s.addEventListener("end", ae), s.addEventListener("inputsourceschange", fe), T.xrCompatible !== !0 && await t.makeXRCompatible(), z = e.getPixelRatio(), e.getSize(U), typeof XRWebGLBinding < "u" && "createProjectionLayer" in XRWebGLBinding.prototype) {
               let Pe = null,
                  Ge = null,
                  Xe = null;
               T.depth && (Xe = T.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, Pe = T.stencil ? $d : fg, Ge = T.stencil ? Jd : Vu);
               const yt = {
                  colorFormat: t.RGBA8,
                  depthFormat: Xe,
                  scaleFactor: r
               };
               g = new XRWebGLBinding(s, t), v = g.createProjectionLayer(yt), s.updateRenderState({
                  layers: [v]
               }), e.setPixelRatio(1), e.setSize(v.textureWidth, v.textureHeight, !1), w = new ss(v.textureWidth, v.textureHeight, {
                  format: Lr,
                  type: qs,
                  depthTexture: new vx(v.textureWidth, v.textureHeight, Ge, void 0, void 0, void 0, void 0, void 0, void 0, Pe),
                  stencilBuffer: T.stencil,
                  colorSpace: e.outputColorSpace,
                  samples: T.antialias ? 4 : 0,
                  resolveDepthBuffer: v.ignoreDepthValues === !1,
                  resolveStencilBuffer: v.ignoreDepthValues === !1
               })
            } else {
               const Pe = {
                  antialias: T.antialias,
                  alpha: !0,
                  depth: T.depth,
                  stencil: T.stencil,
                  framebufferScaleFactor: r
               };
               x = new XRWebGLLayer(s, t, Pe), s.updateRenderState({
                  baseLayer: x
               }), e.setPixelRatio(1), e.setSize(x.framebufferWidth, x.framebufferHeight, !1), w = new ss(x.framebufferWidth, x.framebufferHeight, {
                  format: Lr,
                  type: qs,
                  colorSpace: e.outputColorSpace,
                  stencilBuffer: T.stencil,
                  resolveDepthBuffer: x.ignoreDepthValues === !1,
                  resolveStencilBuffer: x.ignoreDepthValues === !1
               })
            }
            w.isXRRenderTarget = !0, this.setFoveation(c), h = null, a = await s.requestReferenceSpace(l), we.setContext(s), we.start(), i.isPresenting = !0, i.dispatchEvent({
               type: "sessionstart"
            })
         }
      }, this.getEnvironmentBlendMode = function () {
         if (s !== null) return s.environmentBlendMode
      }, this.getDepthTexture = function () {
         return E.getDepthTexture()
      };

      function fe(oe) {
         for (let be = 0; be < oe.removed.length; be++) {
            const Pe = oe.removed[be],
               Ge = N.indexOf(Pe);
            Ge >= 0 && (N[Ge] = null, C[Ge].disconnect(Pe))
         }
         for (let be = 0; be < oe.added.length; be++) {
            const Pe = oe.added[be];
            let Ge = N.indexOf(Pe);
            if (Ge === -1) {
               for (let yt = 0; yt < C.length; yt++)
                  if (yt >= N.length) {
                     N.push(Pe), Ge = yt;
                     break
                  } else if (N[yt] === null) {
                  N[yt] = Pe, Ge = yt;
                  break
               }
               if (Ge === -1) break
            }
            const Xe = C[Ge];
            Xe && Xe.connect(Pe)
         }
      }
      const k = new ee,
         Z = new ee;

      function J(oe, be, Pe) {
         k.setFromMatrixPosition(be.matrixWorld), Z.setFromMatrixPosition(Pe.matrixWorld);
         const Ge = k.distanceTo(Z),
            Xe = be.projectionMatrix.elements,
            yt = Pe.projectionMatrix.elements,
            vt = Xe[14] / (Xe[10] - 1),
            Mt = Xe[14] / (Xe[10] + 1),
            zt = (Xe[9] + 1) / Xe[5],
            lt = (Xe[9] - 1) / Xe[5],
            ne = (Xe[8] - 1) / Xe[0],
            sn = (yt[8] + 1) / yt[0],
            ze = vt * ne,
            te = vt * sn,
            Be = Ge / (-ne + sn),
            Je = Be * -ne;
         if (be.matrixWorld.decompose(oe.position, oe.quaternion, oe.scale), oe.translateX(Je), oe.translateZ(Be), oe.matrixWorld.compose(oe.position, oe.quaternion, oe.scale), oe.matrixWorldInverse.copy(oe.matrixWorld).invert(), Xe[10] === -1) oe.projectionMatrix.copy(be.projectionMatrix), oe.projectionMatrixInverse.copy(be.projectionMatrixInverse);
         else {
            const Ue = vt + Be,
               K = Mt + Be,
               G = ze - Je,
               me = te + (Ge - Je),
               Ne = zt * Mt / K * Ue,
               Oe = lt * Mt / K * Ue;
            oe.projectionMatrix.makePerspective(G, me, Ne, Oe, Ue, K), oe.projectionMatrixInverse.copy(oe.projectionMatrix).invert()
         }
      }

      function pe(oe, be) {
         be === null ? oe.matrixWorld.copy(oe.matrix) : oe.matrixWorld.multiplyMatrices(be.matrixWorld, oe.matrix), oe.matrixWorldInverse.copy(oe.matrixWorld).invert()
      }
      this.updateCamera = function (oe) {
         if (s === null) return;
         let be = oe.near,
            Pe = oe.far;
         E.texture !== null && (E.depthNear > 0 && (be = E.depthNear), E.depthFar > 0 && (Pe = E.depthFar)), P.near = I.near = B.near = be, P.far = I.far = B.far = Pe, (q !== P.near || Q !== P.far) && (s.updateRenderState({
            depthNear: P.near,
            depthFar: P.far
         }), q = P.near, Q = P.far), B.layers.mask = oe.layers.mask | 2, I.layers.mask = oe.layers.mask | 4, P.layers.mask = B.layers.mask | I.layers.mask;
         const Ge = oe.parent,
            Xe = P.cameras;
         pe(P, Ge);
         for (let yt = 0; yt < Xe.length; yt++) pe(Xe[yt], Ge);
         Xe.length === 2 ? J(P, B, I) : P.projectionMatrix.copy(B.projectionMatrix), F(oe, P, Ge)
      };

      function F(oe, be, Pe) {
         Pe === null ? oe.matrix.copy(be.matrixWorld) : (oe.matrix.copy(Pe.matrixWorld), oe.matrix.invert(), oe.matrix.multiply(be.matrixWorld)), oe.matrix.decompose(oe.position, oe.quaternion, oe.scale), oe.updateMatrixWorld(!0), oe.projectionMatrix.copy(be.projectionMatrix), oe.projectionMatrixInverse.copy(be.projectionMatrixInverse), oe.isPerspectiveCamera && (oe.fov = hg * 2 * Math.atan(1 / oe.projectionMatrix.elements[5]), oe.zoom = 1)
      }
      this.getCamera = function () {
         return P
      }, this.getFoveation = function () {
         if (!(v === null && x === null)) return c
      }, this.setFoveation = function (oe) {
         c = oe, v !== null && (v.fixedFoveation = oe), x !== null && x.fixedFoveation !== void 0 && (x.fixedFoveation = oe)
      }, this.hasDepthSensing = function () {
         return E.texture !== null
      }, this.getDepthSensingMesh = function () {
         return E.getMesh(P)
      };
      let ie = null;

      function ye(oe, be) {
         if (m = be.getViewerPose(h || a), S = be, m !== null) {
            const Pe = m.views;
            x !== null && (e.setRenderTargetFramebuffer(w, x.framebuffer), e.setRenderTarget(w));
            let Ge = !1;
            Pe.length !== P.cameras.length && (P.cameras.length = 0, Ge = !0);
            for (let vt = 0; vt < Pe.length; vt++) {
               const Mt = Pe[vt];
               let zt = null;
               if (x !== null) zt = x.getViewport(Mt);
               else {
                  const ne = g.getViewSubImage(v, Mt);
                  zt = ne.viewport, vt === 0 && (e.setRenderTargetTextures(w, ne.colorTexture, ne.depthStencilTexture), e.setRenderTarget(w))
               }
               let lt = O[vt];
               lt === void 0 && (lt = new Cs, lt.layers.enable(vt), lt.viewport = new Gn, O[vt] = lt), lt.matrix.fromArray(Mt.transform.matrix), lt.matrix.decompose(lt.position, lt.quaternion, lt.scale), lt.projectionMatrix.fromArray(Mt.projectionMatrix), lt.projectionMatrixInverse.copy(lt.projectionMatrix).invert(), lt.viewport.set(zt.x, zt.y, zt.width, zt.height), vt === 0 && (P.matrix.copy(lt.matrix), P.matrix.decompose(P.position, P.quaternion, P.scale)), Ge === !0 && P.cameras.push(lt)
            }
            const Xe = s.enabledFeatures;
            if (Xe && Xe.includes("depth-sensing") && s.depthUsage == "gpu-optimized" && g) {
               const vt = g.getDepthInformation(Pe[0]);
               vt && vt.isValid && vt.texture && E.init(e, vt, s.renderState)
            }
         }
         for (let Pe = 0; Pe < C.length; Pe++) {
            const Ge = N[Pe],
               Xe = C[Pe];
            Ge !== null && Xe !== void 0 && Xe.update(Ge, be, h || a)
         }
         ie && ie(oe, be), be.detectedPlanes && i.dispatchEvent({
            type: "planesdetected",
            data: be
         }), S = null
      }
      const we = new AB;
      we.setAnimationLoop(ye), this.setAnimationLoop = function (oe) {
         ie = oe
      }, this.dispose = function () {}
   }
}
const xd = new go,
   Uq = new Zt;

function Pq(n, e) {
   function t(T, b) {
      T.matrixAutoUpdate === !0 && T.updateMatrix(), b.value.copy(T.matrix)
   }

   function i(T, b) {
      b.color.getRGB(T.fogColor.value, wL(n)), b.isFog ? (T.fogNear.value = b.near, T.fogFar.value = b.far) : b.isFogExp2 && (T.fogDensity.value = b.density)
   }

   function s(T, b, w, C, N) {
      b.isMeshBasicMaterial || b.isMeshLambertMaterial ? r(T, b) : b.isMeshToonMaterial ? (r(T, b), g(T, b)) : b.isMeshPhongMaterial ? (r(T, b), m(T, b)) : b.isMeshStandardMaterial ? (r(T, b), v(T, b), b.isMeshPhysicalMaterial && x(T, b, N)) : b.isMeshMatcapMaterial ? (r(T, b), S(T, b)) : b.isMeshDepthMaterial ? r(T, b) : b.isMeshDistanceMaterial ? (r(T, b), E(T, b)) : b.isMeshNormalMaterial ? r(T, b) : b.isLineBasicMaterial ? (a(T, b), b.isLineDashedMaterial && l(T, b)) : b.isPointsMaterial ? c(T, b, w, C) : b.isSpriteMaterial ? h(T, b) : b.isShadowMaterial ? (T.color.value.copy(b.color), T.opacity.value = b.opacity) : b.isShaderMaterial && (b.uniformsNeedUpdate = !1)
   }

   function r(T, b) {
      T.opacity.value = b.opacity, b.color && T.diffuse.value.copy(b.color), b.emissive && T.emissive.value.copy(b.emissive).multiplyScalar(b.emissiveIntensity), b.map && (T.map.value = b.map, t(b.map, T.mapTransform)), b.alphaMap && (T.alphaMap.value = b.alphaMap, t(b.alphaMap, T.alphaMapTransform)), b.bumpMap && (T.bumpMap.value = b.bumpMap, t(b.bumpMap, T.bumpMapTransform), T.bumpScale.value = b.bumpScale, b.side === Ds && (T.bumpScale.value *= -1)), b.normalMap && (T.normalMap.value = b.normalMap, t(b.normalMap, T.normalMapTransform), T.normalScale.value.copy(b.normalScale), b.side === Ds && T.normalScale.value.negate()), b.displacementMap && (T.displacementMap.value = b.displacementMap, t(b.displacementMap, T.displacementMapTransform), T.displacementScale.value = b.displacementScale, T.displacementBias.value = b.displacementBias), b.emissiveMap && (T.emissiveMap.value = b.emissiveMap, t(b.emissiveMap, T.emissiveMapTransform)), b.specularMap && (T.specularMap.value = b.specularMap, t(b.specularMap, T.specularMapTransform)), b.alphaTest > 0 && (T.alphaTest.value = b.alphaTest);
      const w = e.get(b),
         C = w.envMap,
         N = w.envMapRotation;
      C && (T.envMap.value = C, xd.copy(N), xd.x *= -1, xd.y *= -1, xd.z *= -1, C.isCubeTexture && C.isRenderTargetTexture === !1 && (xd.y *= -1, xd.z *= -1), T.envMapRotation.value.setFromMatrix4(Uq.makeRotationFromEuler(xd)), T.flipEnvMap.value = C.isCubeTexture && C.isRenderTargetTexture === !1 ? -1 : 1, T.reflectivity.value = b.reflectivity, T.ior.value = b.ior, T.refractionRatio.value = b.refractionRatio), b.lightMap && (T.lightMap.value = b.lightMap, T.lightMapIntensity.value = b.lightMapIntensity, t(b.lightMap, T.lightMapTransform)), b.aoMap && (T.aoMap.value = b.aoMap, T.aoMapIntensity.value = b.aoMapIntensity, t(b.aoMap, T.aoMapTransform))
   }

   function a(T, b) {
      T.diffuse.value.copy(b.color), T.opacity.value = b.opacity, b.map && (T.map.value = b.map, t(b.map, T.mapTransform))
   }

   function l(T, b) {
      T.dashSize.value = b.dashSize, T.totalSize.value = b.dashSize + b.gapSize, T.scale.value = b.scale
   }

   function c(T, b, w, C) {
      T.diffuse.value.copy(b.color), T.opacity.value = b.opacity, T.size.value = b.size * w, T.scale.value = C * .5, b.map && (T.map.value = b.map, t(b.map, T.uvTransform)), b.alphaMap && (T.alphaMap.value = b.alphaMap, t(b.alphaMap, T.alphaMapTransform)), b.alphaTest > 0 && (T.alphaTest.value = b.alphaTest)
   }

   function h(T, b) {
      T.diffuse.value.copy(b.color), T.opacity.value = b.opacity, T.rotation.value = b.rotation, b.map && (T.map.value = b.map, t(b.map, T.mapTransform)), b.alphaMap && (T.alphaMap.value = b.alphaMap, t(b.alphaMap, T.alphaMapTransform)), b.alphaTest > 0 && (T.alphaTest.value = b.alphaTest)
   }

   function m(T, b) {
      T.specular.value.copy(b.specular), T.shininess.value = Math.max(b.shininess, 1e-4)
   }

   function g(T, b) {
      b.gradientMap && (T.gradientMap.value = b.gradientMap)
   }

   function v(T, b) {
      T.metalness.value = b.metalness, b.metalnessMap && (T.metalnessMap.value = b.metalnessMap, t(b.metalnessMap, T.metalnessMapTransform)), T.roughness.value = b.roughness, b.roughnessMap && (T.roughnessMap.value = b.roughnessMap, t(b.roughnessMap, T.roughnessMapTransform)), b.envMap && (T.envMapIntensity.value = b.envMapIntensity)
   }

   function x(T, b, w) {
      T.ior.value = b.ior, b.sheen > 0 && (T.sheenColor.value.copy(b.sheenColor).multiplyScalar(b.sheen), T.sheenRoughness.value = b.sheenRoughness, b.sheenColorMap && (T.sheenColorMap.value = b.sheenColorMap, t(b.sheenColorMap, T.sheenColorMapTransform)), b.sheenRoughnessMap && (T.sheenRoughnessMap.value = b.sheenRoughnessMap, t(b.sheenRoughnessMap, T.sheenRoughnessMapTransform))), b.clearcoat > 0 && (T.clearcoat.value = b.clearcoat, T.clearcoatRoughness.value = b.clearcoatRoughness, b.clearcoatMap && (T.clearcoatMap.value = b.clearcoatMap, t(b.clearcoatMap, T.clearcoatMapTransform)), b.clearcoatRoughnessMap && (T.clearcoatRoughnessMap.value = b.clearcoatRoughnessMap, t(b.clearcoatRoughnessMap, T.clearcoatRoughnessMapTransform)), b.clearcoatNormalMap && (T.clearcoatNormalMap.value = b.clearcoatNormalMap, t(b.clearcoatNormalMap, T.clearcoatNormalMapTransform), T.clearcoatNormalScale.value.copy(b.clearcoatNormalScale), b.side === Ds && T.clearcoatNormalScale.value.negate())), b.dispersion > 0 && (T.dispersion.value = b.dispersion), b.iridescence > 0 && (T.iridescence.value = b.iridescence, T.iridescenceIOR.value = b.iridescenceIOR, T.iridescenceThicknessMinimum.value = b.iridescenceThicknessRange[0], T.iridescenceThicknessMaximum.value = b.iridescenceThicknessRange[1], b.iridescenceMap && (T.iridescenceMap.value = b.iridescenceMap, t(b.iridescenceMap, T.iridescenceMapTransform)), b.iridescenceThicknessMap && (T.iridescenceThicknessMap.value = b.iridescenceThicknessMap, t(b.iridescenceThicknessMap, T.iridescenceThicknessMapTransform))), b.transmission > 0 && (T.transmission.value = b.transmission, T.transmissionSamplerMap.value = w.texture, T.transmissionSamplerSize.value.set(w.width, w.height), b.transmissionMap && (T.transmissionMap.value = b.transmissionMap, t(b.transmissionMap, T.transmissionMapTransform)), T.thickness.value = b.thickness, b.thicknessMap && (T.thicknessMap.value = b.thicknessMap, t(b.thicknessMap, T.thicknessMapTransform)), T.attenuationDistance.value = b.attenuationDistance, T.attenuationColor.value.copy(b.attenuationColor)), b.anisotropy > 0 && (T.anisotropyVector.value.set(b.anisotropy * Math.cos(b.anisotropyRotation), b.anisotropy * Math.sin(b.anisotropyRotation)), b.anisotropyMap && (T.anisotropyMap.value = b.anisotropyMap, t(b.anisotropyMap, T.anisotropyMapTransform))), T.specularIntensity.value = b.specularIntensity, T.specularColor.value.copy(b.specularColor), b.specularColorMap && (T.specularColorMap.value = b.specularColorMap, t(b.specularColorMap, T.specularColorMapTransform)), b.specularIntensityMap && (T.specularIntensityMap.value = b.specularIntensityMap, t(b.specularIntensityMap, T.specularIntensityMapTransform))
   }

   function S(T, b) {
      b.matcap && (T.matcap.value = b.matcap)
   }

   function E(T, b) {
      const w = e.get(b).light;
      T.referencePosition.value.setFromMatrixPosition(w.matrixWorld), T.nearDistance.value = w.shadow.camera.near, T.farDistance.value = w.shadow.camera.far
   }
   return {
      refreshFogUniforms: i,
      refreshMaterialUniforms: s
   }
}

function Lq(n, e, t, i) {
   let s = {},
      r = {},
      a = [];
   const l = n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS);

   function c(w, C) {
      const N = C.program;
      i.uniformBlockBinding(w, N)
   }

   function h(w, C) {
      let N = s[w.id];
      N === void 0 && (S(w), N = m(w), s[w.id] = N, w.addEventListener("dispose", T));
      const U = C.program;
      i.updateUBOMapping(w, U);
      const z = e.render.frame;
      r[w.id] !== z && (v(w), r[w.id] = z)
   }

   function m(w) {
      const C = g();
      w.__bindingPointIndex = C;
      const N = n.createBuffer(),
         U = w.__size,
         z = w.usage;
      return n.bindBuffer(n.UNIFORM_BUFFER, N), n.bufferData(n.UNIFORM_BUFFER, U, z), n.bindBuffer(n.UNIFORM_BUFFER, null), n.bindBufferBase(n.UNIFORM_BUFFER, C, N), N
   }

   function g() {
      for (let w = 0; w < l; w++)
         if (a.indexOf(w) === -1) return a.push(w), w;
      return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0
   }

   function v(w) {
      const C = s[w.id],
         N = w.uniforms,
         U = w.__cache;
      n.bindBuffer(n.UNIFORM_BUFFER, C);
      for (let z = 0, B = N.length; z < B; z++) {
         const I = Array.isArray(N[z]) ? N[z] : [N[z]];
         for (let O = 0, P = I.length; O < P; O++) {
            const q = I[O];
            if (x(q, z, O, U) === !0) {
               const Q = q.__offset,
                  $ = Array.isArray(q.value) ? q.value : [q.value];
               let ae = 0;
               for (let fe = 0; fe < $.length; fe++) {
                  const k = $[fe],
                     Z = E(k);
                  typeof k == "number" || typeof k == "boolean" ? (q.__data[0] = k, n.bufferSubData(n.UNIFORM_BUFFER, Q + ae, q.__data)) : k.isMatrix3 ? (q.__data[0] = k.elements[0], q.__data[1] = k.elements[1], q.__data[2] = k.elements[2], q.__data[3] = 0, q.__data[4] = k.elements[3], q.__data[5] = k.elements[4], q.__data[6] = k.elements[5], q.__data[7] = 0, q.__data[8] = k.elements[6], q.__data[9] = k.elements[7], q.__data[10] = k.elements[8], q.__data[11] = 0) : (k.toArray(q.__data, ae), ae += Z.storage / Float32Array.BYTES_PER_ELEMENT)
               }
               n.bufferSubData(n.UNIFORM_BUFFER, Q, q.__data)
            }
         }
      }
      n.bindBuffer(n.UNIFORM_BUFFER, null)
   }

   function x(w, C, N, U) {
      const z = w.value,
         B = C + "_" + N;
      if (U[B] === void 0) return typeof z == "number" || typeof z == "boolean" ? U[B] = z : U[B] = z.clone(), !0; {
         const I = U[B];
         if (typeof z == "number" || typeof z == "boolean") {
            if (I !== z) return U[B] = z, !0
         } else if (I.equals(z) === !1) return I.copy(z), !0
      }
      return !1
   }

   function S(w) {
      const C = w.uniforms;
      let N = 0;
      const U = 16;
      for (let B = 0, I = C.length; B < I; B++) {
         const O = Array.isArray(C[B]) ? C[B] : [C[B]];
         for (let P = 0, q = O.length; P < q; P++) {
            const Q = O[P],
               $ = Array.isArray(Q.value) ? Q.value : [Q.value];
            for (let ae = 0, fe = $.length; ae < fe; ae++) {
               const k = $[ae],
                  Z = E(k),
                  J = N % U,
                  pe = J % Z.boundary,
                  F = J + pe;
               N += pe, F !== 0 && U - F < Z.storage && (N += U - F), Q.__data = new Float32Array(Z.storage / Float32Array.BYTES_PER_ELEMENT), Q.__offset = N, N += Z.storage
            }
         }
      }
      const z = N % U;
      return z > 0 && (N += U - z), w.__size = N, w.__cache = {}, this
   }

   function E(w) {
      const C = {
         boundary: 0,
         storage: 0
      };
      return typeof w == "number" || typeof w == "boolean" ? (C.boundary = 4, C.storage = 4) : w.isVector2 ? (C.boundary = 8, C.storage = 8) : w.isVector3 || w.isColor ? (C.boundary = 16, C.storage = 12) : w.isVector4 ? (C.boundary = 16, C.storage = 16) : w.isMatrix3 ? (C.boundary = 48, C.storage = 48) : w.isMatrix4 ? (C.boundary = 64, C.storage = 64) : w.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", w), C
   }

   function T(w) {
      const C = w.target;
      C.removeEventListener("dispose", T);
      const N = a.indexOf(C.__bindingPointIndex);
      a.splice(N, 1), n.deleteBuffer(s[C.id]), delete s[C.id], delete r[C.id]
   }

   function b() {
      for (const w in s) n.deleteBuffer(s[w]);
      a = [], s = {}, r = {}
   }
   return {
      bind: c,
      update: h,
      dispose: b
   }
}
class OB {
   constructor(e = {}) {
      const {
         canvas: t = EL(),
         context: i = null,
         depth: s = !0,
         stencil: r = !1,
         alpha: a = !1,
         antialias: l = !1,
         premultipliedAlpha: c = !0,
         preserveDrawingBuffer: h = !1,
         powerPreference: m = "default",
         failIfMajorPerformanceCaveat: g = !1,
         reverseDepthBuffer: v = !1
      } = e;
      this.isWebGLRenderer = !0;
      let x;
      if (i !== null) {
         if (typeof WebGLRenderingContext < "u" && i instanceof WebGLRenderingContext) throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
         x = i.getContextAttributes().alpha
      } else x = a;
      const S = new Uint32Array(4),
         E = new Int32Array(4);
      let T = null,
         b = null;
      const w = [],
         C = [];
      this.domElement = t, this.debug = {
         checkShaderErrors: !0,
         onShaderError: null
      }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.toneMapping = ho, this.toneMappingExposure = 1, this.transmissionResolutionScale = 1;
      const N = this;
      let U = !1;
      this._outputColorSpace = En;
      let z = 0,
         B = 0,
         I = null,
         O = -1,
         P = null;
      const q = new Gn,
         Q = new Gn;
      let $ = null;
      const ae = new dt(0);
      let fe = 0,
         k = t.width,
         Z = t.height,
         J = 1,
         pe = null,
         F = null;
      const ie = new Gn(0, 0, k, Z),
         ye = new Gn(0, 0, k, Z);
      let we = !1;
      const oe = new gx;
      let be = !1,
         Pe = !1;
      const Ge = new Zt,
         Xe = new Zt,
         yt = new ee,
         vt = new Gn,
         Mt = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: !0
         };
      let zt = !1;

      function lt() {
         return I === null ? J : 1
      }
      let ne = i;

      function sn(X, ue) {
         return t.getContext(X, ue)
      }
      try {
         const X = {
            alpha: !0,
            depth: s,
            stencil: r,
            antialias: l,
            premultipliedAlpha: c,
            preserveDrawingBuffer: h,
            powerPreference: m,
            failIfMajorPerformanceCaveat: g
         };
         if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${Og}`), t.addEventListener("webglcontextlost", Ie, !1), t.addEventListener("webglcontextrestored", nt, !1), t.addEventListener("webglcontextcreationerror", at, !1), ne === null) {
            const ue = "webgl2";
            if (ne = sn(ue, X), ne === null) throw sn(ue) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
         }
      } catch (X) {
         throw console.error("THREE.WebGLRenderer: " + X.message), X
      }
      let ze, te, Be, Je, Ue, K, G, me, Ne, Oe, De, Ye, We, Ze, kt, Ke, et, xt, mt, it, jt, Rt, cn, le;

      function rt() {
         ze = new W7(ne), ze.init(), Rt = new NB(ne, ze), te = new H7(ne, ze, e, Rt), Be = new wq(ne, ze), te.reverseDepthBuffer && v && Be.buffers.depth.setReversed(!0), Je = new Z7(ne), Ue = new pq, K = new Rq(ne, ze, Be, Ue, te, Rt, Je), G = new G7(N), me = new X7(N), Ne = new n8(ne), cn = new I7(ne, Ne), Oe = new Y7(ne, Ne, Je, cn), De = new J7(ne, Oe, Ne, Je), mt = new Q7(ne, te, K), Ke = new V7(Ue), Ye = new dq(N, G, me, ze, te, cn, Ke), We = new Pq(N, Ue), Ze = new gq, kt = new bq(ze), xt = new z7(N, G, me, Be, De, x, c), et = new Mq(N, De, te), le = new Lq(ne, Je, te, Be), it = new F7(ne, ze, Je), jt = new K7(ne, ze, Je), Je.programs = Ye.programs, N.capabilities = te, N.extensions = ze, N.properties = Ue, N.renderLists = Ze, N.shadowMap = et, N.state = Be, N.info = Je
      }
      rt();
      const Re = new Oq(N, ne);
      this.xr = Re, this.getContext = function () {
         return ne
      }, this.getContextAttributes = function () {
         return ne.getContextAttributes()
      }, this.forceContextLoss = function () {
         const X = ze.get("WEBGL_lose_context");
         X && X.loseContext()
      }, this.forceContextRestore = function () {
         const X = ze.get("WEBGL_lose_context");
         X && X.restoreContext()
      }, this.getPixelRatio = function () {
         return J
      }, this.setPixelRatio = function (X) {
         X !== void 0 && (J = X, this.setSize(k, Z, !1))
      }, this.getSize = function (X) {
         return X.set(k, Z)
      }, this.setSize = function (X, ue, Te = !0) {
         if (Re.isPresenting) {
            console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
            return
         }
         k = X, Z = ue, t.width = Math.floor(X * J), t.height = Math.floor(ue * J), Te === !0 && (t.style.width = X + "px", t.style.height = ue + "px"), this.setViewport(0, 0, X, ue)
      }, this.getDrawingBufferSize = function (X) {
         return X.set(k * J, Z * J).floor()
      }, this.setDrawingBufferSize = function (X, ue, Te) {
         k = X, Z = ue, J = Te, t.width = Math.floor(X * Te), t.height = Math.floor(ue * Te), this.setViewport(0, 0, X, ue)
      }, this.getCurrentViewport = function (X) {
         return X.copy(q)
      }, this.getViewport = function (X) {
         return X.copy(ie)
      }, this.setViewport = function (X, ue, Te, xe) {
         X.isVector4 ? ie.set(X.x, X.y, X.z, X.w) : ie.set(X, ue, Te, xe), Be.viewport(q.copy(ie).multiplyScalar(J).round())
      }, this.getScissor = function (X) {
         return X.copy(ye)
      }, this.setScissor = function (X, ue, Te, xe) {
         X.isVector4 ? ye.set(X.x, X.y, X.z, X.w) : ye.set(X, ue, Te, xe), Be.scissor(Q.copy(ye).multiplyScalar(J).round())
      }, this.getScissorTest = function () {
         return we
      }, this.setScissorTest = function (X) {
         Be.setScissorTest(we = X)
      }, this.setOpaqueSort = function (X) {
         pe = X
      }, this.setTransparentSort = function (X) {
         F = X
      }, this.getClearColor = function (X) {
         return X.copy(xt.getClearColor())
      }, this.setClearColor = function () {
         xt.setClearColor(...arguments)
      }, this.getClearAlpha = function () {
         return xt.getClearAlpha()
      }, this.setClearAlpha = function () {
         xt.setClearAlpha(...arguments)
      }, this.clear = function (X = !0, ue = !0, Te = !0) {
         let xe = 0;
         if (X) {
            let de = !1;
            if (I !== null) {
               const je = I.texture.format;
               de = je === oT || je === aT || je === hx
            }
            if (de) {
               const je = I.texture.type,
                  st = je === qs || je === Vu || je === cg || je === Jd || je === iT || je === sT,
                  ot = xt.getClearColor(),
                  ct = xt.getClearAlpha(),
                  At = ot.r,
                  wt = ot.g,
                  Tt = ot.b;
               st ? (S[0] = At, S[1] = wt, S[2] = Tt, S[3] = ct, ne.clearBufferuiv(ne.COLOR, 0, S)) : (E[0] = At, E[1] = wt, E[2] = Tt, E[3] = ct, ne.clearBufferiv(ne.COLOR, 0, E))
            } else xe |= ne.COLOR_BUFFER_BIT
         }
         ue && (xe |= ne.DEPTH_BUFFER_BIT), Te && (xe |= ne.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), ne.clear(xe)
      }, this.clearColor = function () {
         this.clear(!0, !1, !1)
      }, this.clearDepth = function () {
         this.clear(!1, !0, !1)
      }, this.clearStencil = function () {
         this.clear(!1, !1, !0)
      }, this.dispose = function () {
         t.removeEventListener("webglcontextlost", Ie, !1), t.removeEventListener("webglcontextrestored", nt, !1), t.removeEventListener("webglcontextcreationerror", at, !1), xt.dispose(), Ze.dispose(), kt.dispose(), Ue.dispose(), G.dispose(), me.dispose(), De.dispose(), cn.dispose(), le.dispose(), Ye.dispose(), Re.dispose(), Re.removeEventListener("sessionstart", Qe), Re.removeEventListener("sessionend", St), gt.stop()
      };

      function Ie(X) {
         X.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), U = !0
      }

      function nt() {
         console.log("THREE.WebGLRenderer: Context Restored."), U = !1;
         const X = Je.autoReset,
            ue = et.enabled,
            Te = et.autoUpdate,
            xe = et.needsUpdate,
            de = et.type;
         rt(), Je.autoReset = X, et.enabled = ue, et.autoUpdate = Te, et.needsUpdate = xe, et.type = de
      }

      function at(X) {
         console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", X.statusMessage)
      }

      function Bt(X) {
         const ue = X.target;
         ue.removeEventListener("dispose", Bt), mn(ue)
      }

      function mn(X) {
         Yn(X), Ue.remove(X)
      }

      function Yn(X) {
         const ue = Ue.get(X).programs;
         ue !== void 0 && (ue.forEach(function (Te) {
            Ye.releaseProgram(Te)
         }), X.isShaderMaterial && Ye.releaseShaderCache(X))
      }
      this.renderBufferDirect = function (X, ue, Te, xe, de, je) {
         ue === null && (ue = Mt);
         const st = de.isMesh && de.matrixWorld.determinant() < 0,
            ot = Zi(X, ue, Te, xe, de);
         Be.setMaterial(xe, st);
         let ct = Te.index,
            At = 1;
         if (xe.wireframe === !0) {
            if (ct = Oe.getWireframeAttribute(Te), ct === void 0) return;
            At = 2
         }
         const wt = Te.drawRange,
            Tt = Te.attributes.position;
         let Wt = wt.start * At,
            In = (wt.start + wt.count) * At;
         je !== null && (Wt = Math.max(Wt, je.start * At), In = Math.min(In, (je.start + je.count) * At)), ct !== null ? (Wt = Math.max(Wt, 0), In = Math.min(In, ct.count)) : Tt != null && (Wt = Math.max(Wt, 0), In = Math.min(In, Tt.count));
         const Mi = In - Wt;
         if (Mi < 0 || Mi === 1 / 0) return;
         cn.setup(de, xe, ot, Te, ct);
         let Sn, An = it;
         if (ct !== null && (Sn = Ne.get(ct), An = jt, An.setIndex(Sn)), de.isMesh) xe.wireframe === !0 ? (Be.setLineWidth(xe.wireframeLinewidth * lt()), An.setMode(ne.LINES)) : An.setMode(ne.TRIANGLES);
         else if (de.isLine) {
            let Pt = xe.linewidth;
            Pt === void 0 && (Pt = 1), Be.setLineWidth(Pt * lt()), de.isLineSegments ? An.setMode(ne.LINES) : de.isLineLoop ? An.setMode(ne.LINE_LOOP) : An.setMode(ne.LINE_STRIP)
         } else de.isPoints ? An.setMode(ne.POINTS) : de.isSprite && An.setMode(ne.TRIANGLES);
         if (de.isBatchedMesh)
            if (de._multiDrawInstances !== null) _b("THREE.WebGLRenderer: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."), An.renderMultiDrawInstances(de._multiDrawStarts, de._multiDrawCounts, de._multiDrawCount, de._multiDrawInstances);
            else if (ze.get("WEBGL_multi_draw")) An.renderMultiDraw(de._multiDrawStarts, de._multiDrawCounts, de._multiDrawCount);
         else {
            const Pt = de._multiDrawStarts,
               Ri = de._multiDrawCounts,
               Ln = de._multiDrawCount,
               Os = ct ? Ne.get(ct).bytesPerElement : 1,
               _o = Ue.get(xe).currentProgram.getUniforms();
            for (let li = 0; li < Ln; li++) _o.setValue(ne, "_gl_DrawID", li), An.render(Pt[li] / Os, Ri[li])
         } else if (de.isInstancedMesh) An.renderInstances(Wt, Mi, de.count);
         else if (Te.isInstancedBufferGeometry) {
            const Pt = Te._maxInstanceCount !== void 0 ? Te._maxInstanceCount : 1 / 0,
               Ri = Math.min(Te.instanceCount, Pt);
            An.renderInstances(Wt, Mi, Ri)
         } else An.render(Wt, Mi)
      };

      function ut(X, ue, Te) {
         X.transparent === !0 && X.side === Ua && X.forceSinglePass === !1 ? (X.side = Ds, X.needsUpdate = !0, Ft(X, ue, Te), X.side = Hu, X.needsUpdate = !0, Ft(X, ue, Te), X.side = Ua) : Ft(X, ue, Te)
      }
      this.compile = function (X, ue, Te = null) {
         Te === null && (Te = X), b = kt.get(Te), b.init(ue), C.push(b), Te.traverseVisible(function (de) {
            de.isLight && de.layers.test(ue.layers) && (b.pushLight(de), de.castShadow && b.pushShadow(de))
         }), X !== Te && X.traverseVisible(function (de) {
            de.isLight && de.layers.test(ue.layers) && (b.pushLight(de), de.castShadow && b.pushShadow(de))
         }), b.setupLights();
         const xe = new Set;
         return X.traverse(function (de) {
            if (!(de.isMesh || de.isPoints || de.isLine || de.isSprite)) return;
            const je = de.material;
            if (je)
               if (Array.isArray(je))
                  for (let st = 0; st < je.length; st++) {
                     const ot = je[st];
                     ut(ot, Te, de), xe.add(ot)
                  } else ut(je, Te, de), xe.add(je)
         }), b = C.pop(), xe
      }, this.compileAsync = function (X, ue, Te = null) {
         const xe = this.compile(X, ue, Te);
         return new Promise(de => {
            function je() {
               if (xe.forEach(function (st) {
                     Ue.get(st).currentProgram.isReady() && xe.delete(st)
                  }), xe.size === 0) {
                  de(X);
                  return
               }
               setTimeout(je, 10)
            }
            ze.get("KHR_parallel_shader_compile") !== null ? je() : setTimeout(je, 10)
         })
      };
      let _t = null;

      function It(X) {
         _t && _t(X)
      }

      function Qe() {
         gt.stop()
      }

      function St() {
         gt.start()
      }
      const gt = new AB;
      gt.setAnimationLoop(It), typeof self < "u" && gt.setContext(self), this.setAnimationLoop = function (X) {
         _t = X, Re.setAnimationLoop(X), X === null ? gt.stop() : gt.start()
      }, Re.addEventListener("sessionstart", Qe), Re.addEventListener("sessionend", St), this.render = function (X, ue) {
         if (ue !== void 0 && ue.isCamera !== !0) {
            console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
            return
         }
         if (U === !0) return;
         if (X.matrixWorldAutoUpdate === !0 && X.updateMatrixWorld(), ue.parent === null && ue.matrixWorldAutoUpdate === !0 && ue.updateMatrixWorld(), Re.enabled === !0 && Re.isPresenting === !0 && (Re.cameraAutoUpdate === !0 && Re.updateCamera(ue), ue = Re.getCamera()), X.isScene === !0 && X.onBeforeRender(N, X, ue, I), b = kt.get(X, C.length), b.init(ue), C.push(b), Xe.multiplyMatrices(ue.projectionMatrix, ue.matrixWorldInverse), oe.setFromProjectionMatrix(Xe), Pe = this.localClippingEnabled, be = Ke.init(this.clippingPlanes, Pe), T = Ze.get(X, w.length), T.init(), w.push(T), Re.enabled === !0 && Re.isPresenting === !0) {
            const je = N.xr.getDepthSensingMesh();
            je !== null && Dt(je, ue, -1 / 0, N.sortObjects)
         }
         Dt(X, ue, 0, N.sortObjects), T.finish(), N.sortObjects === !0 && T.sort(pe, F), zt = Re.enabled === !1 || Re.isPresenting === !1 || Re.hasDepthSensing() === !1, zt && xt.addToRenderList(T, X), this.info.render.frame++, be === !0 && Ke.beginShadows();
         const Te = b.state.shadowsArray;
         et.render(Te, X, ue), be === !0 && Ke.endShadows(), this.info.autoReset === !0 && this.info.reset();
         const xe = T.opaque,
            de = T.transmissive;
         if (b.setupLights(), ue.isArrayCamera) {
            const je = ue.cameras;
            if (de.length > 0)
               for (let st = 0, ot = je.length; st < ot; st++) {
                  const ct = je[st];
                  Xt(xe, de, X, ct)
               }
            zt && xt.render(X);
            for (let st = 0, ot = je.length; st < ot; st++) {
               const ct = je[st];
               Ti(T, X, ct, ct.viewport)
            }
         } else de.length > 0 && Xt(xe, de, X, ue), zt && xt.render(X), Ti(T, X, ue);
         I !== null && B === 0 && (K.updateMultisampleRenderTarget(I), K.updateRenderTargetMipmap(I)), X.isScene === !0 && X.onAfterRender(N, X, ue), cn.resetDefaultState(), O = -1, P = null, C.pop(), C.length > 0 ? (b = C[C.length - 1], be === !0 && Ke.setGlobalState(N.clippingPlanes, b.state.camera)) : b = null, w.pop(), w.length > 0 ? T = w[w.length - 1] : T = null
      };

      function Dt(X, ue, Te, xe) {
         if (X.visible === !1) return;
         if (X.layers.test(ue.layers)) {
            if (X.isGroup) Te = X.renderOrder;
            else if (X.isLOD) X.autoUpdate === !0 && X.update(ue);
            else if (X.isLight) b.pushLight(X), X.castShadow && b.pushShadow(X);
            else if (X.isSprite) {
               if (!X.frustumCulled || oe.intersectsSprite(X)) {
                  xe && vt.setFromMatrixPosition(X.matrixWorld).applyMatrix4(Xe);
                  const st = De.update(X),
                     ot = X.material;
                  ot.visible && T.push(X, st, ot, Te, vt.z, null)
               }
            } else if ((X.isMesh || X.isLine || X.isPoints) && (!X.frustumCulled || oe.intersectsObject(X))) {
               const st = De.update(X),
                  ot = X.material;
               if (xe && (X.boundingSphere !== void 0 ? (X.boundingSphere === null && X.computeBoundingSphere(), vt.copy(X.boundingSphere.center)) : (st.boundingSphere === null && st.computeBoundingSphere(), vt.copy(st.boundingSphere.center)), vt.applyMatrix4(X.matrixWorld).applyMatrix4(Xe)), Array.isArray(ot)) {
                  const ct = st.groups;
                  for (let At = 0, wt = ct.length; At < wt; At++) {
                     const Tt = ct[At],
                        Wt = ot[Tt.materialIndex];
                     Wt && Wt.visible && T.push(X, st, Wt, Te, vt.z, Tt)
                  }
               } else ot.visible && T.push(X, st, ot, Te, vt.z, null)
            }
         }
         const je = X.children;
         for (let st = 0, ot = je.length; st < ot; st++) Dt(je[st], ue, Te, xe)
      }

      function Ti(X, ue, Te, xe) {
         const de = X.opaque,
            je = X.transmissive,
            st = X.transparent;
         b.setupLightsView(Te), be === !0 && Ke.setGlobalState(N.clippingPlanes, Te), xe && Be.viewport(q.copy(xe)), de.length > 0 && _n(de, ue, Te), je.length > 0 && _n(je, ue, Te), st.length > 0 && _n(st, ue, Te), Be.buffers.depth.setTest(!0), Be.buffers.depth.setMask(!0), Be.buffers.color.setMask(!0), Be.setPolygonOffset(!1)
      }

      function Xt(X, ue, Te, xe) {
         if ((Te.isScene === !0 ? Te.overrideMaterial : null) !== null) return;
         b.state.transmissionRenderTarget[xe.id] === void 0 && (b.state.transmissionRenderTarget[xe.id] = new ss(1, 1, {
            generateMipmaps: !0,
            type: ze.has("EXT_color_buffer_half_float") || ze.has("EXT_color_buffer_float") ? lp : qs,
            minFilter: Du,
            samples: 4,
            stencilBuffer: r,
            resolveDepthBuffer: !1,
            resolveStencilBuffer: !1,
            colorSpace: Vn.workingColorSpace
         }));
         const je = b.state.transmissionRenderTarget[xe.id],
            st = xe.viewport || q;
         je.setSize(st.z * N.transmissionResolutionScale, st.w * N.transmissionResolutionScale);
         const ot = N.getRenderTarget();
         N.setRenderTarget(je), N.getClearColor(ae), fe = N.getClearAlpha(), fe < 1 && N.setClearColor(16777215, .5), N.clear(), zt && xt.render(Te);
         const ct = N.toneMapping;
         N.toneMapping = ho;
         const At = xe.viewport;
         if (xe.viewport !== void 0 && (xe.viewport = void 0), b.setupLightsView(xe), be === !0 && Ke.setGlobalState(N.clippingPlanes, xe), _n(X, Te, xe), K.updateMultisampleRenderTarget(je), K.updateRenderTargetMipmap(je), ze.has("WEBGL_multisampled_render_to_texture") === !1) {
            let wt = !1;
            for (let Tt = 0, Wt = ue.length; Tt < Wt; Tt++) {
               const In = ue[Tt],
                  Mi = In.object,
                  Sn = In.geometry,
                  An = In.material,
                  Pt = In.group;
               if (An.side === Ua && Mi.layers.test(xe.layers)) {
                  const Ri = An.side;
                  An.side = Ds, An.needsUpdate = !0, ii(Mi, Te, xe, Sn, An, Pt), An.side = Ri, An.needsUpdate = !0, wt = !0
               }
            }
            wt === !0 && (K.updateMultisampleRenderTarget(je), K.updateRenderTargetMipmap(je))
         }
         N.setRenderTarget(ot), N.setClearColor(ae, fe), At !== void 0 && (xe.viewport = At), N.toneMapping = ct
      }

      function _n(X, ue, Te) {
         const xe = ue.isScene === !0 ? ue.overrideMaterial : null;
         for (let de = 0, je = X.length; de < je; de++) {
            const st = X[de],
               ot = st.object,
               ct = st.geometry,
               At = st.group;
            let wt = st.material;
            wt.allowOverride === !0 && xe !== null && (wt = xe), ot.layers.test(Te.layers) && ii(ot, ue, Te, ct, wt, At)
         }
      }

      function ii(X, ue, Te, xe, de, je) {
         X.onBeforeRender(N, ue, Te, xe, de, je), X.modelViewMatrix.multiplyMatrices(Te.matrixWorldInverse, X.matrixWorld), X.normalMatrix.getNormalMatrix(X.modelViewMatrix), de.onBeforeRender(N, ue, Te, xe, X, je), de.transparent === !0 && de.side === Ua && de.forceSinglePass === !1 ? (de.side = Ds, de.needsUpdate = !0, N.renderBufferDirect(Te, ue, xe, de, X, je), de.side = Hu, de.needsUpdate = !0, N.renderBufferDirect(Te, ue, xe, de, X, je), de.side = Ua) : N.renderBufferDirect(Te, ue, xe, de, X, je), X.onAfterRender(N, ue, Te, xe, de, je)
      }

      function Ft(X, ue, Te) {
         ue.isScene !== !0 && (ue = Mt);
         const xe = Ue.get(X),
            de = b.state.lights,
            je = b.state.shadowsArray,
            st = de.state.version,
            ot = Ye.getParameters(X, de.state, je, ue, Te),
            ct = Ye.getProgramCacheKey(ot);
         let At = xe.programs;
         xe.environment = X.isMeshStandardMaterial ? ue.environment : null, xe.fog = ue.fog, xe.envMap = (X.isMeshStandardMaterial ? me : G).get(X.envMap || xe.environment), xe.envMapRotation = xe.environment !== null && X.envMap === null ? ue.environmentRotation : X.envMapRotation, At === void 0 && (X.addEventListener("dispose", Bt), At = new Map, xe.programs = At);
         let wt = At.get(ct);
         if (wt !== void 0) {
            if (xe.currentProgram === wt && xe.lightsStateVersion === st) return gn(X, ot), wt
         } else ot.uniforms = Ye.getUniforms(X), X.onBeforeCompile(ot, N), wt = Ye.acquireProgram(ot, ct), At.set(ct, wt), xe.uniforms = ot.uniforms;
         const Tt = xe.uniforms;
         return (!X.isShaderMaterial && !X.isRawShaderMaterial || X.clipping === !0) && (Tt.clippingPlanes = Ke.uniform), gn(X, ot), xe.needsLights = Pn(X), xe.lightsStateVersion = st, xe.needsLights && (Tt.ambientLightColor.value = de.state.ambient, Tt.lightProbe.value = de.state.probe, Tt.directionalLights.value = de.state.directional, Tt.directionalLightShadows.value = de.state.directionalShadow, Tt.spotLights.value = de.state.spot, Tt.spotLightShadows.value = de.state.spotShadow, Tt.rectAreaLights.value = de.state.rectArea, Tt.ltc_1.value = de.state.rectAreaLTC1, Tt.ltc_2.value = de.state.rectAreaLTC2, Tt.pointLights.value = de.state.point, Tt.pointLightShadows.value = de.state.pointShadow, Tt.hemisphereLights.value = de.state.hemi, Tt.directionalShadowMap.value = de.state.directionalShadowMap, Tt.directionalShadowMatrix.value = de.state.directionalShadowMatrix, Tt.spotShadowMap.value = de.state.spotShadowMap, Tt.spotLightMatrix.value = de.state.spotLightMatrix, Tt.spotLightMap.value = de.state.spotLightMap, Tt.pointShadowMap.value = de.state.pointShadowMap, Tt.pointShadowMatrix.value = de.state.pointShadowMatrix), xe.currentProgram = wt, xe.uniformsList = null, wt
      }

      function Mn(X) {
         if (X.uniformsList === null) {
            const ue = X.currentProgram.getUniforms();
            X.uniformsList = bb.seqWithValue(ue.seq, X.uniforms)
         }
         return X.uniformsList
      }

      function gn(X, ue) {
         const Te = Ue.get(X);
         Te.outputColorSpace = ue.outputColorSpace, Te.batching = ue.batching, Te.batchingColor = ue.batchingColor, Te.instancing = ue.instancing, Te.instancingColor = ue.instancingColor, Te.instancingMorph = ue.instancingMorph, Te.skinning = ue.skinning, Te.morphTargets = ue.morphTargets, Te.morphNormals = ue.morphNormals, Te.morphColors = ue.morphColors, Te.morphTargetsCount = ue.morphTargetsCount, Te.numClippingPlanes = ue.numClippingPlanes, Te.numIntersection = ue.numClipIntersection, Te.vertexAlphas = ue.vertexAlphas, Te.vertexTangents = ue.vertexTangents, Te.toneMapping = ue.toneMapping
      }

      function Zi(X, ue, Te, xe, de) {
         ue.isScene !== !0 && (ue = Mt), K.resetTextureUnits();
         const je = ue.fog,
            st = xe.isMeshStandardMaterial ? ue.environment : null,
            ot = I === null ? N.outputColorSpace : I.isXRRenderTarget === !0 ? I.texture.colorSpace : Gu,
            ct = (xe.isMeshStandardMaterial ? me : G).get(xe.envMap || st),
            At = xe.vertexColors === !0 && !!Te.attributes.color && Te.attributes.color.itemSize === 4,
            wt = !!Te.attributes.tangent && (!!xe.normalMap || xe.anisotropy > 0),
            Tt = !!Te.morphAttributes.position,
            Wt = !!Te.morphAttributes.normal,
            In = !!Te.morphAttributes.color;
         let Mi = ho;
         xe.toneMapped && (I === null || I.isXRRenderTarget === !0) && (Mi = N.toneMapping);
         const Sn = Te.morphAttributes.position || Te.morphAttributes.normal || Te.morphAttributes.color,
            An = Sn !== void 0 ? Sn.length : 0,
            Pt = Ue.get(xe),
            Ri = b.state.lights;
         if (be === !0 && (Pe === !0 || X !== P)) {
            const vs = X === P && xe.id === O;
            Ke.setState(xe, X, vs)
         }
         let Ln = !1;
         xe.version === Pt.__version ? (Pt.needsLights && Pt.lightsStateVersion !== Ri.state.version || Pt.outputColorSpace !== ot || de.isBatchedMesh && Pt.batching === !1 || !de.isBatchedMesh && Pt.batching === !0 || de.isBatchedMesh && Pt.batchingColor === !0 && de.colorTexture === null || de.isBatchedMesh && Pt.batchingColor === !1 && de.colorTexture !== null || de.isInstancedMesh && Pt.instancing === !1 || !de.isInstancedMesh && Pt.instancing === !0 || de.isSkinnedMesh && Pt.skinning === !1 || !de.isSkinnedMesh && Pt.skinning === !0 || de.isInstancedMesh && Pt.instancingColor === !0 && de.instanceColor === null || de.isInstancedMesh && Pt.instancingColor === !1 && de.instanceColor !== null || de.isInstancedMesh && Pt.instancingMorph === !0 && de.morphTexture === null || de.isInstancedMesh && Pt.instancingMorph === !1 && de.morphTexture !== null || Pt.envMap !== ct || xe.fog === !0 && Pt.fog !== je || Pt.numClippingPlanes !== void 0 && (Pt.numClippingPlanes !== Ke.numPlanes || Pt.numIntersection !== Ke.numIntersection) || Pt.vertexAlphas !== At || Pt.vertexTangents !== wt || Pt.morphTargets !== Tt || Pt.morphNormals !== Wt || Pt.morphColors !== In || Pt.toneMapping !== Mi || Pt.morphTargetsCount !== An) && (Ln = !0) : (Ln = !0, Pt.__version = xe.version);
         let Os = Pt.currentProgram;
         Ln === !0 && (Os = Ft(xe, ue, de));
         let _o = !1,
            li = !1,
            So = !1;
         const si = Os.getUniforms(),
            Us = Pt.uniforms;
         if (Be.useProgram(Os.program) && (_o = !0, li = !0, So = !0), xe.id !== O && (O = xe.id, li = !0), _o || P !== X) {
            Be.buffers.depth.getReversed() ? (Ge.copy(X.projectionMatrix), E6(Ge), M6(Ge), si.setValue(ne, "projectionMatrix", Ge)) : si.setValue(ne, "projectionMatrix", X.projectionMatrix), si.setValue(ne, "viewMatrix", X.matrixWorldInverse);
            const ys = si.map.cameraPosition;
            ys !== void 0 && ys.setValue(ne, yt.setFromMatrixPosition(X.matrixWorld)), te.logarithmicDepthBuffer && si.setValue(ne, "logDepthBufFC", 2 / (Math.log(X.far + 1) / Math.LN2)), (xe.isMeshPhongMaterial || xe.isMeshToonMaterial || xe.isMeshLambertMaterial || xe.isMeshBasicMaterial || xe.isMeshStandardMaterial || xe.isShaderMaterial) && si.setValue(ne, "isOrthographic", X.isOrthographicCamera === !0), P !== X && (P = X, li = !0, So = !0)
         }
         if (de.isSkinnedMesh) {
            si.setOptional(ne, de, "bindMatrix"), si.setOptional(ne, de, "bindMatrixInverse");
            const vs = de.skeleton;
            vs && (vs.boneTexture === null && vs.computeBoneTexture(), si.setValue(ne, "boneTexture", vs.boneTexture, K))
         }
         de.isBatchedMesh && (si.setOptional(ne, de, "batchingTexture"), si.setValue(ne, "batchingTexture", de._matricesTexture, K), si.setOptional(ne, de, "batchingIdTexture"), si.setValue(ne, "batchingIdTexture", de._indirectTexture, K), si.setOptional(ne, de, "batchingColorTexture"), de._colorsTexture !== null && si.setValue(ne, "batchingColorTexture", de._colorsTexture, K));
         const Qi = Te.morphAttributes;
         if ((Qi.position !== void 0 || Qi.normal !== void 0 || Qi.color !== void 0) && mt.update(de, Te, Os), (li || Pt.receiveShadow !== de.receiveShadow) && (Pt.receiveShadow = de.receiveShadow, si.setValue(ne, "receiveShadow", de.receiveShadow)), xe.isMeshGouraudMaterial && xe.envMap !== null && (Us.envMap.value = ct, Us.flipEnvMap.value = ct.isCubeTexture && ct.isRenderTargetTexture === !1 ? -1 : 1), xe.isMeshStandardMaterial && xe.envMap === null && ue.environment !== null && (Us.envMapIntensity.value = ue.environmentIntensity), li && (si.setValue(ne, "toneMappingExposure", N.toneMappingExposure), Pt.needsLights && zn(Us, So), je && xe.fog === !0 && We.refreshFogUniforms(Us, je), We.refreshMaterialUniforms(Us, xe, J, Z, b.state.transmissionRenderTarget[X.id]), bb.upload(ne, Mn(Pt), Us, K)), xe.isShaderMaterial && xe.uniformsNeedUpdate === !0 && (bb.upload(ne, Mn(Pt), Us, K), xe.uniformsNeedUpdate = !1), xe.isSpriteMaterial && si.setValue(ne, "center", de.center), si.setValue(ne, "modelViewMatrix", de.modelViewMatrix), si.setValue(ne, "normalMatrix", de.normalMatrix), si.setValue(ne, "modelMatrix", de.matrixWorld), xe.isShaderMaterial || xe.isRawShaderMaterial) {
            const vs = xe.uniformsGroups;
            for (let ys = 0, rr = vs.length; ys < rr; ys++) {
               const bo = vs[ys];
               le.update(bo, Os), le.bind(bo, Os)
            }
         }
         return Os
      }

      function zn(X, ue) {
         X.ambientLightColor.needsUpdate = ue, X.lightProbe.needsUpdate = ue, X.directionalLights.needsUpdate = ue, X.directionalLightShadows.needsUpdate = ue, X.pointLights.needsUpdate = ue, X.pointLightShadows.needsUpdate = ue, X.spotLights.needsUpdate = ue, X.spotLightShadows.needsUpdate = ue, X.rectAreaLights.needsUpdate = ue, X.hemisphereLights.needsUpdate = ue
      }

      function Pn(X) {
         return X.isMeshLambertMaterial || X.isMeshToonMaterial || X.isMeshPhongMaterial || X.isMeshStandardMaterial || X.isShadowMaterial || X.isShaderMaterial && X.lights === !0
      }
      this.getActiveCubeFace = function () {
         return z
      }, this.getActiveMipmapLevel = function () {
         return B
      }, this.getRenderTarget = function () {
         return I
      }, this.setRenderTargetTextures = function (X, ue, Te) {
         const xe = Ue.get(X);
         xe.__autoAllocateDepthBuffer = X.resolveDepthBuffer === !1, xe.__autoAllocateDepthBuffer === !1 && (xe.__useRenderToTexture = !1), Ue.get(X.texture).__webglTexture = ue, Ue.get(X.depthTexture).__webglTexture = xe.__autoAllocateDepthBuffer ? void 0 : Te, xe.__hasExternalTextures = !0
      }, this.setRenderTargetFramebuffer = function (X, ue) {
         const Te = Ue.get(X);
         Te.__webglFramebuffer = ue, Te.__useDefaultFramebuffer = ue === void 0
      };
      const Ns = ne.createFramebuffer();
      this.setRenderTarget = function (X, ue = 0, Te = 0) {
         I = X, z = ue, B = Te;
         let xe = !0,
            de = null,
            je = !1,
            st = !1;
         if (X) {
            const ct = Ue.get(X);
            if (ct.__useDefaultFramebuffer !== void 0) Be.bindFramebuffer(ne.FRAMEBUFFER, null), xe = !1;
            else if (ct.__webglFramebuffer === void 0) K.setupRenderTarget(X);
            else if (ct.__hasExternalTextures) K.rebindTextures(X, Ue.get(X.texture).__webglTexture, Ue.get(X.depthTexture).__webglTexture);
            else if (X.depthBuffer) {
               const Tt = X.depthTexture;
               if (ct.__boundDepthTexture !== Tt) {
                  if (Tt !== null && Ue.has(Tt) && (X.width !== Tt.image.width || X.height !== Tt.image.height)) throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
                  K.setupDepthRenderbuffer(X)
               }
            }
            const At = X.texture;
            (At.isData3DTexture || At.isDataArrayTexture || At.isCompressedArrayTexture) && (st = !0);
            const wt = Ue.get(X).__webglFramebuffer;
            X.isWebGLCubeRenderTarget ? (Array.isArray(wt[ue]) ? de = wt[ue][Te] : de = wt[ue], je = !0) : X.samples > 0 && K.useMultisampledRTT(X) === !1 ? de = Ue.get(X).__webglMultisampledFramebuffer : Array.isArray(wt) ? de = wt[Te] : de = wt, q.copy(X.viewport), Q.copy(X.scissor), $ = X.scissorTest
         } else q.copy(ie).multiplyScalar(J).floor(), Q.copy(ye).multiplyScalar(J).floor(), $ = we;
         if (Te !== 0 && (de = Ns), Be.bindFramebuffer(ne.FRAMEBUFFER, de) && xe && Be.drawBuffers(X, de), Be.viewport(q), Be.scissor(Q), Be.setScissorTest($), je) {
            const ct = Ue.get(X.texture);
            ne.framebufferTexture2D(ne.FRAMEBUFFER, ne.COLOR_ATTACHMENT0, ne.TEXTURE_CUBE_MAP_POSITIVE_X + ue, ct.__webglTexture, Te)
         } else if (st) {
            const ct = Ue.get(X.texture),
               At = ue;
            ne.framebufferTextureLayer(ne.FRAMEBUFFER, ne.COLOR_ATTACHMENT0, ct.__webglTexture, Te, At)
         } else if (X !== null && Te !== 0) {
            const ct = Ue.get(X.texture);
            ne.framebufferTexture2D(ne.FRAMEBUFFER, ne.COLOR_ATTACHMENT0, ne.TEXTURE_2D, ct.__webglTexture, Te)
         }
         O = -1
      }, this.readRenderTargetPixels = function (X, ue, Te, xe, de, je, st) {
         if (!(X && X.isWebGLRenderTarget)) {
            console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            return
         }
         let ot = Ue.get(X).__webglFramebuffer;
         if (X.isWebGLCubeRenderTarget && st !== void 0 && (ot = ot[st]), ot) {
            Be.bindFramebuffer(ne.FRAMEBUFFER, ot);
            try {
               const ct = X.texture,
                  At = ct.format,
                  wt = ct.type;
               if (!te.textureFormatReadable(At)) {
                  console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                  return
               }
               if (!te.textureTypeReadable(wt)) {
                  console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                  return
               }
               ue >= 0 && ue <= X.width - xe && Te >= 0 && Te <= X.height - de && ne.readPixels(ue, Te, xe, de, Rt.convert(At), Rt.convert(wt), je)
            } finally {
               const ct = I !== null ? Ue.get(I).__webglFramebuffer : null;
               Be.bindFramebuffer(ne.FRAMEBUFFER, ct)
            }
         }
      }, this.readRenderTargetPixelsAsync = async function (X, ue, Te, xe, de, je, st) {
         if (!(X && X.isWebGLRenderTarget)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
         let ot = Ue.get(X).__webglFramebuffer;
         if (X.isWebGLCubeRenderTarget && st !== void 0 && (ot = ot[st]), ot)
            if (ue >= 0 && ue <= X.width - xe && Te >= 0 && Te <= X.height - de) {
               Be.bindFramebuffer(ne.FRAMEBUFFER, ot);
               const ct = X.texture,
                  At = ct.format,
                  wt = ct.type;
               if (!te.textureFormatReadable(At)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
               if (!te.textureTypeReadable(wt)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
               const Tt = ne.createBuffer();
               ne.bindBuffer(ne.PIXEL_PACK_BUFFER, Tt), ne.bufferData(ne.PIXEL_PACK_BUFFER, je.byteLength, ne.STREAM_READ), ne.readPixels(ue, Te, xe, de, Rt.convert(At), Rt.convert(wt), 0);
               const Wt = I !== null ? Ue.get(I).__webglFramebuffer : null;
               Be.bindFramebuffer(ne.FRAMEBUFFER, Wt);
               const In = ne.fenceSync(ne.SYNC_GPU_COMMANDS_COMPLETE, 0);
               return ne.flush(), await T6(ne, In, 4), ne.bindBuffer(ne.PIXEL_PACK_BUFFER, Tt), ne.getBufferSubData(ne.PIXEL_PACK_BUFFER, 0, je), ne.deleteBuffer(Tt), ne.deleteSync(In), je
            } else throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.")
      }, this.copyFramebufferToTexture = function (X, ue = null, Te = 0) {
         const xe = Math.pow(2, -Te),
            de = Math.floor(X.image.width * xe),
            je = Math.floor(X.image.height * xe),
            st = ue !== null ? ue.x : 0,
            ot = ue !== null ? ue.y : 0;
         K.setTexture2D(X, 0), ne.copyTexSubImage2D(ne.TEXTURE_2D, Te, 0, 0, st, ot, de, je), Be.unbindTexture()
      };
      const Ei = ne.createFramebuffer(),
         ei = ne.createFramebuffer();
      this.copyTextureToTexture = function (X, ue, Te = null, xe = null, de = 0, je = null) {
         je === null && (de !== 0 ? (_b("WebGLRenderer: copyTextureToTexture function signature has changed to support src and dst mipmap levels."), je = de, de = 0) : je = 0);
         let st, ot, ct, At, wt, Tt, Wt, In, Mi;
         const Sn = X.isCompressedTexture ? X.mipmaps[je] : X.image;
         if (Te !== null) st = Te.max.x - Te.min.x, ot = Te.max.y - Te.min.y, ct = Te.isBox3 ? Te.max.z - Te.min.z : 1, At = Te.min.x, wt = Te.min.y, Tt = Te.isBox3 ? Te.min.z : 0;
         else {
            const Qi = Math.pow(2, -de);
            st = Math.floor(Sn.width * Qi), ot = Math.floor(Sn.height * Qi), X.isDataArrayTexture ? ct = Sn.depth : X.isData3DTexture ? ct = Math.floor(Sn.depth * Qi) : ct = 1, At = 0, wt = 0, Tt = 0
         }
         xe !== null ? (Wt = xe.x, In = xe.y, Mi = xe.z) : (Wt = 0, In = 0, Mi = 0);
         const An = Rt.convert(ue.format),
            Pt = Rt.convert(ue.type);
         let Ri;
         ue.isData3DTexture ? (K.setTexture3D(ue, 0), Ri = ne.TEXTURE_3D) : ue.isDataArrayTexture || ue.isCompressedArrayTexture ? (K.setTexture2DArray(ue, 0), Ri = ne.TEXTURE_2D_ARRAY) : (K.setTexture2D(ue, 0), Ri = ne.TEXTURE_2D), ne.pixelStorei(ne.UNPACK_FLIP_Y_WEBGL, ue.flipY), ne.pixelStorei(ne.UNPACK_PREMULTIPLY_ALPHA_WEBGL, ue.premultiplyAlpha), ne.pixelStorei(ne.UNPACK_ALIGNMENT, ue.unpackAlignment);
         const Ln = ne.getParameter(ne.UNPACK_ROW_LENGTH),
            Os = ne.getParameter(ne.UNPACK_IMAGE_HEIGHT),
            _o = ne.getParameter(ne.UNPACK_SKIP_PIXELS),
            li = ne.getParameter(ne.UNPACK_SKIP_ROWS),
            So = ne.getParameter(ne.UNPACK_SKIP_IMAGES);
         ne.pixelStorei(ne.UNPACK_ROW_LENGTH, Sn.width), ne.pixelStorei(ne.UNPACK_IMAGE_HEIGHT, Sn.height), ne.pixelStorei(ne.UNPACK_SKIP_PIXELS, At), ne.pixelStorei(ne.UNPACK_SKIP_ROWS, wt), ne.pixelStorei(ne.UNPACK_SKIP_IMAGES, Tt);
         const si = X.isDataArrayTexture || X.isData3DTexture,
            Us = ue.isDataArrayTexture || ue.isData3DTexture;
         if (X.isDepthTexture) {
            const Qi = Ue.get(X),
               vs = Ue.get(ue),
               ys = Ue.get(Qi.__renderTarget),
               rr = Ue.get(vs.__renderTarget);
            Be.bindFramebuffer(ne.READ_FRAMEBUFFER, ys.__webglFramebuffer), Be.bindFramebuffer(ne.DRAW_FRAMEBUFFER, rr.__webglFramebuffer);
            for (let bo = 0; bo < ct; bo++) si && (ne.framebufferTextureLayer(ne.READ_FRAMEBUFFER, ne.COLOR_ATTACHMENT0, Ue.get(X).__webglTexture, de, Tt + bo), ne.framebufferTextureLayer(ne.DRAW_FRAMEBUFFER, ne.COLOR_ATTACHMENT0, Ue.get(ue).__webglTexture, je, Mi + bo)), ne.blitFramebuffer(At, wt, st, ot, Wt, In, st, ot, ne.DEPTH_BUFFER_BIT, ne.NEAREST);
            Be.bindFramebuffer(ne.READ_FRAMEBUFFER, null), Be.bindFramebuffer(ne.DRAW_FRAMEBUFFER, null)
         } else if (de !== 0 || X.isRenderTargetTexture || Ue.has(X)) {
            const Qi = Ue.get(X),
               vs = Ue.get(ue);
            Be.bindFramebuffer(ne.READ_FRAMEBUFFER, Ei), Be.bindFramebuffer(ne.DRAW_FRAMEBUFFER, ei);
            for (let ys = 0; ys < ct; ys++) si ? ne.framebufferTextureLayer(ne.READ_FRAMEBUFFER, ne.COLOR_ATTACHMENT0, Qi.__webglTexture, de, Tt + ys) : ne.framebufferTexture2D(ne.READ_FRAMEBUFFER, ne.COLOR_ATTACHMENT0, ne.TEXTURE_2D, Qi.__webglTexture, de), Us ? ne.framebufferTextureLayer(ne.DRAW_FRAMEBUFFER, ne.COLOR_ATTACHMENT0, vs.__webglTexture, je, Mi + ys) : ne.framebufferTexture2D(ne.DRAW_FRAMEBUFFER, ne.COLOR_ATTACHMENT0, ne.TEXTURE_2D, vs.__webglTexture, je), de !== 0 ? ne.blitFramebuffer(At, wt, st, ot, Wt, In, st, ot, ne.COLOR_BUFFER_BIT, ne.NEAREST) : Us ? ne.copyTexSubImage3D(Ri, je, Wt, In, Mi + ys, At, wt, st, ot) : ne.copyTexSubImage2D(Ri, je, Wt, In, At, wt, st, ot);
            Be.bindFramebuffer(ne.READ_FRAMEBUFFER, null), Be.bindFramebuffer(ne.DRAW_FRAMEBUFFER, null)
         } else Us ? X.isDataTexture || X.isData3DTexture ? ne.texSubImage3D(Ri, je, Wt, In, Mi, st, ot, ct, An, Pt, Sn.data) : ue.isCompressedArrayTexture ? ne.compressedTexSubImage3D(Ri, je, Wt, In, Mi, st, ot, ct, An, Sn.data) : ne.texSubImage3D(Ri, je, Wt, In, Mi, st, ot, ct, An, Pt, Sn) : X.isDataTexture ? ne.texSubImage2D(ne.TEXTURE_2D, je, Wt, In, st, ot, An, Pt, Sn.data) : X.isCompressedTexture ? ne.compressedTexSubImage2D(ne.TEXTURE_2D, je, Wt, In, Sn.width, Sn.height, An, Sn.data) : ne.texSubImage2D(ne.TEXTURE_2D, je, Wt, In, st, ot, An, Pt, Sn);
         ne.pixelStorei(ne.UNPACK_ROW_LENGTH, Ln), ne.pixelStorei(ne.UNPACK_IMAGE_HEIGHT, Os), ne.pixelStorei(ne.UNPACK_SKIP_PIXELS, _o), ne.pixelStorei(ne.UNPACK_SKIP_ROWS, li), ne.pixelStorei(ne.UNPACK_SKIP_IMAGES, So), je === 0 && ue.generateMipmaps && ne.generateMipmap(Ri), Be.unbindTexture()
      }, this.copyTextureToTexture3D = function (X, ue, Te = null, xe = null, de = 0) {
         return _b('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'), this.copyTextureToTexture(X, ue, Te, xe, de)
      }, this.initRenderTarget = function (X) {
         Ue.get(X).__webglFramebuffer === void 0 && K.setupRenderTarget(X)
      }, this.initTexture = function (X) {
         X.isCubeTexture ? K.setTextureCube(X, 0) : X.isData3DTexture ? K.setTexture3D(X, 0) : X.isDataArrayTexture || X.isCompressedArrayTexture ? K.setTexture2DArray(X, 0) : K.setTexture2D(X, 0), Be.unbindTexture()
      }, this.resetState = function () {
         z = 0, B = 0, I = null, Be.reset(), cn.reset()
      }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
         detail: this
      }))
   }
   get coordinateSystem() {
      return zl
   }
   get outputColorSpace() {
      return this._outputColorSpace
   }
   set outputColorSpace(e) {
      this._outputColorSpace = e;
      const t = this.getContext();
      t.drawingBufferColorSpace = Vn._getDrawingBufferColorSpace(e), t.unpackColorSpace = Vn._getUnpackColorSpace()
   }
}
const Bq = Object.freeze(Object.defineProperty({
   __proto__: null,
   ACESFilmicToneMapping: vR,
   AddEquation: jf,
   AddOperation: nL,
   AdditiveAnimationBlendMode: RR,
   AdditiveBlending: VA,
   AgXToneMapping: oL,
   AlphaFormat: bR,
   AlwaysCompare: SL,
   AlwaysDepth: yy,
   AlwaysStencilFunc: qA,
   AmbientLight: pB,
   AnimationAction: TB,
   AnimationClip: Fy,
   AnimationLoader: ZG,
   AnimationMixer: Ek,
   AnimationObjectGroup: bk,
   AnimationUtils: XG,
   ArcCurve: HL,
   ArrayCamera: _B,
   ArrowHelper: Wk,
   AttachedBindMode: jA,
   Audio: SB,
   AudioAnalyser: hk,
   AudioContext: JR,
   AudioListener: uk,
   AudioLoader: ak,
   AxesHelper: Yk,
   BackSide: Ds,
   BasicDepthPacking: Hl,
   BasicShadowMap: BP,
   BatchedMesh: BL,
   Bone: PR,
   BooleanKeyframeTrack: fp,
   Box2: Uk,
   Box3: pa,
   Box3Helper: qk,
   BoxGeometry: up,
   BoxHelper: jk,
   BufferAttribute: oi,
   BufferGeometry: pn,
   BufferGeometryLoader: xB,
   ByteType: xR,
   Cache: wc,
   Camera: px,
   CameraHelper: kk,
   CanvasTexture: mG,
   CapsuleGeometry: vT,
   CatmullRomCurve3: VL,
   CineonToneMapping: rL,
   CircleGeometry: yT,
   ClampToEdgeWrapping: Ko,
   Clock: $R,
   Color: dt,
   ColorKeyframeTrack: YR,
   ColorManagement: Vn,
   CompressedArrayTexture: dG,
   CompressedCubeTexture: pG,
   CompressedTexture: mT,
   CompressedTextureLoader: QG,
   ConeGeometry: xT,
   ConstantAlphaFactor: $P,
   ConstantColorFactor: QP,
   Controls: Zk,
   CubeCamera: CL,
   CubeReflectionMapping: Uc,
   CubeRefractionMapping: sh,
   CubeTexture: mx,
   CubeTextureLoader: JG,
   CubeUVReflectionMapping: Ug,
   CubicBezierCurve: zR,
   CubicBezierCurve3: GL,
   CubicInterpolant: oB,
   CullFaceBack: HA,
   CullFaceFront: LP,
   CullFaceFrontBack: MV,
   CullFaceNone: PP,
   Curve: jl,
   CurvePath: jL,
   CustomBlending: zP,
   CustomToneMapping: aL,
   CylinderGeometry: Lg,
   Cylindrical: Ok,
   Data3DTexture: cT,
   DataArrayTexture: dx,
   DataTexture: Pu,
   DataTextureLoader: $G,
   DataUtils: H6,
   DecrementStencilOp: FV,
   DecrementWrapStencilOp: VV,
   DefaultLoadingManager: qm,
   DepthFormat: fg,
   DepthStencilFormat: $d,
   DepthTexture: vx,
   DetachedBindMode: uL,
   DirectionalLight: dB,
   DirectionalLightHelper: Gk,
   DiscreteInterpolant: lB,
   DodecahedronGeometry: _T,
   DoubleSide: Ua,
   DstAlphaFactor: XP,
   DstColorFactor: YP,
   DynamicCopyUsage: n6,
   DynamicDrawUsage: ZV,
   DynamicReadUsage: $V,
   EdgesGeometry: qL,
   EllipseCurve: gT,
   EqualCompare: vL,
   EqualDepth: xy,
   EqualStencilFunc: qV,
   EquirectangularReflectionMapping: Ty,
   EquirectangularRefractionMapping: Ey,
   Euler: go,
   EventDispatcher: xo,
   ExtrudeGeometry: ST,
   FileLoader: Pc,
   Float16BufferAttribute: W6,
   Float32BufferAttribute: Ct,
   FloatType: ha,
   Fog: hT,
   FogExp2: fT,
   FramebufferTexture: hG,
   FrontSide: Hu,
   Frustum: gx,
   GLBufferAttribute: Dk,
   GLSL1: s6,
   GLSL3: XA,
   GreaterCompare: yL,
   GreaterDepth: Sy,
   GreaterEqualCompare: _L,
   GreaterEqualDepth: _y,
   GreaterEqualStencilFunc: KV,
   GreaterStencilFunc: WV,
   GridHelper: Hk,
   Group: jm,
   HalfFloatType: lp,
   HemisphereLight: cB,
   HemisphereLightHelper: Fk,
   IcosahedronGeometry: bT,
   ImageBitmapLoader: rk,
   ImageLoader: Hy,
   ImageUtils: ML,
   IncrementStencilOp: IV,
   IncrementWrapStencilOp: HV,
   InstancedBufferAttribute: gg,
   InstancedBufferGeometry: yB,
   InstancedInterleavedBuffer: Ck,
   InstancedMesh: LL,
   Int16BufferAttribute: q6,
   Int32BufferAttribute: X6,
   Int8BufferAttribute: G6,
   IntType: nT,
   InterleavedBuffer: dT,
   InterleavedBufferAttribute: ep,
   Interpolant: _x,
   InterpolateDiscrete: wy,
   InterpolateLinear: x1,
   InterpolateSmooth: xb,
   InvertStencilOp: GV,
   KeepStencilOp: Td,
   KeyframeTrack: sl,
   LOD: UL,
   LatheGeometry: yx,
   Layers: dg,
   LessCompare: gL,
   LessDepth: ug,
   LessEqualCompare: CR,
   LessEqualDepth: ih,
   LessEqualStencilFunc: XV,
   LessStencilFunc: jV,
   Light: dh,
   LightProbe: vB,
   Line: rh,
   Line3: Pk,
   LineBasicMaterial: ma,
   LineCurve: IR,
   LineCurve3: kL,
   LineDashedMaterial: sB,
   LineLoop: zL,
   LineSegments: qu,
   LinearFilter: Ni,
   LinearInterpolant: WR,
   LinearMipMapLinearFilter: CV,
   LinearMipMapNearestFilter: RV,
   LinearMipmapLinearFilter: Du,
   LinearMipmapNearestFilter: F0,
   LinearSRGBColorSpace: Gu,
   LinearToneMapping: iL,
   LinearTransfer: Cy,
   Loader: ja,
   LoaderUtils: QA,
   LoadingManager: KR,
   LoopOnce: cL,
   LoopPingPong: hL,
   LoopRepeat: fL,
   LuminanceAlphaFormat: MR,
   LuminanceFormat: ER,
   MOUSE: TV,
   Material: sr,
   MaterialLoader: CT,
   MathUtils: bL,
   Matrix2: n2,
   Matrix3: un,
   Matrix4: Zt,
   MaxEquation: VP,
   Mesh: ds,
   MeshBasicMaterial: Fc,
   MeshDepthMaterial: jR,
   MeshDistanceMaterial: qR,
   MeshLambertMaterial: nB,
   MeshMatcapMaterial: iB,
   MeshNormalMaterial: kR,
   MeshPhongMaterial: eB,
   MeshPhysicalMaterial: $L,
   MeshStandardMaterial: GR,
   MeshToonMaterial: tB,
   MinEquation: HP,
   MirroredRepeatWrapping: Ay,
   MixOperation: tL,
   MultiplyBlending: kA,
   MultiplyOperation: fx,
   NearestFilter: ms,
   NearestMipMapLinearFilter: wV,
   NearestMipMapNearestFilter: AV,
   NearestMipmapLinearFilter: Gm,
   NearestMipmapNearestFilter: yR,
   NeutralToneMapping: lL,
   NeverCompare: mL,
   NeverDepth: vy,
   NeverStencilFunc: kV,
   NoBlending: nr,
   NoColorSpace: Bl,
   NoToneMapping: ho,
   NormalAnimationBlendMode: lT,
   NormalBlending: Fd,
   NotEqualCompare: xL,
   NotEqualDepth: by,
   NotEqualStencilFunc: YV,
   NumberKeyframeTrack: zy,
   Object3D: Wn,
   ObjectLoader: ik,
   ObjectSpaceNormalMap: pL,
   OctahedronGeometry: xx,
   OneFactor: kP,
   OneMinusConstantAlphaFactor: eL,
   OneMinusConstantColorFactor: JP,
   OneMinusDstAlphaFactor: WP,
   OneMinusDstColorFactor: KP,
   OneMinusSrcAlphaFactor: Xb,
   OneMinusSrcColorFactor: qP,
   OrthographicCamera: bx,
   PCFShadowMap: eT,
   PCFSoftShadowMap: I0,
   PMREMGenerator: ew,
   Path: Uy,
   PerspectiveCamera: Cs,
   Plane: kf,
   PlaneGeometry: Bg,
   PlaneHelper: Xk,
   PointLight: hB,
   PointLightHelper: zk,
   Points: IL,
   PointsMaterial: LR,
   PolarGridHelper: Vk,
   PolyhedronGeometry: hh,
   PositionalAudio: fk,
   PropertyBinding: Xn,
   PropertyMixer: bB,
   QuadraticBezierCurve: FR,
   QuadraticBezierCurve3: HR,
   Quaternion: Ba,
   QuaternionKeyframeTrack: Sx,
   QuaternionLinearInterpolant: uB,
   RED_GREEN_RGTC2_Format: v1,
   RED_RGTC1_Format: wR,
   REVISION: Og,
   RGBADepthPacking: dL,
   RGBAFormat: Lr,
   RGBAIntegerFormat: oT,
   RGBA_ASTC_10x10_Format: f1,
   RGBA_ASTC_10x5_Format: l1,
   RGBA_ASTC_10x6_Format: u1,
   RGBA_ASTC_10x8_Format: c1,
   RGBA_ASTC_12x10_Format: h1,
   RGBA_ASTC_12x12_Format: d1,
   RGBA_ASTC_4x4_Format: e1,
   RGBA_ASTC_5x4_Format: t1,
   RGBA_ASTC_5x5_Format: n1,
   RGBA_ASTC_6x5_Format: i1,
   RGBA_ASTC_6x6_Format: s1,
   RGBA_ASTC_8x5_Format: r1,
   RGBA_ASTC_8x6_Format: a1,
   RGBA_ASTC_8x8_Format: o1,
   RGBA_BPTC_Format: j0,
   RGBA_ETC2_EAC_Format: $b,
   RGBA_PVRTC_2BPPV1_Format: Zb,
   RGBA_PVRTC_4BPPV1_Format: Kb,
   RGBA_S3TC_DXT1_Format: V0,
   RGBA_S3TC_DXT3_Format: G0,
   RGBA_S3TC_DXT5_Format: k0,
   RGBDepthPacking: PV,
   RGBFormat: TR,
   RGBIntegerFormat: DV,
   RGB_BPTC_SIGNED_Format: p1,
   RGB_BPTC_UNSIGNED_Format: m1,
   RGB_ETC1_Format: Qb,
   RGB_ETC2_Format: Jb,
   RGB_PVRTC_2BPPV1_Format: Yb,
   RGB_PVRTC_4BPPV1_Format: Wb,
   RGB_S3TC_DXT1_Format: H0,
   RGDepthPacking: LV,
   RGFormat: AR,
   RGIntegerFormat: aT,
   RawShaderMaterial: JL,
   Ray: Pg,
   Raycaster: EB,
   RectAreaLight: mB,
   RedFormat: rT,
   RedIntegerFormat: hx,
   ReinhardToneMapping: sL,
   RenderTarget: uT,
   RenderTarget3D: Mk,
   RenderTargetArray: Ak,
   RepeatWrapping: My,
   ReplaceStencilOp: zV,
   ReverseSubtractEquation: FP,
   RingGeometry: TT,
   SIGNED_RED_GREEN_RGTC2_Format: y1,
   SIGNED_RED_RGTC1_Format: g1,
   SRGBColorSpace: En,
   SRGBTransfer: di,
   Scene: mg,
   ShaderChunk: yn,
   ShaderLib: Ll,
   ShaderMaterial: gs,
   ShadowMaterial: QL,
   Shape: Vd,
   ShapeGeometry: ET,
   ShapePath: Kk,
   ShapeUtils: Lu,
   ShortType: _R,
   Skeleton: pT,
   SkeletonHelper: Bk,
   SkinnedMesh: PL,
   Source: Xf,
   Sphere: zr,
   SphereGeometry: cp,
   Spherical: Nk,
   SphericalHarmonics3: gB,
   SplineCurve: VR,
   SpotLight: fB,
   SpotLightHelper: Lk,
   Sprite: OL,
   SpriteMaterial: UR,
   SrcAlphaFactor: qb,
   SrcAlphaSaturateFactor: ZP,
   SrcColorFactor: jP,
   StaticCopyUsage: t6,
   StaticDrawUsage: Dy,
   StaticReadUsage: JV,
   StereoCamera: ok,
   StreamCopyUsage: i6,
   StreamDrawUsage: QV,
   StreamReadUsage: e6,
   StringKeyframeTrack: hp,
   SubtractEquation: IP,
   SubtractiveBlending: GA,
   TOUCH: EV,
   TangentSpaceNormalMap: fh,
   TetrahedronGeometry: MT,
   Texture: Hi,
   TextureLoader: ZR,
   TextureUtils: t8,
   TimestampQuery: r6,
   TorusGeometry: AT,
   TorusKnotGeometry: wT,
   Triangle: Pa,
   TriangleFanDrawMode: UV,
   TriangleStripDrawMode: OV,
   TrianglesDrawMode: NV,
   TubeGeometry: RT,
   UVMapping: tT,
   Uint16BufferAttribute: NR,
   Uint32BufferAttribute: OR,
   Uint8BufferAttribute: k6,
   Uint8ClampedBufferAttribute: j6,
   Uniform: nn,
   UniformsGroup: Rk,
   UniformsLib: ht,
   UniformsUtils: RL,
   UnsignedByteType: qs,
   UnsignedInt248Type: Jd,
   UnsignedInt5999Type: SR,
   UnsignedIntType: Vu,
   UnsignedShort4444Type: iT,
   UnsignedShort5551Type: sT,
   UnsignedShortType: cg,
   VSMShadowMap: Pl,
   Vector2: Fe,
   Vector3: ee,
   Vector4: Gn,
   VectorKeyframeTrack: Iy,
   VideoFrameTexture: fG,
   VideoTexture: FL,
   WebGL3DRenderTarget: D6,
   WebGLArrayRenderTarget: C6,
   WebGLCoordinateSystem: zl,
   WebGLCubeRenderTarget: DL,
   WebGLRenderTarget: ss,
   WebGLRenderer: OB,
   WebGLUtils: NB,
   WebGPUCoordinateSystem: Ny,
   WebXRController: Sb,
   WireframeGeometry: ZL,
   WrapAroundEnding: Ry,
   ZeroCurvatureEnding: Dd,
   ZeroFactor: GP,
   ZeroSlopeEnding: Nd,
   ZeroStencilOp: BV,
   createCanvasElement: EL
}, Symbol.toStringTag, {
   value: "Module"
}));
var LM = {
      exports: {}
   },
   Sc = {};
/**
 * @license React
 * react-reconciler-constants.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var $3;

function zq() {
   return $3 || ($3 = 1, Sc.ConcurrentRoot = 1, Sc.ContinuousEventPriority = 8, Sc.DefaultEventPriority = 32, Sc.DiscreteEventPriority = 2, Sc.IdleEventPriority = 268435456, Sc.LegacyRoot = 0, Sc.NoEventPriority = 0), Sc
}
var eN;

function Iq() {
   return eN || (eN = 1, LM.exports = zq()), LM.exports
}
var Tb = Iq(),
   BM = {
      exports: {}
   },
   zM = {},
   IM = {
      exports: {}
   },
   FM = {};
/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var tN;

function Fq() {
   if (tN) return FM;
   tN = 1;
   var n = Rg();

   function e(g, v) {
      return g === v && (g !== 0 || 1 / g === 1 / v) || g !== g && v !== v
   }
   var t = typeof Object.is == "function" ? Object.is : e,
      i = n.useState,
      s = n.useEffect,
      r = n.useLayoutEffect,
      a = n.useDebugValue;

   function l(g, v) {
      var x = v(),
         S = i({
            inst: {
               value: x,
               getSnapshot: v
            }
         }),
         E = S[0].inst,
         T = S[1];
      return r(function () {
         E.value = x, E.getSnapshot = v, c(E) && T({
            inst: E
         })
      }, [g, x, v]), s(function () {
         return c(E) && T({
            inst: E
         }), g(function () {
            c(E) && T({
               inst: E
            })
         })
      }, [g]), a(x), x
   }

   function c(g) {
      var v = g.getSnapshot;
      g = g.value;
      try {
         var x = v();
         return !t(g, x)
      } catch {
         return !0
      }
   }

   function h(g, v) {
      return v()
   }
   var m = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? h : l;
   return FM.useSyncExternalStore = n.useSyncExternalStore !== void 0 ? n.useSyncExternalStore : m, FM
}
var nN;

function Hq() {
   return nN || (nN = 1, IM.exports = Fq()), IM.exports
}
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var iN;

function Vq() {
   if (iN) return zM;
   iN = 1;
   var n = Rg(),
      e = Hq();

   function t(h, m) {
      return h === m && (h !== 0 || 1 / h === 1 / m) || h !== h && m !== m
   }
   var i = typeof Object.is == "function" ? Object.is : t,
      s = e.useSyncExternalStore,
      r = n.useRef,
      a = n.useEffect,
      l = n.useMemo,
      c = n.useDebugValue;
   return zM.useSyncExternalStoreWithSelector = function (h, m, g, v, x) {
      var S = r(null);
      if (S.current === null) {
         var E = {
            hasValue: !1,
            value: null
         };
         S.current = E
      } else E = S.current;
      S = l(function () {
         function b(z) {
            if (!w) {
               if (w = !0, C = z, z = v(z), x !== void 0 && E.hasValue) {
                  var B = E.value;
                  if (x(B, z)) return N = B
               }
               return N = z
            }
            if (B = N, i(C, z)) return B;
            var I = v(z);
            return x !== void 0 && x(B, I) ? (C = z, B) : (C = z, N = I)
         }
         var w = !1,
            C, N, U = g === void 0 ? null : g;
         return [function () {
            return b(m())
         }, U === null ? void 0 : function () {
            return b(U())
         }]
      }, [m, g, v, x]);
      var T = s(h, S[0], S[1]);
      return a(function () {
         E.hasValue = !0, E.value = T
      }, [T]), c(T), T
   }, zM
}
var sN;

function Gq() {
   return sN || (sN = 1, BM.exports = Vq()), BM.exports
}
var kq = Gq();
const jq = lx(kq),
   rN = n => {
      let e;
      const t = new Set,
         i = (h, m) => {
            const g = typeof h == "function" ? h(e) : h;
            if (!Object.is(g, e)) {
               const v = e;
               e = m ?? (typeof g != "object" || g === null) ? g : Object.assign({}, e, g), t.forEach(x => x(e, v))
            }
         },
         s = () => e,
         l = {
            setState: i,
            getState: s,
            getInitialState: () => c,
            subscribe: h => (t.add(h), () => t.delete(h))
         },
         c = e = n(i, s, l);
      return l
   },
   UB = n => n ? rN(n) : rN,
   {
      useSyncExternalStoreWithSelector: qq
   } = jq,
   Xq = n => n;

function Wq(n, e = Xq, t) {
   const i = qq(n.subscribe, n.getState, n.getInitialState, e, t);
   return $o.useDebugValue(i), i
}
const aN = (n, e) => {
      const t = UB(n),
         i = (s, r = e) => Wq(t, s, r);
      return Object.assign(i, t), i
   },
   Yq = (n, e) => n ? aN(n, e) : aN;
var HM = {
      exports: {}
   },
   VM = {
      exports: {}
   },
   GM = {
      exports: {}
   },
   kM = {};
/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var oN;

function Kq() {
   return oN || (oN = 1, function (n) {
      function e(k, Z) {
         var J = k.length;
         k.push(Z);
         e: for (; 0 < J;) {
            var pe = J - 1 >>> 1,
               F = k[pe];
            if (0 < s(F, Z)) k[pe] = Z, k[J] = F, J = pe;
            else break e
         }
      }

      function t(k) {
         return k.length === 0 ? null : k[0]
      }

      function i(k) {
         if (k.length === 0) return null;
         var Z = k[0],
            J = k.pop();
         if (J !== Z) {
            k[0] = J;
            e: for (var pe = 0, F = k.length, ie = F >>> 1; pe < ie;) {
               var ye = 2 * (pe + 1) - 1,
                  we = k[ye],
                  oe = ye + 1,
                  be = k[oe];
               if (0 > s(we, J)) oe < F && 0 > s(be, we) ? (k[pe] = be, k[oe] = J, pe = oe) : (k[pe] = we, k[ye] = J, pe = ye);
               else if (oe < F && 0 > s(be, J)) k[pe] = be, k[oe] = J, pe = oe;
               else break e
            }
         }
         return Z
      }

      function s(k, Z) {
         var J = k.sortIndex - Z.sortIndex;
         return J !== 0 ? J : k.id - Z.id
      }
      if (n.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
         var r = performance;
         n.unstable_now = function () {
            return r.now()
         }
      } else {
         var a = Date,
            l = a.now();
         n.unstable_now = function () {
            return a.now() - l
         }
      }
      var c = [],
         h = [],
         m = 1,
         g = null,
         v = 3,
         x = !1,
         S = !1,
         E = !1,
         T = typeof setTimeout == "function" ? setTimeout : null,
         b = typeof clearTimeout == "function" ? clearTimeout : null,
         w = typeof setImmediate < "u" ? setImmediate : null;

      function C(k) {
         for (var Z = t(h); Z !== null;) {
            if (Z.callback === null) i(h);
            else if (Z.startTime <= k) i(h), Z.sortIndex = Z.expirationTime, e(c, Z);
            else break;
            Z = t(h)
         }
      }

      function N(k) {
         if (E = !1, C(k), !S)
            if (t(c) !== null) S = !0, ae();
            else {
               var Z = t(h);
               Z !== null && fe(N, Z.startTime - k)
            }
      }
      var U = !1,
         z = -1,
         B = 5,
         I = -1;

      function O() {
         return !(n.unstable_now() - I < B)
      }

      function P() {
         if (U) {
            var k = n.unstable_now();
            I = k;
            var Z = !0;
            try {
               e: {
                  S = !1,
                  E && (E = !1, b(z), z = -1),
                  x = !0;
                  var J = v;
                  try {
                     t: {
                        for (C(k), g = t(c); g !== null && !(g.expirationTime > k && O());) {
                           var pe = g.callback;
                           if (typeof pe == "function") {
                              g.callback = null, v = g.priorityLevel;
                              var F = pe(g.expirationTime <= k);
                              if (k = n.unstable_now(), typeof F == "function") {
                                 g.callback = F, C(k), Z = !0;
                                 break t
                              }
                              g === t(c) && i(c), C(k)
                           } else i(c);
                           g = t(c)
                        }
                        if (g !== null) Z = !0;
                        else {
                           var ie = t(h);
                           ie !== null && fe(N, ie.startTime - k), Z = !1
                        }
                     }
                     break e
                  }
                  finally {
                     g = null, v = J, x = !1
                  }
                  Z = void 0
               }
            }
            finally {
               Z ? q() : U = !1
            }
         }
      }
      var q;
      if (typeof w == "function") q = function () {
         w(P)
      };
      else if (typeof MessageChannel < "u") {
         var Q = new MessageChannel,
            $ = Q.port2;
         Q.port1.onmessage = P, q = function () {
            $.postMessage(null)
         }
      } else q = function () {
         T(P, 0)
      };

      function ae() {
         U || (U = !0, q())
      }

      function fe(k, Z) {
         z = T(function () {
            k(n.unstable_now())
         }, Z)
      }
      n.unstable_IdlePriority = 5, n.unstable_ImmediatePriority = 1, n.unstable_LowPriority = 4, n.unstable_NormalPriority = 3, n.unstable_Profiling = null, n.unstable_UserBlockingPriority = 2, n.unstable_cancelCallback = function (k) {
         k.callback = null
      }, n.unstable_continueExecution = function () {
         S || x || (S = !0, ae())
      }, n.unstable_forceFrameRate = function (k) {
         0 > k || 125 < k ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : B = 0 < k ? Math.floor(1e3 / k) : 5
      }, n.unstable_getCurrentPriorityLevel = function () {
         return v
      }, n.unstable_getFirstCallbackNode = function () {
         return t(c)
      }, n.unstable_next = function (k) {
         switch (v) {
            case 1:
            case 2:
            case 3:
               var Z = 3;
               break;
            default:
               Z = v
         }
         var J = v;
         v = Z;
         try {
            return k()
         } finally {
            v = J
         }
      }, n.unstable_pauseExecution = function () {}, n.unstable_requestPaint = function () {}, n.unstable_runWithPriority = function (k, Z) {
         switch (k) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
               break;
            default:
               k = 3
         }
         var J = v;
         v = k;
         try {
            return Z()
         } finally {
            v = J
         }
      }, n.unstable_scheduleCallback = function (k, Z, J) {
         var pe = n.unstable_now();
         switch (typeof J == "object" && J !== null ? (J = J.delay, J = typeof J == "number" && 0 < J ? pe + J : pe) : J = pe, k) {
            case 1:
               var F = -1;
               break;
            case 2:
               F = 250;
               break;
            case 5:
               F = 1073741823;
               break;
            case 4:
               F = 1e4;
               break;
            default:
               F = 5e3
         }
         return F = J + F, k = {
            id: m++,
            callback: Z,
            priorityLevel: k,
            startTime: J,
            expirationTime: F,
            sortIndex: -1
         }, J > pe ? (k.sortIndex = J, e(h, k), t(c) === null && k === t(h) && (E ? (b(z), z = -1) : E = !0, fe(N, J - pe))) : (k.sortIndex = F, e(c, k), S || x || (S = !0, ae())), k
      }, n.unstable_shouldYield = O, n.unstable_wrapCallback = function (k) {
         var Z = v;
         return function () {
            var J = v;
            v = Z;
            try {
               return k.apply(this, arguments)
            } finally {
               v = J
            }
         }
      }
   }(kM)), kM
}
var lN;

function PB() {
   return lN || (lN = 1, GM.exports = Kq()), GM.exports
}
/**
 * @license React
 * react-reconciler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var uN;

function Zq() {
   return uN || (uN = 1, function (n) {
      n.exports = function (e) {
         function t(f, d, _, A) {
            return new yv(f, d, _, A)
         }

         function i() {}

         function s(f) {
            var d = "https://react.dev/errors/" + f;
            if (1 < arguments.length) {
               d += "?args[]=" + encodeURIComponent(arguments[1]);
               for (var _ = 2; _ < arguments.length; _++) d += "&args[]=" + encodeURIComponent(arguments[_])
            }
            return "Minified React error #" + f + "; visit " + d + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
         }

         function r(f) {
            return f === null || typeof f != "object" ? null : (f = vl && f[vl] || f["@@iterator"], typeof f == "function" ? f : null)
         }

         function a(f) {
            if (f == null) return null;
            if (typeof f == "function") return f.$$typeof === bv ? null : f.displayName || f.name || null;
            if (typeof f == "string") return f;
            switch (f) {
               case ou:
                  return "Fragment";
               case _a:
                  return "Portal";
               case zp:
                  return "Profiler";
               case kh:
                  return "StrictMode";
               case Ip:
                  return "Suspense";
               case af:
                  return "SuspenseList"
            }
            if (typeof f == "object") switch (f.$$typeof) {
               case Wa:
                  return (f.displayName || "Context") + ".Provider";
               case _v:
                  return (f._context.displayName || "Context") + ".Consumer";
               case qh:
                  var d = f.render;
                  return f = f.displayName, f || (f = d.displayName || d.name || "", f = f !== "" ? "ForwardRef(" + f + ")" : "ForwardRef"), f;
               case Fp:
                  return d = f.displayName || null, d !== null ? d : a(f.type) || "Memo";
               case Sa:
                  d = f._payload, f = f._init;
                  try {
                     return a(f(d))
                  } catch {}
            }
            return null
         }

         function l(f) {
            if (wo === void 0) try {
               throw Error()
            } catch (_) {
               var d = _.stack.trim().match(/\n( *(at )?)/);
               wo = d && d[1] || "", yl = -1 < _.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < _.stack.indexOf("@") ? "@unknown:0:0" : ""
            }
            return `
` + wo + f + yl
         }

         function c(f, d) {
            if (!f || Zu) return "";
            Zu = !0;
            var _ = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            try {
               var A = {
                  DetermineComponentFrameRoot: function () {
                     try {
                        if (d) {
                           var ft = function () {
                              throw Error()
                           };
                           if (Object.defineProperty(ft.prototype, "props", {
                                 set: function () {
                                    throw Error()
                                 }
                              }), typeof Reflect == "object" && Reflect.construct) {
                              try {
                                 Reflect.construct(ft, [])
                              } catch (tn) {
                                 var pt = tn
                              }
                              Reflect.construct(f, [], ft)
                           } else {
                              try {
                                 ft.call()
                              } catch (tn) {
                                 pt = tn
                              }
                              f.call(ft.prototype)
                           }
                        } else {
                           try {
                              throw Error()
                           } catch (tn) {
                              pt = tn
                           }(ft = f()) && typeof ft.catch == "function" && ft.catch(function () {})
                        }
                     } catch (tn) {
                        if (tn && pt && typeof tn.stack == "string") return [tn.stack, pt.stack]
                     }
                     return [null, null]
                  }
               };
               A.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
               var D = Object.getOwnPropertyDescriptor(A.DetermineComponentFrameRoot, "name");
               D && D.configurable && Object.defineProperty(A.DetermineComponentFrameRoot, "name", {
                  value: "DetermineComponentFrameRoot"
               });
               var L = A.DetermineComponentFrameRoot(),
                  Y = L[0],
                  re = L[1];
               if (Y && re) {
                  var ve = Y.split(`
`),
                     He = re.split(`
`);
                  for (D = A = 0; A < ve.length && !ve[A].includes("DetermineComponentFrameRoot");) A++;
                  for (; D < He.length && !He[D].includes("DetermineComponentFrameRoot");) D++;
                  if (A === ve.length || D === He.length)
                     for (A = ve.length - 1, D = He.length - 1; 1 <= A && 0 <= D && ve[A] !== He[D];) D--;
                  for (; 1 <= A && 0 <= D; A--, D--)
                     if (ve[A] !== He[D]) {
                        if (A !== 1 || D !== 1)
                           do
                              if (A--, D--, 0 > D || ve[A] !== He[D]) {
                                 var tt = `
` + ve[A].replace(" at new ", " at ");
                                 return f.displayName && tt.includes("<anonymous>") && (tt = tt.replace("<anonymous>", f.displayName)), tt
                              } while (1 <= A && 0 <= D);
                        break
                     }
               }
            } finally {
               Zu = !1, Error.prepareStackTrace = _
            }
            return (_ = f ? f.displayName || f.name : "") ? l(_) : ""
         }

         function h(f) {
            switch (f.tag) {
               case 26:
               case 27:
               case 5:
                  return l(f.type);
               case 16:
                  return l("Lazy");
               case 13:
                  return l("Suspense");
               case 19:
                  return l("SuspenseList");
               case 0:
               case 15:
                  return f = c(f.type, !1), f;
               case 11:
                  return f = c(f.type.render, !1), f;
               case 1:
                  return f = c(f.type, !0), f;
               default:
                  return ""
            }
         }

         function m(f) {
            try {
               var d = "";
               do d += h(f), f = f.return; while (f);
               return d
            } catch (_) {
               return `
Error generating stack: ` + _.message + `
` + _.stack
            }
         }

         function g(f) {
            var d = f,
               _ = f;
            if (f.alternate)
               for (; d.return;) d = d.return;
            else {
               f = d;
               do d = f, (d.flags & 4098) !== 0 && (_ = d.return), f = d.return; while (f)
            }
            return d.tag === 3 ? _ : null
         }

         function v(f) {
            if (g(f) !== f) throw Error(s(188))
         }

         function x(f) {
            var d = f.alternate;
            if (!d) {
               if (d = g(f), d === null) throw Error(s(188));
               return d !== f ? null : f
            }
            for (var _ = f, A = d;;) {
               var D = _.return;
               if (D === null) break;
               var L = D.alternate;
               if (L === null) {
                  if (A = D.return, A !== null) {
                     _ = A;
                     continue
                  }
                  break
               }
               if (D.child === L.child) {
                  for (L = D.child; L;) {
                     if (L === _) return v(D), f;
                     if (L === A) return v(D), d;
                     L = L.sibling
                  }
                  throw Error(s(188))
               }
               if (_.return !== A.return) _ = D, A = L;
               else {
                  for (var Y = !1, re = D.child; re;) {
                     if (re === _) {
                        Y = !0, _ = D, A = L;
                        break
                     }
                     if (re === A) {
                        Y = !0, A = D, _ = L;
                        break
                     }
                     re = re.sibling
                  }
                  if (!Y) {
                     for (re = L.child; re;) {
                        if (re === _) {
                           Y = !0, _ = L, A = D;
                           break
                        }
                        if (re === A) {
                           Y = !0, A = L, _ = D;
                           break
                        }
                        re = re.sibling
                     }
                     if (!Y) throw Error(s(189))
                  }
               }
               if (_.alternate !== A) throw Error(s(190))
            }
            if (_.tag !== 3) throw Error(s(188));
            return _.stateNode.current === _ ? f : d
         }

         function S(f) {
            var d = f.tag;
            if (d === 5 || d === 26 || d === 27 || d === 6) return f;
            for (f = f.child; f !== null;) {
               if (d = S(f), d !== null) return d;
               f = f.sibling
            }
            return null
         }

         function E(f) {
            var d = f.tag;
            if (d === 5 || d === 26 || d === 27 || d === 6) return f;
            for (f = f.child; f !== null;) {
               if (f.tag !== 4 && (d = E(f), d !== null)) return d;
               f = f.sibling
            }
            return null
         }

         function T(f) {
            return {
               current: f
            }
         }

         function b(f) {
            0 > bl || (f.current = ki[bl], ki[bl] = null, bl--)
         }

         function w(f, d) {
            bl++, ki[bl] = f.current, f.current = d
         }

         function C(f) {
            return f >>>= 0, f === 0 ? 32 : 31 - (B_(f) / z_ | 0) | 0
         }

         function N(f) {
            var d = f & 42;
            if (d !== 0) return d;
            switch (f & -f) {
               case 1:
                  return 1;
               case 2:
                  return 2;
               case 4:
                  return 4;
               case 8:
                  return 8;
               case 16:
                  return 16;
               case 32:
                  return 32;
               case 64:
                  return 64;
               case 128:
               case 256:
               case 512:
               case 1024:
               case 2048:
               case 4096:
               case 8192:
               case 16384:
               case 32768:
               case 65536:
               case 131072:
               case 262144:
               case 524288:
               case 1048576:
               case 2097152:
                  return f & 4194176;
               case 4194304:
               case 8388608:
               case 16777216:
               case 33554432:
                  return f & 62914560;
               case 67108864:
                  return 67108864;
               case 134217728:
                  return 134217728;
               case 268435456:
                  return 268435456;
               case 536870912:
                  return 536870912;
               case 1073741824:
                  return 0;
               default:
                  return f
            }
         }

         function U(f, d) {
            var _ = f.pendingLanes;
            if (_ === 0) return 0;
            var A = 0,
               D = f.suspendedLanes,
               L = f.pingedLanes,
               Y = f.warmLanes;
            f = f.finishedLanes !== 0;
            var re = _ & 134217727;
            return re !== 0 ? (_ = re & ~D, _ !== 0 ? A = N(_) : (L &= re, L !== 0 ? A = N(L) : f || (Y = re & ~Y, Y !== 0 && (A = N(Y))))) : (re = _ & ~D, re !== 0 ? A = N(re) : L !== 0 ? A = N(L) : f || (Y = _ & ~Y, Y !== 0 && (A = N(Y)))), A === 0 ? 0 : d !== 0 && d !== A && (d & D) === 0 && (D = A & -A, Y = d & -d, D >= Y || D === 32 && (Y & 4194176) !== 0) ? d : A
         }

         function z(f, d) {
            return (f.pendingLanes & ~(f.suspendedLanes & ~f.pingedLanes) & d) === 0
         }

         function B(f, d) {
            switch (f) {
               case 1:
               case 2:
               case 4:
               case 8:
                  return d + 250;
               case 16:
               case 32:
               case 64:
               case 128:
               case 256:
               case 512:
               case 1024:
               case 2048:
               case 4096:
               case 8192:
               case 16384:
               case 32768:
               case 65536:
               case 131072:
               case 262144:
               case 524288:
               case 1048576:
               case 2097152:
                  return d + 5e3;
               case 4194304:
               case 8388608:
               case 16777216:
               case 33554432:
                  return -1;
               case 67108864:
               case 134217728:
               case 268435456:
               case 536870912:
               case 1073741824:
                  return -1;
               default:
                  return -1
            }
         }

         function I() {
            var f = Co;
            return Co <<= 1, (Co & 4194176) === 0 && (Co = 128), f
         }

         function O() {
            var f = $u;
            return $u <<= 1, ($u & 62914560) === 0 && ($u = 4194304), f
         }

         function P(f) {
            for (var d = [], _ = 0; 31 > _; _++) d.push(f);
            return d
         }

         function q(f, d) {
            f.pendingLanes |= d, d !== 268435456 && (f.suspendedLanes = 0, f.pingedLanes = 0, f.warmLanes = 0)
         }

         function Q(f, d, _, A, D, L) {
            var Y = f.pendingLanes;
            f.pendingLanes = _, f.suspendedLanes = 0, f.pingedLanes = 0, f.warmLanes = 0, f.expiredLanes &= _, f.entangledLanes &= _, f.errorRecoveryDisabledLanes &= _, f.shellSuspendCounter = 0;
            var re = f.entanglements,
               ve = f.expirationTimes,
               He = f.hiddenUpdates;
            for (_ = Y & ~_; 0 < _;) {
               var tt = 31 - fr(_),
                  ft = 1 << tt;
               re[tt] = 0, ve[tt] = -1;
               var pt = He[tt];
               if (pt !== null)
                  for (He[tt] = null, tt = 0; tt < pt.length; tt++) {
                     var tn = pt[tt];
                     tn !== null && (tn.lane &= -536870913)
                  }
               _ &= ~ft
            }
            A !== 0 && $(f, A, 0), L !== 0 && D === 0 && f.tag !== 0 && (f.suspendedLanes |= L & ~(Y & ~d))
         }

         function $(f, d, _) {
            f.pendingLanes |= d, f.suspendedLanes &= ~d;
            var A = 31 - fr(d);
            f.entangledLanes |= d, f.entanglements[A] = f.entanglements[A] | 1073741824 | _ & 4194218
         }

         function ae(f, d) {
            var _ = f.entangledLanes |= d;
            for (f = f.entanglements; _;) {
               var A = 31 - fr(_),
                  D = 1 << A;
               D & d | f[A] & d && (f[A] |= d), _ &= ~D
            }
         }

         function fe(f) {
            return f &= -f, 2 < f ? 8 < f ? (f & 134217727) !== 0 ? 32 : 268435456 : 8 : 2
         }

         function k(f) {
            if (Er && typeof Er.onCommitFiberRoot == "function") try {
               Er.onCommitFiberRoot(ji, f, void 0, (f.current.flags & 128) === 128)
            } catch {}
         }

         function Z(f) {
            if (typeof H_ == "function" && Ss(f), Er && typeof Er.setStrictMode == "function") try {
               Er.setStrictMode(ji, f)
            } catch {}
         }

         function J(f, d) {
            return f === d && (f !== 0 || 1 / f === 1 / d) || f !== f && d !== d
         }

         function pe(f, d) {
            if (typeof f == "object" && f !== null) {
               var _ = Vv.get(f);
               return _ !== void 0 ? _ : (d = {
                  value: f,
                  source: d,
                  stack: m(d)
               }, Vv.set(f, d), d)
            }
            return {
               value: f,
               source: d,
               stack: m(d)
            }
         }

         function F(f, d) {
            ec[tc++] = mf, ec[tc++] = nc, nc = f, mf = d
         }

         function ie(f, d, _) {
            jr[qr++] = Za, jr[qr++] = Qa, jr[qr++] = pu, pu = f;
            var A = Za;
            f = Qa;
            var D = 32 - fr(A) - 1;
            A &= ~(1 << D), _ += 1;
            var L = 32 - fr(d) + D;
            if (30 < L) {
               var Y = D - D % 5;
               L = (A & (1 << Y) - 1).toString(32), A >>= Y, D -= Y, Za = 1 << 32 - fr(d) + D | _ << D | A, Qa = L + f
            } else Za = 1 << L | _ << D | A, Qa = f
         }

         function ye(f) {
            f.return !== null && (F(f, 1), ie(f, 1, 0))
         }

         function we(f) {
            for (; f === nc;) nc = ec[--tc], ec[tc] = null, mf = ec[--tc], ec[tc] = null;
            for (; f === pu;) pu = jr[--qr], jr[qr] = null, Qa = jr[--qr], jr[qr] = null, Za = jr[--qr], jr[qr] = null
         }

         function oe(f, d) {
            w(Do, d), w(gf, f), w(os, null), f = t_(d), b(os), w(os, f)
         }

         function be() {
            b(os), b(gf), b(Do)
         }

         function Pe(f) {
            f.memoizedState !== null && w(ic, f);
            var d = os.current,
               _ = cf(d, f.type);
            d !== _ && (w(gf, f), w(os, _))
         }

         function Ge(f) {
            gf.current === f && (b(os), b(gf)), ic.current === f && (b(ic), ur ? Ya._currentValue = uu : Ya._currentValue2 = uu)
         }

         function Xe(f) {
            var d = Error(s(418, ""));
            throw lt(pe(d, f)), ed
         }

         function yt(f, d) {
            if (!Fs) throw Error(s(175));
            A_(f.stateNode, f.type, f.memoizedProps, d, f) || Xe(f)
         }

         function vt(f) {
            for (Hs = f.return; Hs;) switch (Hs.tag) {
               case 3:
               case 27:
                  bs = !0;
                  return;
               case 5:
               case 13:
                  bs = !1;
                  return;
               default:
                  Hs = Hs.return
            }
         }

         function Mt(f) {
            if (!Fs || f !== Hs) return !1;
            if (!Bn) return vt(f), Bn = !0, !1;
            var d = !1;
            if (ui ? f.tag !== 3 && f.tag !== 27 && (f.tag !== 5 || Yp(f.type) && !an(f.type, f.memoizedProps)) && (d = !0) : f.tag !== 3 && (f.tag !== 5 || Yp(f.type) && !an(f.type, f.memoizedProps)) && (d = !0), d && Vs && Xe(f), vt(f), f.tag === 13) {
               if (!Fs) throw Error(s(316));
               if (f = f.memoizedState, f = f !== null ? f.dehydrated : null, !f) throw Error(s(317));
               Vs = R_(f)
            } else Vs = Hs ? zv(f.stateNode) : null;
            return !0
         }

         function zt() {
            Fs && (Vs = Hs = null, Bn = !1)
         }

         function lt(f) {
            Ea === null ? Ea = [f] : Ea.push(f)
         }

         function ne() {
            for (var f = sc, d = Ja = sc = 0; d < f;) {
               var _ = Ma[d];
               Ma[d++] = null;
               var A = Ma[d];
               Ma[d++] = null;
               var D = Ma[d];
               Ma[d++] = null;
               var L = Ma[d];
               if (Ma[d++] = null, A !== null && D !== null) {
                  var Y = A.pending;
                  Y === null ? D.next = D : (D.next = Y.next, Y.next = D), A.pending = D
               }
               L !== 0 && Be(_, D, L)
            }
         }

         function sn(f, d, _, A) {
            Ma[sc++] = f, Ma[sc++] = d, Ma[sc++] = _, Ma[sc++] = A, Ja |= A, f.lanes |= A, f = f.alternate, f !== null && (f.lanes |= A)
         }

         function ze(f, d, _, A) {
            return sn(f, d, _, A), Je(f)
         }

         function te(f, d) {
            return sn(f, null, null, d), Je(f)
         }

         function Be(f, d, _) {
            f.lanes |= _;
            var A = f.alternate;
            A !== null && (A.lanes |= _);
            for (var D = !1, L = f.return; L !== null;) L.childLanes |= _, A = L.alternate, A !== null && (A.childLanes |= _), L.tag === 22 && (f = L.stateNode, f === null || f._visibility & 1 || (D = !0)), f = L, L = L.return;
            D && d !== null && f.tag === 3 && (L = f.stateNode, D = 31 - fr(_), L = L.hiddenUpdates, f = L[D], f === null ? L[D] = [d] : f.push(d), d.lane = _ | 536870912)
         }

         function Je(f) {
            if (50 < Mf) throw Mf = 0, um = null, Error(s(185));
            for (var d = f.return; d !== null;) f = d, d = f.return;
            return f.tag === 3 ? f.stateNode : null
         }

         function Ue(f) {
            f !== Tl && f.next === null && (Tl === null ? td = Tl = f : Tl = Tl.next = f), pi = !0, rc || (rc = !0, De(G))
         }

         function K(f, d) {
            if (!Gv && pi) {
               Gv = !0;
               do
                  for (var _ = !1, A = td; A !== null;) {
                     if (f !== 0) {
                        var D = A.pendingLanes;
                        if (D === 0) var L = 0;
                        else {
                           var Y = A.suspendedLanes,
                              re = A.pingedLanes;
                           L = (1 << 31 - fr(42 | f) + 1) - 1, L &= D & ~(Y & ~re), L = L & 201326677 ? L & 201326677 | 1 : L ? L | 2 : 0
                        }
                        L !== 0 && (_ = !0, Oe(A, L))
                     } else L = wn, L = U(A, A === Qn ? L : 0), (L & 3) === 0 || z(A, L) || (_ = !0, Oe(A, L));
                     A = A.next
                  }
               while (_);
               Gv = !1
            }
         }

         function G() {
            pi = rc = !1;
            var f = 0;
            vf !== 0 && (r_() && (f = vf), vf = 0);
            for (var d = Ta(), _ = null, A = td; A !== null;) {
               var D = A.next,
                  L = me(A, d);
               L === 0 ? (A.next = null, _ === null ? td = D : _.next = D, D === null && (Tl = _)) : (_ = A, (f !== 0 || (L & 3) !== 0) && (pi = !0)), A = D
            }
            K(f)
         }

         function me(f, d) {
            for (var _ = f.suspendedLanes, A = f.pingedLanes, D = f.expirationTimes, L = f.pendingLanes & -62914561; 0 < L;) {
               var Y = 31 - fr(L),
                  re = 1 << Y,
                  ve = D[Y];
               ve === -1 ? ((re & _) === 0 || (re & A) !== 0) && (D[Y] = B(re, d)) : ve <= d && (f.expiredLanes |= re), L &= ~re
            }
            if (d = Qn, _ = wn, _ = U(f, f === d ? _ : 0), A = f.callbackNode, _ === 0 || f === d && ri === 2 || f.cancelPendingCommit !== null) return A !== null && A !== null && Jp(A), f.callbackNode = null, f.callbackPriority = 0;
            if ((_ & 3) === 0 || z(f, _)) {
               if (d = _ & -_, d === f.callbackPriority) return d;
               switch (A !== null && Jp(A), fe(_)) {
                  case 2:
                  case 8:
                     _ = F_;
                     break;
                  case 32:
                     _ = tm;
                     break;
                  case 268435456:
                     _ = pE;
                     break;
                  default:
                     _ = tm
               }
               return A = Ne.bind(null, f), _ = $h(_, A), f.callbackPriority = d, f.callbackNode = _, d
            }
            return A !== null && A !== null && Jp(A), f.callbackPriority = 2, f.callbackNode = null, 2
         }

         function Ne(f, d) {
            var _ = f.callbackNode;
            if (Xa() && f.callbackNode !== _) return null;
            var A = wn;
            return A = U(f, f === Qn ? A : 0), A === 0 ? null : (nu(f, A, d), me(f, Ta()), f.callbackNode != null && f.callbackNode === _ ? Ne.bind(null, f) : null)
         }

         function Oe(f, d) {
            if (Xa()) return null;
            nu(f, d, !0)
         }

         function De(f) {
            wv ? Sl(function () {
               (Hn & 6) !== 0 ? $h(em, f) : f()
            }) : $h(em, f)
         }

         function Ye() {
            return vf === 0 && (vf = I()), vf
         }

         function We(f, d) {
            if (yf === null) {
               var _ = yf = [];
               ac = 0, Xr = Ye(), oc = {
                  status: "pending",
                  value: void 0,
                  then: function (A) {
                     _.push(A)
                  }
               }
            }
            return ac++, d.then(Ze, Ze), d
         }

         function Ze() {
            if (--ac === 0 && yf !== null) {
               oc !== null && (oc.status = "fulfilled");
               var f = yf;
               yf = null, Xr = 0, oc = null;
               for (var d = 0; d < f.length; d++)(0, f[d])()
            }
         }

         function kt(f, d) {
            var _ = [],
               A = {
                  status: "pending",
                  value: null,
                  reason: null,
                  then: function (D) {
                     _.push(D)
                  }
               };
            return f.then(function () {
               A.status = "fulfilled", A.value = d;
               for (var D = 0; D < _.length; D++)(0, _[D])(d)
            }, function (D) {
               for (A.status = "rejected", A.reason = D, D = 0; D < _.length; D++)(0, _[D])(void 0)
            }), A
         }

         function Ke(f) {
            f.updateQueue = {
               baseState: f.memoizedState,
               firstBaseUpdate: null,
               lastBaseUpdate: null,
               shared: {
                  pending: null,
                  lanes: 0,
                  hiddenCallbacks: null
               },
               callbacks: null
            }
         }

         function et(f, d) {
            f = f.updateQueue, d.updateQueue === f && (d.updateQueue = {
               baseState: f.baseState,
               firstBaseUpdate: f.firstBaseUpdate,
               lastBaseUpdate: f.lastBaseUpdate,
               shared: f.shared,
               callbacks: null
            })
         }

         function xt(f) {
            return {
               lane: f,
               tag: 0,
               payload: null,
               callback: null,
               next: null
            }
         }

         function mt(f, d, _) {
            var A = f.updateQueue;
            if (A === null) return null;
            if (A = A.shared, (Hn & 2) !== 0) {
               var D = A.pending;
               return D === null ? d.next = d : (d.next = D.next, D.next = d), A.pending = d, d = Je(f), Be(f, null, _), d
            }
            return sn(f, A, d, _), Je(f)
         }

         function it(f, d, _) {
            if (d = d.updateQueue, d !== null && (d = d.shared, (_ & 4194176) !== 0)) {
               var A = d.lanes;
               A &= f.pendingLanes, _ |= A, d.lanes = _, ae(f, _)
            }
         }

         function jt(f, d) {
            var _ = f.updateQueue,
               A = f.alternate;
            if (A !== null && (A = A.updateQueue, _ === A)) {
               var D = null,
                  L = null;
               if (_ = _.firstBaseUpdate, _ !== null) {
                  do {
                     var Y = {
                        lane: _.lane,
                        tag: _.tag,
                        payload: _.payload,
                        callback: null,
                        next: null
                     };
                     L === null ? D = L = Y : L = L.next = Y, _ = _.next
                  } while (_ !== null);
                  L === null ? D = L = d : L = L.next = d
               } else D = L = d;
               _ = {
                  baseState: A.baseState,
                  firstBaseUpdate: D,
                  lastBaseUpdate: L,
                  shared: A.shared,
                  callbacks: A.callbacks
               }, f.updateQueue = _;
               return
            }
            f = _.lastBaseUpdate, f === null ? _.firstBaseUpdate = d : f.next = d, _.lastBaseUpdate = d
         }

         function Rt() {
            if (lc) {
               var f = oc;
               if (f !== null) throw f
            }
         }

         function cn(f, d, _, A) {
            lc = !1;
            var D = f.updateQueue;
            El = !1;
            var L = D.firstBaseUpdate,
               Y = D.lastBaseUpdate,
               re = D.shared.pending;
            if (re !== null) {
               D.shared.pending = null;
               var ve = re,
                  He = ve.next;
               ve.next = null, Y === null ? L = He : Y.next = He, Y = ve;
               var tt = f.alternate;
               tt !== null && (tt = tt.updateQueue, re = tt.lastBaseUpdate, re !== Y && (re === null ? tt.firstBaseUpdate = He : re.next = He, tt.lastBaseUpdate = ve))
            }
            if (L !== null) {
               var ft = D.baseState;
               Y = 0, tt = He = ve = null, re = L;
               do {
                  var pt = re.lane & -536870913,
                     tn = pt !== re.lane;
                  if (tn ? (wn & pt) === pt : (A & pt) === pt) {
                     pt !== 0 && pt === Xr && (lc = !0), tt !== null && (tt = tt.next = {
                        lane: 0,
                        tag: re.tag,
                        payload: re.payload,
                        callback: null,
                        next: null
                     });
                     e: {
                        var ea = f,
                           Tu = re;pt = d;
                        var Eu = _;
                        switch (Tu.tag) {
                           case 1:
                              if (ea = Tu.payload, typeof ea == "function") {
                                 ft = ea.call(Eu, ft, pt);
                                 break e
                              }
                              ft = ea;
                              break e;
                           case 3:
                              ea.flags = ea.flags & -65537 | 128;
                           case 0:
                              if (ea = Tu.payload, pt = typeof ea == "function" ? ea.call(Eu, ft, pt) : ea, pt == null) break e;
                              ft = Bp({}, ft, pt);
                              break e;
                           case 2:
                              El = !0
                        }
                     }
                     pt = re.callback, pt !== null && (f.flags |= 64, tn && (f.flags |= 8192), tn = D.callbacks, tn === null ? D.callbacks = [pt] : tn.push(pt))
                  } else tn = {
                     lane: pt,
                     tag: re.tag,
                     payload: re.payload,
                     callback: re.callback,
                     next: null
                  }, tt === null ? (He = tt = tn, ve = ft) : tt = tt.next = tn, Y |= pt;
                  if (re = re.next, re === null) {
                     if (re = D.shared.pending, re === null) break;
                     tn = re, re = tn.next, tn.next = null, D.lastBaseUpdate = tn, D.shared.pending = null
                  }
               } while (!0);
               tt === null && (ve = ft), D.baseState = ve, D.firstBaseUpdate = He, D.lastBaseUpdate = tt, L === null && (D.shared.lanes = 0), Jr |= Y, f.lanes = Y, f.memoizedState = ft
            }
         }

         function le(f, d) {
            if (typeof f != "function") throw Error(s(191, f));
            f.call(d)
         }

         function rt(f, d) {
            var _ = f.callbacks;
            if (_ !== null)
               for (f.callbacks = null, f = 0; f < _.length; f++) le(_[f], d)
         }

         function Re(f, d) {
            if (Mr(f, d)) return !0;
            if (typeof f != "object" || f === null || typeof d != "object" || d === null) return !1;
            var _ = Object.keys(f),
               A = Object.keys(d);
            if (_.length !== A.length) return !1;
            for (A = 0; A < _.length; A++) {
               var D = _[A];
               if (!No.call(d, D) || !Mr(f[D], d[D])) return !1
            }
            return !0
         }

         function Ie(f) {
            return f = f.status, f === "fulfilled" || f === "rejected"
         }

         function nt() {}

         function at(f, d, _) {
            switch (_ = f[_], _ === void 0 ? f.push(d) : _ !== d && (d.then(nt, nt), d = _), d.status) {
               case "fulfilled":
                  return d.value;
               case "rejected":
                  throw f = d.reason, f === xf ? Error(s(483)) : f;
               default:
                  if (typeof d.status == "string") d.then(nt, nt);
                  else {
                     if (f = Qn, f !== null && 100 < f.shellSuspendCounter) throw Error(s(482));
                     f = d, f.status = "pending", f.then(function (A) {
                        if (d.status === "pending") {
                           var D = d;
                           D.status = "fulfilled", D.value = A
                        }
                     }, function (A) {
                        if (d.status === "pending") {
                           var D = d;
                           D.status = "rejected", D.reason = A
                        }
                     })
                  }
                  switch (d.status) {
                     case "fulfilled":
                        return d.value;
                     case "rejected":
                        throw f = d.reason, f === xf ? Error(s(483)) : f
                  }
                  throw mu = d, xf
            }
         }

         function Bt() {
            if (mu === null) throw Error(s(459));
            var f = mu;
            return mu = null, f
         }

         function mn(f) {
            var d = vu;
            return vu += 1, gu === null && (gu = []), at(gu, f, d)
         }

         function Yn(f, d) {
            d = d.props.ref, f.ref = d !== void 0 ? d : null
         }

         function ut(f, d) {
            throw d.$$typeof === oE ? Error(s(525)) : (f = Object.prototype.toString.call(d), Error(s(31, f === "[object Object]" ? "object with keys {" + Object.keys(d).join(", ") + "}" : f)))
         }

         function _t(f) {
            var d = f._init;
            return d(f._payload)
         }

         function It(f) {
            function d(Ee, ce) {
               if (f) {
                  var Ce = Ee.deletions;
                  Ce === null ? (Ee.deletions = [ce], Ee.flags |= 16) : Ce.push(ce)
               }
            }

            function _(Ee, ce) {
               if (!f) return null;
               for (; ce !== null;) d(Ee, ce), ce = ce.sibling;
               return null
            }

            function A(Ee) {
               for (var ce = new Map; Ee !== null;) Ee.key !== null ? ce.set(Ee.key, Ee) : ce.set(Ee.index, Ee), Ee = Ee.sibling;
               return ce
            }

            function D(Ee, ce) {
               return Ee = xa(Ee, ce), Ee.index = 0, Ee.sibling = null, Ee
            }

            function L(Ee, ce, Ce) {
               return Ee.index = Ce, f ? (Ce = Ee.alternate, Ce !== null ? (Ce = Ce.index, Ce < ce ? (Ee.flags |= 33554434, ce) : Ce) : (Ee.flags |= 33554434, ce)) : (Ee.flags |= 1048576, ce)
            }

            function Y(Ee) {
               return f && Ee.alternate === null && (Ee.flags |= 33554434), Ee
            }

            function re(Ee, ce, Ce, $e) {
               return ce === null || ce.tag !== 6 ? (ce = Pp(Ce, Ee.mode, $e), ce.return = Ee, ce) : (ce = D(ce, Ce), ce.return = Ee, ce)
            }

            function ve(Ee, ce, Ce, $e) {
               var Nt = Ce.type;
               return Nt === ou ? tt(Ee, ce, Ce.props.children, $e, Ce.key) : ce !== null && (ce.elementType === Nt || typeof Nt == "object" && Nt !== null && Nt.$$typeof === Sa && _t(Nt) === ce.type) ? (ce = D(ce, Ce.props), Yn(ce, Ce), ce.return = Ee, ce) : (ce = Ao(Ce.type, Ce.key, Ce.props, null, Ee.mode, $e), Yn(ce, Ce), ce.return = Ee, ce)
            }

            function He(Ee, ce, Ce, $e) {
               return ce === null || ce.tag !== 4 || ce.stateNode.containerInfo !== Ce.containerInfo || ce.stateNode.implementation !== Ce.implementation ? (ce = xv(Ce, Ee.mode, $e), ce.return = Ee, ce) : (ce = D(ce, Ce.children || []), ce.return = Ee, ce)
            }

            function tt(Ee, ce, Ce, $e, Nt) {
               return ce === null || ce.tag !== 7 ? (ce = Oi(Ce, Ee.mode, $e, Nt), ce.return = Ee, ce) : (ce = D(ce, Ce), ce.return = Ee, ce)
            }

            function ft(Ee, ce, Ce) {
               if (typeof ce == "string" && ce !== "" || typeof ce == "number" || typeof ce == "bigint") return ce = Pp("" + ce, Ee.mode, Ce), ce.return = Ee, ce;
               if (typeof ce == "object" && ce !== null) {
                  switch (ce.$$typeof) {
                     case Gh:
                        return Ce = Ao(ce.type, ce.key, ce.props, null, Ee.mode, Ce), Yn(Ce, ce), Ce.return = Ee, Ce;
                     case _a:
                        return ce = xv(ce, Ee.mode, Ce), ce.return = Ee, ce;
                     case Sa:
                        var $e = ce._init;
                        return ce = $e(ce._payload), ft(Ee, ce, Ce)
                  }
                  if ( of (ce) || r(ce)) return ce = Oi(ce, Ee.mode, Ce, null), ce.return = Ee, ce;
                  if (typeof ce.then == "function") return ft(Ee, mn(ce), Ce);
                  if (ce.$$typeof === Wa) return ft(Ee, wh(Ee, ce), Ce);
                  ut(Ee, ce)
               }
               return null
            }

            function pt(Ee, ce, Ce, $e) {
               var Nt = ce !== null ? ce.key : null;
               if (typeof Ce == "string" && Ce !== "" || typeof Ce == "number" || typeof Ce == "bigint") return Nt !== null ? null : re(Ee, ce, "" + Ce, $e);
               if (typeof Ce == "object" && Ce !== null) {
                  switch (Ce.$$typeof) {
                     case Gh:
                        return Ce.key === Nt ? ve(Ee, ce, Ce, $e) : null;
                     case _a:
                        return Ce.key === Nt ? He(Ee, ce, Ce, $e) : null;
                     case Sa:
                        return Nt = Ce._init, Ce = Nt(Ce._payload), pt(Ee, ce, Ce, $e)
                  }
                  if ( of (Ce) || r(Ce)) return Nt !== null ? null : tt(Ee, ce, Ce, $e, null);
                  if (typeof Ce.then == "function") return pt(Ee, ce, mn(Ce), $e);
                  if (Ce.$$typeof === Wa) return pt(Ee, ce, wh(Ee, Ce), $e);
                  ut(Ee, Ce)
               }
               return null
            }

            function tn(Ee, ce, Ce, $e, Nt) {
               if (typeof $e == "string" && $e !== "" || typeof $e == "number" || typeof $e == "bigint") return Ee = Ee.get(Ce) || null, re(ce, Ee, "" + $e, Nt);
               if (typeof $e == "object" && $e !== null) {
                  switch ($e.$$typeof) {
                     case Gh:
                        return Ee = Ee.get($e.key === null ? Ce : $e.key) || null, ve(ce, Ee, $e, Nt);
                     case _a:
                        return Ee = Ee.get($e.key === null ? Ce : $e.key) || null, He(ce, Ee, $e, Nt);
                     case Sa:
                        var _i = $e._init;
                        return $e = _i($e._payload), tn(Ee, ce, Ce, $e, Nt)
                  }
                  if ( of ($e) || r($e)) return Ee = Ee.get(Ce) || null, tt(ce, Ee, $e, Nt, null);
                  if (typeof $e.then == "function") return tn(Ee, ce, Ce, mn($e), Nt);
                  if ($e.$$typeof === Wa) return tn(Ee, ce, Ce, wh(ce, $e), Nt);
                  ut(ce, $e)
               }
               return null
            }

            function ea(Ee, ce, Ce, $e) {
               for (var Nt = null, _i = null, Kt = ce, qn = ce = 0, qi = null; Kt !== null && qn < Ce.length; qn++) {
                  Kt.index > qn ? (qi = Kt, Kt = null) : qi = Kt.sibling;
                  var bn = pt(Ee, Kt, Ce[qn], $e);
                  if (bn === null) {
                     Kt === null && (Kt = qi);
                     break
                  }
                  f && Kt && bn.alternate === null && d(Ee, Kt), ce = L(bn, ce, qn), _i === null ? Nt = bn : _i.sibling = bn, _i = bn, Kt = qi
               }
               if (qn === Ce.length) return _(Ee, Kt), Bn && F(Ee, qn), Nt;
               if (Kt === null) {
                  for (; qn < Ce.length; qn++) Kt = ft(Ee, Ce[qn], $e), Kt !== null && (ce = L(Kt, ce, qn), _i === null ? Nt = Kt : _i.sibling = Kt, _i = Kt);
                  return Bn && F(Ee, qn), Nt
               }
               for (Kt = A(Kt); qn < Ce.length; qn++) qi = tn(Kt, Ee, qn, Ce[qn], $e), qi !== null && (f && qi.alternate !== null && Kt.delete(qi.key === null ? qn : qi.key), ce = L(qi, ce, qn), _i === null ? Nt = qi : _i.sibling = qi, _i = qi);
               return f && Kt.forEach(function (Fo) {
                  return d(Ee, Fo)
               }), Bn && F(Ee, qn), Nt
            }

            function Tu(Ee, ce, Ce, $e) {
               if (Ce == null) throw Error(s(151));
               for (var Nt = null, _i = null, Kt = ce, qn = ce = 0, qi = null, bn = Ce.next(); Kt !== null && !bn.done; qn++, bn = Ce.next()) {
                  Kt.index > qn ? (qi = Kt, Kt = null) : qi = Kt.sibling;
                  var Fo = pt(Ee, Kt, bn.value, $e);
                  if (Fo === null) {
                     Kt === null && (Kt = qi);
                     break
                  }
                  f && Kt && Fo.alternate === null && d(Ee, Kt), ce = L(Fo, ce, qn), _i === null ? Nt = Fo : _i.sibling = Fo, _i = Fo, Kt = qi
               }
               if (bn.done) return _(Ee, Kt), Bn && F(Ee, qn), Nt;
               if (Kt === null) {
                  for (; !bn.done; qn++, bn = Ce.next()) bn = ft(Ee, bn.value, $e), bn !== null && (ce = L(bn, ce, qn), _i === null ? Nt = bn : _i.sibling = bn, _i = bn);
                  return Bn && F(Ee, qn), Nt
               }
               for (Kt = A(Kt); !bn.done; qn++, bn = Ce.next()) bn = tn(Kt, Ee, qn, bn.value, $e), bn !== null && (f && bn.alternate !== null && Kt.delete(bn.key === null ? qn : bn.key), ce = L(bn, ce, qn), _i === null ? Nt = bn : _i.sibling = bn, _i = bn);
               return f && Kt.forEach(function (cm) {
                  return d(Ee, cm)
               }), Bn && F(Ee, qn), Nt
            }

            function Eu(Ee, ce, Ce, $e) {
               if (typeof Ce == "object" && Ce !== null && Ce.type === ou && Ce.key === null && (Ce = Ce.props.children), typeof Ce == "object" && Ce !== null) {
                  switch (Ce.$$typeof) {
                     case Gh:
                        e: {
                           for (var Nt = Ce.key; ce !== null;) {
                              if (ce.key === Nt) {
                                 if (Nt = Ce.type, Nt === ou) {
                                    if (ce.tag === 7) {
                                       _(Ee, ce.sibling), $e = D(ce, Ce.props.children), $e.return = Ee, Ee = $e;
                                       break e
                                    }
                                 } else if (ce.elementType === Nt || typeof Nt == "object" && Nt !== null && Nt.$$typeof === Sa && _t(Nt) === ce.type) {
                                    _(Ee, ce.sibling), $e = D(ce, Ce.props), Yn($e, Ce), $e.return = Ee, Ee = $e;
                                    break e
                                 }
                                 _(Ee, ce);
                                 break
                              } else d(Ee, ce);
                              ce = ce.sibling
                           }
                           Ce.type === ou ? ($e = Oi(Ce.props.children, Ee.mode, $e, Ce.key), $e.return = Ee, Ee = $e) : ($e = Ao(Ce.type, Ce.key, Ce.props, null, Ee.mode, $e), Yn($e, Ce), $e.return = Ee, Ee = $e)
                        }
                        return Y(Ee);
                     case _a:
                        e: {
                           for (Nt = Ce.key; ce !== null;) {
                              if (ce.key === Nt)
                                 if (ce.tag === 4 && ce.stateNode.containerInfo === Ce.containerInfo && ce.stateNode.implementation === Ce.implementation) {
                                    _(Ee, ce.sibling), $e = D(ce, Ce.children || []), $e.return = Ee, Ee = $e;
                                    break e
                                 } else {
                                    _(Ee, ce);
                                    break
                                 }
                              else d(Ee, ce);
                              ce = ce.sibling
                           }
                           $e = xv(Ce, Ee.mode, $e),
                           $e.return = Ee,
                           Ee = $e
                        }
                        return Y(Ee);
                     case Sa:
                        return Nt = Ce._init, Ce = Nt(Ce._payload), Eu(Ee, ce, Ce, $e)
                  }
                  if ( of (Ce)) return ea(Ee, ce, Ce, $e);
                  if (r(Ce)) {
                     if (Nt = r(Ce), typeof Nt != "function") throw Error(s(150));
                     return Ce = Nt.call(Ce), Tu(Ee, ce, Ce, $e)
                  }
                  if (typeof Ce.then == "function") return Eu(Ee, ce, mn(Ce), $e);
                  if (Ce.$$typeof === Wa) return Eu(Ee, ce, wh(Ee, Ce), $e);
                  ut(Ee, Ce)
               }
               return typeof Ce == "string" && Ce !== "" || typeof Ce == "number" || typeof Ce == "bigint" ? (Ce = "" + Ce, ce !== null && ce.tag === 6 ? (_(Ee, ce.sibling), $e = D(ce, Ce), $e.return = Ee, Ee = $e) : (_(Ee, ce), $e = Pp(Ce, Ee.mode, $e), $e.return = Ee, Ee = $e), Y(Ee)) : _(Ee, ce)
            }
            return function (Ee, ce, Ce, $e) {
               try {
                  vu = 0;
                  var Nt = Eu(Ee, ce, Ce, $e);
                  return gu = null, Nt
               } catch (Kt) {
                  if (Kt === xf) throw Kt;
                  var _i = t(29, Kt, null, Ee.mode);
                  return _i.lanes = $e, _i.return = Ee, _i
               } finally {}
            }
         }

         function Qe(f, d) {
            f = Qs, w(_f, f), w(mi, d), Qs = f | d.baseLanes
         }

         function St() {
            w(_f, Qs), w(mi, mi.current)
         }

         function gt() {
            Qs = _f.current, b(mi), b(_f)
         }

         function Dt(f) {
            var d = f.alternate;
            w(ls, ls.current & 1), w(Wr, f), ci === null && (d === null || mi.current !== null || d.memoizedState !== null) && (ci = f)
         }

         function Ti(f) {
            if (f.tag === 22) {
               if (w(ls, ls.current), w(Wr, f), ci === null) {
                  var d = f.alternate;
                  d !== null && d.memoizedState !== null && (ci = f)
               }
            } else Xt()
         }

         function Xt() {
            w(ls, ls.current), w(Wr, Wr.current)
         }

         function _n(f) {
            b(Wr), ci === f && (ci = null), b(ls)
         }

         function ii(f) {
            for (var d = f; d !== null;) {
               if (d.tag === 13) {
                  var _ = d.memoizedState;
                  if (_ !== null && (_ = _.dehydrated, _ === null || qp(_) || Xp(_))) return d
               } else if (d.tag === 19 && d.memoizedProps.revealOrder !== void 0) {
                  if ((d.flags & 128) !== 0) return d
               } else if (d.child !== null) {
                  d.child.return = d, d = d.child;
                  continue
               }
               if (d === f) break;
               for (; d.sibling === null;) {
                  if (d.return === null || d.return === f) return null;
                  d = d.return
               }
               d.sibling.return = d.return, d = d.sibling
            }
            return null
         }

         function Ft() {
            throw Error(s(321))
         }

         function Mn(f, d) {
            if (d === null) return !1;
            for (var _ = 0; _ < d.length && _ < f.length; _++)
               if (!Mr(f[_], d[_])) return !1;
            return !0
         }

         function gn(f, d, _, A, D, L) {
            return Ml = L, fn = d, d.memoizedState = null, d.updateQueue = null, d.lanes = 0, Yt.H = f === null || f.memoizedState === null ? _u : hr, xu = !1, L = _(A, D), xu = !1, uc && (L = zn(d, _, A, D)), Zi(f), L
         }

         function Zi(f) {
            Yt.H = Ui;
            var d = Ht !== null && Ht.next !== null;
            if (Ml = 0, Fn = Ht = fn = null, Aa = !1, cc = 0, Ts = null, d) throw Error(s(300));
            f === null || fi || (f = f.dependencies, f !== null && Ah(f) && (fi = !0))
         }

         function zn(f, d, _, A) {
            fn = f;
            var D = 0;
            do {
               if (uc && (Ts = null), cc = 0, uc = !1, 25 <= D) throw Error(s(301));
               if (D += 1, Fn = Ht = null, f.updateQueue != null) {
                  var L = f.updateQueue;
                  L.lastEffect = null, L.events = null, L.stores = null, L.memoCache != null && (L.memoCache.index = 0)
               }
               Yt.H = Yr, L = d(_, A)
            } while (uc);
            return L
         }

         function Pn() {
            var f = Yt.H,
               d = f.useState()[0];
            return d = typeof d.then == "function" ? Te(d) : d, f = f.useState()[0], (Ht !== null ? Ht.memoizedState : null) !== f && (fn.flags |= 1024), d
         }

         function Ns() {
            var f = nm !== 0;
            return nm = 0, f
         }

         function Ei(f, d, _) {
            d.updateQueue = f.updateQueue, d.flags &= -2053, f.lanes &= ~_
         }

         function ei(f) {
            if (Aa) {
               for (f = f.memoizedState; f !== null;) {
                  var d = f.queue;
                  d !== null && (d.pending = null), f = f.next
               }
               Aa = !1
            }
            Ml = 0, Fn = Ht = fn = null, uc = !1, cc = nm = 0, Ts = null
         }

         function X() {
            var f = {
               memoizedState: null,
               baseState: null,
               baseQueue: null,
               queue: null,
               next: null
            };
            return Fn === null ? fn.memoizedState = Fn = f : Fn = Fn.next = f, Fn
         }

         function ue() {
            if (Ht === null) {
               var f = fn.alternate;
               f = f !== null ? f.memoizedState : null
            } else f = Ht.next;
            var d = Fn === null ? fn.memoizedState : Fn.next;
            if (d !== null) Fn = d, Ht = f;
            else {
               if (f === null) throw fn.alternate === null ? Error(s(467)) : Error(s(310));
               Ht = f, f = {
                  memoizedState: Ht.memoizedState,
                  baseState: Ht.baseState,
                  baseQueue: Ht.baseQueue,
                  queue: Ht.queue,
                  next: null
               }, Fn === null ? fn.memoizedState = Fn = f : Fn = Fn.next = f
            }
            return Fn
         }

         function Te(f) {
            var d = cc;
            return cc += 1, Ts === null && (Ts = []), f = at(Ts, f, d), d = fn, (Fn === null ? d.memoizedState : Fn.next) === null && (d = d.alternate, Yt.H = d === null || d.memoizedState === null ? _u : hr), f
         }

         function xe(f) {
            if (f !== null && typeof f == "object") {
               if (typeof f.then == "function") return Te(f);
               if (f.$$typeof === Wa) return Ls(f)
            }
            throw Error(s(438, String(f)))
         }

         function de(f) {
            var d = null,
               _ = fn.updateQueue;
            if (_ !== null && (d = _.memoCache), d == null) {
               var A = fn.alternate;
               A !== null && (A = A.updateQueue, A !== null && (A = A.memoCache, A != null && (d = {
                  data: A.data.map(function (D) {
                     return D.slice()
                  }),
                  index: 0
               })))
            }
            if (d == null && (d = {
                  data: [],
                  index: 0
               }), _ === null && (_ = im(), fn.updateQueue = _), _.memoCache = d, _ = d.data[d.index], _ === void 0)
               for (_ = d.data[d.index] = Array(f), A = 0; A < f; A++) _[A] = e_;
            return d.index++, _
         }

         function je(f, d) {
            return typeof d == "function" ? d(f) : d
         }

         function st(f) {
            var d = ue();
            return ot(d, Ht, f)
         }

         function ot(f, d, _) {
            var A = f.queue;
            if (A === null) throw Error(s(311));
            A.lastRenderedReducer = _;
            var D = f.baseQueue,
               L = A.pending;
            if (L !== null) {
               if (D !== null) {
                  var Y = D.next;
                  D.next = L.next, L.next = Y
               }
               d.baseQueue = D = L, A.pending = null
            }
            if (L = f.baseState, D === null) f.memoizedState = L;
            else {
               d = D.next;
               var re = Y = null,
                  ve = null,
                  He = d,
                  tt = !1;
               do {
                  var ft = He.lane & -536870913;
                  if (ft !== He.lane ? (wn & ft) === ft : (Ml & ft) === ft) {
                     var pt = He.revertLane;
                     if (pt === 0) ve !== null && (ve = ve.next = {
                        lane: 0,
                        revertLane: 0,
                        action: He.action,
                        hasEagerState: He.hasEagerState,
                        eagerState: He.eagerState,
                        next: null
                     }), ft === Xr && (tt = !0);
                     else if ((Ml & pt) === pt) {
                        He = He.next, pt === Xr && (tt = !0);
                        continue
                     } else ft = {
                        lane: 0,
                        revertLane: He.revertLane,
                        action: He.action,
                        hasEagerState: He.hasEagerState,
                        eagerState: He.eagerState,
                        next: null
                     }, ve === null ? (re = ve = ft, Y = L) : ve = ve.next = ft, fn.lanes |= pt, Jr |= pt;
                     ft = He.action, xu && _(L, ft), L = He.hasEagerState ? He.eagerState : _(L, ft)
                  } else pt = {
                     lane: ft,
                     revertLane: He.revertLane,
                     action: He.action,
                     hasEagerState: He.hasEagerState,
                     eagerState: He.eagerState,
                     next: null
                  }, ve === null ? (re = ve = pt, Y = L) : ve = ve.next = pt, fn.lanes |= ft, Jr |= ft;
                  He = He.next
               } while (He !== null && He !== d);
               if (ve === null ? Y = L : ve.next = re, !Mr(L, f.memoizedState) && (fi = !0, tt && (_ = oc, _ !== null))) throw _;
               f.memoizedState = L, f.baseState = Y, f.baseQueue = ve, A.lastRenderedState = L
            }
            return D === null && (A.lanes = 0), [f.memoizedState, A.dispatch]
         }

         function ct(f) {
            var d = ue(),
               _ = d.queue;
            if (_ === null) throw Error(s(311));
            _.lastRenderedReducer = f;
            var A = _.dispatch,
               D = _.pending,
               L = d.memoizedState;
            if (D !== null) {
               _.pending = null;
               var Y = D = D.next;
               do L = f(L, Y.action), Y = Y.next; while (Y !== D);
               Mr(L, d.memoizedState) || (fi = !0), d.memoizedState = L, d.baseQueue === null && (d.baseState = L), _.lastRenderedState = L
            }
            return [L, A]
         }

         function At(f, d, _) {
            var A = fn,
               D = ue(),
               L = Bn;
            if (L) {
               if (_ === void 0) throw Error(s(407));
               _ = _()
            } else _ = d();
            var Y = !Mr((Ht || D).memoizedState, _);
            if (Y && (D.memoizedState = _, fi = !0), D = D.queue, jg(Wt.bind(null, A, D, f), [f]), D.getSnapshot !== d || Y || Fn !== null && Fn.memoizedState.tag & 1) {
               if (A.flags |= 2048, rr(9, Tt.bind(null, A, D, _, d), {
                     destroy: void 0
                  }, null), Qn === null) throw Error(s(349));
               L || (Ml & 60) !== 0 || wt(A, d, _)
            }
            return _
         }

         function wt(f, d, _) {
            f.flags |= 16384, f = {
               getSnapshot: d,
               value: _
            }, d = fn.updateQueue, d === null ? (d = im(), fn.updateQueue = d, d.stores = [f]) : (_ = d.stores, _ === null ? d.stores = [f] : _.push(f))
         }

         function Tt(f, d, _, A) {
            d.value = _, d.getSnapshot = A, In(d) && Mi(f)
         }

         function Wt(f, d, _) {
            return _(function () {
               In(d) && Mi(f)
            })
         }

         function In(f) {
            var d = f.getSnapshot;
            f = f.value;
            try {
               var _ = d();
               return !Mr(f, _)
            } catch {
               return !0
            }
         }

         function Mi(f) {
            var d = te(f, 2);
            d !== null && _s(d, f, 2)
         }

         function Sn(f) {
            var d = X();
            if (typeof f == "function") {
               var _ = f;
               if (f = _(), xu) {
                  Z(!0);
                  try {
                     _()
                  } finally {
                     Z(!1)
                  }
               }
            }
            return d.memoizedState = d.baseState = f, d.queue = {
               pending: null,
               lanes: 0,
               dispatch: null,
               lastRenderedReducer: je,
               lastRenderedState: f
            }, d
         }

         function An(f, d, _, A) {
            return f.baseState = _, ot(f, Ht, typeof A == "function" ? A : je)
         }

         function Pt(f, d, _, A, D) {
            if (Sh(f)) throw Error(s(485));
            if (f = d.action, f !== null) {
               var L = {
                  payload: D,
                  action: f,
                  next: null,
                  isTransition: !0,
                  status: "pending",
                  value: null,
                  reason: null,
                  listeners: [],
                  then: function (Y) {
                     L.listeners.push(Y)
                  }
               };
               Yt.T !== null ? _(!0) : L.isTransition = !1, A(L), _ = d.pending, _ === null ? (L.next = d.pending = L, Ri(d, L)) : (L.next = _.next, d.pending = _.next = L)
            }
         }

         function Ri(f, d) {
            var _ = d.action,
               A = d.payload,
               D = f.state;
            if (d.isTransition) {
               var L = Yt.T,
                  Y = {};
               Yt.T = Y;
               try {
                  var re = _(D, A),
                     ve = Yt.S;
                  ve !== null && ve(Y, re), Ln(f, d, re)
               } catch (He) {
                  _o(f, d, He)
               } finally {
                  Yt.T = L
               }
            } else try {
               L = _(D, A), Ln(f, d, L)
            } catch (He) {
               _o(f, d, He)
            }
         }

         function Ln(f, d, _) {
            _ !== null && typeof _ == "object" && typeof _.then == "function" ? _.then(function (A) {
               Os(f, d, A)
            }, function (A) {
               return _o(f, d, A)
            }) : Os(f, d, _)
         }

         function Os(f, d, _) {
            d.status = "fulfilled", d.value = _, li(d), f.state = _, d = f.pending, d !== null && (_ = d.next, _ === d ? f.pending = null : (_ = _.next, d.next = _, Ri(f, _)))
         }

         function _o(f, d, _) {
            var A = f.pending;
            if (f.pending = null, A !== null) {
               A = A.next;
               do d.status = "rejected", d.reason = _, li(d), d = d.next; while (d !== A)
            }
            f.action = null
         }

         function li(f) {
            f = f.listeners;
            for (var d = 0; d < f.length; d++)(0, f[d])()
         }

         function So(f, d) {
            return d
         }

         function si(f, d) {
            if (Bn) {
               var _ = Qn.formState;
               if (_ !== null) {
                  e: {
                     var A = fn;
                     if (Bn) {
                        if (Vs) {
                           var D = Bv(Vs, bs);
                           if (D) {
                              Vs = zv(D), A = b_(D);
                              break e
                           }
                        }
                        Xe(A)
                     }
                     A = !1
                  }
                  A && (d = _[0])
               }
            }
            _ = X(), _.memoizedState = _.baseState = d, A = {
               pending: null,
               lanes: 0,
               dispatch: null,
               lastRenderedReducer: So,
               lastRenderedState: d
            }, _.queue = A, _ = Yg.bind(null, fn, A), A.dispatch = _, A = Sn(!1);
            var L = Gc.bind(null, fn, !1, A.queue);
            return A = X(), D = {
               state: d,
               dispatch: null,
               action: f,
               pending: null
            }, A.queue = D, _ = Pt.bind(null, fn, D, L, _), D.dispatch = _, A.memoizedState = f, [d, _, !1]
         }

         function Us(f) {
            var d = ue();
            return Qi(d, Ht, f)
         }

         function Qi(f, d, _) {
            d = ot(f, d, So)[0], f = st(je)[0], d = typeof d == "object" && d !== null && typeof d.then == "function" ? Te(d) : d;
            var A = ue(),
               D = A.queue,
               L = D.dispatch;
            return _ !== A.memoizedState && (fn.flags |= 2048, rr(9, vs.bind(null, D, _), {
               destroy: void 0
            }, null)), [d, L, f]
         }

         function vs(f, d) {
            f.action = d
         }

         function ys(f) {
            var d = ue(),
               _ = Ht;
            if (_ !== null) return Qi(d, _, f);
            ue(), d = d.memoizedState, _ = ue();
            var A = _.queue.dispatch;
            return _.memoizedState = f, [d, A, !1]
         }

         function rr(f, d, _, A) {
            return f = {
               tag: f,
               create: d,
               inst: _,
               deps: A,
               next: null
            }, d = fn.updateQueue, d === null && (d = im(), fn.updateQueue = d), _ = d.lastEffect, _ === null ? d.lastEffect = f.next = f : (A = _.next, _.next = f, f.next = A, d.lastEffect = f), f
         }

         function bo() {
            return ue().memoizedState
         }

         function gh(f, d, _, A) {
            var D = X();
            fn.flags |= f, D.memoizedState = rr(1 | d, _, {
               destroy: void 0
            }, A === void 0 ? null : A)
         }

         function vh(f, d, _, A) {
            var D = ue();
            A = A === void 0 ? null : A;
            var L = D.memoizedState.inst;
            Ht !== null && A !== null && Mn(A, Ht.memoizedState.deps) ? D.memoizedState = rr(d, _, L, A) : (fn.flags |= f, D.memoizedState = rr(1 | d, _, L, A))
         }

         function pp(f, d) {
            gh(8390656, 8, f, d)
         }

         function jg(f, d) {
            vh(2048, 8, f, d)
         }

         function Ox(f, d) {
            return vh(4, 2, f, d)
         }

         function yh(f, d) {
            return vh(4, 4, f, d)
         }

         function mp(f, d) {
            if (typeof d == "function") {
               f = f();
               var _ = d(f);
               return function () {
                  typeof _ == "function" ? _() : d(null)
               }
            }
            if (d != null) return f = f(), d.current = f,
               function () {
                  d.current = null
               }
         }

         function gp(f, d, _) {
            _ = _ != null ? _.concat([f]) : null, vh(4, 4, mp.bind(null, d, f), _)
         }

         function Xl() {}

         function Xu(f, d) {
            var _ = ue();
            d = d === void 0 ? null : d;
            var A = _.memoizedState;
            return d !== null && Mn(d, A[1]) ? A[0] : (_.memoizedState = [f, d], f)
         }

         function qg(f, d) {
            var _ = ue();
            d = d === void 0 ? null : d;
            var A = _.memoizedState;
            if (d !== null && Mn(d, A[1])) return A[0];
            if (A = f(), xu) {
               Z(!0);
               try {
                  f()
               } finally {
                  Z(!1)
               }
            }
            return _.memoizedState = [A, d], A
         }

         function xh(f, d, _) {
            return _ === void 0 || (Ml & 1073741824) !== 0 ? f.memoizedState = d : (f.memoizedState = _, f = dv(), fn.lanes |= f, Jr |= f, _)
         }

         function Xg(f, d, _, A) {
            return Mr(_, d) ? _ : mi.current !== null ? (f = xh(f, _, A), Mr(f, d) || (fi = !0), f) : (Ml & 42) === 0 ? (fi = !0, f.memoizedState = _) : (f = dv(), fn.lanes |= f, Jr |= f, d)
         }

         function Hc(f, d, _, A, D) {
            var L = _l();
            Ks(L !== 0 && 8 > L ? L : 8);
            var Y = Yt.T,
               re = {};
            Yt.T = re, Gc(f, !1, d, _);
            try {
               var ve = D(),
                  He = Yt.S;
               if (He !== null && He(re, ve), ve !== null && typeof ve == "object" && typeof ve.then == "function") {
                  var tt = kt(ve, A);
                  Wl(f, d, tt, Vi(f))
               } else Wl(f, d, A, Vi(f))
            } catch (ft) {
               Wl(f, d, {
                  then: function () {},
                  status: "rejected",
                  reason: ft
               }, Vi())
            } finally {
               Ks(L), Yt.T = Y
            }
         }

         function To(f) {
            var d = f.memoizedState;
            if (d !== null) return d;
            d = {
               memoizedState: uu,
               baseState: uu,
               baseQueue: null,
               queue: {
                  pending: null,
                  lanes: 0,
                  dispatch: null,
                  lastRenderedReducer: je,
                  lastRenderedState: uu
               },
               next: null
            };
            var _ = {};
            return d.next = {
               memoizedState: _,
               baseState: _,
               baseQueue: null,
               queue: {
                  pending: null,
                  lanes: 0,
                  dispatch: null,
                  lastRenderedReducer: je,
                  lastRenderedState: _
               },
               next: null
            }, f.memoizedState = d, f = f.alternate, f !== null && (f.memoizedState = d), d
         }

         function _h() {
            return Ls(Ya)
         }

         function Vc() {
            return ue().memoizedState
         }

         function rl() {
            return ue().memoizedState
         }

         function Wg(f) {
            for (var d = f.return; d !== null;) {
               switch (d.tag) {
                  case 24:
                  case 3:
                     var _ = Vi();
                     f = xt(_);
                     var A = mt(d, f, _);
                     A !== null && (_s(A, d, _), it(A, d, _)), d = {
                        cache: Ql()
                     }, f.payload = d;
                     return
               }
               d = d.return
            }
         }

         function vp(f, d, _) {
            var A = Vi();
            _ = {
               lane: A,
               revertLane: 0,
               action: _,
               hasEagerState: !1,
               eagerState: null,
               next: null
            }, Sh(f) ? ar(d, _) : (_ = ze(f, d, _, A), _ !== null && (_s(_, f, A), Yl(_, d, A)))
         }

         function Yg(f, d, _) {
            var A = Vi();
            Wl(f, d, _, A)
         }

         function Wl(f, d, _, A) {
            var D = {
               lane: A,
               revertLane: 0,
               action: _,
               hasEagerState: !1,
               eagerState: null,
               next: null
            };
            if (Sh(f)) ar(d, D);
            else {
               var L = f.alternate;
               if (f.lanes === 0 && (L === null || L.lanes === 0) && (L = d.lastRenderedReducer, L !== null)) try {
                  var Y = d.lastRenderedState,
                     re = L(Y, _);
                  if (D.hasEagerState = !0, D.eagerState = re, Mr(re, Y)) return sn(f, d, D, 0), Qn === null && ne(), !1
               } catch {} finally {}
               if (_ = ze(f, d, D, A), _ !== null) return _s(_, f, A), Yl(_, d, A), !0
            }
            return !1
         }

         function Gc(f, d, _, A) {
            if (A = {
                  lane: 2,
                  revertLane: Ye(),
                  action: A,
                  hasEagerState: !1,
                  eagerState: null,
                  next: null
               }, Sh(f)) {
               if (d) throw Error(s(479))
            } else d = ze(f, _, A, 2), d !== null && _s(d, f, 2)
         }

         function Sh(f) {
            var d = f.alternate;
            return f === fn || d !== null && d === fn
         }

         function ar(f, d) {
            uc = Aa = !0;
            var _ = f.pending;
            _ === null ? d.next = d : (d.next = _.next, _.next = d), f.pending = d
         }

         function Yl(f, d, _) {
            if ((_ & 4194176) !== 0) {
               var A = d.lanes;
               A &= f.pendingLanes, _ |= A, d.lanes = _, ae(f, _)
            }
         }

         function kc(f, d, _, A) {
            d = f.memoizedState, _ = _(A, d), _ = _ == null ? d : Bp({}, d, _), f.memoizedState = _, f.lanes === 0 && (f.updateQueue.baseState = _)
         }

         function jc(f, d, _, A, D, L, Y) {
            return f = f.stateNode, typeof f.shouldComponentUpdate == "function" ? f.shouldComponentUpdate(A, L, Y) : d.prototype && d.prototype.isPureReactComponent ? !Re(_, A) || !Re(D, L) : !0
         }

         function Ux(f, d, _, A) {
            f = d.state, typeof d.componentWillReceiveProps == "function" && d.componentWillReceiveProps(_, A), typeof d.UNSAFE_componentWillReceiveProps == "function" && d.UNSAFE_componentWillReceiveProps(_, A), d.state !== f && Uo.enqueueReplaceState(d, d.state, null)
         }

         function al(f, d) {
            var _ = d;
            if ("ref" in d) {
               _ = {};
               for (var A in d) A !== "ref" && (_[A] = d[A])
            }
            if (f = f.defaultProps) {
               _ === d && (_ = Bp({}, _));
               for (var D in f) _[D] === void 0 && (_[D] = f[D])
            }
            return _
         }

         function qc(f, d) {
            try {
               var _ = f.onUncaughtError;
               _(d.value, {
                  componentStack: d.stack
               })
            } catch (A) {
               setTimeout(function () {
                  throw A
               })
            }
         }

         function Xc(f, d, _) {
            try {
               var A = f.onCaughtError;
               A(_.value, {
                  componentStack: _.stack,
                  errorBoundary: d.tag === 1 ? d.stateNode : null
               })
            } catch (D) {
               setTimeout(function () {
                  throw D
               })
            }
         }

         function Wc(f, d, _) {
            return _ = xt(_), _.tag = 3, _.payload = {
               element: null
            }, _.callback = function () {
               qc(f, d)
            }, _
         }

         function Kg(f) {
            return f = xt(f), f.tag = 3, f
         }

         function Px(f, d, _, A) {
            var D = _.type.getDerivedStateFromError;
            if (typeof D == "function") {
               var L = A.value;
               f.payload = function () {
                  return D(L)
               }, f.callback = function () {
                  Xc(d, _, A)
               }
            }
            var Y = _.stateNode;
            Y !== null && typeof Y.componentDidCatch == "function" && (f.callback = function () {
               Xc(d, _, A), typeof D != "function" && (Su === null ? Su = new Set([this]) : Su.add(this));
               var re = A.stack;
               this.componentDidCatch(A.value, {
                  componentStack: re !== null ? re : ""
               })
            })
         }

         function iE(f, d, _, A, D) {
            if (_.flags |= 32768, A !== null && typeof A == "object" && typeof A.then == "function") {
               if (d = _.alternate, d !== null && Mh(d, _, D, !0), _ = Wr.current, _ !== null) {
                  switch (_.tag) {
                     case 13:
                        return ci === null ? pl() : _.alternate === null && hi === 0 && (hi = 3), _.flags &= -257, _.flags |= 65536, _.lanes = D, A === id ? _.flags |= 16384 : (d = _.updateQueue, d === null ? _.updateQueue = new Set([A]) : d.add(A), Ku(f, A, D)), !1;
                     case 22:
                        return _.flags |= 65536, A === id ? _.flags |= 16384 : (d = _.updateQueue, d === null ? (d = {
                           transitions: null,
                           markerInstances: null,
                           retryQueue: new Set([A])
                        }, _.updateQueue = d) : (_ = d.retryQueue, _ === null ? d.retryQueue = new Set([A]) : _.add(A)), Ku(f, A, D)), !1
                  }
                  throw Error(s(435, _.tag))
               }
               return Ku(f, A, D), pl(), !1
            }
            if (Bn) return d = Wr.current, d !== null ? ((d.flags & 65536) === 0 && (d.flags |= 256), d.flags |= 65536, d.lanes = D, A !== ed && (f = Error(s(422), {
               cause: A
            }), lt(pe(f, _)))) : (A !== ed && (d = Error(s(423), {
               cause: A
            }), lt(pe(d, _))), f = f.current.alternate, f.flags |= 65536, D &= -D, f.lanes |= D, A = pe(A, _), D = Wc(f.stateNode, A, D), jt(f, D), hi !== 4 && (hi = 2)), !1;
            var L = Error(s(520), {
               cause: A
            });
            if (L = pe(L, _), hc === null ? hc = [L] : hc.push(L), hi !== 4 && (hi = 2), d === null) return !0;
            A = pe(A, _), _ = d;
            do {
               switch (_.tag) {
                  case 3:
                     return _.flags |= 65536, f = D & -D, _.lanes |= f, f = Wc(_.stateNode, A, f), jt(_, f), !1;
                  case 1:
                     if (d = _.type, L = _.stateNode, (_.flags & 128) === 0 && (typeof d.getDerivedStateFromError == "function" || L !== null && typeof L.componentDidCatch == "function" && (Su === null || !Su.has(L)))) return _.flags |= 65536, D &= -D, _.lanes |= D, D = Kg(D), Px(D, f, _, A), jt(_, D), !1
               }
               _ = _.return
            } while (_ !== null);
            return !1
         }

         function Ps(f, d, _, A) {
            d.child = f === null ? Oo(d, null, _, A) : yu(d, f.child, _, A)
         }

         function yp(f, d, _, A, D) {
            _ = _.render;
            var L = d.ref;
            if ("ref" in A) {
               var Y = {};
               for (var re in A) re !== "ref" && (Y[re] = A[re])
            } else Y = A;
            return Zl(d), A = gn(f, d, _, Y, L, D), re = Ns(), f !== null && !fi ? (Ei(f, d, D), ol(f, d, D)) : (Bn && re && ye(d), d.flags |= 1, Ps(f, d, A, D), d.child)
         }

         function Lx(f, d, _, A, D) {
            if (f === null) {
               var L = _.type;
               return typeof L == "function" && !Ih(L) && L.defaultProps === void 0 && _.compare === null ? (d.tag = 15, d.type = L, Bx(f, d, L, A, D)) : (f = Ao(_.type, null, A, d, d.mode, D), f.ref = d.ref, f.return = d, d.child = f)
            }
            if (L = f.child, !ev(f, D)) {
               var Y = L.memoizedProps;
               if (_ = _.compare, _ = _ !== null ? _ : Re, _(Y, A) && f.ref === d.ref) return ol(f, d, D)
            }
            return d.flags |= 1, f = xa(L, A), f.ref = d.ref, f.return = d, d.child = f
         }

         function Bx(f, d, _, A, D) {
            if (f !== null) {
               var L = f.memoizedProps;
               if (Re(L, A) && f.ref === d.ref)
                  if (fi = !1, d.pendingProps = A = L, ev(f, D))(f.flags & 131072) !== 0 && (fi = !0);
                  else return d.lanes = f.lanes, ol(f, d, D)
            }
            return xp(f, d, _, A, D)
         }

         function zx(f, d, _) {
            var A = d.pendingProps,
               D = A.children,
               L = (d.stateNode._pendingVisibility & 2) !== 0,
               Y = f !== null ? f.memoizedState : null;
            if (bh(f, d), A.mode === "hidden" || L) {
               if ((d.flags & 128) !== 0) {
                  if (A = Y !== null ? Y.baseLanes | _ : _, f !== null) {
                     for (D = d.child = f.child, L = 0; D !== null;) L = L | D.lanes | D.childLanes, D = D.sibling;
                     d.childLanes = L & ~A
                  } else d.childLanes = 0, d.child = null;
                  return Ix(f, d, A, _)
               }
               if ((_ & 536870912) !== 0) d.memoizedState = {
                  baseLanes: 0,
                  cachePool: null
               }, f !== null && Sp(d, Y !== null ? Y.cachePool : null), Y !== null ? Qe(d, Y) : St(), Ti(d);
               else return d.lanes = d.childLanes = 536870912, Ix(f, d, Y !== null ? Y.baseLanes | _ : _, _)
            } else Y !== null ? (Sp(d, Y.cachePool), Qe(d, Y), Xt(), d.memoizedState = null) : (f !== null && Sp(d, null), St(), Xt());
            return Ps(f, d, D, _), d.child
         }

         function Ix(f, d, _, A) {
            var D = nv();
            return D = D === null ? null : {
               parent: ur ? gi._currentValue : gi._currentValue2,
               pool: D
            }, d.memoizedState = {
               baseLanes: _,
               cachePool: D
            }, f !== null && Sp(d, null), St(), Ti(d), f !== null && Mh(f, d, A, !0), null
         }

         function bh(f, d) {
            var _ = d.ref;
            if (_ === null) f !== null && f.ref !== null && (d.flags |= 2097664);
            else {
               if (typeof _ != "function" && typeof _ != "object") throw Error(s(284));
               (f === null || f.ref !== _) && (d.flags |= 2097664)
            }
         }

         function xp(f, d, _, A, D) {
            return Zl(d), _ = gn(f, d, _, A, void 0, D), A = Ns(), f !== null && !fi ? (Ei(f, d, D), ol(f, d, D)) : (Bn && A && ye(d), d.flags |= 1, Ps(f, d, _, D), d.child)
         }

         function Fx(f, d, _, A, D, L) {
            return Zl(d), d.updateQueue = null, _ = zn(d, A, _, D), Zi(f), A = Ns(), f !== null && !fi ? (Ei(f, d, L), ol(f, d, L)) : (Bn && A && ye(d), d.flags |= 1, Ps(f, d, _, L), d.child)
         }

         function Hx(f, d, _, A, D) {
            if (Zl(d), d.stateNode === null) {
               var L = du,
                  Y = _.contextType;
               typeof Y == "object" && Y !== null && (L = Ls(Y)), L = new _(A, L), d.memoizedState = L.state !== null && L.state !== void 0 ? L.state : null, L.updater = Uo, d.stateNode = L, L._reactInternals = d, L = d.stateNode, L.props = A, L.state = d.memoizedState, L.refs = {}, Ke(d), Y = _.contextType, L.context = typeof Y == "object" && Y !== null ? Ls(Y) : du, L.state = d.memoizedState, Y = _.getDerivedStateFromProps, typeof Y == "function" && (kc(d, _, Y, A), L.state = d.memoizedState), typeof _.getDerivedStateFromProps == "function" || typeof L.getSnapshotBeforeUpdate == "function" || typeof L.UNSAFE_componentWillMount != "function" && typeof L.componentWillMount != "function" || (Y = L.state, typeof L.componentWillMount == "function" && L.componentWillMount(), typeof L.UNSAFE_componentWillMount == "function" && L.UNSAFE_componentWillMount(), Y !== L.state && Uo.enqueueReplaceState(L, L.state, null), cn(d, A, L, D), Rt(), L.state = d.memoizedState), typeof L.componentDidMount == "function" && (d.flags |= 4194308), A = !0
            } else if (f === null) {
               L = d.stateNode;
               var re = d.memoizedProps,
                  ve = al(_, re);
               L.props = ve;
               var He = L.context,
                  tt = _.contextType;
               Y = du, typeof tt == "object" && tt !== null && (Y = Ls(tt));
               var ft = _.getDerivedStateFromProps;
               tt = typeof ft == "function" || typeof L.getSnapshotBeforeUpdate == "function", re = d.pendingProps !== re, tt || typeof L.UNSAFE_componentWillReceiveProps != "function" && typeof L.componentWillReceiveProps != "function" || (re || He !== Y) && Ux(d, L, A, Y), El = !1;
               var pt = d.memoizedState;
               L.state = pt, cn(d, A, L, D), Rt(), He = d.memoizedState, re || pt !== He || El ? (typeof ft == "function" && (kc(d, _, ft, A), He = d.memoizedState), (ve = El || jc(d, _, ve, A, pt, He, Y)) ? (tt || typeof L.UNSAFE_componentWillMount != "function" && typeof L.componentWillMount != "function" || (typeof L.componentWillMount == "function" && L.componentWillMount(), typeof L.UNSAFE_componentWillMount == "function" && L.UNSAFE_componentWillMount()), typeof L.componentDidMount == "function" && (d.flags |= 4194308)) : (typeof L.componentDidMount == "function" && (d.flags |= 4194308), d.memoizedProps = A, d.memoizedState = He), L.props = A, L.state = He, L.context = Y, A = ve) : (typeof L.componentDidMount == "function" && (d.flags |= 4194308), A = !1)
            } else {
               L = d.stateNode, et(f, d), Y = d.memoizedProps, tt = al(_, Y), L.props = tt, ft = d.pendingProps, pt = L.context, He = _.contextType, ve = du, typeof He == "object" && He !== null && (ve = Ls(He)), re = _.getDerivedStateFromProps, (He = typeof re == "function" || typeof L.getSnapshotBeforeUpdate == "function") || typeof L.UNSAFE_componentWillReceiveProps != "function" && typeof L.componentWillReceiveProps != "function" || (Y !== ft || pt !== ve) && Ux(d, L, A, ve), El = !1, pt = d.memoizedState, L.state = pt, cn(d, A, L, D), Rt();
               var tn = d.memoizedState;
               Y !== ft || pt !== tn || El || f !== null && f.dependencies !== null && Ah(f.dependencies) ? (typeof re == "function" && (kc(d, _, re, A), tn = d.memoizedState), (tt = El || jc(d, _, tt, A, pt, tn, ve) || f !== null && f.dependencies !== null && Ah(f.dependencies)) ? (He || typeof L.UNSAFE_componentWillUpdate != "function" && typeof L.componentWillUpdate != "function" || (typeof L.componentWillUpdate == "function" && L.componentWillUpdate(A, tn, ve), typeof L.UNSAFE_componentWillUpdate == "function" && L.UNSAFE_componentWillUpdate(A, tn, ve)), typeof L.componentDidUpdate == "function" && (d.flags |= 4), typeof L.getSnapshotBeforeUpdate == "function" && (d.flags |= 1024)) : (typeof L.componentDidUpdate != "function" || Y === f.memoizedProps && pt === f.memoizedState || (d.flags |= 4), typeof L.getSnapshotBeforeUpdate != "function" || Y === f.memoizedProps && pt === f.memoizedState || (d.flags |= 1024), d.memoizedProps = A, d.memoizedState = tn), L.props = A, L.state = tn, L.context = ve, A = tt) : (typeof L.componentDidUpdate != "function" || Y === f.memoizedProps && pt === f.memoizedState || (d.flags |= 4), typeof L.getSnapshotBeforeUpdate != "function" || Y === f.memoizedProps && pt === f.memoizedState || (d.flags |= 1024), A = !1)
            }
            return L = A, bh(f, d), A = (d.flags & 128) !== 0, L || A ? (L = d.stateNode, _ = A && typeof _.getDerivedStateFromError != "function" ? null : L.render(), d.flags |= 1, f !== null && A ? (d.child = yu(d, f.child, null, D), d.child = yu(d, null, _, D)) : Ps(f, d, _, D), d.memoizedState = L.state, f = d.child) : f = ol(f, d, D), f
         }

         function Vx(f, d, _, A) {
            return zt(), d.flags |= 256, Ps(f, d, _, A), d.child
         }

         function Zg(f) {
            return {
               baseLanes: f,
               cachePool: iv()
            }
         }

         function Th(f, d, _) {
            return f = f !== null ? f.childLanes & ~_ : 0, d && (f |= $r), f
         }

         function Gx(f, d, _) {
            var A = d.pendingProps,
               D = !1,
               L = (d.flags & 128) !== 0,
               Y;
            if ((Y = L) || (Y = f !== null && f.memoizedState === null ? !1 : (ls.current & 2) !== 0), Y && (D = !0, d.flags &= -129), Y = (d.flags & 32) !== 0, d.flags &= -33, f === null) {
               if (Bn) {
                  if (D ? Dt(d) : Xt(), Bn) {
                     var re = Vs,
                        ve;
                     (ve = re) && (re = M_(re, bs), re !== null ? (d.memoizedState = {
                        dehydrated: re,
                        treeContext: pu !== null ? {
                           id: Za,
                           overflow: Qa
                        } : null,
                        retryLane: 536870912
                     }, ve = t(18, null, null, 0), ve.stateNode = re, ve.return = d, d.child = ve, Hs = d, Vs = null, ve = !0) : ve = !1), ve || Xe(d)
                  }
                  if (re = d.memoizedState, re !== null && (re = re.dehydrated, re !== null)) return Xp(re) ? d.lanes = 16 : d.lanes = 536870912, null;
                  _n(d)
               }
               return re = A.children, A = A.fallback, D ? (Xt(), D = d.mode, re = Jg({
                  mode: "hidden",
                  children: re
               }, D), A = Oi(A, D, _, null), re.return = d, A.return = d, re.sibling = A, d.child = re, D = d.child, D.memoizedState = Zg(_), D.childLanes = Th(f, Y, _), d.memoizedState = am, A) : (Dt(d), Qg(d, re))
            }
            if (ve = f.memoizedState, ve !== null && (re = ve.dehydrated, re !== null)) {
               if (L) d.flags & 256 ? (Dt(d), d.flags &= -257, d = _p(f, d, _)) : d.memoizedState !== null ? (Xt(), d.child = f.child, d.flags |= 128, d = null) : (Xt(), D = A.fallback, re = d.mode, A = Jg({
                  mode: "visible",
                  children: A.children
               }, re), D = Oi(D, re, _, null), D.flags |= 2, A.return = d, D.return = d, A.sibling = D, d.child = A, yu(d, f.child, null, _), A = d.child, A.memoizedState = Zg(_), A.childLanes = Th(f, Y, _), d.memoizedState = am, d = D);
               else if (Dt(d), Xp(re)) Y = __(re).digest, A = Error(s(419)), A.stack = "", A.digest = Y, lt({
                  value: A,
                  source: null,
                  stack: null
               }), d = _p(f, d, _);
               else if (fi || Mh(f, d, _, !1), Y = (_ & f.childLanes) !== 0, fi || Y) {
                  if (Y = Qn, Y !== null) {
                     if (A = _ & -_, (A & 42) !== 0) A = 1;
                     else switch (A) {
                        case 2:
                           A = 1;
                           break;
                        case 8:
                           A = 4;
                           break;
                        case 32:
                           A = 16;
                           break;
                        case 128:
                        case 256:
                        case 512:
                        case 1024:
                        case 2048:
                        case 4096:
                        case 8192:
                        case 16384:
                        case 32768:
                        case 65536:
                        case 131072:
                        case 262144:
                        case 524288:
                        case 1048576:
                        case 2097152:
                        case 4194304:
                        case 8388608:
                        case 16777216:
                        case 33554432:
                           A = 64;
                           break;
                        case 268435456:
                           A = 134217728;
                           break;
                        default:
                           A = 0
                     }
                     if (A = (A & (Y.suspendedLanes | _)) !== 0 ? 0 : A, A !== 0 && A !== ve.retryLane) throw ve.retryLane = A, te(f, A), _s(Y, f, A), rm
                  }
                  qp(re) || pl(), d = _p(f, d, _)
               } else qp(re) ? (d.flags |= 128, d.child = f.child, d = ml.bind(null, f), S_(re, d), d = null) : (f = ve.treeContext, Fs && (Vs = E_(re), Hs = d, Bn = !0, Ea = null, bs = !1, f !== null && (jr[qr++] = Za, jr[qr++] = Qa, jr[qr++] = pu, Za = f.id, Qa = f.overflow, pu = d)), d = Qg(d, A.children), d.flags |= 4096);
               return d
            }
            return D ? (Xt(), D = A.fallback, re = d.mode, ve = f.child, L = ve.sibling, A = xa(ve, {
               mode: "hidden",
               children: A.children
            }), A.subtreeFlags = ve.subtreeFlags & 31457280, L !== null ? D = xa(L, D) : (D = Oi(D, re, _, null), D.flags |= 2), D.return = d, A.return = d, A.sibling = D, d.child = A, A = D, D = d.child, re = f.child.memoizedState, re === null ? re = Zg(_) : (ve = re.cachePool, ve !== null ? (L = ur ? gi._currentValue : gi._currentValue2, ve = ve.parent !== L ? {
               parent: L,
               pool: L
            } : ve) : ve = iv(), re = {
               baseLanes: re.baseLanes | _,
               cachePool: ve
            }), D.memoizedState = re, D.childLanes = Th(f, Y, _), d.memoizedState = am, A) : (Dt(d), _ = f.child, f = _.sibling, _ = xa(_, {
               mode: "visible",
               children: A.children
            }), _.return = d, _.sibling = null, f !== null && (Y = d.deletions, Y === null ? (d.deletions = [f], d.flags |= 16) : Y.push(f)), d.child = _, d.memoizedState = null, _)
         }

         function Qg(f, d) {
            return d = Jg({
               mode: "visible",
               children: d
            }, f.mode), d.return = f, f.child = d
         }

         function Jg(f, d) {
            return Hh(f, d, 0, null)
         }

         function _p(f, d, _) {
            return yu(d, f.child, null, _), f = Qg(d, d.pendingProps.children), f.flags |= 2, d.memoizedState = null, f
         }

         function kx(f, d, _) {
            f.lanes |= d;
            var A = f.alternate;
            A !== null && (A.lanes |= d), Eh(f.return, d, _)
         }

         function $g(f, d, _, A, D) {
            var L = f.memoizedState;
            L === null ? f.memoizedState = {
               isBackwards: d,
               rendering: null,
               renderingStartTime: 0,
               last: A,
               tail: _,
               tailMode: D
            } : (L.isBackwards = d, L.rendering = null, L.renderingStartTime = 0, L.last = A, L.tail = _, L.tailMode = D)
         }

         function jx(f, d, _) {
            var A = d.pendingProps,
               D = A.revealOrder,
               L = A.tail;
            if (Ps(f, d, A.children, _), A = ls.current, (A & 2) !== 0) A = A & 1 | 2, d.flags |= 128;
            else {
               if (f !== null && (f.flags & 128) !== 0) e: for (f = d.child; f !== null;) {
                  if (f.tag === 13) f.memoizedState !== null && kx(f, _, d);
                  else if (f.tag === 19) kx(f, _, d);
                  else if (f.child !== null) {
                     f.child.return = f, f = f.child;
                     continue
                  }
                  if (f === d) break e;
                  for (; f.sibling === null;) {
                     if (f.return === null || f.return === d) break e;
                     f = f.return
                  }
                  f.sibling.return = f.return, f = f.sibling
               }
               A &= 1
            }
            switch (w(ls, A), D) {
               case "forwards":
                  for (_ = d.child, D = null; _ !== null;) f = _.alternate, f !== null && ii(f) === null && (D = _), _ = _.sibling;
                  _ = D, _ === null ? (D = d.child, d.child = null) : (D = _.sibling, _.sibling = null), $g(d, !1, D, _, L);
                  break;
               case "backwards":
                  for (_ = null, D = d.child, d.child = null; D !== null;) {
                     if (f = D.alternate, f !== null && ii(f) === null) {
                        d.child = D;
                        break
                     }
                     f = D.sibling, D.sibling = _, _ = D, D = f
                  }
                  $g(d, !0, _, null, L);
                  break;
               case "together":
                  $g(d, !1, null, null, void 0);
                  break;
               default:
                  d.memoizedState = null
            }
            return d.child
         }

         function ol(f, d, _) {
            if (f !== null && (d.dependencies = f.dependencies), Jr |= d.lanes, (_ & d.childLanes) === 0)
               if (f !== null) {
                  if (Mh(f, d, _, !1), (_ & d.childLanes) === 0) return null
               } else return null;
            if (f !== null && d.child !== f.child) throw Error(s(153));
            if (d.child !== null) {
               for (f = d.child, _ = xa(f, f.pendingProps), d.child = _, _.return = d; f.sibling !== null;) f = f.sibling, _ = _.sibling = xa(f, f.pendingProps), _.return = d;
               _.sibling = null
            }
            return d.child
         }

         function ev(f, d) {
            return (f.lanes & d) !== 0 ? !0 : (f = f.dependencies, !!(f !== null && Ah(f)))
         }

         function sE(f, d, _) {
            switch (d.tag) {
               case 3:
                  oe(d, d.stateNode.containerInfo), Kl(d, gi, f.memoizedState.cache), zt();
                  break;
               case 27:
               case 5:
                  Pe(d);
                  break;
               case 4:
                  oe(d, d.stateNode.containerInfo);
                  break;
               case 10:
                  Kl(d, d.type, d.memoizedProps.value);
                  break;
               case 13:
                  var A = d.memoizedState;
                  if (A !== null) return A.dehydrated !== null ? (Dt(d), d.flags |= 128, null) : (_ & d.child.childLanes) !== 0 ? Gx(f, d, _) : (Dt(d), f = ol(f, d, _), f !== null ? f.sibling : null);
                  Dt(d);
                  break;
               case 19:
                  var D = (f.flags & 128) !== 0;
                  if (A = (_ & d.childLanes) !== 0, A || (Mh(f, d, _, !1), A = (_ & d.childLanes) !== 0), D) {
                     if (A) return jx(f, d, _);
                     d.flags |= 128
                  }
                  if (D = d.memoizedState, D !== null && (D.rendering = null, D.tail = null, D.lastEffect = null), w(ls, ls.current), A) break;
                  return null;
               case 22:
               case 23:
                  return d.lanes = 0, zx(f, d, _);
               case 24:
                  Kl(d, gi, f.memoizedState.cache)
            }
            return ol(f, d, _)
         }

         function qx(f, d, _) {
            if (f !== null)
               if (f.memoizedProps !== d.pendingProps) fi = !0;
               else {
                  if (!ev(f, _) && (d.flags & 128) === 0) return fi = !1, sE(f, d, _);
                  fi = (f.flags & 131072) !== 0
               }
            else fi = !1, Bn && (d.flags & 1048576) !== 0 && ie(d, mf, d.index);
            switch (d.lanes = 0, d.tag) {
               case 16:
                  e: {
                     f = d.pendingProps;
                     var A = d.elementType,
                        D = A._init;
                     if (A = D(A._payload), d.type = A, typeof A == "function") Ih(A) ? (f = al(A, f), d.tag = 1, d = Hx(null, d, A, f, _)) : (d.tag = 0, d = xp(null, d, A, f, _));
                     else {
                        if (A != null) {
                           if (D = A.$$typeof, D === qh) {
                              d.tag = 11, d = yp(null, d, A, f, _);
                              break e
                           } else if (D === Fp) {
                              d.tag = 14, d = Lx(null, d, A, f, _);
                              break e
                           }
                        }
                        throw d = a(A) || A, Error(s(306, d, ""))
                     }
                  }
                  return d;
               case 0:
                  return xp(f, d, d.type, d.pendingProps, _);
               case 1:
                  return A = d.type, D = al(A, d.pendingProps), Hx(f, d, A, D, _);
               case 3:
                  e: {
                     if (oe(d, d.stateNode.containerInfo), f === null) throw Error(s(387));
                     var L = d.pendingProps;D = d.memoizedState,
                     A = D.element,
                     et(f, d),
                     cn(d, L, null, _);
                     var Y = d.memoizedState;
                     if (L = Y.cache, Kl(d, gi, L), L !== D.cache && Wu(d, [gi], _, !0), Rt(), L = Y.element, Fs && D.isDehydrated)
                        if (D = {
                              element: L,
                              isDehydrated: !1,
                              cache: Y.cache
                           }, d.updateQueue.baseState = D, d.memoizedState = D, d.flags & 256) {
                           d = Vx(f, d, L, _);
                           break e
                        } else if (L !== A) {
                        A = pe(Error(s(424)), d), lt(A), d = Vx(f, d, L, _);
                        break e
                     } else
                        for (Fs && (Vs = T_(d.stateNode.containerInfo), Hs = d, Bn = !0, Ea = null, bs = !0), _ = Oo(d, null, L, _), d.child = _; _;) _.flags = _.flags & -3 | 4096, _ = _.sibling;
                     else {
                        if (zt(), L === A) {
                           d = ol(f, d, _);
                           break e
                        }
                        Ps(f, d, L, _)
                     }
                     d = d.child
                  }
                  return d;
               case 26:
                  if (kr) return bh(f, d), f === null ? (_ = Hv(d.type, null, d.pendingProps, null)) ? d.memoizedState = _ : Bn || (d.stateNode = Qp(d.type, d.pendingProps, Do.current, d)) : d.memoizedState = Hv(d.type, f.memoizedProps, d.pendingProps, f.memoizedState), null;
               case 27:
                  if (ui) return Pe(d), f === null && ui && Bn && (A = d.stateNode = Ka(d.type, d.pendingProps, Do.current, os.current, !1), Hs = d, bs = !0, Vs = Wp(A)), A = d.pendingProps.children, f !== null || Bn ? Ps(f, d, A, _) : d.child = yu(d, null, A, _), bh(f, d), d.child;
               case 5:
                  return f === null && Bn && (Kp(d.type, d.pendingProps, os.current), (D = A = Vs) && (A = fE(A, d.type, d.pendingProps, bs), A !== null ? (d.stateNode = A, Hs = d, Vs = Wp(A), bs = !1, D = !0) : D = !1), D || Xe(d)), Pe(d), D = d.type, L = d.pendingProps, Y = f !== null ? f.memoizedProps : null, A = L.children, an(D, L) ? A = null : Y !== null && an(D, Y) && (d.flags |= 32), d.memoizedState !== null && (D = gn(f, d, Pn, null, null, _), ur ? Ya._currentValue = D : Ya._currentValue2 = D), bh(f, d), Ps(f, d, A, _), d.child;
               case 6:
                  return f === null && Bn && (D_(d.pendingProps, os.current), (f = _ = Vs) && (_ = Iv(_, d.pendingProps, bs), _ !== null ? (d.stateNode = _, Hs = d, Vs = null, f = !0) : f = !1), f || Xe(d)), null;
               case 13:
                  return Gx(f, d, _);
               case 4:
                  return oe(d, d.stateNode.containerInfo), A = d.pendingProps, f === null ? d.child = yu(d, null, A, _) : Ps(f, d, A, _), d.child;
               case 11:
                  return yp(f, d, d.type, d.pendingProps, _);
               case 7:
                  return Ps(f, d, d.pendingProps, _), d.child;
               case 8:
                  return Ps(f, d, d.pendingProps.children, _), d.child;
               case 12:
                  return Ps(f, d, d.pendingProps.children, _), d.child;
               case 10:
                  return A = d.pendingProps, Kl(d, d.type, A.value), Ps(f, d, A.children, _), d.child;
               case 9:
                  return D = d.type._context, A = d.pendingProps.children, Zl(d), D = Ls(D), A = A(D), d.flags |= 1, Ps(f, d, A, _), d.child;
               case 14:
                  return Lx(f, d, d.type, d.pendingProps, _);
               case 15:
                  return Bx(f, d, d.type, d.pendingProps, _);
               case 19:
                  return jx(f, d, _);
               case 22:
                  return zx(f, d, _);
               case 24:
                  return Zl(d), A = Ls(gi), f === null ? (D = nv(), D === null && (D = Qn, L = Ql(), D.pooledCache = L, L.refCount++, L !== null && (D.pooledCacheLanes |= _), D = L), d.memoizedState = {
                     parent: A,
                     cache: D
                  }, Ke(d), Kl(d, gi, D)) : ((f.lanes & _) !== 0 && (et(f, d), cn(d, null, null, _), Rt()), D = f.memoizedState, L = d.memoizedState, D.parent !== A ? (D = {
                     parent: A,
                     cache: A
                  }, d.memoizedState = D, d.lanes === 0 && (d.memoizedState = d.updateQueue.baseState = D), Kl(d, gi, A)) : (A = L.cache, Kl(d, gi, A), A !== D.cache && Wu(d, [gi], _, !0))), Ps(f, d, d.pendingProps.children, _), d.child;
               case 29:
                  throw d.pendingProps
            }
            throw Error(s(156, d.tag))
         }

         function Kl(f, d, _) {
            ur ? (w(Al, d._currentValue), d._currentValue = _) : (w(Al, d._currentValue2), d._currentValue2 = _)
         }

         function ll(f) {
            var d = Al.current;
            ur ? f._currentValue = d : f._currentValue2 = d, b(Al)
         }

         function Eh(f, d, _) {
            for (; f !== null;) {
               var A = f.alternate;
               if ((f.childLanes & d) !== d ? (f.childLanes |= d, A !== null && (A.childLanes |= d)) : A !== null && (A.childLanes & d) !== d && (A.childLanes |= d), f === _) break;
               f = f.return
            }
         }

         function Wu(f, d, _, A) {
            var D = f.child;
            for (D !== null && (D.return = f); D !== null;) {
               var L = D.dependencies;
               if (L !== null) {
                  var Y = D.child;
                  L = L.firstContext;
                  e: for (; L !== null;) {
                     var re = L;
                     L = D;
                     for (var ve = 0; ve < d.length; ve++)
                        if (re.context === d[ve]) {
                           L.lanes |= _, re = L.alternate, re !== null && (re.lanes |= _), Eh(L.return, _, f), A || (Y = null);
                           break e
                        } L = re.next
                  }
               } else if (D.tag === 18) {
                  if (Y = D.return, Y === null) throw Error(s(341));
                  Y.lanes |= _, L = Y.alternate, L !== null && (L.lanes |= _), Eh(Y, _, f), Y = null
               } else Y = D.child;
               if (Y !== null) Y.return = D;
               else
                  for (Y = D; Y !== null;) {
                     if (Y === f) {
                        Y = null;
                        break
                     }
                     if (D = Y.sibling, D !== null) {
                        D.return = Y.return, Y = D;
                        break
                     }
                     Y = Y.return
                  }
               D = Y
            }
         }

         function Mh(f, d, _, A) {
            f = null;
            for (var D = d, L = !1; D !== null;) {
               if (!L) {
                  if ((D.flags & 524288) !== 0) L = !0;
                  else if ((D.flags & 262144) !== 0) break
               }
               if (D.tag === 10) {
                  var Y = D.alternate;
                  if (Y === null) throw Error(s(387));
                  if (Y = Y.memoizedProps, Y !== null) {
                     var re = D.type;
                     Mr(D.pendingProps.value, Y.value) || (f !== null ? f.push(re) : f = [re])
                  }
               } else if (D === ic.current) {
                  if (Y = D.alternate, Y === null) throw Error(s(387));
                  Y.memoizedState.memoizedState !== D.memoizedState.memoizedState && (f !== null ? f.push(Ya) : f = [Ya])
               }
               D = D.return
            }
            f !== null && Wu(d, f, _, A), d.flags |= 262144
         }

         function Ah(f) {
            for (f = f.firstContext; f !== null;) {
               var d = f.context;
               if (!Mr(ur ? d._currentValue : d._currentValue2, f.memoizedValue)) return !0;
               f = f.next
            }
            return !1
         }

         function Zl(f) {
            eo = f, Kr = null, f = f.dependencies, f !== null && (f.firstContext = null)
         }

         function Ls(f) {
            return tv(eo, f)
         }

         function wh(f, d) {
            return eo === null && Zl(f), tv(f, d)
         }

         function tv(f, d) {
            var _ = ur ? d._currentValue : d._currentValue2;
            if (d = {
                  context: d,
                  memoizedValue: _,
                  next: null
               }, Kr === null) {
               if (f === null) throw Error(s(308));
               Kr = d, f.dependencies = {
                  lanes: 0,
                  firstContext: d
               }, f.flags |= 524288
            } else Kr = Kr.next = d;
            return _
         }

         function Ql() {
            return {
               controller: new Sf,
               data: new Map,
               refCount: 0
            }
         }

         function Rh(f) {
            f.refCount--, f.refCount === 0 && V_(G_, function () {
               f.controller.abort()
            })
         }

         function nv() {
            var f = Po.current;
            return f !== null ? f : Qn.pooledCache
         }

         function Sp(f, d) {
            d === null ? w(Po, Po.current) : w(Po, d.pool)
         }

         function iv() {
            var f = nv();
            return f === null ? null : {
               parent: ur ? gi._currentValue : gi._currentValue2,
               pool: f
            }
         }

         function yr(f) {
            f.flags |= 4
         }

         function Yc(f, d) {
            if (f !== null && f.child === d.child) return !1;
            if ((d.flags & 16) !== 0) return !0;
            for (f = d.child; f !== null;) {
               if ((f.flags & 13878) !== 0 || (f.subtreeFlags & 13878) !== 0) return !0;
               f = f.sibling
            }
            return !1
         }

         function Yu(f, d, _, A) {
            if (as)
               for (_ = d.child; _ !== null;) {
                  if (_.tag === 5 || _.tag === 6) Wh(f, _.stateNode);
                  else if (!(_.tag === 4 || ui && _.tag === 27) && _.child !== null) {
                     _.child.return = _, _ = _.child;
                     continue
                  }
                  if (_ === d) break;
                  for (; _.sibling === null;) {
                     if (_.return === null || _.return === d) return;
                     _ = _.return
                  }
                  _.sibling.return = _.return, _ = _.sibling
               } else if (ba)
                  for (var D = d.child; D !== null;) {
                     if (D.tag === 5) {
                        var L = D.stateNode;
                        _ && A && (L = Pv(L, D.type, D.memoizedProps)), Wh(f, L)
                     } else if (D.tag === 6) L = D.stateNode, _ && A && (L = Lv(L, D.memoizedProps)), Wh(f, L);
                     else if (D.tag !== 4) {
                        if (D.tag === 22 && D.memoizedState !== null) L = D.child, L !== null && (L.return = D), Yu(f, D, !0, !0);
                        else if (D.child !== null) {
                           D.child.return = D, D = D.child;
                           continue
                        }
                     }
                     if (D === d) break;
                     for (; D.sibling === null;) {
                        if (D.return === null || D.return === d) return;
                        D = D.return
                     }
                     D.sibling.return = D.return, D = D.sibling
                  }
         }

         function Xx(f, d, _, A) {
            if (ba)
               for (var D = d.child; D !== null;) {
                  if (D.tag === 5) {
                     var L = D.stateNode;
                     _ && A && (L = Pv(L, D.type, D.memoizedProps)), Uv(f, L)
                  } else if (D.tag === 6) L = D.stateNode, _ && A && (L = Lv(L, D.memoizedProps)), Uv(f, L);
                  else if (D.tag !== 4) {
                     if (D.tag === 22 && D.memoizedState !== null) L = D.child, L !== null && (L.return = D), Xx(f, D, !(D.memoizedProps !== null && D.memoizedProps.mode === "manual"), !0);
                     else if (D.child !== null) {
                        D.child.return = D, D = D.child;
                        continue
                     }
                  }
                  if (D === d) break;
                  for (; D.sibling === null;) {
                     if (D.return === null || D.return === d) return;
                     D = D.return
                  }
                  D.sibling.return = D.return, D = D.sibling
               }
         }

         function Ch(f, d) {
            if (ba && Yc(f, d)) {
               f = d.stateNode;
               var _ = f.containerInfo,
                  A = Yh();
               Xx(A, d, !1, !1), f.pendingChildren = A, yr(d), jp(_, A)
            }
         }

         function bp(f, d, _, A) {
            if (as) f.memoizedProps !== A && yr(d);
            else if (ba) {
               var D = f.stateNode,
                  L = f.memoizedProps;
               if ((f = Yc(f, d)) || L !== A) {
                  var Y = os.current;
                  L = hf(D, _, L, A, !f, null), L === D ? d.stateNode = D : (xl(L, _, A, Y) && yr(d), d.stateNode = L, f ? Yu(L, d, !1, !1) : yr(d))
               } else d.stateNode = D
            }
         }

         function Tp(f, d, _) {
            if (Mv(d, _)) {
               if (f.flags |= 16777216, !Gp(d, _))
                  if (iu()) f.flags |= 8192;
                  else throw mu = id, nd
            } else f.flags &= -16777217
         }

         function Ep(f, d) {
            if (U_(d)) {
               if (f.flags |= 16777216, !Ju(d))
                  if (iu()) f.flags |= 8192;
                  else throw mu = id, nd
            } else f.flags &= -16777217
         }

         function Kc(f, d) {
            d !== null && (f.flags |= 4), f.flags & 16384 && (d = f.tag !== 22 ? O() : 536870912, f.lanes |= d, zo |= d)
         }

         function Zc(f, d) {
            if (!Bn) switch (f.tailMode) {
               case "hidden":
                  d = f.tail;
                  for (var _ = null; d !== null;) d.alternate !== null && (_ = d), d = d.sibling;
                  _ === null ? f.tail = null : _.sibling = null;
                  break;
               case "collapsed":
                  _ = f.tail;
                  for (var A = null; _ !== null;) _.alternate !== null && (A = _), _ = _.sibling;
                  A === null ? d || f.tail === null ? f.tail = null : f.tail.sibling = null : A.sibling = null
            }
         }

         function Ai(f) {
            var d = f.alternate !== null && f.alternate.child === f.child,
               _ = 0,
               A = 0;
            if (d)
               for (var D = f.child; D !== null;) _ |= D.lanes | D.childLanes, A |= D.subtreeFlags & 31457280, A |= D.flags & 31457280, D.return = f, D = D.sibling;
            else
               for (D = f.child; D !== null;) _ |= D.lanes | D.childLanes, A |= D.subtreeFlags, A |= D.flags, D.return = f, D = D.sibling;
            return f.subtreeFlags |= A, f.childLanes = _, d
         }

         function Wx(f, d, _) {
            var A = d.pendingProps;
            switch (we(d), d.tag) {
               case 16:
               case 15:
               case 0:
               case 11:
               case 7:
               case 8:
               case 12:
               case 9:
               case 14:
                  return Ai(d), null;
               case 1:
                  return Ai(d), null;
               case 3:
                  return _ = d.stateNode, A = null, f !== null && (A = f.memoizedState.cache), d.memoizedState.cache !== A && (d.flags |= 2048), ll(gi), be(), _.pendingContext && (_.context = _.pendingContext, _.pendingContext = null), (f === null || f.child === null) && (Mt(d) ? yr(d) : f === null || f.memoizedState.isDehydrated && (d.flags & 256) === 0 || (d.flags |= 1024, Ea !== null && (Bh(Ea), Ea = null))), Ch(f, d), Ai(d), null;
               case 26:
                  if (kr) {
                     _ = d.type;
                     var D = d.memoizedState;
                     return f === null ? (yr(d), D !== null ? (Ai(d), Ep(d, D)) : (Ai(d), Tp(d, _, A))) : D ? D !== f.memoizedState ? (yr(d), Ai(d), Ep(d, D)) : (Ai(d), d.flags &= -16777217) : (as ? f.memoizedProps !== A && yr(d) : bp(f, d, _, A), Ai(d), Tp(d, _, A)), null
                  }
               case 27:
                  if (ui) {
                     if (Ge(d), _ = Do.current, D = d.type, f !== null && d.stateNode != null) as ? f.memoizedProps !== A && yr(d) : bp(f, d, D, A);
                     else {
                        if (!A) {
                           if (d.stateNode === null) throw Error(s(166));
                           return Ai(d), null
                        }
                        f = os.current, Mt(d) ? yt(d, f) : (f = Ka(D, A, _, f, !0), d.stateNode = f, yr(d))
                     }
                     return Ai(d), null
                  }
               case 5:
                  if (Ge(d), _ = d.type, f !== null && d.stateNode != null) bp(f, d, _, A);
                  else {
                     if (!A) {
                        if (d.stateNode === null) throw Error(s(166));
                        return Ai(d), null
                     }
                     f = os.current, Mt(d) ? yt(d, f) : (D = Ev(_, A, Do.current, f, d), Yu(D, d, !1, !1), d.stateNode = D, xl(D, _, A, f) && yr(d))
                  }
                  return Ai(d), Tp(d, d.type, d.pendingProps), null;
               case 6:
                  if (f && d.stateNode != null) _ = f.memoizedProps, as ? _ !== A && yr(d) : ba && (_ !== A ? (d.stateNode = ti(A, Do.current, os.current, d), yr(d)) : d.stateNode = f.stateNode);
                  else {
                     if (typeof A != "string" && d.stateNode === null) throw Error(s(166));
                     if (f = Do.current, _ = os.current, Mt(d)) {
                        if (!Fs) throw Error(s(176));
                        if (f = d.stateNode, _ = d.memoizedProps, A = null, D = Hs, D !== null) switch (D.tag) {
                           case 27:
                           case 5:
                              A = D.memoizedProps
                        }
                        Fv(f, _, d, A) || Xe(d)
                     } else d.stateNode = ti(A, f, _, d)
                  }
                  return Ai(d), null;
               case 13:
                  if (A = d.memoizedState, f === null || f.memoizedState !== null && f.memoizedState.dehydrated !== null) {
                     if (D = Mt(d), A !== null && A.dehydrated !== null) {
                        if (f === null) {
                           if (!D) throw Error(s(318));
                           if (!Fs) throw Error(s(344));
                           if (D = d.memoizedState, D = D !== null ? D.dehydrated : null, !D) throw Error(s(317));
                           w_(D, d)
                        } else zt(), (d.flags & 128) === 0 && (d.memoizedState = null), d.flags |= 4;
                        Ai(d), D = !1
                     } else Ea !== null && (Bh(Ea), Ea = null), D = !0;
                     if (!D) return d.flags & 256 ? (_n(d), d) : (_n(d), null)
                  }
                  if (_n(d), (d.flags & 128) !== 0) return d.lanes = _, d;
                  if (_ = A !== null, f = f !== null && f.memoizedState !== null, _) {
                     A = d.child, D = null, A.alternate !== null && A.alternate.memoizedState !== null && A.alternate.memoizedState.cachePool !== null && (D = A.alternate.memoizedState.cachePool.pool);
                     var L = null;
                     A.memoizedState !== null && A.memoizedState.cachePool !== null && (L = A.memoizedState.cachePool.pool), L !== D && (A.flags |= 2048)
                  }
                  return _ !== f && _ && (d.child.flags |= 8192), Kc(d, d.updateQueue), Ai(d), null;
               case 4:
                  return be(), Ch(f, d), f === null && Gi(d.stateNode.containerInfo), Ai(d), null;
               case 10:
                  return ll(d.type), Ai(d), null;
               case 19:
                  if (b(ls), D = d.memoizedState, D === null) return Ai(d), null;
                  if (A = (d.flags & 128) !== 0, L = D.rendering, L === null)
                     if (A) Zc(D, !1);
                     else {
                        if (hi !== 0 || f !== null && (f.flags & 128) !== 0)
                           for (f = d.child; f !== null;) {
                              if (L = ii(f), L !== null) {
                                 for (d.flags |= 128, Zc(D, !1), f = L.updateQueue, d.updateQueue = f, Kc(d, f), d.subtreeFlags = 0, f = _, _ = d.child; _ !== null;) Fh(_, f), _ = _.sibling;
                                 return w(ls, ls.current & 1 | 2), d.child
                              }
                              f = f.sibling
                           }
                        D.tail !== null && Ta() > Ef && (d.flags |= 128, A = !0, Zc(D, !1), d.lanes = 4194304)
                     }
                  else {
                     if (!A)
                        if (f = ii(L), f !== null) {
                           if (d.flags |= 128, A = !0, f = f.updateQueue, d.updateQueue = f, Kc(d, f), Zc(D, !0), D.tail === null && D.tailMode === "hidden" && !L.alternate && !Bn) return Ai(d), null
                        } else 2 * Ta() - D.renderingStartTime > Ef && _ !== 536870912 && (d.flags |= 128, A = !0, Zc(D, !1), d.lanes = 4194304);
                     D.isBackwards ? (L.sibling = d.child, d.child = L) : (f = D.last, f !== null ? f.sibling = L : d.child = L, D.last = L)
                  }
                  return D.tail !== null ? (d = D.tail, D.rendering = d, D.tail = d.sibling, D.renderingStartTime = Ta(), d.sibling = null, f = ls.current, w(ls, A ? f & 1 | 2 : f & 1), d) : (Ai(d), null);
               case 22:
               case 23:
                  return _n(d), gt(), A = d.memoizedState !== null, f !== null ? f.memoizedState !== null !== A && (d.flags |= 8192) : A && (d.flags |= 8192), A ? (_ & 536870912) !== 0 && (d.flags & 128) === 0 && (Ai(d), d.subtreeFlags & 6 && (d.flags |= 8192)) : Ai(d), _ = d.updateQueue, _ !== null && Kc(d, _.retryQueue), _ = null, f !== null && f.memoizedState !== null && f.memoizedState.cachePool !== null && (_ = f.memoizedState.cachePool.pool), A = null, d.memoizedState !== null && d.memoizedState.cachePool !== null && (A = d.memoizedState.cachePool.pool), A !== _ && (d.flags |= 2048), f !== null && b(Po), null;
               case 24:
                  return _ = null, f !== null && (_ = f.memoizedState.cache), d.memoizedState.cache !== _ && (d.flags |= 2048), ll(gi), Ai(d), null;
               case 25:
                  return null
            }
            throw Error(s(156, d.tag))
         }

         function rE(f, d) {
            switch (we(d), d.tag) {
               case 1:
                  return f = d.flags, f & 65536 ? (d.flags = f & -65537 | 128, d) : null;
               case 3:
                  return ll(gi), be(), f = d.flags, (f & 65536) !== 0 && (f & 128) === 0 ? (d.flags = f & -65537 | 128, d) : null;
               case 26:
               case 27:
               case 5:
                  return Ge(d), null;
               case 13:
                  if (_n(d), f = d.memoizedState, f !== null && f.dehydrated !== null) {
                     if (d.alternate === null) throw Error(s(340));
                     zt()
                  }
                  return f = d.flags, f & 65536 ? (d.flags = f & -65537 | 128, d) : null;
               case 19:
                  return b(ls), null;
               case 4:
                  return be(), null;
               case 10:
                  return ll(d.type), null;
               case 22:
               case 23:
                  return _n(d), gt(), f !== null && b(Po), f = d.flags, f & 65536 ? (d.flags = f & -65537 | 128, d) : null;
               case 24:
                  return ll(gi), null;
               case 25:
                  return null;
               default:
                  return null
            }
         }

         function Yx(f, d) {
            switch (we(d), d.tag) {
               case 3:
                  ll(gi), be();
                  break;
               case 26:
               case 27:
               case 5:
                  Ge(d);
                  break;
               case 4:
                  be();
                  break;
               case 13:
                  _n(d);
                  break;
               case 19:
                  b(ls);
                  break;
               case 10:
                  ll(d.type);
                  break;
               case 22:
               case 23:
                  _n(d), gt(), f !== null && b(Po);
                  break;
               case 24:
                  ll(gi)
            }
         }

         function Dh(f, d) {
            try {
               var _ = d.updateQueue,
                  A = _ !== null ? _.lastEffect : null;
               if (A !== null) {
                  var D = A.next;
                  _ = D;
                  do {
                     if ((_.tag & f) === f) {
                        A = void 0;
                        var L = _.create,
                           Y = _.inst;
                        A = L(), Y.destroy = A
                     }
                     _ = _.next
                  } while (_ !== D)
               }
            } catch (re) {
               Kn(d, d.return, re)
            }
         }

         function Jl(f, d, _) {
            try {
               var A = d.updateQueue,
                  D = A !== null ? A.lastEffect : null;
               if (D !== null) {
                  var L = D.next;
                  A = L;
                  do {
                     if ((A.tag & f) === f) {
                        var Y = A.inst,
                           re = Y.destroy;
                        if (re !== void 0) {
                           Y.destroy = void 0, D = d;
                           var ve = _;
                           try {
                              re()
                           } catch (He) {
                              Kn(D, ve, He)
                           }
                        }
                     }
                     A = A.next
                  } while (A !== L)
               }
            } catch (He) {
               Kn(d, d.return, He)
            }
         }

         function Kx(f) {
            var d = f.updateQueue;
            if (d !== null) {
               var _ = f.stateNode;
               try {
                  rt(d, _)
               } catch (A) {
                  Kn(f, f.return, A)
               }
            }
         }

         function xr(f, d, _) {
            _.props = al(f.type, f.memoizedProps), _.state = f.memoizedState;
            try {
               _.componentWillUnmount()
            } catch (A) {
               Kn(f, d, A)
            }
         }

         function qa(f, d) {
            try {
               var _ = f.ref;
               if (_ !== null) {
                  var A = f.stateNode;
                  switch (f.tag) {
                     case 26:
                     case 27:
                     case 5:
                        var D = uf(A);
                        break;
                     default:
                        D = A
                  }
                  typeof _ == "function" ? f.refCleanup = _(D) : _.current = D
               }
            } catch (L) {
               Kn(f, d, L)
            }
         }

         function _r(f, d) {
            var _ = f.ref,
               A = f.refCleanup;
            if (_ !== null)
               if (typeof A == "function") try {
                  A()
               } catch (D) {
                  Kn(f, d, D)
               } finally {
                  f.refCleanup = null, f = f.alternate, f != null && (f.refCleanup = null)
               } else if (typeof _ == "function") try {
                  _(null)
               } catch (D) {
                  Kn(f, d, D)
               } else _.current = null
         }

         function sv(f) {
            var d = f.type,
               _ = f.memoizedProps,
               A = f.stateNode;
            try {
               uE(A, d, _, f)
            } catch (D) {
               Kn(f, f.return, D)
            }
         }

         function rv(f, d, _) {
            try {
               h_(f.stateNode, f.type, _, d, f)
            } catch (A) {
               Kn(f, f.return, A)
            }
         }

         function av(f) {
            return f.tag === 5 || f.tag === 3 || (kr ? f.tag === 26 : !1) || (ui ? f.tag === 27 : !1) || f.tag === 4
         }

         function Nh(f) {
            e: for (;;) {
               for (; f.sibling === null;) {
                  if (f.return === null || av(f.return)) return null;
                  f = f.return
               }
               for (f.sibling.return = f.return, f = f.sibling; f.tag !== 5 && f.tag !== 6 && (!ui || f.tag !== 27) && f.tag !== 18;) {
                  if (f.flags & 2 || f.child === null || f.tag === 4) continue e;
                  f.child.return = f, f = f.child
               }
               if (!(f.flags & 2)) return f.stateNode
            }
         }

         function ov(f, d, _) {
            var A = f.tag;
            if (A === 5 || A === 6) f = f.stateNode, d ? p_(_, f, d) : Dv(_, f);
            else if (!(A === 4 || ui && A === 27) && (f = f.child, f !== null))
               for (ov(f, d, _), f = f.sibling; f !== null;) ov(f, d, _), f = f.sibling
         }

         function ul(f, d, _) {
            var A = f.tag;
            if (A === 5 || A === 6) f = f.stateNode, d ? d_(_, f, d) : c_(_, f);
            else if (!(A === 4 || ui && A === 27) && (f = f.child, f !== null))
               for (ul(f, d, _), f = f.sibling; f !== null;) ul(f, d, _), f = f.sibling
         }

         function Mp(f, d, _) {
            f = f.containerInfo;
            try {
               df(f, _)
            } catch (A) {
               Kn(d, d.return, A)
            }
         }

         function Oh(f, d) {
            for (Hp(f.containerInfo), en = d; en !== null;)
               if (f = en, d = f.child, (f.subtreeFlags & 1028) !== 0 && d !== null) d.return = f, en = d;
               else
                  for (; en !== null;) {
                     f = en;
                     var _ = f.alternate;
                     switch (d = f.flags, f.tag) {
                        case 0:
                           break;
                        case 11:
                        case 15:
                           break;
                        case 1:
                           if ((d & 1024) !== 0 && _ !== null) {
                              d = void 0;
                              var A = f,
                                 D = _.memoizedProps;
                              _ = _.memoizedState;
                              var L = A.stateNode;
                              try {
                                 var Y = al(A.type, D, A.elementType === A.type);
                                 d = L.getSnapshotBeforeUpdate(Y, _), L.__reactInternalSnapshotBeforeUpdate = d
                              } catch (re) {
                                 Kn(A, A.return, re)
                              }
                           }
                           break;
                        case 3:
                           (d & 1024) !== 0 && as && x_(f.stateNode.containerInfo);
                           break;
                        case 5:
                        case 26:
                        case 27:
                        case 6:
                        case 4:
                        case 17:
                           break;
                        default:
                           if ((d & 1024) !== 0) throw Error(s(163))
                     }
                     if (d = f.sibling, d !== null) {
                        d.return = f.return, en = d;
                        break
                     }
                     en = f.return
                  }
            return Y = xn, xn = !1, Y
         }

         function Ap(f, d, _) {
            var A = _.flags;
            switch (_.tag) {
               case 0:
               case 11:
               case 15:
                  fl(f, _), A & 4 && Dh(5, _);
                  break;
               case 1:
                  if (fl(f, _), A & 4)
                     if (f = _.stateNode, d === null) try {
                        f.componentDidMount()
                     } catch (re) {
                        Kn(_, _.return, re)
                     } else {
                        var D = al(_.type, d.memoizedProps);
                        d = d.memoizedState;
                        try {
                           f.componentDidUpdate(D, d, f.__reactInternalSnapshotBeforeUpdate)
                        } catch (re) {
                           Kn(_, _.return, re)
                        }
                     }
                  A & 64 && Kx(_), A & 512 && qa(_, _.return);
                  break;
               case 3:
                  if (fl(f, _), A & 64 && (A = _.updateQueue, A !== null)) {
                     if (f = null, _.child !== null) switch (_.child.tag) {
                        case 27:
                        case 5:
                           f = uf(_.child.stateNode);
                           break;
                        case 1:
                           f = _.child.stateNode
                     }
                     try {
                        rt(A, f)
                     } catch (re) {
                        Kn(_, _.return, re)
                     }
                  }
                  break;
               case 26:
                  if (kr) {
                     fl(f, _), A & 512 && qa(_, _.return);
                     break
                  }
               case 27:
               case 5:
                  fl(f, _), d === null && A & 4 && sv(_), A & 512 && qa(_, _.return);
                  break;
               case 12:
                  fl(f, _);
                  break;
               case 13:
                  fl(f, _), A & 4 && wp(f, _);
                  break;
               case 22:
                  if (D = _.memoizedState !== null || Lo, !D) {
                     d = d !== null && d.memoizedState !== null || Pi;
                     var L = Lo,
                        Y = Pi;
                     Lo = D, (Pi = d) && !Y ? hl(f, _, (_.subtreeFlags & 8772) !== 0) : fl(f, _), Lo = L, Pi = Y
                  }
                  A & 512 && (_.memoizedProps.mode === "manual" ? qa(_, _.return) : _r(_, _.return));
                  break;
               default:
                  fl(f, _)
            }
         }

         function lv(f) {
            var d = f.alternate;
            d !== null && (f.alternate = null, lv(d)), f.child = null, f.deletions = null, f.sibling = null, f.tag === 5 && (d = f.stateNode, d !== null && lE(d)), f.stateNode = null, f.return = null, f.dependencies = null, f.memoizedProps = null, f.memoizedState = null, f.pendingProps = null, f.stateNode = null, f.updateQueue = null
         }

         function Bs(f, d, _) {
            for (_ = _.child; _ !== null;) $l(f, d, _), _ = _.sibling
         }

         function $l(f, d, _) {
            if (Er && typeof Er.onCommitFiberUnmount == "function") try {
               Er.onCommitFiberUnmount(ji, _)
            } catch {}
            switch (_.tag) {
               case 26:
                  if (kr) {
                     Pi || _r(_, d), Bs(f, d, _), _.memoizedState ? Qu(_.memoizedState) : _.stateNode && pf(_.stateNode);
                     break
                  }
               case 27:
                  if (ui) {
                     Pi || _r(_, d);
                     var A = Lt,
                        D = ln;
                     Lt = _.stateNode, Bs(f, d, _), hu(_.stateNode), Lt = A, ln = D;
                     break
                  }
               case 5:
                  Pi || _r(_, d);
               case 6:
                  if (as) {
                     if (A = Lt, D = ln, Lt = null, Bs(f, d, _), Lt = A, ln = D, Lt !== null)
                        if (ln) try {
                           m_(Lt, _.stateNode)
                        } catch (L) {
                           Kn(_, d, L)
                        } else try {
                           Nv(Lt, _.stateNode)
                        } catch (L) {
                           Kn(_, d, L)
                        }
                  } else Bs(f, d, _);
                  break;
               case 18:
                  as && Lt !== null && (ln ? Kh(Lt, _.stateNode) : C_(Lt, _.stateNode));
                  break;
               case 4:
                  as ? (A = Lt, D = ln, Lt = _.stateNode.containerInfo, ln = !0, Bs(f, d, _), Lt = A, ln = D) : (ba && Mp(_.stateNode, _, Yh()), Bs(f, d, _));
                  break;
               case 0:
               case 11:
               case 14:
               case 15:
                  Pi || Jl(2, _, d), Pi || Jl(4, _, d), Bs(f, d, _);
                  break;
               case 1:
                  Pi || (_r(_, d), A = _.stateNode, typeof A.componentWillUnmount == "function" && xr(_, d, A)), Bs(f, d, _);
                  break;
               case 21:
                  Bs(f, d, _);
                  break;
               case 22:
                  Pi || _r(_, d), Pi = (A = Pi) || _.memoizedState !== null, Bs(f, d, _), Pi = A;
                  break;
               default:
                  Bs(f, d, _)
            }
         }

         function wp(f, d) {
            if (Fs && d.memoizedState === null && (f = d.alternate, f !== null && (f = f.memoizedState, f !== null && (f = f.dehydrated, f !== null)))) try {
               dE(f)
            } catch (_) {
               Kn(d, d.return, _)
            }
         }

         function Zx(f) {
            switch (f.tag) {
               case 13:
               case 19:
                  var d = f.stateNode;
                  return d === null && (d = f.stateNode = new Zn), d;
               case 22:
                  return f = f.stateNode, d = f._retryCache, d === null && (d = f._retryCache = new Zn), d;
               default:
                  throw Error(s(435, f.tag))
            }
         }

         function cl(f, d) {
            var _ = Zx(f);
            d.forEach(function (A) {
               var D = au.bind(null, f, A);
               _.has(A) || (_.add(A), A.then(D, D))
            })
         }

         function or(f, d) {
            var _ = d.deletions;
            if (_ !== null)
               for (var A = 0; A < _.length; A++) {
                  var D = _[A],
                     L = f,
                     Y = d;
                  if (as) {
                     var re = Y;
                     e: for (; re !== null;) {
                        switch (re.tag) {
                           case 27:
                           case 5:
                              Lt = re.stateNode, ln = !1;
                              break e;
                           case 3:
                              Lt = re.stateNode.containerInfo, ln = !0;
                              break e;
                           case 4:
                              Lt = re.stateNode.containerInfo, ln = !0;
                              break e
                        }
                        re = re.return
                     }
                     if (Lt === null) throw Error(s(160));
                     $l(L, Y, D), Lt = null, ln = !1
                  } else $l(L, Y, D);
                  L = D.alternate, L !== null && (L.return = null), D.return = null
               }
            if (d.subtreeFlags & 13878)
               for (d = d.child; d !== null;) uv(d, f), d = d.sibling
         }

         function uv(f, d) {
            var _ = f.alternate,
               A = f.flags;
            switch (f.tag) {
               case 0:
               case 11:
               case 14:
               case 15:
                  or(d, f), Sr(f), A & 4 && (Jl(3, f, f.return), Dh(3, f), Jl(5, f, f.return));
                  break;
               case 1:
                  or(d, f), Sr(f), A & 512 && (Pi || _ === null || _r(_, _.return)), A & 64 && Lo && (f = f.updateQueue, f !== null && (A = f.callbacks, A !== null && (_ = f.shared.hiddenCallbacks, f.shared.hiddenCallbacks = _ === null ? A : _.concat(A))));
                  break;
               case 26:
                  if (kr) {
                     var D = Di;
                     or(d, f), Sr(f), A & 512 && (Pi || _ === null || _r(_, _.return)), A & 4 && (A = _ !== null ? _.memoizedState : null, d = f.memoizedState, _ === null ? d === null ? f.stateNode === null ? f.stateNode = Qh(D, f.type, f.memoizedProps, f) : Jh(D, f.type, f.stateNode) : f.stateNode = N_(D, d, f.memoizedProps) : A !== d ? (A === null ? _.stateNode !== null && pf(_.stateNode) : Qu(A), d === null ? Jh(D, f.type, f.stateNode) : N_(D, d, f.memoizedProps)) : d === null && f.stateNode !== null && rv(f, f.memoizedProps, _.memoizedProps));
                     break
                  }
               case 27:
                  if (ui && A & 4 && f.alternate === null) {
                     D = f.stateNode;
                     var L = f.memoizedProps;
                     try {
                        fu(D), L_(f.type, L, D, f)
                     } catch (tt) {
                        Kn(f, f.return, tt)
                     }
                  }
               case 5:
                  if (or(d, f), Sr(f), A & 512 && (Pi || _ === null || _r(_, _.return)), as) {
                     if (f.flags & 32) {
                        d = f.stateNode;
                        try {
                           Ov(d)
                        } catch (tt) {
                           Kn(f, f.return, tt)
                        }
                     }
                     A & 4 && f.stateNode != null && (d = f.memoizedProps, rv(f, d, _ !== null ? _.memoizedProps : d)), A & 1024 && (jv = !0)
                  }
                  break;
               case 6:
                  if (or(d, f), Sr(f), A & 4 && as) {
                     if (f.stateNode === null) throw Error(s(162));
                     A = f.memoizedProps, _ = _ !== null ? _.memoizedProps : A, d = f.stateNode;
                     try {
                        f_(d, _, A)
                     } catch (tt) {
                        Kn(f, f.return, tt)
                     }
                  }
                  break;
               case 3:
                  if (kr ? (O_(), D = Di, Di = Zp(d.containerInfo), or(d, f), Di = D) : or(d, f), Sr(f), A & 4) {
                     if (as && Fs && _ !== null && _.memoizedState.isDehydrated) try {
                        hE(d.containerInfo)
                     } catch (tt) {
                        Kn(f, f.return, tt)
                     }
                     if (ba) {
                        A = d.containerInfo, _ = d.pendingChildren;
                        try {
                           df(A, _)
                        } catch (tt) {
                           Kn(f, f.return, tt)
                        }
                     }
                  }
                  jv && (jv = !1, Qx(f));
                  break;
               case 4:
                  kr ? (_ = Di, Di = Zp(f.stateNode.containerInfo), or(d, f), Sr(f), Di = _) : (or(d, f), Sr(f)), A & 4 && ba && Mp(f.stateNode, f, f.stateNode.pendingChildren);
                  break;
               case 12:
                  or(d, f), Sr(f);
                  break;
               case 13:
                  or(d, f), Sr(f), f.child.flags & 8192 && f.memoizedState !== null != (_ !== null && _.memoizedState !== null) && (dr = Ta()), A & 4 && (A = f.updateQueue, A !== null && (f.updateQueue = null, cl(f, A)));
                  break;
               case 22:
                  A & 512 && (Pi || _ === null || _r(_, _.return)), D = f.memoizedState !== null;
                  var Y = _ !== null && _.memoizedState !== null,
                     re = Lo,
                     ve = Pi;
                  if (Lo = re || D, Pi = ve || Y, or(d, f), Pi = ve, Lo = re, Sr(f), d = f.stateNode, d._current = f, d._visibility &= -3, d._visibility |= d._pendingVisibility & 2, A & 8192 && (d._visibility = D ? d._visibility & -2 : d._visibility | 1, D && (d = Lo || Pi, _ === null || Y || d || Qc(f)), as && (f.memoizedProps === null || f.memoizedProps.mode !== "manual"))) {
                     e: if (_ = null, as)
                        for (d = f;;) {
                           if (d.tag === 5 || kr && d.tag === 26 || ui && d.tag === 27) {
                              if (_ === null) {
                                 Y = _ = d;
                                 try {
                                    L = Y.stateNode, D ? g_(L) : y_(Y.stateNode, Y.memoizedProps)
                                 } catch (tt) {
                                    Kn(Y, Y.return, tt)
                                 }
                              }
                           } else if (d.tag === 6) {
                              if (_ === null) {
                                 Y = d;
                                 try {
                                    var He = Y.stateNode;
                                    D ? v_(He) : cE(He, Y.memoizedProps)
                                 } catch (tt) {
                                    Kn(Y, Y.return, tt)
                                 }
                              }
                           } else if ((d.tag !== 22 && d.tag !== 23 || d.memoizedState === null || d === f) && d.child !== null) {
                              d.child.return = d, d = d.child;
                              continue
                           }
                           if (d === f) break e;
                           for (; d.sibling === null;) {
                              if (d.return === null || d.return === f) break e;
                              _ === d && (_ = null), d = d.return
                           }
                           _ === d && (_ = null), d.sibling.return = d.return, d = d.sibling
                        }
                  }
                  A & 4 && (A = f.updateQueue, A !== null && (_ = A.retryQueue, _ !== null && (A.retryQueue = null, cl(f, _))));
                  break;
               case 19:
                  or(d, f), Sr(f), A & 4 && (A = f.updateQueue, A !== null && (f.updateQueue = null, cl(f, A)));
                  break;
               case 21:
                  break;
               default:
                  or(d, f), Sr(f)
            }
         }

         function Sr(f) {
            var d = f.flags;
            if (d & 2) {
               try {
                  if (as && (!ui || f.tag !== 27)) {
                     e: {
                        for (var _ = f.return; _ !== null;) {
                           if (av(_)) {
                              var A = _;
                              break e
                           }
                           _ = _.return
                        }
                        throw Error(s(160))
                     }
                     switch (A.tag) {
                        case 27:
                           if (ui) {
                              var D = A.stateNode,
                                 L = Nh(f);
                              ul(f, L, D);
                              break
                           }
                        case 5:
                           var Y = A.stateNode;
                           A.flags & 32 && (Ov(Y), A.flags &= -33);
                           var re = Nh(f);
                           ul(f, re, Y);
                           break;
                        case 3:
                        case 4:
                           var ve = A.stateNode.containerInfo,
                              He = Nh(f);
                           ov(f, He, ve);
                           break;
                        default:
                           throw Error(s(161))
                     }
                  }
               } catch (tt) {
                  Kn(f, f.return, tt)
               }
               f.flags &= -3
            }
            d & 4096 && (f.flags &= -4097)
         }

         function Qx(f) {
            if (f.subtreeFlags & 1024)
               for (f = f.child; f !== null;) {
                  var d = f;
                  Qx(d), d.tag === 5 && d.flags & 1024 && kp(d.stateNode), f = f.sibling
               }
         }

         function fl(f, d) {
            if (d.subtreeFlags & 8772)
               for (d = d.child; d !== null;) Ap(f, d.alternate, d), d = d.sibling
         }

         function Qc(f) {
            for (f = f.child; f !== null;) {
               var d = f;
               switch (d.tag) {
                  case 0:
                  case 11:
                  case 14:
                  case 15:
                     Jl(4, d, d.return), Qc(d);
                     break;
                  case 1:
                     _r(d, d.return);
                     var _ = d.stateNode;
                     typeof _.componentWillUnmount == "function" && xr(d, d.return, _), Qc(d);
                     break;
                  case 26:
                  case 27:
                  case 5:
                     _r(d, d.return), Qc(d);
                     break;
                  case 22:
                     _r(d, d.return), d.memoizedState === null && Qc(d);
                     break;
                  default:
                     Qc(d)
               }
               f = f.sibling
            }
         }

         function hl(f, d, _) {
            for (_ = _ && (d.subtreeFlags & 8772) !== 0, d = d.child; d !== null;) {
               var A = d.alternate,
                  D = f,
                  L = d,
                  Y = L.flags;
               switch (L.tag) {
                  case 0:
                  case 11:
                  case 15:
                     hl(D, L, _), Dh(4, L);
                     break;
                  case 1:
                     if (hl(D, L, _), A = L, D = A.stateNode, typeof D.componentDidMount == "function") try {
                        D.componentDidMount()
                     } catch (He) {
                        Kn(A, A.return, He)
                     }
                     if (A = L, D = A.updateQueue, D !== null) {
                        var re = A.stateNode;
                        try {
                           var ve = D.shared.hiddenCallbacks;
                           if (ve !== null)
                              for (D.shared.hiddenCallbacks = null, D = 0; D < ve.length; D++) le(ve[D], re)
                        } catch (He) {
                           Kn(A, A.return, He)
                        }
                     }
                     _ && Y & 64 && Kx(L), qa(L, L.return);
                     break;
                  case 26:
                  case 27:
                  case 5:
                     hl(D, L, _), _ && A === null && Y & 4 && sv(L), qa(L, L.return);
                     break;
                  case 12:
                     hl(D, L, _);
                     break;
                  case 13:
                     hl(D, L, _), _ && Y & 4 && wp(D, L);
                     break;
                  case 22:
                     L.memoizedState === null && hl(D, L, _), qa(L, L.return);
                     break;
                  default:
                     hl(D, L, _)
               }
               d = d.sibling
            }
         }

         function Rp(f, d) {
            var _ = null;
            f !== null && f.memoizedState !== null && f.memoizedState.cachePool !== null && (_ = f.memoizedState.cachePool.pool), f = null, d.memoizedState !== null && d.memoizedState.cachePool !== null && (f = d.memoizedState.cachePool.pool), f !== _ && (f != null && f.refCount++, _ != null && Rh(_))
         }

         function Uh(f, d) {
            f = null, d.alternate !== null && (f = d.alternate.memoizedState.cache), d = d.memoizedState.cache, d !== f && (d.refCount++, f != null && Rh(f))
         }

         function xs(f, d, _, A) {
            if (d.subtreeFlags & 10256)
               for (d = d.child; d !== null;) cv(f, d, _, A), d = d.sibling
         }

         function cv(f, d, _, A) {
            var D = d.flags;
            switch (d.tag) {
               case 0:
               case 11:
               case 15:
                  xs(f, d, _, A), D & 2048 && Dh(9, d);
                  break;
               case 3:
                  xs(f, d, _, A), D & 2048 && (f = null, d.alternate !== null && (f = d.alternate.memoizedState.cache), d = d.memoizedState.cache, d !== f && (d.refCount++, f != null && Rh(f)));
                  break;
               case 12:
                  if (D & 2048) {
                     xs(f, d, _, A), f = d.stateNode;
                     try {
                        var L = d.memoizedProps,
                           Y = L.id,
                           re = L.onPostCommit;
                        typeof re == "function" && re(Y, d.alternate === null ? "mount" : "update", f.passiveEffectDuration, -0)
                     } catch (ve) {
                        Kn(d, d.return, ve)
                     }
                  } else xs(f, d, _, A);
                  break;
               case 23:
                  break;
               case 22:
                  L = d.stateNode, d.memoizedState !== null ? L._visibility & 4 ? xs(f, d, _, A) : Ys(f, d) : L._visibility & 4 ? xs(f, d, _, A) : (L._visibility |= 4, zs(f, d, _, A, (d.subtreeFlags & 10256) !== 0)), D & 2048 && Rp(d.alternate, d);
                  break;
               case 24:
                  xs(f, d, _, A), D & 2048 && Uh(d.alternate, d);
                  break;
               default:
                  xs(f, d, _, A)
            }
         }

         function zs(f, d, _, A, D) {
            for (D = D && (d.subtreeFlags & 10256) !== 0, d = d.child; d !== null;) {
               var L = f,
                  Y = d,
                  re = _,
                  ve = A,
                  He = Y.flags;
               switch (Y.tag) {
                  case 0:
                  case 11:
                  case 15:
                     zs(L, Y, re, ve, D), Dh(8, Y);
                     break;
                  case 23:
                     break;
                  case 22:
                     var tt = Y.stateNode;
                     Y.memoizedState !== null ? tt._visibility & 4 ? zs(L, Y, re, ve, D) : Ys(L, Y) : (tt._visibility |= 4, zs(L, Y, re, ve, D)), D && He & 2048 && Rp(Y.alternate, Y);
                     break;
                  case 24:
                     zs(L, Y, re, ve, D), D && He & 2048 && Uh(Y.alternate, Y);
                     break;
                  default:
                     zs(L, Y, re, ve, D)
               }
               d = d.sibling
            }
         }

         function Ys(f, d) {
            if (d.subtreeFlags & 10256)
               for (d = d.child; d !== null;) {
                  var _ = f,
                     A = d,
                     D = A.flags;
                  switch (A.tag) {
                     case 22:
                        Ys(_, A), D & 2048 && Rp(A.alternate, A);
                        break;
                     case 24:
                        Ys(_, A), D & 2048 && Uh(A.alternate, A);
                        break;
                     default:
                        Ys(_, A)
                  }
                  d = d.sibling
               }
         }

         function va(f) {
            if (f.subtreeFlags & Zr)
               for (f = f.child; f !== null;) Cp(f), f = f.sibling
         }

         function Cp(f) {
            switch (f.tag) {
               case 26:
                  va(f), f.flags & Zr && (f.memoizedState !== null ? P_(Di, f.memoizedState, f.memoizedProps) : cr(f.type, f.memoizedProps));
                  break;
               case 5:
                  va(f), f.flags & Zr && cr(f.type, f.memoizedProps);
                  break;
               case 3:
               case 4:
                  if (kr) {
                     var d = Di;
                     Di = Zp(f.stateNode.containerInfo), va(f), Di = d
                  } else va(f);
                  break;
               case 22:
                  f.memoizedState === null && (d = f.alternate, d !== null && d.memoizedState !== null ? (d = Zr, Zr = 16777216, va(f), Zr = d) : va(f));
                  break;
               default:
                  va(f)
            }
         }

         function Ph(f) {
            var d = f.alternate;
            if (d !== null && (f = d.child, f !== null)) {
               d.child = null;
               do d = f.sibling, f.sibling = null, f = d; while (f !== null)
            }
         }

         function eu(f) {
            var d = f.deletions;
            if ((f.flags & 16) !== 0) {
               if (d !== null)
                  for (var _ = 0; _ < d.length; _++) {
                     var A = d[_];
                     en = A, fv(A, f)
                  }
               Ph(f)
            }
            if (f.subtreeFlags & 10256)
               for (f = f.child; f !== null;) Dp(f), f = f.sibling
         }

         function Dp(f) {
            switch (f.tag) {
               case 0:
               case 11:
               case 15:
                  eu(f), f.flags & 2048 && Jl(9, f, f.return);
                  break;
               case 3:
                  eu(f);
                  break;
               case 12:
                  eu(f);
                  break;
               case 22:
                  var d = f.stateNode;
                  f.memoizedState !== null && d._visibility & 4 && (f.return === null || f.return.tag !== 13) ? (d._visibility &= -5, dl(f)) : eu(f);
                  break;
               default:
                  eu(f)
            }
         }

         function dl(f) {
            var d = f.deletions;
            if ((f.flags & 16) !== 0) {
               if (d !== null)
                  for (var _ = 0; _ < d.length; _++) {
                     var A = d[_];
                     en = A, fv(A, f)
                  }
               Ph(f)
            }
            for (f = f.child; f !== null;) {
               switch (d = f, d.tag) {
                  case 0:
                  case 11:
                  case 15:
                     Jl(8, d, d.return), dl(d);
                     break;
                  case 22:
                     _ = d.stateNode, _._visibility & 4 && (_._visibility &= -5, dl(d));
                     break;
                  default:
                     dl(d)
               }
               f = f.sibling
            }
         }

         function fv(f, d) {
            for (; en !== null;) {
               var _ = en;
               switch (_.tag) {
                  case 0:
                  case 11:
                  case 15:
                     Jl(8, _, d);
                     break;
                  case 23:
                  case 22:
                     if (_.memoizedState !== null && _.memoizedState.cachePool !== null) {
                        var A = _.memoizedState.cachePool.pool;
                        A != null && A.refCount++
                     }
                     break;
                  case 24:
                     Rh(_.memoizedState.cache)
               }
               if (A = _.child, A !== null) A.return = _, en = A;
               else e: for (_ = f; en !== null;) {
                  A = en;
                  var D = A.sibling,
                     L = A.return;
                  if (lv(A), A === _) {
                     en = null;
                     break e
                  }
                  if (D !== null) {
                     D.return = L, en = D;
                     break e
                  }
                  en = L
               }
            }
         }

         function Jc(f) {
            var d = i_(f);
            if (d != null) {
               if (typeof d.memoizedProps["data-testname"] != "string") throw Error(s(364));
               return d
            }
            if (f = Rv(f), f === null) throw Error(s(362));
            return f.stateNode.current
         }

         function tu(f, d) {
            var _ = f.tag;
            switch (d.$$typeof) {
               case Tf:
                  if (f.type === d.value) return !0;
                  break;
               case wa:
                  e: {
                     for (d = d.value, f = [f, 0], _ = 0; _ < f.length;) {
                        var A = f[_++],
                           D = A.tag,
                           L = f[_++],
                           Y = d[L];
                        if (D !== 5 && D !== 26 && D !== 27 || !ff(A)) {
                           for (; Y != null && tu(A, Y);) L++, Y = d[L];
                           if (L === d.length) {
                              d = !0;
                              break e
                           } else
                              for (A = A.child; A !== null;) f.push(A, L), A = A.sibling
                        }
                     }
                     d = !1
                  }
                  return d;
               case xi:
                  if ((_ === 5 || _ === 26 || _ === 27) && o_(f.stateNode, d.value)) return !0;
                  break;
               case Bo:
                  if ((_ === 5 || _ === 6 || _ === 26 || _ === 27) && (f = a_(f), f !== null && 0 <= f.indexOf(d.value))) return !0;
                  break;
               case to:
                  if ((_ === 5 || _ === 26 || _ === 27) && (f = f.memoizedProps["data-testname"], typeof f == "string" && f.toLowerCase() === d.value.toLowerCase())) return !0;
                  break;
               default:
                  throw Error(s(365))
            }
            return !1
         }

         function hv(f) {
            switch (f.$$typeof) {
               case Tf:
                  return "<" + (a(f.value) || "Unknown") + ">";
               case wa:
                  return ":has(" + (hv(f) || "") + ")";
               case xi:
                  return '[role="' + f.value + '"]';
               case Bo:
                  return '"' + f.value + '"';
               case to:
                  return '[data-testname="' + f.value + '"]';
               default:
                  throw Error(s(365))
            }
         }

         function br(f, d) {
            var _ = [];
            f = [f, 0];
            for (var A = 0; A < f.length;) {
               var D = f[A++],
                  L = D.tag,
                  Y = f[A++],
                  re = d[Y];
               if (L !== 5 && L !== 26 && L !== 27 || !ff(D)) {
                  for (; re != null && tu(D, re);) Y++, re = d[Y];
                  if (Y === d.length) _.push(D);
                  else
                     for (D = D.child; D !== null;) f.push(D, Y), D = D.sibling
               }
            }
            return _
         }

         function Lh(f, d) {
            if (!cu) throw Error(s(363));
            f = Jc(f), f = br(f, d), d = [], f = Array.from(f);
            for (var _ = 0; _ < f.length;) {
               var A = f[_++],
                  D = A.tag;
               if (D === 5 || D === 26 || D === 27) ff(A) || d.push(A.stateNode);
               else
                  for (A = A.child; A !== null;) f.push(A), A = A.sibling
            }
            return d
         }

         function Vi() {
            if ((Hn & 2) !== 0 && wn !== 0) return wn & -wn;
            if (Yt.T !== null) {
               var f = Xr;
               return f !== 0 ? f : Ye()
            }
            return s_()
         }

         function dv() {
            $r === 0 && ($r = (wn & 536870912) === 0 || Bn ? I() : 536870912);
            var f = Wr.current;
            return f !== null && (f.flags |= 32), $r
         }

         function _s(f, d, _) {
            (f === Qn && ri === 2 || f.cancelPendingCommit !== null) && (Is(f, 0), Tr(f, wn, $r, !1)), q(f, _), ((Hn & 2) === 0 || f !== Qn) && (f === Qn && ((Hn & 2) === 0 && (wl |= _), hi === 4 && Tr(f, wn, $r, !1)), Ue(f))
         }

         function nu(f, d, _) {
            if ((Hn & 6) !== 0) throw Error(s(327));
            var A = !_ && (d & 60) === 0 && (d & f.expiredLanes) === 0 || z(f, d),
               D = A ? mv(f, d) : Op(f, d, !0),
               L = A;
            do {
               if (D === 0) {
                  Qr && !A && Tr(f, d, 0, !1);
                  break
               } else if (D === 6) Tr(f, d, 0, !Ca);
               else {
                  if (_ = f.current.alternate, L && !$c(_)) {
                     D = Op(f, d, !1), L = !1;
                     continue
                  }
                  if (D === 2) {
                     if (L = d, f.errorRecoveryDisabledLanes & L) var Y = 0;
                     else Y = f.pendingLanes & -536870913, Y = Y !== 0 ? Y : Y & 536870912 ? 536870912 : 0;
                     if (Y !== 0) {
                        d = Y;
                        e: {
                           var re = f;D = hc;
                           var ve = Fs && re.current.memoizedState.isDehydrated;
                           if (ve && (Is(re, Y).flags |= 256), Y = Op(re, Y, !1), Y !== 2) {
                              if (us && !ve) {
                                 re.errorRecoveryDisabledLanes |= L, wl |= L, D = 4;
                                 break e
                              }
                              L = Li, Li = D, L !== null && Bh(L)
                           }
                           D = Y
                        }
                        if (L = !1, D !== 2) continue
                     }
                  }
                  if (D === 1) {
                     Is(f, 0), Tr(f, d, 0, !0);
                     break
                  }
                  e: {
                     switch (A = f, D) {
                        case 0:
                        case 1:
                           throw Error(s(345));
                        case 4:
                           if ((d & 4194176) === d) {
                              Tr(A, d, $r, !Ca);
                              break e
                           }
                           break;
                        case 2:
                           Li = null;
                           break;
                        case 3:
                        case 5:
                           break;
                        default:
                           throw Error(s(329))
                     }
                     if (A.finishedWork = _, A.finishedLanes = d, (d & 62914560) === d && (L = dr + 300 - Ta(), 10 < L)) {
                        if (Tr(A, d, $r, !Ca), U(A, 0) !== 0) break e;
                        A.timeoutHandle = $i(Np.bind(null, A, _, Li, rd, om, d, $r, wl, zo, Ca, 2, -0, 0), L);
                        break e
                     }
                     Np(A, _, Li, rd, om, d, $r, wl, zo, Ca, 0, -0, 0)
                  }
               }
               break
            } while (!0);
            Ue(f)
         }

         function Bh(f) {
            Li === null ? Li = f : Li.push.apply(Li, f)
         }

         function Np(f, d, _, A, D, L, Y, re, ve, He, tt, ft, pt) {
            var tn = d.subtreeFlags;
            if ((tn & 8192 || (tn & 16785408) === 16785408) && (Av(), Cp(d), d = es(), d !== null)) {
               f.cancelPendingCommit = d(su.bind(null, f, _, A, D, Y, re, ve, 1, ft, pt)), Tr(f, L, Y, !He);
               return
            }
            su(f, _, A, D, Y, re, ve, tt, ft, pt)
         }

         function $c(f) {
            for (var d = f;;) {
               var _ = d.tag;
               if ((_ === 0 || _ === 11 || _ === 15) && d.flags & 16384 && (_ = d.updateQueue, _ !== null && (_ = _.stores, _ !== null)))
                  for (var A = 0; A < _.length; A++) {
                     var D = _[A],
                        L = D.getSnapshot;
                     D = D.value;
                     try {
                        if (!Mr(L(), D)) return !1
                     } catch {
                        return !1
                     }
                  }
               if (_ = d.child, d.subtreeFlags & 16384 && _ !== null) _.return = d, d = _;
               else {
                  if (d === f) break;
                  for (; d.sibling === null;) {
                     if (d.return === null || d.return === f) return !0;
                     d = d.return
                  }
                  d.sibling.return = d.return, d = d.sibling
               }
            }
            return !0
         }

         function Tr(f, d, _, A) {
            d &= ~sd, d &= ~wl, f.suspendedLanes |= d, f.pingedLanes &= ~d, A && (f.warmLanes |= d), A = f.expirationTimes;
            for (var D = d; 0 < D;) {
               var L = 31 - fr(D),
                  Y = 1 << L;
               A[L] = -1, D &= ~Y
            }
            _ !== 0 && $(f, _, d)
         }

         function zh() {
            return (Hn & 6) === 0 ? (K(0), !1) : !0
         }

         function ef() {
            if (Vt !== null) {
               if (ri === 0) var f = Vt.return;
               else f = Vt, Kr = eo = null, ei(f), gu = null, vu = 0, f = Vt;
               for (; f !== null;) Yx(f.alternate, f), f = f.return;
               Vt = null
            }
         }

         function Is(f, d) {
            f.finishedWork = null, f.finishedLanes = 0;
            var _ = f.timeoutHandle;
            _ !== lu && (f.timeoutHandle = lu, Vp(_)), _ = f.cancelPendingCommit, _ !== null && (f.cancelPendingCommit = null, _()), ef(), Qn = f, Vt = _ = xa(f.current, null), wn = d, ri = 0, Zs = null, Ca = !1, Qr = z(f, d), us = !1, zo = $r = sd = wl = Jr = hi = 0, Li = hc = null, om = !1, (d & 8) !== 0 && (d |= d & 32);
            var A = f.entangledLanes;
            if (A !== 0)
               for (f = f.entanglements, A &= d; 0 < A;) {
                  var D = 31 - fr(A),
                     L = 1 << D;
                  d |= f[D], A &= ~L
               }
            return Qs = d, ne(), _
         }

         function Hr(f, d) {
            fn = null, Yt.H = Ui, d === xf ? (d = Bt(), ri = 3) : d === nd ? (d = Bt(), ri = 4) : ri = d === rm ? 8 : d !== null && typeof d == "object" && typeof d.then == "function" ? 6 : 1, Zs = d, Vt === null && (hi = 1, qc(f, pe(d, f.current)))
         }

         function iu() {
            var f = Wr.current;
            return f === null ? !0 : (wn & 4194176) === wn ? ci === null : (wn & 62914560) === wn || (wn & 536870912) !== 0 ? f === ci : !1
         }

         function Eo() {
            var f = Yt.H;
            return Yt.H = Ui, f === null ? Ui : f
         }

         function Mo() {
            var f = Yt.A;
            return Yt.A = bf, f
         }

         function pl() {
            hi = 4, Ca || (wn & 4194176) !== wn && Wr.current !== null || (Qr = !0), (Jr & 134217727) === 0 && (wl & 134217727) === 0 || Qn === null || Tr(Qn, wn, $r, !1)
         }

         function Op(f, d, _) {
            var A = Hn;
            Hn |= 2;
            var D = Eo(),
               L = Mo();
            (Qn !== f || wn !== d) && (rd = null, Is(f, d)), d = !1;
            var Y = hi;
            e: do try {
                  if (ri !== 0 && Vt !== null) {
                     var re = Vt,
                        ve = Zs;
                     switch (ri) {
                        case 8:
                           ef(), Y = 6;
                           break e;
                        case 3:
                        case 2:
                        case 6:
                           Wr.current === null && (d = !0);
                           var He = ri;
                           if (ri = 0, Zs = null, ya(f, re, ve, He), _ && Qr) {
                              Y = 0;
                              break e
                           }
                           break;
                        default:
                           He = ri, ri = 0, Zs = null, ya(f, re, ve, He)
                     }
                  }
                  pv(), Y = hi;
                  break
               } catch (tt) {
                  Hr(f, tt)
               }
               while (!0);
               return d && f.shellSuspendCounter++, Kr = eo = null, Hn = A, Yt.H = D, Yt.A = L, Vt === null && (Qn = null, wn = 0, ne()), Y
         }

         function pv() {
            for (; Vt !== null;) Ci(Vt)
         }

         function mv(f, d) {
            var _ = Hn;
            Hn |= 2;
            var A = Eo(),
               D = Mo();
            Qn !== f || wn !== d ? (rd = null, Ef = Ta() + 500, Is(f, d)) : Qr = z(f, d);
            e: do try {
                  if (ri !== 0 && Vt !== null) {
                     d = Vt;
                     var L = Zs;
                     t: switch (ri) {
                        case 1:
                           ri = 0, Zs = null, ya(f, d, L, 1);
                           break;
                        case 2:
                           if (Ie(L)) {
                              ri = 0, Zs = null, jn(d);
                              break
                           }
                           d = function () {
                              ri === 2 && Qn === f && (ri = 7), Ue(f)
                           }, L.then(d, d);
                           break e;
                        case 3:
                           ri = 7;
                           break e;
                        case 4:
                           ri = 5;
                           break e;
                        case 7:
                           Ie(L) ? (ri = 0, Zs = null, jn(d)) : (ri = 0, Zs = null, ya(f, d, L, 7));
                           break;
                        case 5:
                           var Y = null;
                           switch (Vt.tag) {
                              case 26:
                                 Y = Vt.memoizedState;
                              case 5:
                              case 27:
                                 var re = Vt,
                                    ve = re.type,
                                    He = re.pendingProps;
                                 if (Y ? Ju(Y) : Gp(ve, He)) {
                                    ri = 0, Zs = null;
                                    var tt = re.sibling;
                                    if (tt !== null) Vt = tt;
                                    else {
                                       var ft = re.return;
                                       ft !== null ? (Vt = ft, Vr(ft)) : Vt = null
                                    }
                                    break t
                                 }
                           }
                           ri = 0, Zs = null, ya(f, d, L, 5);
                           break;
                        case 6:
                           ri = 0, Zs = null, ya(f, d, L, 6);
                           break;
                        case 8:
                           ef(), hi = 6;
                           break e;
                        default:
                           throw Error(s(462))
                     }
                  }
                  lr();
                  break
               } catch (pt) {
                  Hr(f, pt)
               }
               while (!0);
               return Kr = eo = null, Yt.H = A, Yt.A = D, Hn = _, Vt !== null ? 0 : (Qn = null, wn = 0, ne(), hi)
         }

         function lr() {
            for (; Vt !== null && !I_();) Ci(Vt)
         }

         function Ci(f) {
            var d = qx(f.alternate, f, Qs);
            f.memoizedProps = f.pendingProps, d === null ? Vr(f) : Vt = d
         }

         function jn(f) {
            var d = f,
               _ = d.alternate;
            switch (d.tag) {
               case 15:
               case 0:
                  d = Fx(_, d, d.pendingProps, d.type, void 0, wn);
                  break;
               case 11:
                  d = Fx(_, d, d.pendingProps, d.type.render, d.ref, wn);
                  break;
               case 5:
                  ei(d);
               default:
                  Yx(_, d), d = Vt = Fh(d, Qs), d = qx(_, d, Qs)
            }
            f.memoizedProps = f.pendingProps, d === null ? Vr(f) : Vt = d
         }

         function ya(f, d, _, A) {
            Kr = eo = null, ei(d), gu = null, vu = 0;
            var D = d.return;
            try {
               if (iE(f, D, d, _, wn)) {
                  hi = 1, qc(f, pe(_, f.current)), Vt = null;
                  return
               }
            } catch (L) {
               if (D !== null) throw Vt = D, L;
               hi = 1, qc(f, pe(_, f.current)), Vt = null;
               return
            }
            d.flags & 32768 ? (Bn || A === 1 ? f = !0 : Qr || (wn & 536870912) !== 0 ? f = !1 : (Ca = f = !0, (A === 2 || A === 3 || A === 6) && (A = Wr.current, A !== null && A.tag === 13 && (A.flags |= 16384))), Up(d, f)) : Vr(d)
         }

         function Vr(f) {
            var d = f;
            do {
               if ((d.flags & 32768) !== 0) {
                  Up(d, Ca);
                  return
               }
               f = d.return;
               var _ = Wx(d.alternate, d, Qs);
               if (_ !== null) {
                  Vt = _;
                  return
               }
               if (d = d.sibling, d !== null) {
                  Vt = d;
                  return
               }
               Vt = d = f
            } while (d !== null);
            hi === 0 && (hi = 5)
         }

         function Up(f, d) {
            do {
               var _ = rE(f.alternate, f);
               if (_ !== null) {
                  _.flags &= 32767, Vt = _;
                  return
               }
               if (_ = f.return, _ !== null && (_.flags |= 32768, _.subtreeFlags = 0, _.deletions = null), !d && (f = f.sibling, f !== null)) {
                  Vt = f;
                  return
               }
               Vt = f = _
            } while (f !== null);
            hi = 6, Vt = null
         }

         function su(f, d, _, A, D, L, Y, re, ve, He) {
            var tt = Yt.T,
               ft = _l();
            try {
               Ks(2), Yt.T = null, Jx(f, d, _, A, ft, D, L, Y, re, ve, He)
            } finally {
               Yt.T = tt, Ks(ft)
            }
         }

         function Jx(f, d, _, A, D, L, Y, re) {
            do Xa(); while (Io !== null);
            if ((Hn & 6) !== 0) throw Error(s(327));
            var ve = f.finishedWork;
            if (A = f.finishedLanes, ve === null) return null;
            if (f.finishedWork = null, f.finishedLanes = 0, ve === f.current) throw Error(s(177));
            f.callbackNode = null, f.callbackPriority = 0, f.cancelPendingCommit = null;
            var He = ve.lanes | ve.childLanes;
            if (He |= Ja, Q(f, A, He, L, Y, re), f === Qn && (Vt = Qn = null, wn = 0), (ve.subtreeFlags & 10256) === 0 && (ve.flags & 10256) === 0 || no || (no = !0, bu = He, lm = _, gl(tm, function () {
                  return Xa(), null
               })), _ = (ve.flags & 15990) !== 0, (ve.subtreeFlags & 15990) !== 0 || _ ? (_ = Yt.T, Yt.T = null, L = _l(), Ks(2), Y = Hn, Hn |= 4, Oh(f, ve), uv(ve, f), n_(f.containerInfo), f.current = ve, Ap(f, ve.alternate, ve), $p(), Hn = Y, Ks(L), Yt.T = _) : f.current = ve, no ? (no = !1, Io = f, dc = A) : gv(f, He), He = f.pendingLanes, He === 0 && (Su = null), k(ve.stateNode), Ue(f), d !== null)
               for (D = f.onRecoverableError, ve = 0; ve < d.length; ve++) He = d[ve], D(He.value, {
                  componentStack: He.stack
               });
            return (dc & 3) !== 0 && Xa(), He = f.pendingLanes, (A & 4194218) !== 0 && (He & 42) !== 0 ? f === um ? Mf++ : (Mf = 0, um = f) : Mf = 0, K(0), null
         }

         function gv(f, d) {
            (f.pooledCacheLanes &= d) === 0 && (d = f.pooledCache, d != null && (f.pooledCache = null, Rh(d)))
         }

         function Xa() {
            if (Io !== null) {
               var f = Io,
                  d = bu;
               bu = 0;
               var _ = fe(dc),
                  A = 32 > _ ? 32 : _;
               _ = Yt.T;
               var D = _l();
               try {
                  if (Ks(A), Yt.T = null, Io === null) var L = !1;
                  else {
                     A = lm, lm = null;
                     var Y = Io,
                        re = dc;
                     if (Io = null, dc = 0, (Hn & 6) !== 0) throw Error(s(331));
                     var ve = Hn;
                     if (Hn |= 4, Dp(Y.current), cv(Y, Y.current, re, A), Hn = ve, K(0, !1), Er && typeof Er.onPostCommitFiberRoot == "function") try {
                        Er.onPostCommitFiberRoot(ji, Y)
                     } catch {}
                     L = !0
                  }
                  return L
               } finally {
                  Ks(D), Yt.T = _, gv(f, d)
               }
            }
            return !1
         }

         function tf(f, d, _) {
            d = pe(_, d), d = Wc(f.stateNode, d, 2), f = mt(f, d, 2), f !== null && (q(f, 2), Ue(f))
         }

         function Kn(f, d, _) {
            if (f.tag === 3) tf(f, f, _);
            else
               for (; d !== null;) {
                  if (d.tag === 3) {
                     tf(d, f, _);
                     break
                  } else if (d.tag === 1) {
                     var A = d.stateNode;
                     if (typeof d.type.getDerivedStateFromError == "function" || typeof A.componentDidCatch == "function" && (Su === null || !Su.has(A))) {
                        f = pe(_, f), _ = Kg(2), A = mt(d, _, 2), A !== null && (Px(_, A, d, f), q(A, 2), Ue(A));
                        break
                     }
                  }
                  d = d.return
               }
         }

         function Ku(f, d, _) {
            var A = f.pingCache;
            if (A === null) {
               A = f.pingCache = new Ra;
               var D = new Set;
               A.set(d, D)
            } else D = A.get(d), D === void 0 && (D = new Set, A.set(d, D));
            D.has(_) || (us = !0, D.add(_), f = vv.bind(null, f, d, _), d.then(f, f))
         }

         function vv(f, d, _) {
            var A = f.pingCache;
            A !== null && A.delete(d), f.pingedLanes |= f.suspendedLanes & _, f.warmLanes &= ~_, Qn === f && (wn & _) === _ && (hi === 4 || hi === 3 && (wn & 62914560) === wn && 300 > Ta() - dr ? (Hn & 2) === 0 && Is(f, 0) : sd |= _, zo === wn && (zo = 0)), Ue(f)
         }

         function ru(f, d) {
            d === 0 && (d = O()), f = te(f, d), f !== null && (q(f, d), Ue(f))
         }

         function ml(f) {
            var d = f.memoizedState,
               _ = 0;
            d !== null && (_ = d.retryLane), ru(f, _)
         }

         function au(f, d) {
            var _ = 0;
            switch (f.tag) {
               case 13:
                  var A = f.stateNode,
                     D = f.memoizedState;
                  D !== null && (_ = D.retryLane);
                  break;
               case 19:
                  A = f.stateNode;
                  break;
               case 22:
                  A = f.stateNode._retryCache;
                  break;
               default:
                  throw Error(s(314))
            }
            A !== null && A.delete(d), ru(f, _)
         }

         function gl(f, d) {
            return $h(f, d)
         }

         function yv(f, d, _, A) {
            this.tag = f, this.key = _, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = d, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = A, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null
         }

         function Ih(f) {
            return f = f.prototype, !(!f || !f.isReactComponent)
         }

         function xa(f, d) {
            var _ = f.alternate;
            return _ === null ? (_ = t(f.tag, d, f.key, f.mode), _.elementType = f.elementType, _.type = f.type, _.stateNode = f.stateNode, _.alternate = f, f.alternate = _) : (_.pendingProps = d, _.type = f.type, _.flags = 0, _.subtreeFlags = 0, _.deletions = null), _.flags = f.flags & 31457280, _.childLanes = f.childLanes, _.lanes = f.lanes, _.child = f.child, _.memoizedProps = f.memoizedProps, _.memoizedState = f.memoizedState, _.updateQueue = f.updateQueue, d = f.dependencies, _.dependencies = d === null ? null : {
               lanes: d.lanes,
               firstContext: d.firstContext
            }, _.sibling = f.sibling, _.index = f.index, _.ref = f.ref, _.refCleanup = f.refCleanup, _
         }

         function Fh(f, d) {
            f.flags &= 31457282;
            var _ = f.alternate;
            return _ === null ? (f.childLanes = 0, f.lanes = d, f.child = null, f.subtreeFlags = 0, f.memoizedProps = null, f.memoizedState = null, f.updateQueue = null, f.dependencies = null, f.stateNode = null) : (f.childLanes = _.childLanes, f.lanes = _.lanes, f.child = _.child, f.subtreeFlags = 0, f.deletions = null, f.memoizedProps = _.memoizedProps, f.memoizedState = _.memoizedState, f.updateQueue = _.updateQueue, f.type = _.type, d = _.dependencies, f.dependencies = d === null ? null : {
               lanes: d.lanes,
               firstContext: d.firstContext
            }), f
         }

         function Ao(f, d, _, A, D, L) {
            var Y = 0;
            if (A = f, typeof f == "function") Ih(f) && (Y = 1);
            else if (typeof f == "string") Y = kr && ui ? Zh(f, _, os.current) ? 26 : Ro(f) ? 27 : 5 : kr ? Zh(f, _, os.current) ? 26 : 5 : ui && Ro(f) ? 27 : 5;
            else e: switch (f) {
               case ou:
                  return Oi(_.children, D, L, d);
               case kh:
                  Y = 8, D |= 24;
                  break;
               case zp:
                  return f = t(12, _, d, D | 2), f.elementType = zp, f.lanes = L, f;
               case Ip:
                  return f = t(13, _, d, D), f.elementType = Ip, f.lanes = L, f;
               case af:
                  return f = t(19, _, d, D), f.elementType = af, f.lanes = L, f;
               case Sv:
                  return Hh(_, D, L, d);
               default:
                  if (typeof f == "object" && f !== null) switch (f.$$typeof) {
                     case jh:
                     case Wa:
                        Y = 10;
                        break e;
                     case _v:
                        Y = 9;
                        break e;
                     case qh:
                        Y = 11;
                        break e;
                     case Fp:
                        Y = 14;
                        break e;
                     case Sa:
                        Y = 16, A = null;
                        break e
                  }
                  Y = 29, _ = Error(s(130, f === null ? "null" : typeof f, "")), A = null
            }
            return d = t(Y, _, d, D), d.elementType = f, d.type = A, d.lanes = L, d
         }

         function Oi(f, d, _, A) {
            return f = t(7, f, A, d), f.lanes = _, f
         }

         function Hh(f, d, _, A) {
            f = t(22, f, A, d), f.elementType = Sv, f.lanes = _;
            var D = {
               _visibility: 1,
               _pendingVisibility: 1,
               _pendingMarkers: null,
               _retryCache: null,
               _transitions: null,
               _current: null,
               detach: function () {
                  var L = D._current;
                  if (L === null) throw Error(s(456));
                  if ((D._pendingVisibility & 2) === 0) {
                     var Y = te(L, 2);
                     Y !== null && (D._pendingVisibility |= 2, _s(Y, L, 2))
                  }
               },
               attach: function () {
                  var L = D._current;
                  if (L === null) throw Error(s(456));
                  if ((D._pendingVisibility & 2) !== 0) {
                     var Y = te(L, 2);
                     Y !== null && (D._pendingVisibility &= -3, _s(Y, L, 2))
                  }
               }
            };
            return f.stateNode = D, f
         }

         function Pp(f, d, _) {
            return f = t(6, f, null, d), f.lanes = _, f
         }

         function xv(f, d, _) {
            return d = t(4, f.children !== null ? f.children : [], f.key, d), d.lanes = _, d.stateNode = {
               containerInfo: f.containerInfo,
               pendingChildren: null,
               implementation: f.implementation
            }, d
         }

         function aE(f, d, _, A, D, L, Y, re) {
            this.tag = 1, this.containerInfo = f, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = lu, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = P(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.finishedLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = P(0), this.hiddenUpdates = P(null), this.identifierPrefix = A, this.onUncaughtError = D, this.onCaughtError = L, this.onRecoverableError = Y, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = re, this.incompleteTransitions = new Map
         }

         function $x(f, d, _, A, D, L, Y, re, ve, He, tt, ft) {
            return f = new aE(f, d, _, Y, re, ve, He, ft), d = 1, L === !0 && (d |= 24), L = t(3, null, null, d), f.current = L, L.stateNode = f, d = Ql(), d.refCount++, f.pooledCache = d, d.refCount++, L.memoizedState = {
               element: A,
               isDehydrated: _,
               cache: d
            }, Ke(L), f
         }

         function Ji(f) {
            return f ? (f = du, f) : du
         }

         function Lp(f) {
            var d = f._reactInternals;
            if (d === void 0) throw typeof f.render == "function" ? Error(s(188)) : (f = Object.keys(f).join(","), Error(s(268, f)));
            return f = x(d), f = f !== null ? S(f) : null, f === null ? null : uf(f.stateNode)
         }

         function nf(f, d, _, A, D, L) {
            D = Ji(D), A.context === null ? A.context = D : A.pendingContext = D, A = xt(d), A.payload = {
               element: _
            }, L = L === void 0 ? null : L, L !== null && (A.callback = L), _ = mt(f, A, d), _ !== null && (_s(_, f, d), it(_, f, d))
         }

         function sf(f, d) {
            if (f = f.memoizedState, f !== null && f.dehydrated !== null) {
               var _ = f.retryLane;
               f.retryLane = _ !== 0 && _ < d ? _ : d
            }
         }

         function Vh(f, d) {
            sf(f, d), (f = f.alternate) && sf(f, d)
         }
         var rn = {},
            rf = Rg(),
            Gr = PB(),
            Bp = Object.assign,
            oE = Symbol.for("react.element"),
            Gh = Symbol.for("react.transitional.element"),
            _a = Symbol.for("react.portal"),
            ou = Symbol.for("react.fragment"),
            kh = Symbol.for("react.strict_mode"),
            zp = Symbol.for("react.profiler"),
            jh = Symbol.for("react.provider"),
            _v = Symbol.for("react.consumer"),
            Wa = Symbol.for("react.context"),
            qh = Symbol.for("react.forward_ref"),
            Ip = Symbol.for("react.suspense"),
            af = Symbol.for("react.suspense_list"),
            Fp = Symbol.for("react.memo"),
            Sa = Symbol.for("react.lazy"),
            Sv = Symbol.for("react.offscreen"),
            e_ = Symbol.for("react.memo_cache_sentinel"),
            vl = Symbol.iterator,
            bv = Symbol.for("react.client.reference"),
            Yt = rf.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,
            wo, yl, Zu = !1,
            of = Array.isArray,
            Tv = e.rendererVersion,
            Xh = e.rendererPackageName,
            lf = e.extraDevToolsConfig,
            uf = e.getPublicInstance,
            t_ = e.getRootHostContext,
            cf = e.getChildHostContext,
            Hp = e.prepareForCommit,
            n_ = e.resetAfterCommit,
            Ev = e.createInstance,
            Wh = e.appendInitialChild,
            xl = e.finalizeInitialChildren,
            an = e.shouldSetTextContent,
            ti = e.createTextInstance,
            $i = e.scheduleTimeout,
            Vp = e.cancelTimeout,
            lu = e.noTimeout,
            ur = e.isPrimaryRenderer;
         e.warnsIfNotActing;
         var as = e.supportsMutation,
            ba = e.supportsPersistence,
            Fs = e.supportsHydration,
            i_ = e.getInstanceFromNode;
         e.beforeActiveInstanceBlur, e.afterActiveInstanceBlur;
         var Gi = e.preparePortalMount;
         e.prepareScopeUpdate, e.getInstanceFromScope;
         var Ks = e.setCurrentUpdatePriority,
            _l = e.getCurrentUpdatePriority,
            s_ = e.resolveUpdatePriority;
         e.resolveEventType, e.resolveEventTimeStamp;
         var r_ = e.shouldAttemptEagerTransition,
            lE = e.detachDeletedInstance;
         e.requestPostPaintCallback;
         var Mv = e.maySuspendCommit,
            Gp = e.preloadInstance,
            Av = e.startSuspendingCommit,
            cr = e.suspendInstance,
            es = e.waitForCommitToBeReady,
            uu = e.NotPendingTransition,
            Ya = e.HostTransitionContext,
            kp = e.resetFormInstance;
         e.bindToConsole;
         var wv = e.supportsMicrotasks,
            Sl = e.scheduleMicrotask,
            cu = e.supportsTestSelectors,
            Rv = e.findFiberRoot,
            Cv = e.getBoundingRect,
            a_ = e.getTextContent,
            ff = e.isHiddenSubtree,
            o_ = e.matchAccessibilityRole,
            l_ = e.setFocusIfFocusable,
            u_ = e.setupIntersectionObserver,
            c_ = e.appendChild,
            Dv = e.appendChildToContainer,
            f_ = e.commitTextUpdate,
            uE = e.commitMount,
            h_ = e.commitUpdate,
            d_ = e.insertBefore,
            p_ = e.insertInContainerBefore,
            Nv = e.removeChild,
            m_ = e.removeChildFromContainer,
            Ov = e.resetTextContent,
            g_ = e.hideInstance,
            v_ = e.hideTextInstance,
            y_ = e.unhideInstance,
            cE = e.unhideTextInstance,
            x_ = e.clearContainer,
            hf = e.cloneInstance,
            Yh = e.createContainerChildSet,
            Uv = e.appendChildToContainerChildSet,
            jp = e.finalizeContainerChildren,
            df = e.replaceContainerChildren,
            Pv = e.cloneHiddenInstance,
            Lv = e.cloneHiddenTextInstance,
            qp = e.isSuspenseInstancePending,
            Xp = e.isSuspenseInstanceFallback,
            __ = e.getSuspenseInstanceFallbackErrorDetails,
            S_ = e.registerSuspenseInstanceRetry,
            Bv = e.canHydrateFormStateMarker,
            b_ = e.isFormStateMarkerMatching,
            zv = e.getNextHydratableSibling,
            Wp = e.getFirstHydratableChild,
            T_ = e.getFirstHydratableChildWithinContainer,
            E_ = e.getFirstHydratableChildWithinSuspenseInstance,
            fE = e.canHydrateInstance,
            Iv = e.canHydrateTextInstance,
            M_ = e.canHydrateSuspenseInstance,
            A_ = e.hydrateInstance,
            Fv = e.hydrateTextInstance,
            w_ = e.hydrateSuspenseInstance,
            R_ = e.getNextHydratableInstanceAfterSuspenseInstance,
            hE = e.commitHydratedContainer,
            dE = e.commitHydratedSuspenseInstance,
            C_ = e.clearSuspenseBoundary,
            Kh = e.clearSuspenseBoundaryFromContainer,
            Yp = e.shouldDeleteUnhydratedTailInstances;
         e.diffHydratedPropsForDevWarnings, e.diffHydratedTextForDevWarnings, e.describeHydratableInstanceForDevWarnings;
         var Kp = e.validateHydratableInstance,
            D_ = e.validateHydratableTextInstance,
            kr = e.supportsResources,
            Zh = e.isHostHoistableType,
            Zp = e.getHoistableRoot,
            Hv = e.getResource,
            N_ = e.acquireResource,
            Qu = e.releaseResource,
            Qh = e.hydrateHoistable,
            Jh = e.mountHoistable,
            pf = e.unmountHoistable,
            Qp = e.createHoistableInstance,
            O_ = e.prepareToCommitHoistables,
            U_ = e.mayResourceSuspendCommit,
            Ju = e.preloadResource,
            P_ = e.suspendResource,
            ui = e.supportsSingletons,
            Ka = e.resolveSingletonInstance,
            fu = e.clearSingleton,
            L_ = e.acquireSingletonInstance,
            hu = e.releaseSingletonInstance,
            Ro = e.isHostSingletonType,
            ki = [],
            bl = -1,
            du = {},
            fr = Math.clz32 ? Math.clz32 : C,
            B_ = Math.log,
            z_ = Math.LN2,
            Co = 128,
            $u = 4194304,
            $h = Gr.unstable_scheduleCallback,
            Jp = Gr.unstable_cancelCallback,
            I_ = Gr.unstable_shouldYield,
            $p = Gr.unstable_requestPaint,
            Ta = Gr.unstable_now,
            em = Gr.unstable_ImmediatePriority,
            F_ = Gr.unstable_UserBlockingPriority,
            tm = Gr.unstable_NormalPriority,
            pE = Gr.unstable_IdlePriority,
            H_ = Gr.log,
            Ss = Gr.unstable_setDisableYieldValue,
            ji = null,
            Er = null,
            Mr = typeof Object.is == "function" ? Object.is : J,
            Vv = new WeakMap,
            ec = [],
            tc = 0,
            nc = null,
            mf = 0,
            jr = [],
            qr = 0,
            pu = null,
            Za = 1,
            Qa = "",
            os = T(null),
            gf = T(null),
            Do = T(null),
            ic = T(null),
            Hs = null,
            Vs = null,
            Bn = !1,
            Ea = null,
            bs = !1,
            ed = Error(s(519)),
            Ma = [],
            sc = 0,
            Ja = 0,
            td = null,
            Tl = null,
            rc = !1,
            pi = !1,
            Gv = !1,
            vf = 0,
            yf = null,
            ac = 0,
            Xr = 0,
            oc = null,
            El = !1,
            lc = !1,
            No = Object.prototype.hasOwnProperty,
            xf = Error(s(460)),
            nd = Error(s(474)),
            id = {
               then: function () {}
            },
            mu = null,
            gu = null,
            vu = 0,
            yu = It(!0),
            Oo = It(!1),
            mi = T(null),
            _f = T(0),
            Wr = T(null),
            ci = null,
            ls = T(0),
            Ml = 0,
            fn = null,
            Ht = null,
            Fn = null,
            Aa = !1,
            uc = !1,
            xu = !1,
            nm = 0,
            cc = 0,
            Ts = null,
            $a = 0,
            im = function () {
               return {
                  lastEffect: null,
                  events: null,
                  stores: null,
                  memoCache: null
               }
            },
            Ui = {
               readContext: Ls,
               use: xe,
               useCallback: Ft,
               useContext: Ft,
               useEffect: Ft,
               useImperativeHandle: Ft,
               useLayoutEffect: Ft,
               useInsertionEffect: Ft,
               useMemo: Ft,
               useReducer: Ft,
               useRef: Ft,
               useState: Ft,
               useDebugValue: Ft,
               useDeferredValue: Ft,
               useTransition: Ft,
               useSyncExternalStore: Ft,
               useId: Ft
            };
         Ui.useCacheRefresh = Ft, Ui.useMemoCache = Ft, Ui.useHostTransitionStatus = Ft, Ui.useFormState = Ft, Ui.useActionState = Ft, Ui.useOptimistic = Ft;
         var _u = {
            readContext: Ls,
            use: xe,
            useCallback: function (f, d) {
               return X().memoizedState = [f, d === void 0 ? null : d], f
            },
            useContext: Ls,
            useEffect: pp,
            useImperativeHandle: function (f, d, _) {
               _ = _ != null ? _.concat([f]) : null, gh(4194308, 4, mp.bind(null, d, f), _)
            },
            useLayoutEffect: function (f, d) {
               return gh(4194308, 4, f, d)
            },
            useInsertionEffect: function (f, d) {
               gh(4, 2, f, d)
            },
            useMemo: function (f, d) {
               var _ = X();
               d = d === void 0 ? null : d;
               var A = f();
               if (xu) {
                  Z(!0);
                  try {
                     f()
                  } finally {
                     Z(!1)
                  }
               }
               return _.memoizedState = [A, d], A
            },
            useReducer: function (f, d, _) {
               var A = X();
               if (_ !== void 0) {
                  var D = _(d);
                  if (xu) {
                     Z(!0);
                     try {
                        _(d)
                     } finally {
                        Z(!1)
                     }
                  }
               } else D = d;
               return A.memoizedState = A.baseState = D, f = {
                  pending: null,
                  lanes: 0,
                  dispatch: null,
                  lastRenderedReducer: f,
                  lastRenderedState: D
               }, A.queue = f, f = f.dispatch = vp.bind(null, fn, f), [A.memoizedState, f]
            },
            useRef: function (f) {
               var d = X();
               return f = {
                  current: f
               }, d.memoizedState = f
            },
            useState: function (f) {
               f = Sn(f);
               var d = f.queue,
                  _ = Yg.bind(null, fn, d);
               return d.dispatch = _, [f.memoizedState, _]
            },
            useDebugValue: Xl,
            useDeferredValue: function (f, d) {
               var _ = X();
               return xh(_, f, d)
            },
            useTransition: function () {
               var f = Sn(!1);
               return f = Hc.bind(null, fn, f.queue, !0, !1), X().memoizedState = f, [!1, f]
            },
            useSyncExternalStore: function (f, d, _) {
               var A = fn,
                  D = X();
               if (Bn) {
                  if (_ === void 0) throw Error(s(407));
                  _ = _()
               } else {
                  if (_ = d(), Qn === null) throw Error(s(349));
                  (wn & 60) !== 0 || wt(A, d, _)
               }
               D.memoizedState = _;
               var L = {
                  value: _,
                  getSnapshot: d
               };
               return D.queue = L, pp(Wt.bind(null, A, L, f), [f]), A.flags |= 2048, rr(9, Tt.bind(null, A, L, _, d), {
                  destroy: void 0
               }, null), _
            },
            useId: function () {
               var f = X(),
                  d = Qn.identifierPrefix;
               if (Bn) {
                  var _ = Qa,
                     A = Za;
                  _ = (A & ~(1 << 32 - fr(A) - 1)).toString(32) + _, d = ":" + d + "R" + _, _ = nm++, 0 < _ && (d += "H" + _.toString(32)), d += ":"
               } else _ = $a++, d = ":" + d + "r" + _.toString(32) + ":";
               return f.memoizedState = d
            },
            useCacheRefresh: function () {
               return X().memoizedState = Wg.bind(null, fn)
            }
         };
         _u.useMemoCache = de, _u.useHostTransitionStatus = _h, _u.useFormState = si, _u.useActionState = si, _u.useOptimistic = function (f) {
            var d = X();
            d.memoizedState = d.baseState = f;
            var _ = {
               pending: null,
               lanes: 0,
               dispatch: null,
               lastRenderedReducer: null,
               lastRenderedState: null
            };
            return d.queue = _, d = Gc.bind(null, fn, !0, _), _.dispatch = d, [f, d]
         };
         var hr = {
            readContext: Ls,
            use: xe,
            useCallback: Xu,
            useContext: Ls,
            useEffect: jg,
            useImperativeHandle: gp,
            useInsertionEffect: Ox,
            useLayoutEffect: yh,
            useMemo: qg,
            useReducer: st,
            useRef: bo,
            useState: function () {
               return st(je)
            },
            useDebugValue: Xl,
            useDeferredValue: function (f, d) {
               var _ = ue();
               return Xg(_, Ht.memoizedState, f, d)
            },
            useTransition: function () {
               var f = st(je)[0],
                  d = ue().memoizedState;
               return [typeof f == "boolean" ? f : Te(f), d]
            },
            useSyncExternalStore: At,
            useId: Vc
         };
         hr.useCacheRefresh = rl, hr.useMemoCache = de, hr.useHostTransitionStatus = _h, hr.useFormState = Us, hr.useActionState = Us, hr.useOptimistic = function (f, d) {
            var _ = ue();
            return An(_, Ht, f, d)
         };
         var Yr = {
            readContext: Ls,
            use: xe,
            useCallback: Xu,
            useContext: Ls,
            useEffect: jg,
            useImperativeHandle: gp,
            useInsertionEffect: Ox,
            useLayoutEffect: yh,
            useMemo: qg,
            useReducer: ct,
            useRef: bo,
            useState: function () {
               return ct(je)
            },
            useDebugValue: Xl,
            useDeferredValue: function (f, d) {
               var _ = ue();
               return Ht === null ? xh(_, f, d) : Xg(_, Ht.memoizedState, f, d)
            },
            useTransition: function () {
               var f = ct(je)[0],
                  d = ue().memoizedState;
               return [typeof f == "boolean" ? f : Te(f), d]
            },
            useSyncExternalStore: At,
            useId: Vc
         };
         Yr.useCacheRefresh = rl, Yr.useMemoCache = de, Yr.useHostTransitionStatus = _h, Yr.useFormState = ys, Yr.useActionState = ys, Yr.useOptimistic = function (f, d) {
            var _ = ue();
            return Ht !== null ? An(_, Ht, f, d) : (_.baseState = f, [f, _.queue.dispatch])
         };
         var Uo = {
               isMounted: function (f) {
                  return (f = f._reactInternals) ? g(f) === f : !1
               },
               enqueueSetState: function (f, d, _) {
                  f = f._reactInternals;
                  var A = Vi(),
                     D = xt(A);
                  D.payload = d, _ != null && (D.callback = _), d = mt(f, D, A), d !== null && (_s(d, f, A), it(d, f, A))
               },
               enqueueReplaceState: function (f, d, _) {
                  f = f._reactInternals;
                  var A = Vi(),
                     D = xt(A);
                  D.tag = 1, D.payload = d, _ != null && (D.callback = _), d = mt(f, D, A), d !== null && (_s(d, f, A), it(d, f, A))
               },
               enqueueForceUpdate: function (f, d) {
                  f = f._reactInternals;
                  var _ = Vi(),
                     A = xt(_);
                  A.tag = 2, d != null && (A.callback = d), d = mt(f, A, _), d !== null && (_s(d, f, _), it(d, f, _))
               }
            },
            sm = typeof reportError == "function" ? reportError : function (f) {
               if (typeof window == "object" && typeof window.ErrorEvent == "function") {
                  var d = new window.ErrorEvent("error", {
                     bubbles: !0,
                     cancelable: !0,
                     message: typeof f == "object" && f !== null && typeof f.message == "string" ? String(f.message) : String(f),
                     error: f
                  });
                  if (!window.dispatchEvent(d)) return
               } else if (typeof process == "object" && typeof process.emit == "function") {
                  process.emit("uncaughtException", f);
                  return
               }
               console.error(f)
            },
            rm = Error(s(461)),
            fi = !1,
            am = {
               dehydrated: null,
               treeContext: null,
               retryLane: 0
            },
            Al = T(null),
            eo = null,
            Kr = null,
            Sf = typeof AbortController < "u" ? AbortController : function () {
               var f = [],
                  d = this.signal = {
                     aborted: !1,
                     addEventListener: function (_, A) {
                        f.push(A)
                     }
                  };
               this.abort = function () {
                  d.aborted = !0, f.forEach(function (_) {
                     return _()
                  })
               }
            },
            V_ = Gr.unstable_scheduleCallback,
            G_ = Gr.unstable_NormalPriority,
            gi = {
               $$typeof: Wa,
               Consumer: null,
               Provider: null,
               _currentValue: null,
               _currentValue2: null,
               _threadCount: 0
            },
            kv = Yt.S;
         Yt.S = function (f, d) {
            typeof d == "object" && d !== null && typeof d.then == "function" && We(f, d), kv !== null && kv(f, d)
         };
         var Po = T(null),
            Lo = !1,
            Pi = !1,
            jv = !1,
            Zn = typeof WeakSet == "function" ? WeakSet : Set,
            en = null,
            xn = !1,
            Lt = null,
            ln = !1,
            Di = null,
            Zr = 8192,
            bf = {
               getCacheForType: function (f) {
                  var d = Ls(gi),
                     _ = d.data.get(f);
                  return _ === void 0 && (_ = f(), d.data.set(f, _)), _
               }
            },
            Tf = 0,
            wa = 1,
            xi = 2,
            to = 3,
            Bo = 4;
         if (typeof Symbol == "function" && Symbol.for) {
            var fc = Symbol.for;
            Tf = fc("selector.component"), wa = fc("selector.has_pseudo_class"), xi = fc("selector.role"), to = fc("selector.test_id"), Bo = fc("selector.text")
         }
         var Ra = typeof WeakMap == "function" ? WeakMap : Map,
            Hn = 0,
            Qn = null,
            Vt = null,
            wn = 0,
            ri = 0,
            Zs = null,
            Ca = !1,
            Qr = !1,
            us = !1,
            Qs = 0,
            hi = 0,
            Jr = 0,
            wl = 0,
            sd = 0,
            $r = 0,
            zo = 0,
            hc = null,
            Li = null,
            om = !1,
            dr = 0,
            Ef = 1 / 0,
            rd = null,
            Su = null,
            no = !1,
            Io = null,
            dc = 0,
            bu = 0,
            lm = null,
            Mf = 0,
            um = null;
         return rn.attemptContinuousHydration = function (f) {
            if (f.tag === 13) {
               var d = te(f, 67108864);
               d !== null && _s(d, f, 67108864), Vh(f, 67108864)
            }
         }, rn.attemptHydrationAtCurrentPriority = function (f) {
            if (f.tag === 13) {
               var d = Vi(),
                  _ = te(f, d);
               _ !== null && _s(_, f, d), Vh(f, d)
            }
         }, rn.attemptSynchronousHydration = function (f) {
            switch (f.tag) {
               case 3:
                  if (f = f.stateNode, f.current.memoizedState.isDehydrated) {
                     var d = N(f.pendingLanes);
                     if (d !== 0) {
                        for (f.pendingLanes |= 2, f.entangledLanes |= 2; d;) {
                           var _ = 1 << 31 - fr(d);
                           f.entanglements[1] |= _, d &= ~_
                        }
                        Ue(f), (Hn & 6) === 0 && (Ef = Ta() + 500, K(0))
                     }
                  }
                  break;
               case 13:
                  d = te(f, 2), d !== null && _s(d, f, 2), zh(), Vh(f, 2)
            }
         }, rn.batchedUpdates = function (f, d) {
            return f(d)
         }, rn.createComponentSelector = function (f) {
            return {
               $$typeof: Tf,
               value: f
            }
         }, rn.createContainer = function (f, d, _, A, D, L, Y, re, ve, He) {
            return $x(f, d, !1, null, _, A, L, Y, re, ve, He, null)
         }, rn.createHasPseudoClassSelector = function (f) {
            return {
               $$typeof: wa,
               value: f
            }
         }, rn.createHydrationContainer = function (f, d, _, A, D, L, Y, re, ve, He, tt, ft, pt) {
            return f = $x(_, A, !0, f, D, L, re, ve, He, tt, ft, pt), f.context = Ji(null), _ = f.current, A = Vi(), D = xt(A), D.callback = d ?? null, mt(_, D, A), f.current.lanes = A, q(f, A), Ue(f), f
         }, rn.createPortal = function (f, d, _) {
            var A = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
            return {
               $$typeof: _a,
               key: A == null ? null : "" + A,
               children: f,
               containerInfo: d,
               implementation: _
            }
         }, rn.createRoleSelector = function (f) {
            return {
               $$typeof: xi,
               value: f
            }
         }, rn.createTestNameSelector = function (f) {
            return {
               $$typeof: to,
               value: f
            }
         }, rn.createTextSelector = function (f) {
            return {
               $$typeof: Bo,
               value: f
            }
         }, rn.defaultOnCaughtError = function (f) {
            console.error(f)
         }, rn.defaultOnRecoverableError = function (f) {
            sm(f)
         }, rn.defaultOnUncaughtError = function (f) {
            sm(f)
         }, rn.deferredUpdates = function (f) {
            var d = Yt.T,
               _ = _l();
            try {
               return Ks(32), Yt.T = null, f()
            } finally {
               Ks(_), Yt.T = d
            }
         }, rn.discreteUpdates = function (f, d, _, A, D) {
            var L = Yt.T,
               Y = _l();
            try {
               return Ks(2), Yt.T = null, f(d, _, A, D)
            } finally {
               Ks(Y), Yt.T = L, Hn === 0 && (Ef = Ta() + 500)
            }
         }, rn.findAllNodes = Lh, rn.findBoundingRects = function (f, d) {
            if (!cu) throw Error(s(363));
            d = Lh(f, d), f = [];
            for (var _ = 0; _ < d.length; _++) f.push(Cv(d[_]));
            for (d = f.length - 1; 0 < d; d--) {
               _ = f[d];
               for (var A = _.x, D = A + _.width, L = _.y, Y = L + _.height, re = d - 1; 0 <= re; re--)
                  if (d !== re) {
                     var ve = f[re],
                        He = ve.x,
                        tt = He + ve.width,
                        ft = ve.y,
                        pt = ft + ve.height;
                     if (A >= He && L >= ft && D <= tt && Y <= pt) {
                        f.splice(d, 1);
                        break
                     } else if (A !== He || _.width !== ve.width || pt < L || ft > Y) {
                        if (!(L !== ft || _.height !== ve.height || tt < A || He > D)) {
                           He > A && (ve.width += He - A, ve.x = A), tt < D && (ve.width = D - He), f.splice(d, 1);
                           break
                        }
                     } else {
                        ft > L && (ve.height += ft - L, ve.y = L), pt < Y && (ve.height = Y - ft), f.splice(d, 1);
                        break
                     }
                  }
            }
            return f
         }, rn.findHostInstance = Lp, rn.findHostInstanceWithNoPortals = function (f) {
            return f = x(f), f = f !== null ? E(f) : null, f === null ? null : uf(f.stateNode)
         }, rn.findHostInstanceWithWarning = function (f) {
            return Lp(f)
         }, rn.flushPassiveEffects = Xa, rn.flushSyncFromReconciler = function (f) {
            var d = Hn;
            Hn |= 1;
            var _ = Yt.T,
               A = _l();
            try {
               if (Ks(2), Yt.T = null, f) return f()
            } finally {
               Ks(A), Yt.T = _, Hn = d, (Hn & 6) === 0 && K(0)
            }
         }, rn.flushSyncWork = zh, rn.focusWithin = function (f, d) {
            if (!cu) throw Error(s(363));
            for (f = Jc(f), d = br(f, d), d = Array.from(d), f = 0; f < d.length;) {
               var _ = d[f++],
                  A = _.tag;
               if (!ff(_)) {
                  if ((A === 5 || A === 26 || A === 27) && l_(_.stateNode)) return !0;
                  for (_ = _.child; _ !== null;) d.push(_), _ = _.sibling
               }
            }
            return !1
         }, rn.getFindAllNodesFailureDescription = function (f, d) {
            if (!cu) throw Error(s(363));
            var _ = 0,
               A = [];
            f = [Jc(f), 0];
            for (var D = 0; D < f.length;) {
               var L = f[D++],
                  Y = L.tag,
                  re = f[D++],
                  ve = d[re];
               if ((Y !== 5 && Y !== 26 && Y !== 27 || !ff(L)) && (tu(L, ve) && (A.push(hv(ve)), re++, re > _ && (_ = re)), re < d.length))
                  for (L = L.child; L !== null;) f.push(L, re), L = L.sibling
            }
            if (_ < d.length) {
               for (f = []; _ < d.length; _++) f.push(hv(d[_]));
               return `findAllNodes was able to match part of the selector:
  ` + (A.join(" > ") + `

No matching component was found for:
  `) + f.join(" > ")
            }
            return null
         }, rn.getPublicRootInstance = function (f) {
            if (f = f.current, !f.child) return null;
            switch (f.child.tag) {
               case 27:
               case 5:
                  return uf(f.child.stateNode);
               default:
                  return f.child.stateNode
            }
         }, rn.injectIntoDevTools = function () {
            var f = {
               bundleType: 0,
               version: Tv,
               rendererPackageName: Xh,
               currentDispatcherRef: Yt,
               findFiberByHostInstance: i_,
               reconcilerVersion: "19.0.0"
            };
            if (lf !== null && (f.rendererConfig = lf), typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u") f = !1;
            else {
               var d = __REACT_DEVTOOLS_GLOBAL_HOOK__;
               if (d.isDisabled || !d.supportsFiber) f = !0;
               else {
                  try {
                     ji = d.inject(f), Er = d
                  } catch {}
                  f = !!d.checkDCE
               }
            }
            return f
         }, rn.isAlreadyRendering = function () {
            return !1
         }, rn.observeVisibleRects = function (f, d, _, A) {
            if (!cu) throw Error(s(363));
            f = Lh(f, d);
            var D = u_(f, _, A).disconnect;
            return {
               disconnect: function () {
                  D()
               }
            }
         }, rn.shouldError = function () {
            return null
         }, rn.shouldSuspend = function () {
            return !1
         }, rn.startHostTransition = function (f, d, _, A) {
            if (f.tag !== 5) throw Error(s(476));
            var D = To(f).queue;
            Hc(f, D, d, uu, _ === null ? i : function () {
               var L = To(f).next.queue;
               return Wl(f, L, {}, Vi()), _(A)
            })
         }, rn.updateContainer = function (f, d, _, A) {
            var D = d.current,
               L = Vi();
            return nf(D, L, f, d, _, A), L
         }, rn.updateContainerSync = function (f, d, _, A) {
            return d.tag === 0 && Xa(), nf(d.current, 2, f, d, _, A), 2
         }, rn
      }, n.exports.default = n.exports, Object.defineProperty(n.exports, "__esModule", {
         value: !0
      })
   }(VM)), VM.exports
}
var cN;

function Qq() {
   return cN || (cN = 1, HM.exports = Zq()), HM.exports
}
var Jq = Qq();
const $q = lx(Jq);
var fN = PB();
const eX = n => typeof n == "object" && typeof n.then == "function",
   Ud = [];

function LB(n, e, t = (i, s) => i === s) {
   if (n === e) return !0;
   if (!n || !e) return !1;
   const i = n.length;
   if (e.length !== i) return !1;
   for (let s = 0; s < i; s++)
      if (!t(n[s], e[s])) return !1;
   return !0
}

function BB(n, e = null, t = !1, i = {}) {
   e === null && (e = [n]);
   for (const r of Ud)
      if (LB(e, r.keys, r.equal)) {
         if (t) return;
         if (Object.prototype.hasOwnProperty.call(r, "error")) throw r.error;
         if (Object.prototype.hasOwnProperty.call(r, "response")) return i.lifespan && i.lifespan > 0 && (r.timeout && clearTimeout(r.timeout), r.timeout = setTimeout(r.remove, i.lifespan)), r.response;
         if (!t) throw r.promise
      } const s = {
      keys: e,
      equal: i.equal,
      remove: () => {
         const r = Ud.indexOf(s);
         r !== -1 && Ud.splice(r, 1)
      },
      promise: (eX(n) ? n : n(...e)).then(r => {
         s.response = r, i.lifespan && i.lifespan > 0 && (s.timeout = setTimeout(s.remove, i.lifespan))
      }).catch(r => s.error = r)
   };
   if (Ud.push(s), !t) throw s.promise
}
const tX = (n, e, t) => BB(n, e, !1, t),
   nX = (n, e, t) => void BB(n, e, !0, t),
   iX = n => {
      if (n === void 0 || n.length === 0) Ud.splice(0, Ud.length);
      else {
         const e = Ud.find(t => LB(n, t.keys, t.equal));
         e && e.remove()
      }
   };

function s2(n, e, t) {
   if (!n) return;
   if (t(n) === !0) return n;
   let i = e ? n.return : n.child;
   for (; i;) {
      const s = s2(i, e, t);
      if (s) return s;
      i = e ? null : i.sibling
   }
}

function zB(n) {
   try {
      return Object.defineProperties(n, {
         _currentRenderer: {
            get() {
               return null
            },
            set() {}
         },
         _currentRenderer2: {
            get() {
               return null
            },
            set() {}
         }
      })
   } catch {
      return n
   }
}
const r2 = zB(j.createContext(null));
let IB = class extends j.Component {
   render() {
      return j.createElement(r2.Provider, {
         value: this._reactInternals
      }, this.props.children)
   }
};

function FB() {
   const n = j.useContext(r2);
   if (n === null) throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");
   const e = j.useId();
   return j.useMemo(() => {
      for (const t of [n, n == null ? void 0 : n.alternate]) {
         if (!t) continue;
         const i = s2(t, !1, s => {
            let r = s.memoizedState;
            for (; r;) {
               if (r.memoizedState === e) return !0;
               r = r.next
            }
         });
         if (i) return i
      }
   }, [n, e])
}
const sX = Symbol.for("react.context"),
   rX = n => n !== null && typeof n == "object" && "$$typeof" in n && n.$$typeof === sX;

function aX() {
   const n = FB(),
      [e] = j.useState(() => new Map);
   e.clear();
   let t = n;
   for (; t;) {
      const i = t.type;
      rX(i) && i !== r2 && !e.has(i) && e.set(i, j.use(zB(i))), t = t.return
   }
   return e
}

function oX() {
   const n = aX();
   return j.useMemo(() => Array.from(n.keys()).reduce((e, t) => i => j.createElement(e, null, j.createElement(t.Provider, {
      ...i,
      value: n.get(t)
   })), e => j.createElement(IB, {
      ...e
   })), [n])
}

function HB(n) {
   let e = n.root;
   for (; e.getState().previousRoot;) e = e.getState().previousRoot;
   return e
}
const VB = n => n && n.isOrthographicCamera,
   lX = n => n && n.hasOwnProperty("current"),
   uX = n => n != null && (typeof n == "string" || typeof n == "number" || n.isColor),
   Tx = ((n, e) => typeof window < "u" && (((n = window.document) == null ? void 0 : n.createElement) || ((e = window.navigator) == null ? void 0 : e.product) === "ReactNative"))() ? j.useLayoutEffect : j.useEffect;

function GB(n) {
   const e = j.useRef(n);
   return Tx(() => void(e.current = n), [n]), e
}

function cX() {
   const n = FB(),
      e = oX();
   return j.useMemo(() => ({
      children: t
   }) => {
      const s = !!s2(n, !0, r => r.type === j.StrictMode) ? j.StrictMode : j.Fragment;
      return H.jsx(s, {
         children: H.jsx(e, {
            children: t
         })
      })
   }, [n, e])
}

function fX({
   set: n
}) {
   return Tx(() => (n(new Promise(() => null)), () => n(!1)), [n]), null
}
const hX = (n => (n = class extends j.Component {
   constructor(...t) {
      super(...t), this.state = {
         error: !1
      }
   }
   componentDidCatch(t) {
      this.props.set(t)
   }
   render() {
      return this.state.error ? null : this.props.children
   }
}, n.getDerivedStateFromError = () => ({
   error: !0
}), n))();

function kB(n) {
   var e;
   const t = typeof window < "u" ? (e = window.devicePixelRatio) != null ? e : 2 : 1;
   return Array.isArray(n) ? Math.min(Math.max(n[0], t), n[1]) : n
}

function Um(n) {
   var e;
   return (e = n.__r3f) == null ? void 0 : e.root.getState()
}
const Bi = {
   obj: n => n === Object(n) && !Bi.arr(n) && typeof n != "function",
   fun: n => typeof n == "function",
   str: n => typeof n == "string",
   num: n => typeof n == "number",
   boo: n => typeof n == "boolean",
   und: n => n === void 0,
   nul: n => n === null,
   arr: n => Array.isArray(n),
   equ(n, e, {
      arrays: t = "shallow",
      objects: i = "reference",
      strict: s = !0
   } = {}) {
      if (typeof n != typeof e || !!n != !!e) return !1;
      if (Bi.str(n) || Bi.num(n) || Bi.boo(n)) return n === e;
      const r = Bi.obj(n);
      if (r && i === "reference") return n === e;
      const a = Bi.arr(n);
      if (a && t === "reference") return n === e;
      if ((a || r) && n === e) return !0;
      let l;
      for (l in n)
         if (!(l in e)) return !1;
      if (r && t === "shallow" && i === "shallow") {
         for (l in s ? e : n)
            if (!Bi.equ(n[l], e[l], {
                  strict: s,
                  objects: "reference"
               })) return !1
      } else
         for (l in s ? e : n)
            if (n[l] !== e[l]) return !1;
      if (Bi.und(l)) {
         if (a && n.length === 0 && e.length === 0 || r && Object.keys(n).length === 0 && Object.keys(e).length === 0) return !0;
         if (n !== e) return !1
      }
      return !0
   }
};

function dX(n) {
   const e = {
      nodes: {},
      materials: {},
      meshes: {}
   };
   return n && n.traverse(t => {
      t.name && (e.nodes[t.name] = t), t.material && !e.materials[t.material.name] && (e.materials[t.material.name] = t.material), t.isMesh && !e.meshes[t.name] && (e.meshes[t.name] = t)
   }), e
}

function pX(n) {
   n.type !== "Scene" && (n.dispose == null || n.dispose());
   for (const e in n) {
      const t = n[e];
      (t == null ? void 0 : t.type) !== "Scene" && (t == null || t.dispose == null || t.dispose())
   }
}
const jB = ["children", "key", "ref"];

function mX(n) {
   const e = {};
   for (const t in n) jB.includes(t) || (e[t] = n[t]);
   return e
}

function T1(n, e, t, i) {
   const s = n;
   let r = s == null ? void 0 : s.__r3f;
   return r || (r = {
      root: e,
      type: t,
      parent: null,
      children: [],
      props: mX(i),
      object: s,
      eventCount: 0,
      handlers: {},
      isHidden: !1
   }, s && (s.__r3f = r)), r
}

function Vy(n, e) {
   let t = n[e];
   if (!e.includes("-")) return {
      root: n,
      key: e,
      target: t
   };
   t = n;
   for (const s of e.split("-")) {
      var i;
      e = s, n = t, t = (i = t) == null ? void 0 : i[e]
   }
   return {
      root: n,
      key: e,
      target: t
   }
}
const hN = /-\d+$/;

function E1(n, e) {
   if (Bi.str(e.props.attach)) {
      if (hN.test(e.props.attach)) {
         const s = e.props.attach.replace(hN, ""),
            {
               root: r,
               key: a
            } = Vy(n.object, s);
         Array.isArray(r[a]) || (r[a] = [])
      }
      const {
         root: t,
         key: i
      } = Vy(n.object, e.props.attach);
      e.previousAttach = t[i], t[i] = e.object
   } else Bi.fun(e.props.attach) && (e.previousAttach = e.props.attach(n.object, e.object))
}

function M1(n, e) {
   if (Bi.str(e.props.attach)) {
      const {
         root: t,
         key: i
      } = Vy(n.object, e.props.attach), s = e.previousAttach;
      s === void 0 ? delete t[i] : t[i] = s
   } else e.previousAttach == null || e.previousAttach(n.object, e.object);
   delete e.previousAttach
}
const nw = [...jB, "args", "dispose", "attach", "object", "onUpdate", "dispose"],
   dN = new Map;

function gX(n) {
   let e = dN.get(n.constructor);
   try {
      e || (e = new n.constructor, dN.set(n.constructor, e))
   } catch {}
   return e
}

function vX(n, e) {
   const t = {};
   for (const i in e)
      if (!nw.includes(i) && !Bi.equ(e[i], n.props[i])) {
         t[i] = e[i];
         for (const s in e) s.startsWith(`${i}-`) && (t[s] = e[s])
      } for (const i in n.props) {
      if (nw.includes(i) || e.hasOwnProperty(i)) continue;
      const {
         root: s,
         key: r
      } = Vy(n.object, i);
      if (s.constructor && s.constructor.length === 0) {
         const a = gX(s);
         Bi.und(a) || (t[r] = a[r])
      } else t[r] = 0
   }
   return t
}
const yX = ["map", "emissiveMap", "sheenColorMap", "specularColorMap", "envMap"],
   xX = /^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/;

function qf(n, e) {
   var t;
   const i = n.__r3f,
      s = i && HB(i).getState(),
      r = i == null ? void 0 : i.eventCount;
   for (const l in e) {
      let c = e[l];
      if (nw.includes(l)) continue;
      if (i && xX.test(l)) {
         typeof c == "function" ? i.handlers[l] = c : delete i.handlers[l], i.eventCount = Object.keys(i.handlers).length;
         continue
      }
      if (c === void 0) continue;
      let {
         root: h,
         key: m,
         target: g
      } = Vy(n, l);
      if (g instanceof dg && c instanceof dg) g.mask = c.mask;
      else if (g instanceof dt && uX(c)) g.set(c);
      else if (g !== null && typeof g == "object" && typeof g.set == "function" && typeof g.copy == "function" && c != null && c.constructor && g.constructor === c.constructor) g.copy(c);
      else if (g !== null && typeof g == "object" && typeof g.set == "function" && Array.isArray(c)) typeof g.fromArray == "function" ? g.fromArray(c) : g.set(...c);
      else if (g !== null && typeof g == "object" && typeof g.set == "function" && typeof c == "number") typeof g.setScalar == "function" ? g.setScalar(c) : g.set(c);
      else {
         var a;
         h[m] = c, s && !s.linear && yX.includes(m) && (a = h[m]) != null && a.isTexture && h[m].format === Lr && h[m].type === qs && (h[m].colorSpace = En)
      }
   }
   if (i != null && i.parent && s != null && s.internal && (t = i.object) != null && t.isObject3D && r !== i.eventCount) {
      const l = i.object,
         c = s.internal.interaction.indexOf(l);
      c > -1 && s.internal.interaction.splice(c, 1), i.eventCount && l.raycast !== null && s.internal.interaction.push(l)
   }
   return i && i.props.attach === void 0 && (i.object.isBufferGeometry ? i.props.attach = "geometry" : i.object.isMaterial && (i.props.attach = "material")), i && Ig(i), n
}

function Ig(n) {
   var e;
   if (!n.parent) return;
   n.props.onUpdate == null || n.props.onUpdate(n.object);
   const t = (e = n.root) == null || e.getState == null ? void 0 : e.getState();
   t && t.internal.frames === 0 && t.invalidate()
}

function _X(n, e) {
   n.manual || (VB(n) ? (n.left = e.width / -2, n.right = e.width / 2, n.top = e.height / 2, n.bottom = e.height / -2) : n.aspect = e.width / e.height, n.updateProjectionMatrix())
}
const la = n => n == null ? void 0 : n.isObject3D;

function QS(n) {
   return (n.eventObject || n.object).uuid + "/" + n.index + n.instanceId
}

function qB(n, e, t, i) {
   const s = t.get(e);
   s && (t.delete(e), t.size === 0 && (n.delete(i), s.target.releasePointerCapture(i)))
}

function SX(n, e) {
   const {
      internal: t
   } = n.getState();
   t.interaction = t.interaction.filter(i => i !== e), t.initialHits = t.initialHits.filter(i => i !== e), t.hovered.forEach((i, s) => {
      (i.eventObject === e || i.object === e) && t.hovered.delete(s)
   }), t.capturedMap.forEach((i, s) => {
      qB(t.capturedMap, e, i, s)
   })
}

function bX(n) {
   function e(c) {
      const {
         internal: h
      } = n.getState(), m = c.offsetX - h.initialClick[0], g = c.offsetY - h.initialClick[1];
      return Math.round(Math.sqrt(m * m + g * g))
   }

   function t(c) {
      return c.filter(h => ["Move", "Over", "Enter", "Out", "Leave"].some(m => {
         var g;
         return (g = h.__r3f) == null ? void 0 : g.handlers["onPointer" + m]
      }))
   }

   function i(c, h) {
      const m = n.getState(),
         g = new Set,
         v = [],
         x = h ? h(m.internal.interaction) : m.internal.interaction;
      for (let b = 0; b < x.length; b++) {
         const w = Um(x[b]);
         w && (w.raycaster.camera = void 0)
      }
      m.previousRoot || m.events.compute == null || m.events.compute(c, m);

      function S(b) {
         const w = Um(b);
         if (!w || !w.events.enabled || w.raycaster.camera === null) return [];
         if (w.raycaster.camera === void 0) {
            var C;
            w.events.compute == null || w.events.compute(c, w, (C = w.previousRoot) == null ? void 0 : C.getState()), w.raycaster.camera === void 0 && (w.raycaster.camera = null)
         }
         return w.raycaster.camera ? w.raycaster.intersectObject(b, !0) : []
      }
      let E = x.flatMap(S).sort((b, w) => {
         const C = Um(b.object),
            N = Um(w.object);
         return !C || !N ? b.distance - w.distance : N.events.priority - C.events.priority || b.distance - w.distance
      }).filter(b => {
         const w = QS(b);
         return g.has(w) ? !1 : (g.add(w), !0)
      });
      m.events.filter && (E = m.events.filter(E, m));
      for (const b of E) {
         let w = b.object;
         for (; w;) {
            var T;
            (T = w.__r3f) != null && T.eventCount && v.push({
               ...b,
               eventObject: w
            }), w = w.parent
         }
      }
      if ("pointerId" in c && m.internal.capturedMap.has(c.pointerId))
         for (let b of m.internal.capturedMap.get(c.pointerId).values()) g.has(QS(b.intersection)) || v.push(b.intersection);
      return v
   }

   function s(c, h, m, g) {
      if (c.length) {
         const v = {
            stopped: !1
         };
         for (const x of c) {
            let S = Um(x.object);
            if (S || x.object.traverseAncestors(E => {
                  const T = Um(E);
                  if (T) return S = T, !1
               }), S) {
               const {
                  raycaster: E,
                  pointer: T,
                  camera: b,
                  internal: w
               } = S, C = new ee(T.x, T.y, 0).unproject(b), N = O => {
                  var P, q;
                  return (P = (q = w.capturedMap.get(O)) == null ? void 0 : q.has(x.eventObject)) != null ? P : !1
               }, U = O => {
                  const P = {
                     intersection: x,
                     target: h.target
                  };
                  w.capturedMap.has(O) ? w.capturedMap.get(O).set(x.eventObject, P) : w.capturedMap.set(O, new Map([
                     [x.eventObject, P]
                  ])), h.target.setPointerCapture(O)
               }, z = O => {
                  const P = w.capturedMap.get(O);
                  P && qB(w.capturedMap, x.eventObject, P, O)
               };
               let B = {};
               for (let O in h) {
                  let P = h[O];
                  typeof P != "function" && (B[O] = P)
               }
               let I = {
                  ...x,
                  ...B,
                  pointer: T,
                  intersections: c,
                  stopped: v.stopped,
                  delta: m,
                  unprojectedPoint: C,
                  ray: E.ray,
                  camera: b,
                  stopPropagation() {
                     const O = "pointerId" in h && w.capturedMap.get(h.pointerId);
                     if ((!O || O.has(x.eventObject)) && (I.stopped = v.stopped = !0, w.hovered.size && Array.from(w.hovered.values()).find(P => P.eventObject === x.eventObject))) {
                        const P = c.slice(0, c.indexOf(x));
                        r([...P, x])
                     }
                  },
                  target: {
                     hasPointerCapture: N,
                     setPointerCapture: U,
                     releasePointerCapture: z
                  },
                  currentTarget: {
                     hasPointerCapture: N,
                     setPointerCapture: U,
                     releasePointerCapture: z
                  },
                  nativeEvent: h
               };
               if (g(I), v.stopped === !0) break
            }
         }
      }
      return c
   }

   function r(c) {
      const {
         internal: h
      } = n.getState();
      for (const m of h.hovered.values())
         if (!c.length || !c.find(g => g.object === m.object && g.index === m.index && g.instanceId === m.instanceId)) {
            const v = m.eventObject.__r3f;
            if (h.hovered.delete(QS(m)), v != null && v.eventCount) {
               const x = v.handlers,
                  S = {
                     ...m,
                     intersections: c
                  };
               x.onPointerOut == null || x.onPointerOut(S), x.onPointerLeave == null || x.onPointerLeave(S)
            }
         }
   }

   function a(c, h) {
      for (let m = 0; m < h.length; m++) {
         const g = h[m].__r3f;
         g == null || g.handlers.onPointerMissed == null || g.handlers.onPointerMissed(c)
      }
   }

   function l(c) {
      switch (c) {
         case "onPointerLeave":
         case "onPointerCancel":
            return () => r([]);
         case "onLostPointerCapture":
            return h => {
               const {
                  internal: m
               } = n.getState();
               "pointerId" in h && m.capturedMap.has(h.pointerId) && requestAnimationFrame(() => {
                  m.capturedMap.has(h.pointerId) && (m.capturedMap.delete(h.pointerId), r([]))
               })
            }
      }
      return function (m) {
         const {
            onPointerMissed: g,
            internal: v
         } = n.getState();
         v.lastEvent.current = m;
         const x = c === "onPointerMove",
            S = c === "onClick" || c === "onContextMenu" || c === "onDoubleClick",
            T = i(m, x ? t : void 0),
            b = S ? e(m) : 0;
         c === "onPointerDown" && (v.initialClick = [m.offsetX, m.offsetY], v.initialHits = T.map(C => C.eventObject)), S && !T.length && b <= 2 && (a(m, v.interaction), g && g(m)), x && r(T);

         function w(C) {
            const N = C.eventObject,
               U = N.__r3f;
            if (!(U != null && U.eventCount)) return;
            const z = U.handlers;
            if (x) {
               if (z.onPointerOver || z.onPointerEnter || z.onPointerOut || z.onPointerLeave) {
                  const B = QS(C),
                     I = v.hovered.get(B);
                  I ? I.stopped && C.stopPropagation() : (v.hovered.set(B, C), z.onPointerOver == null || z.onPointerOver(C), z.onPointerEnter == null || z.onPointerEnter(C))
               }
               z.onPointerMove == null || z.onPointerMove(C)
            } else {
               const B = z[c];
               B ? (!S || v.initialHits.includes(N)) && (a(m, v.interaction.filter(I => !v.initialHits.includes(I))), B(C)) : S && v.initialHits.includes(N) && a(m, v.interaction.filter(I => !v.initialHits.includes(I)))
            }
         }
         s(T, m, b, w)
      }
   }
   return {
      handlePointer: l
   }
}
const pN = n => !!(n != null && n.render),
   XB = j.createContext(null),
   TX = (n, e) => {
      const t = Yq((l, c) => {
            const h = new ee,
               m = new ee,
               g = new ee;

            function v(b = c().camera, w = m, C = c().size) {
               const {
                  width: N,
                  height: U,
                  top: z,
                  left: B
               } = C, I = N / U;
               w.isVector3 ? g.copy(w) : g.set(...w);
               const O = b.getWorldPosition(h).distanceTo(g);
               if (VB(b)) return {
                  width: N / b.zoom,
                  height: U / b.zoom,
                  top: z,
                  left: B,
                  factor: 1,
                  distance: O,
                  aspect: I
               }; {
                  const P = b.fov * Math.PI / 180,
                     q = 2 * Math.tan(P / 2) * O,
                     Q = q * (N / U);
                  return {
                     width: Q,
                     height: q,
                     top: z,
                     left: B,
                     factor: N / Q,
                     distance: O,
                     aspect: I
                  }
               }
            }
            let x;
            const S = b => l(w => ({
                  performance: {
                     ...w.performance,
                     current: b
                  }
               })),
               E = new Fe;
            return {
               set: l,
               get: c,
               gl: null,
               camera: null,
               raycaster: null,
               events: {
                  priority: 1,
                  enabled: !0,
                  connected: !1
               },
               scene: null,
               xr: null,
               invalidate: (b = 1) => n(c(), b),
               advance: (b, w) => e(b, w, c()),
               legacy: !1,
               linear: !1,
               flat: !1,
               controls: null,
               clock: new $R,
               pointer: E,
               mouse: E,
               frameloop: "always",
               onPointerMissed: void 0,
               performance: {
                  current: 1,
                  min: .5,
                  max: 1,
                  debounce: 200,
                  regress: () => {
                     const b = c();
                     x && clearTimeout(x), b.performance.current !== b.performance.min && S(b.performance.min), x = setTimeout(() => S(c().performance.max), b.performance.debounce)
                  }
               },
               size: {
                  width: 0,
                  height: 0,
                  top: 0,
                  left: 0
               },
               viewport: {
                  initialDpr: 0,
                  dpr: 0,
                  width: 0,
                  height: 0,
                  top: 0,
                  left: 0,
                  aspect: 0,
                  distance: 0,
                  factor: 0,
                  getCurrentViewport: v
               },
               setEvents: b => l(w => ({
                  ...w,
                  events: {
                     ...w.events,
                     ...b
                  }
               })),
               setSize: (b, w, C = 0, N = 0) => {
                  const U = c().camera,
                     z = {
                        width: b,
                        height: w,
                        top: C,
                        left: N
                     };
                  l(B => ({
                     size: z,
                     viewport: {
                        ...B.viewport,
                        ...v(U, m, z)
                     }
                  }))
               },
               setDpr: b => l(w => {
                  const C = kB(b);
                  return {
                     viewport: {
                        ...w.viewport,
                        dpr: C,
                        initialDpr: w.viewport.initialDpr || C
                     }
                  }
               }),
               setFrameloop: (b = "always") => {
                  const w = c().clock;
                  w.stop(), w.elapsedTime = 0, b !== "never" && (w.start(), w.elapsedTime = 0), l(() => ({
                     frameloop: b
                  }))
               },
               previousRoot: void 0,
               internal: {
                  interaction: [],
                  hovered: new Map,
                  subscribers: [],
                  initialClick: [0, 0],
                  initialHits: [],
                  capturedMap: new Map,
                  lastEvent: j.createRef(),
                  active: !1,
                  frames: 0,
                  priority: 0,
                  subscribe: (b, w, C) => {
                     const N = c().internal;
                     return N.priority = N.priority + (w > 0 ? 1 : 0), N.subscribers.push({
                        ref: b,
                        priority: w,
                        store: C
                     }), N.subscribers = N.subscribers.sort((U, z) => U.priority - z.priority), () => {
                        const U = c().internal;
                        U != null && U.subscribers && (U.priority = U.priority - (w > 0 ? 1 : 0), U.subscribers = U.subscribers.filter(z => z.ref !== b))
                     }
                  }
               }
            }
         }),
         i = t.getState();
      let s = i.size,
         r = i.viewport.dpr,
         a = i.camera;
      return t.subscribe(() => {
         const {
            camera: l,
            size: c,
            viewport: h,
            gl: m,
            set: g
         } = t.getState();
         if (c.width !== s.width || c.height !== s.height || h.dpr !== r) {
            s = c, r = h.dpr, _X(l, c), h.dpr > 0 && m.setPixelRatio(h.dpr);
            const v = typeof HTMLCanvasElement < "u" && m.domElement instanceof HTMLCanvasElement;
            m.setSize(c.width, c.height, v)
         }
         l !== a && (a = l, g(v => ({
            viewport: {
               ...v.viewport,
               ...v.viewport.getCurrentViewport(l)
            }
         })))
      }), t.subscribe(l => n(l)), t
   };

function WB() {
   const n = j.useContext(XB);
   if (!n) throw new Error("R3F: Hooks can only be used within the Canvas component!");
   return n
}

function NT(n = t => t, e) {
   return WB()(n, e)
}

function a2(n, e = 0) {
   const t = WB(),
      i = t.getState().internal.subscribe,
      s = GB(n);
   return Tx(() => i(s, e, t), [e, i, t]), null
}
const mN = new WeakMap,
   EX = n => {
      var e;
      return typeof n == "function" && (n == null || (e = n.prototype) == null ? void 0 : e.constructor) === n
   };

function YB(n, e) {
   return function (t, ...i) {
      let s;
      return EX(t) ? (s = mN.get(t), s || (s = new t, mN.set(t, s))) : s = t, n && n(s), Promise.all(i.map(r => new Promise((a, l) => s.load(r, c => {
         la(c == null ? void 0 : c.scene) && Object.assign(c, dX(c.scene)), a(c)
      }, e, c => l(new Error(`Could not load ${r}: ${c==null?void 0:c.message}`))))))
   }
}

function OT(n, e, t, i) {
   const s = Array.isArray(e) ? e : [e],
      r = tX(YB(t, i), [n, ...s], {
         equal: Bi.equ
      });
   return Array.isArray(e) ? r : r[0]
}
OT.preload = function (n, e, t) {
   const i = Array.isArray(e) ? e : [e];
   return nX(YB(t), [n, ...i])
};
OT.clear = function (n, e) {
   const t = Array.isArray(e) ? e : [e];
   return iX([n, ...t])
};

function MX(n) {
   const e = $q(n);
   return e.injectIntoDevTools({
      bundleType: 0,
      rendererPackageName: "@react-three/fiber",
      version: j.version
   }), e
}
const KB = 0,
   yg = {},
   AX = /^three(?=[A-Z])/,
   UT = n => `${n[0].toUpperCase()}${n.slice(1)}`;
let wX = 0;
const RX = n => typeof n == "function";

function ZB(n) {
   if (RX(n)) {
      const e = `${wX++}`;
      return yg[e] = n, e
   } else Object.assign(yg, n)
}

function QB(n, e) {
   const t = UT(n),
      i = yg[t];
   if (n !== "primitive" && !i) throw new Error(`R3F: ${t} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);
   if (n === "primitive" && !e.object) throw new Error("R3F: Primitives without 'object' are invalid!");
   if (e.args !== void 0 && !Array.isArray(e.args)) throw new Error("R3F: The args prop must be an array!")
}

function CX(n, e, t) {
   var i;
   return n = UT(n) in yg ? n : n.replace(AX, ""), QB(n, e), n === "primitive" && (i = e.object) != null && i.__r3f && delete e.object.__r3f, T1(e.object, t, n, e)
}

function DX(n) {
   if (!n.isHidden) {
      var e;
      n.props.attach && (e = n.parent) != null && e.object ? M1(n.parent, n) : la(n.object) && (n.object.visible = !1), n.isHidden = !0, Ig(n)
   }
}

function JB(n) {
   if (n.isHidden) {
      var e;
      n.props.attach && (e = n.parent) != null && e.object ? E1(n.parent, n) : la(n.object) && n.props.visible !== !1 && (n.object.visible = !0), n.isHidden = !1, Ig(n)
   }
}

function o2(n, e, t) {
   const i = e.root.getState();
   if (!(!n.parent && n.object !== i.scene)) {
      if (!e.object) {
         var s, r;
         const a = yg[UT(e.type)];
         e.object = (s = e.props.object) != null ? s : new a(...(r = e.props.args) != null ? r : []), e.object.__r3f = e
      }
      if (qf(e.object, e.props), e.props.attach) E1(n, e);
      else if (la(e.object) && la(n.object)) {
         const a = n.object.children.indexOf(t == null ? void 0 : t.object);
         if (t && a !== -1) {
            const l = n.object.children.indexOf(e.object);
            if (l !== -1) {
               n.object.children.splice(l, 1);
               const c = l < a ? a - 1 : a;
               n.object.children.splice(c, 0, e.object)
            } else e.object.parent = n.object, n.object.children.splice(a, 0, e.object), e.object.dispatchEvent({
               type: "added"
            }), n.object.dispatchEvent({
               type: "childadded",
               child: e.object
            })
         } else n.object.add(e.object)
      }
      for (const a of e.children) o2(e, a);
      Ig(e)
   }
}

function jM(n, e) {
   e && (e.parent = n, n.children.push(e), o2(n, e))
}

function gN(n, e, t) {
   if (!e || !t) return;
   e.parent = n;
   const i = n.children.indexOf(t);
   i !== -1 ? n.children.splice(i, 0, e) : n.children.push(e), o2(n, e, t)
}

function $B(n) {
   if (typeof n.dispose == "function") {
      const e = () => {
         try {
            n.dispose()
         } catch {}
      };
      typeof IS_REACT_ACT_ENVIRONMENT < "u" ? e() : fN.unstable_scheduleCallback(fN.unstable_IdlePriority, e)
   }
}

function iw(n, e, t) {
   if (!e) return;
   e.parent = null;
   const i = n.children.indexOf(e);
   i !== -1 && n.children.splice(i, 1), e.props.attach ? M1(n, e) : la(e.object) && la(n.object) && (n.object.remove(e.object), SX(HB(e), e.object));
   const s = e.props.dispose !== null && t !== !1;
   for (let r = e.children.length - 1; r >= 0; r--) {
      const a = e.children[r];
      iw(e, a, s)
   }
   e.children.length = 0, delete e.object.__r3f, s && e.type !== "primitive" && e.object.type !== "Scene" && $B(e.object), t === void 0 && Ig(e)
}

function NX(n, e) {
   for (const t of [n, n.alternate])
      if (t !== null)
         if (typeof t.ref == "function") {
            t.refCleanup == null || t.refCleanup();
            const i = t.ref(e);
            typeof i == "function" && (t.refCleanup = i)
         } else t.ref && (t.ref.current = e)
}
const Eb = [];

function OX() {
   for (const [t] of Eb) {
      const i = t.parent;
      if (i) {
         t.props.attach ? M1(i, t) : la(t.object) && la(i.object) && i.object.remove(t.object);
         for (const s of t.children) s.props.attach ? M1(t, s) : la(s.object) && la(t.object) && t.object.remove(s.object)
      }
      t.isHidden && JB(t), t.object.__r3f && delete t.object.__r3f, t.type !== "primitive" && $B(t.object)
   }
   for (const [t, i, s] of Eb) {
      t.props = i;
      const r = t.parent;
      if (r) {
         var n, e;
         const a = yg[UT(t.type)];
         t.object = (n = t.props.object) != null ? n : new a(...(e = t.props.args) != null ? e : []), t.object.__r3f = t, NX(s, t.object), qf(t.object, t.props), t.props.attach ? E1(r, t) : la(t.object) && la(r.object) && r.object.add(t.object);
         for (const l of t.children) l.props.attach ? E1(t, l) : la(l.object) && la(t.object) && t.object.add(l.object);
         Ig(t)
      }
   }
   Eb.length = 0
}
const qM = () => {},
   vN = {};
let JS = KB;
const UX = 0,
   PX = 4,
   sw = MX({
      isPrimaryRenderer: !1,
      warnsIfNotActing: !1,
      supportsMutation: !0,
      supportsPersistence: !1,
      supportsHydration: !1,
      createInstance: CX,
      removeChild: iw,
      appendChild: jM,
      appendInitialChild: jM,
      insertBefore: gN,
      appendChildToContainer(n, e) {
         const t = n.getState().scene.__r3f;
         !e || !t || jM(t, e)
      },
      removeChildFromContainer(n, e) {
         const t = n.getState().scene.__r3f;
         !e || !t || iw(t, e)
      },
      insertInContainerBefore(n, e, t) {
         const i = n.getState().scene.__r3f;
         !e || !t || !i || gN(i, e, t)
      },
      getRootHostContext: () => vN,
      getChildHostContext: () => vN,
      commitUpdate(n, e, t, i, s) {
         var r, a, l;
         QB(e, i);
         let c = !1;
         if ((n.type === "primitive" && t.object !== i.object || ((r = i.args) == null ? void 0 : r.length) !== ((a = t.args) == null ? void 0 : a.length) || (l = i.args) != null && l.some((m, g) => {
               var v;
               return m !== ((v = t.args) == null ? void 0 : v[g])
            })) && (c = !0), c) Eb.push([n, {
            ...i
         }, s]);
         else {
            const m = vX(n, i);
            Object.keys(m).length && (Object.assign(n.props, m), qf(n.object, m))
         }(s.sibling === null || (s.flags & PX) === UX) && OX()
      },
      finalizeInitialChildren: () => !1,
      commitMount() {},
      getPublicInstance: n => n == null ? void 0 : n.object,
      prepareForCommit: () => null,
      preparePortalMount: n => T1(n.getState().scene, n, "", {}),
      resetAfterCommit: () => {},
      shouldSetTextContent: () => !1,
      clearContainer: () => !1,
      hideInstance: DX,
      unhideInstance: JB,
      createTextInstance: qM,
      hideTextInstance: qM,
      unhideTextInstance: qM,
      scheduleTimeout: typeof setTimeout == "function" ? setTimeout : void 0,
      cancelTimeout: typeof clearTimeout == "function" ? clearTimeout : void 0,
      noTimeout: -1,
      getInstanceFromNode: () => null,
      beforeActiveInstanceBlur() {},
      afterActiveInstanceBlur() {},
      detachDeletedInstance() {},
      prepareScopeUpdate() {},
      getInstanceFromScope: () => null,
      shouldAttemptEagerTransition: () => !1,
      trackSchedulerEvent: () => {},
      resolveEventType: () => null,
      resolveEventTimeStamp: () => -1.1,
      requestPostPaintCallback() {},
      maySuspendCommit: () => !1,
      preloadInstance: () => !0,
      startSuspendingCommit() {},
      suspendInstance() {},
      waitForCommitToBeReady: () => null,
      NotPendingTransition: null,
      HostTransitionContext: j.createContext(null),
      setCurrentUpdatePriority(n) {
         JS = n
      },
      getCurrentUpdatePriority() {
         return JS
      },
      resolveUpdatePriority() {
         var n;
         if (JS !== KB) return JS;
         switch (typeof window < "u" && ((n = window.event) == null ? void 0 : n.type)) {
            case "click":
            case "contextmenu":
            case "dblclick":
            case "pointercancel":
            case "pointerdown":
            case "pointerup":
               return Tb.DiscreteEventPriority;
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerenter":
            case "pointerleave":
            case "wheel":
               return Tb.ContinuousEventPriority;
            default:
               return Tb.DefaultEventPriority
         }
      },
      resetFormInstance() {}
   }),
   np = new Map,
   Pm = {
      objects: "shallow",
      strict: !1
   };

function LX(n, e) {
   if (!e && typeof HTMLCanvasElement < "u" && n instanceof HTMLCanvasElement && n.parentElement) {
      const {
         width: t,
         height: i,
         top: s,
         left: r
      } = n.parentElement.getBoundingClientRect();
      return {
         width: t,
         height: i,
         top: s,
         left: r
      }
   } else if (!e && typeof OffscreenCanvas < "u" && n instanceof OffscreenCanvas) return {
      width: n.width,
      height: n.height,
      top: 0,
      left: 0
   };
   return {
      width: 0,
      height: 0,
      top: 0,
      left: 0,
      ...e
   }
}

function BX(n) {
   const e = np.get(n),
      t = e == null ? void 0 : e.fiber,
      i = e == null ? void 0 : e.store;
   e && console.warn("R3F.createRoot should only be called once!");
   const s = typeof reportError == "function" ? reportError : console.error,
      r = i || TX(ow, xN),
      a = t || sw.createContainer(r, Tb.ConcurrentRoot, null, !1, null, "", s, s, s, null);
   e || np.set(n, {
      fiber: a,
      store: r
   });
   let l, c, h = !1,
      m = null;
   return {
      async configure(g = {}) {
         let v;
         m = new Promise(ie => v = ie);
         let {
            gl: x,
            size: S,
            scene: E,
            events: T,
            onCreated: b,
            shadows: w = !1,
            linear: C = !1,
            flat: N = !1,
            legacy: U = !1,
            orthographic: z = !1,
            frameloop: B = "always",
            dpr: I = [1, 2],
            performance: O,
            raycaster: P,
            camera: q,
            onPointerMissed: Q
         } = g, $ = r.getState(), ae = $.gl;
         if (!$.gl) {
            const ie = {
                  canvas: n,
                  powerPreference: "high-performance",
                  antialias: !0,
                  alpha: !0
               },
               ye = typeof x == "function" ? await x(ie) : x;
            pN(ye) ? ae = ye : ae = new OB({
               ...ie,
               ...x
            }), $.set({
               gl: ae
            })
         }
         let fe = $.raycaster;
         fe || $.set({
            raycaster: fe = new EB
         });
         const {
            params: k,
            ...Z
         } = P || {};
         if (Bi.equ(Z, fe, Pm) || qf(fe, {
               ...Z
            }), Bi.equ(k, fe.params, Pm) || qf(fe, {
               params: {
                  ...fe.params,
                  ...k
               }
            }), !$.camera || $.camera === c && !Bi.equ(c, q, Pm)) {
            c = q;
            const ie = q == null ? void 0 : q.isCamera,
               ye = ie ? q : z ? new bx(0, 0, 0, 0, .1, 1e3) : new Cs(75, 0, .1, 1e3);
            ie || (ye.position.z = 5, q && (qf(ye, q), ye.manual || ("aspect" in q || "left" in q || "right" in q || "bottom" in q || "top" in q) && (ye.manual = !0, ye.updateProjectionMatrix())), !$.camera && !(q != null && q.rotation) && ye.lookAt(0, 0, 0)), $.set({
               camera: ye
            }), fe.camera = ye
         }
         if (!$.scene) {
            let ie;
            E != null && E.isScene ? (ie = E, T1(ie, r, "", {})) : (ie = new mg, T1(ie, r, "", {}), E && qf(ie, E)), $.set({
               scene: ie
            })
         }
         T && !$.events.handlers && $.set({
            events: T(r)
         });
         const J = LX(n, S);
         if (Bi.equ(J, $.size, Pm) || $.setSize(J.width, J.height, J.top, J.left), I && $.viewport.dpr !== kB(I) && $.setDpr(I), $.frameloop !== B && $.setFrameloop(B), $.onPointerMissed || $.set({
               onPointerMissed: Q
            }), O && !Bi.equ(O, $.performance, Pm) && $.set(ie => ({
               performance: {
                  ...ie.performance,
                  ...O
               }
            })), !$.xr) {
            var pe;
            const ie = (oe, be) => {
                  const Pe = r.getState();
                  Pe.frameloop !== "never" && xN(oe, !0, Pe, be)
               },
               ye = () => {
                  const oe = r.getState();
                  oe.gl.xr.enabled = oe.gl.xr.isPresenting, oe.gl.xr.setAnimationLoop(oe.gl.xr.isPresenting ? ie : null), oe.gl.xr.isPresenting || ow(oe)
               },
               we = {
                  connect() {
                     const oe = r.getState().gl;
                     oe.xr.addEventListener("sessionstart", ye), oe.xr.addEventListener("sessionend", ye)
                  },
                  disconnect() {
                     const oe = r.getState().gl;
                     oe.xr.removeEventListener("sessionstart", ye), oe.xr.removeEventListener("sessionend", ye)
                  }
               };
            typeof ((pe = ae.xr) == null ? void 0 : pe.addEventListener) == "function" && we.connect(), $.set({
               xr: we
            })
         }
         if (ae.shadowMap) {
            const ie = ae.shadowMap.enabled,
               ye = ae.shadowMap.type;
            if (ae.shadowMap.enabled = !!w, Bi.boo(w)) ae.shadowMap.type = I0;
            else if (Bi.str(w)) {
               var F;
               const we = {
                  basic: BP,
                  percentage: eT,
                  soft: I0,
                  variance: Pl
               };
               ae.shadowMap.type = (F = we[w]) != null ? F : I0
            } else Bi.obj(w) && Object.assign(ae.shadowMap, w);
            (ie !== ae.shadowMap.enabled || ye !== ae.shadowMap.type) && (ae.shadowMap.needsUpdate = !0)
         }
         return Vn.enabled = !U, h || (ae.outputColorSpace = C ? Gu : En, ae.toneMapping = N ? ho : vR), $.legacy !== U && $.set(() => ({
            legacy: U
         })), $.linear !== C && $.set(() => ({
            linear: C
         })), $.flat !== N && $.set(() => ({
            flat: N
         })), x && !Bi.fun(x) && !pN(x) && !Bi.equ(x, ae, Pm) && qf(ae, x), l = b, h = !0, v(), this
      },
      render(g) {
         return !h && !m && this.configure(), m.then(() => {
            sw.updateContainer(H.jsx(zX, {
               store: r,
               children: g,
               onCreated: l,
               rootElement: n
            }), a, null, () => {})
         }), r
      },
      unmount() {
         ez(n)
      }
   }
}

function zX({
   store: n,
   children: e,
   onCreated: t,
   rootElement: i
}) {
   return Tx(() => {
      const s = n.getState();
      s.set(r => ({
         internal: {
            ...r.internal,
            active: !0
         }
      })), t && t(s), n.getState().events.connected || s.events.connect == null || s.events.connect(i)
   }, []), H.jsx(XB.Provider, {
      value: n,
      children: e
   })
}

function ez(n, e) {
   const t = np.get(n),
      i = t == null ? void 0 : t.fiber;
   if (i) {
      const s = t == null ? void 0 : t.store.getState();
      s && (s.internal.active = !1), sw.updateContainer(null, i, null, () => {
         s && setTimeout(() => {
            try {
               var r, a, l, c;
               s.events.disconnect == null || s.events.disconnect(), (r = s.gl) == null || (a = r.renderLists) == null || a.dispose == null || a.dispose(), (l = s.gl) == null || l.forceContextLoss == null || l.forceContextLoss(), (c = s.gl) != null && c.xr && s.xr.disconnect(), pX(s.scene), np.delete(n)
            } catch {}
         }, 500)
      })
   }
}
const IX = new Set,
   FX = new Set,
   HX = new Set;

function XM(n, e) {
   if (n.size)
      for (const {
            callback: t
         } of n.values()) t(e)
}

function Y0(n, e) {
   switch (n) {
      case "before":
         return XM(IX, e);
      case "after":
         return XM(FX, e);
      case "tail":
         return XM(HX, e)
   }
}
let WM, YM;

function rw(n, e, t) {
   let i = e.clock.getDelta();
   e.frameloop === "never" && typeof n == "number" && (i = n - e.clock.elapsedTime, e.clock.oldTime = e.clock.elapsedTime, e.clock.elapsedTime = n), WM = e.internal.subscribers;
   for (let s = 0; s < WM.length; s++) YM = WM[s], YM.ref.current(YM.store.getState(), i, t);
   return !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera), e.internal.frames = Math.max(0, e.internal.frames - 1), e.frameloop === "always" ? 1 : e.internal.frames
}
let A1 = !1,
   aw = !1,
   KM, yN, Lm;

function tz(n) {
   yN = requestAnimationFrame(tz), A1 = !0, KM = 0, Y0("before", n), aw = !0;
   for (const t of np.values()) {
      var e;
      Lm = t.store.getState(), Lm.internal.active && (Lm.frameloop === "always" || Lm.internal.frames > 0) && !((e = Lm.gl.xr) != null && e.isPresenting) && (KM += rw(n, Lm))
   }
   if (aw = !1, Y0("after", n), KM === 0) return Y0("tail", n), A1 = !1, cancelAnimationFrame(yN)
}

function ow(n, e = 1) {
   var t;
   if (!n) return np.forEach(i => ow(i.store.getState(), e));
   (t = n.gl.xr) != null && t.isPresenting || !n.internal.active || n.frameloop === "never" || (e > 1 ? n.internal.frames = Math.min(60, n.internal.frames + e) : aw ? n.internal.frames = 2 : n.internal.frames = 1, A1 || (A1 = !0, requestAnimationFrame(tz)))
}

function xN(n, e = !0, t, i) {
   if (e && Y0("before", n), t) rw(n, t, i);
   else
      for (const s of np.values()) rw(n, s.store.getState());
   e && Y0("after", n)
}
const ZM = {
   onClick: ["click", !1],
   onContextMenu: ["contextmenu", !1],
   onDoubleClick: ["dblclick", !1],
   onWheel: ["wheel", !0],
   onPointerDown: ["pointerdown", !0],
   onPointerUp: ["pointerup", !0],
   onPointerLeave: ["pointerleave", !0],
   onPointerMove: ["pointermove", !0],
   onPointerCancel: ["pointercancel", !0],
   onLostPointerCapture: ["lostpointercapture", !0]
};

function VX(n) {
   const {
      handlePointer: e
   } = bX(n);
   return {
      priority: 1,
      enabled: !0,
      compute(t, i, s) {
         i.pointer.set(t.offsetX / i.size.width * 2 - 1, -(t.offsetY / i.size.height) * 2 + 1), i.raycaster.setFromCamera(i.pointer, i.camera)
      },
      connected: void 0,
      handlers: Object.keys(ZM).reduce((t, i) => ({
         ...t,
         [i]: e(i)
      }), {}),
      update: () => {
         var t;
         const {
            events: i,
            internal: s
         } = n.getState();
         (t = s.lastEvent) != null && t.current && i.handlers && i.handlers.onPointerMove(s.lastEvent.current)
      },
      connect: t => {
         const {
            set: i,
            events: s
         } = n.getState();
         if (s.disconnect == null || s.disconnect(), i(r => ({
               events: {
                  ...r.events,
                  connected: t
               }
            })), s.handlers)
            for (const r in s.handlers) {
               const a = s.handlers[r],
                  [l, c] = ZM[r];
               t.addEventListener(l, a, {
                  passive: c
               })
            }
      },
      disconnect: () => {
         const {
            set: t,
            events: i
         } = n.getState();
         if (i.connected) {
            if (i.handlers)
               for (const s in i.handlers) {
                  const r = i.handlers[s],
                     [a] = ZM[s];
                  i.connected.removeEventListener(a, r)
               }
            t(s => ({
               events: {
                  ...s.events,
                  connected: void 0
               }
            }))
         }
      }
   }
}

function _N(n, e) {
   let t;
   return (...i) => {
      window.clearTimeout(t), t = window.setTimeout(() => n(...i), e)
   }
}

function GX({
   debounce: n,
   scroll: e,
   polyfill: t,
   offsetSize: i
} = {
   debounce: 0,
   scroll: !1,
   offsetSize: !1
}) {
   const s = t || (typeof window > "u" ? class {} : window.ResizeObserver);
   if (!s) throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");
   const [r, a] = j.useState({
      left: 0,
      top: 0,
      width: 0,
      height: 0,
      bottom: 0,
      right: 0,
      x: 0,
      y: 0
   }), l = j.useRef({
      element: null,
      scrollContainers: null,
      resizeObserver: null,
      lastBounds: r,
      orientationHandler: null
   }), c = n ? typeof n == "number" ? n : n.scroll : null, h = n ? typeof n == "number" ? n : n.resize : null, m = j.useRef(!1);
   j.useEffect(() => (m.current = !0, () => void(m.current = !1)));
   const [g, v, x] = j.useMemo(() => {
      const b = () => {
         if (!l.current.element) return;
         const {
            left: w,
            top: C,
            width: N,
            height: U,
            bottom: z,
            right: B,
            x: I,
            y: O
         } = l.current.element.getBoundingClientRect(), P = {
            left: w,
            top: C,
            width: N,
            height: U,
            bottom: z,
            right: B,
            x: I,
            y: O
         };
         l.current.element instanceof HTMLElement && i && (P.height = l.current.element.offsetHeight, P.width = l.current.element.offsetWidth), Object.freeze(P), m.current && !XX(l.current.lastBounds, P) && a(l.current.lastBounds = P)
      };
      return [b, h ? _N(b, h) : b, c ? _N(b, c) : b]
   }, [a, i, c, h]);

   function S() {
      l.current.scrollContainers && (l.current.scrollContainers.forEach(b => b.removeEventListener("scroll", x, !0)), l.current.scrollContainers = null), l.current.resizeObserver && (l.current.resizeObserver.disconnect(), l.current.resizeObserver = null), l.current.orientationHandler && ("orientation" in screen && "removeEventListener" in screen.orientation ? screen.orientation.removeEventListener("change", l.current.orientationHandler) : "onorientationchange" in window && window.removeEventListener("orientationchange", l.current.orientationHandler))
   }

   function E() {
      l.current.element && (l.current.resizeObserver = new s(x), l.current.resizeObserver.observe(l.current.element), e && l.current.scrollContainers && l.current.scrollContainers.forEach(b => b.addEventListener("scroll", x, {
         capture: !0,
         passive: !0
      })), l.current.orientationHandler = () => {
         x()
      }, "orientation" in screen && "addEventListener" in screen.orientation ? screen.orientation.addEventListener("change", l.current.orientationHandler) : "onorientationchange" in window && window.addEventListener("orientationchange", l.current.orientationHandler))
   }
   const T = b => {
      !b || b === l.current.element || (S(), l.current.element = b, l.current.scrollContainers = nz(b), E())
   };
   return jX(x, !!e), kX(v), j.useEffect(() => {
      S(), E()
   }, [e, x, v]), j.useEffect(() => S, []), [T, r, g]
}

function kX(n) {
   j.useEffect(() => {
      const e = n;
      return window.addEventListener("resize", e), () => void window.removeEventListener("resize", e)
   }, [n])
}

function jX(n, e) {
   j.useEffect(() => {
      if (e) {
         const t = n;
         return window.addEventListener("scroll", t, {
            capture: !0,
            passive: !0
         }), () => void window.removeEventListener("scroll", t, !0)
      }
   }, [n, e])
}

function nz(n) {
   const e = [];
   if (!n || n === document.body) return e;
   const {
      overflow: t,
      overflowX: i,
      overflowY: s
   } = window.getComputedStyle(n);
   return [t, i, s].some(r => r === "auto" || r === "scroll") && e.push(n), [...e, ...nz(n.parentElement)]
}
const qX = ["x", "y", "top", "bottom", "left", "right", "width", "height"],
   XX = (n, e) => qX.every(t => n[t] === e[t]);

function WX({
   ref: n,
   children: e,
   fallback: t,
   resize: i,
   style: s,
   gl: r,
   events: a = VX,
   eventSource: l,
   eventPrefix: c,
   shadows: h,
   linear: m,
   flat: g,
   legacy: v,
   orthographic: x,
   frameloop: S,
   dpr: E,
   performance: T,
   raycaster: b,
   camera: w,
   scene: C,
   onPointerMissed: N,
   onCreated: U,
   ...z
}) {
   j.useMemo(() => ZB(Bq), []);
   const B = cX(),
      [I, O] = GX({
         scroll: !0,
         debounce: {
            scroll: 50,
            resize: 0
         },
         ...i
      }),
      P = j.useRef(null),
      q = j.useRef(null);
   j.useImperativeHandle(n, () => P.current);
   const Q = GB(N),
      [$, ae] = j.useState(!1),
      [fe, k] = j.useState(!1);
   if ($) throw $;
   if (fe) throw fe;
   const Z = j.useRef(null);
   Tx(() => {
      const pe = P.current;
      if (O.width > 0 && O.height > 0 && pe) {
         Z.current || (Z.current = BX(pe));
         async function F() {
            await Z.current.configure({
               gl: r,
               scene: C,
               events: a,
               shadows: h,
               linear: m,
               flat: g,
               legacy: v,
               orthographic: x,
               frameloop: S,
               dpr: E,
               performance: T,
               raycaster: b,
               camera: w,
               size: O,
               onPointerMissed: (...ie) => Q.current == null ? void 0 : Q.current(...ie),
               onCreated: ie => {
                  ie.events.connect == null || ie.events.connect(l ? lX(l) ? l.current : l : q.current), c && ie.setEvents({
                     compute: (ye, we) => {
                        const oe = ye[c + "X"],
                           be = ye[c + "Y"];
                        we.pointer.set(oe / we.size.width * 2 - 1, -(be / we.size.height) * 2 + 1), we.raycaster.setFromCamera(we.pointer, we.camera)
                     }
                  }), U == null || U(ie)
               }
            }), Z.current.render(H.jsx(B, {
               children: H.jsx(hX, {
                  set: k,
                  children: H.jsx(j.Suspense, {
                     fallback: H.jsx(fX, {
                        set: ae
                     }),
                     children: e ?? null
                  })
               })
            }))
         }
         F()
      }
   }), j.useEffect(() => {
      const pe = P.current;
      if (pe) return () => ez(pe)
   }, []);
   const J = l ? "none" : "auto";
   return H.jsx("div", {
      ref: q,
      style: {
         position: "relative",
         width: "100%",
         height: "100%",
         overflow: "hidden",
         pointerEvents: J,
         ...s
      },
      ...z,
      children: H.jsx("div", {
         ref: I,
         style: {
            width: "100%",
            height: "100%"
         },
         children: H.jsx("canvas", {
            ref: P,
            style: {
               display: "block"
            },
            children: t
         })
      })
   })
}

function YX(n) {
   return H.jsx(IB, {
      children: H.jsx(WX, {
         ...n
      })
   })
}
const KX = n => n;

function ZX(n, e = KX) {
   const t = $o.useSyncExternalStore(n.subscribe, () => e(n.getState()), () => e(n.getInitialState()));
   return $o.useDebugValue(t), t
}
const SN = n => {
      const e = UB(n),
         t = i => ZX(e, i);
      return Object.assign(t, e), t
   },
   l2 = n => n ? SN(n) : SN,
   u2 = l2(n => ({
      isPlanetClicked: !1,
      setPlanetClicked: e => n({
         isPlanetClicked: e
      })
   }));
var QM, bN;

function QX() {
   return bN || (bN = 1, QM = {
      area: !0,
      base: !0,
      br: !0,
      col: !0,
      embed: !0,
      hr: !0,
      img: !0,
      input: !0,
      link: !0,
      meta: !0,
      param: !0,
      source: !0,
      track: !0,
      wbr: !0
   }), QM
}
var JX = QX();
const $X = lx(JX);
var eW = /\s([^'"/\s><]+?)[\s/>]|([^\s=]+)=\s?(".*?"|'.*?')/g;

function TN(n) {
   var e = {
         type: "tag",
         name: "",
         voidElement: !1,
         attrs: {},
         children: []
      },
      t = n.match(/<\/?([^\s]+?)[/\s>]/);
   if (t && (e.name = t[1], ($X[t[1]] || n.charAt(n.length - 2) === "/") && (e.voidElement = !0), e.name.startsWith("!--"))) {
      var i = n.indexOf("-->");
      return {
         type: "comment",
         comment: i !== -1 ? n.slice(4, i) : ""
      }
   }
   for (var s = new RegExp(eW), r = null;
      (r = s.exec(n)) !== null;)
      if (r[0].trim())
         if (r[1]) {
            var a = r[1].trim(),
               l = [a, ""];
            a.indexOf("=") > -1 && (l = a.split("=")), e.attrs[l[0]] = l[1], s.lastIndex--
         } else r[2] && (e.attrs[r[2]] = r[3].trim().substring(1, r[3].length - 1));
   return e
}
var tW = /<[a-zA-Z0-9\-\!\/](?:"[^"]*"|'[^']*'|[^'">])*>/g,
   nW = /^\s*$/,
   iW = Object.create(null);

function iz(n, e) {
   switch (e.type) {
      case "text":
         return n + e.content;
      case "tag":
         return n += "<" + e.name + (e.attrs ? function (t) {
            var i = [];
            for (var s in t) i.push(s + '="' + t[s] + '"');
            return i.length ? " " + i.join(" ") : ""
         }(e.attrs) : "") + (e.voidElement ? "/>" : ">"), e.voidElement ? n : n + e.children.reduce(iz, "") + "</" + e.name + ">";
      case "comment":
         return n + "<!--" + e.comment + "-->"
   }
}
var sW = {
   parse: function (n, e) {
      e || (e = {}), e.components || (e.components = iW);
      var t, i = [],
         s = [],
         r = -1,
         a = !1;
      if (n.indexOf("<") !== 0) {
         var l = n.indexOf("<");
         i.push({
            type: "text",
            content: l === -1 ? n : n.substring(0, l)
         })
      }
      return n.replace(tW, function (c, h) {
         if (a) {
            if (c !== "</" + t.name + ">") return;
            a = !1
         }
         var m, g = c.charAt(1) !== "/",
            v = c.startsWith("<!--"),
            x = h + c.length,
            S = n.charAt(x);
         if (v) {
            var E = TN(c);
            return r < 0 ? (i.push(E), i) : ((m = s[r]).children.push(E), i)
         }
         if (g && (r++, (t = TN(c)).type === "tag" && e.components[t.name] && (t.type = "component", a = !0), t.voidElement || a || !S || S === "<" || t.children.push({
               type: "text",
               content: n.slice(x, n.indexOf("<", x))
            }), r === 0 && i.push(t), (m = s[r - 1]) && m.children.push(t), s[r] = t), (!g || t.voidElement) && (r > -1 && (t.voidElement || t.name === c.slice(2, -1)) && (r--, t = r === -1 ? i : s[r]), !a && S !== "<" && S)) {
            m = r === -1 ? i : s[r].children;
            var T = n.indexOf("<", x),
               b = n.slice(x, T === -1 ? void 0 : T);
            nW.test(b) && (b = " "), (T > -1 && r + m.length >= 0 || b !== " ") && m.push({
               type: "text",
               content: b
            })
         }
      }), i
   },
   stringify: function (n) {
      return n.reduce(function (e, t) {
         return e + iz("", t)
      }, "")
   }
};
const Mb = (n, e, t, i) => {
      var r, a, l, c;
      const s = [t, {
         code: e,
         ...i || {}
      }];
      if ((a = (r = n == null ? void 0 : n.services) == null ? void 0 : r.logger) != null && a.forward) return n.services.logger.forward(s, "warn", "react-i18next::", !0);
      el(s[0]) && (s[0] = `react-i18next:: ${s[0]}`), (c = (l = n == null ? void 0 : n.services) == null ? void 0 : l.logger) != null && c.warn ? n.services.logger.warn(...s) : console != null && console.warn && console.warn(...s)
   },
   EN = {},
   Gy = (n, e, t, i) => {
      el(t) && EN[t] || (el(t) && (EN[t] = new Date), Mb(n, e, t, i))
   },
   sz = (n, e) => () => {
      if (n.isInitialized) e();
      else {
         const t = () => {
            setTimeout(() => {
               n.off("initialized", t)
            }, 0), e()
         };
         n.on("initialized", t)
      }
   },
   lw = (n, e, t) => {
      n.loadNamespaces(e, sz(n, t))
   },
   MN = (n, e, t, i) => {
      if (el(t) && (t = [t]), n.options.preload && n.options.preload.indexOf(e) > -1) return lw(n, t, i);
      t.forEach(s => {
         n.options.ns.indexOf(s) < 0 && n.options.ns.push(s)
      }), n.loadLanguages(e, sz(n, i))
   },
   rW = (n, e, t = {}) => !e.languages || !e.languages.length ? (Gy(e, "NO_LANGUAGES", "i18n.languages were undefined or empty", {
      languages: e.languages
   }), !0) : e.hasLoadedNamespace(n, {
      lng: t.lng,
      precheck: (i, s) => {
         var r;
         if (((r = t.bindI18n) == null ? void 0 : r.indexOf("languageChanging")) > -1 && i.services.backendConnector.backend && i.isLanguageChangingTo && !s(i.isLanguageChangingTo, n)) return !1
      }
   }),
   el = n => typeof n == "string",
   Wf = n => typeof n == "object" && n !== null,
   aW = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g,
   oW = {
      "&amp;": "&",
      "&#38;": "&",
      "&lt;": "<",
      "&#60;": "<",
      "&gt;": ">",
      "&#62;": ">",
      "&apos;": "'",
      "&#39;": "'",
      "&quot;": '"',
      "&#34;": '"',
      "&nbsp;": " ",
      "&#160;": " ",
      "&copy;": "",
      "&#169;": "",
      "&reg;": "",
      "&#174;": "",
      "&hellip;": "",
      "&#8230;": "",
      "&#x2F;": "/",
      "&#47;": "/"
   },
   lW = n => oW[n],
   uW = n => n.replace(aW, lW);
let uw = {
   bindI18n: "languageChanged",
   bindI18nStore: "",
   transEmptyNodeValue: "",
   transSupportBasicHtmlNodes: !0,
   transWrapTextNodes: "",
   transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
   useSuspense: !0,
   unescape: uW
};
const cW = (n = {}) => {
      uw = {
         ...uw,
         ...n
      }
   },
   rz = () => uw;
let az;
const fW = n => {
      az = n
   },
   c2 = () => az,
   JM = (n, e) => {
      var i;
      if (!n) return !1;
      const t = ((i = n.props) == null ? void 0 : i.children) ?? n.children;
      return e ? t.length > 0 : !!t
   },
   $M = n => {
      var t, i;
      if (!n) return [];
      const e = ((t = n.props) == null ? void 0 : t.children) ?? n.children;
      return (i = n.props) != null && i.i18nIsDynamicList ? Wm(e) : e
   },
   hW = n => Array.isArray(n) && n.every(j.isValidElement),
   Wm = n => Array.isArray(n) ? n : [n],
   dW = (n, e) => {
      const t = {
         ...e
      };
      return t.props = Object.assign(n.props, e.props), t
   },
   oz = (n, e, t, i) => {
      if (!n) return "";
      let s = "";
      const r = Wm(n),
         a = e != null && e.transSupportBasicHtmlNodes ? e.transKeepBasicHtmlNodesFor ?? [] : [];
      return r.forEach((l, c) => {
         if (el(l)) {
            s += `${l}`;
            return
         }
         if (j.isValidElement(l)) {
            const {
               props: h,
               type: m
            } = l, g = Object.keys(h).length, v = a.indexOf(m) > -1, x = h.children;
            if (!x && v && !g) {
               s += `<${m}/>`;
               return
            }
            if (!x && (!v || g) || h.i18nIsDynamicList) {
               s += `<${c}></${c}>`;
               return
            }
            if (v && g === 1 && el(x)) {
               s += `<${m}>${x}</${m}>`;
               return
            }
            const S = oz(x, e, t, i);
            s += `<${c}>${S}</${c}>`;
            return
         }
         if (l === null) {
            Mb(t, "TRANS_NULL_VALUE", "Passed in a null value as child", {
               i18nKey: i
            });
            return
         }
         if (Wf(l)) {
            const {
               format: h,
               ...m
            } = l, g = Object.keys(m);
            if (g.length === 1) {
               const v = h ? `${g[0]}, ${h}` : g[0];
               s += `{{${v}}}`;
               return
            }
            Mb(t, "TRANS_INVALID_OBJ", "Invalid child - Object should only have keys {{ value, format }} (format is optional).", {
               i18nKey: i,
               child: l
            });
            return
         }
         Mb(t, "TRANS_INVALID_VAR", "Passed in a variable like {number} - pass variables for interpolation as full objects like {{number}}.", {
            i18nKey: i,
            child: l
         })
      }), s
   },
   pW = (n, e, t, i, s, r, a) => {
      if (t === "") return [];
      const l = s.transKeepBasicHtmlNodesFor || [],
         c = t && new RegExp(l.map(b => `<${b}`).join("|")).test(t);
      if (!n && !e && !c && !a) return [t];
      const h = e ?? {},
         m = b => {
            Wm(b).forEach(C => {
               el(C) || (JM(C) ? m($M(C)) : Wf(C) && !j.isValidElement(C) && Object.assign(h, C))
            })
         };
      m(n);
      const g = sW.parse(`<0>${t}</0>`),
         v = {
            ...h,
            ...r
         },
         x = (b, w, C) => {
            var z;
            const N = $M(b),
               U = E(N, w.children, C);
            return hW(N) && U.length === 0 || (z = b.props) != null && z.i18nIsDynamicList ? N : U
         },
         S = (b, w, C, N, U) => {
            b.dummy ? (b.children = w, C.push(j.cloneElement(b, {
               key: N
            }, U ? void 0 : w))) : C.push(...j.Children.map([b], z => {
               const B = {
                  ...z.props
               };
               return delete B.i18nIsDynamicList, j.createElement(z.type, {
                  ...B,
                  key: N,
                  ref: z.props.ref ?? z.ref
               }, U ? null : w)
            }))
         },
         E = (b, w, C) => {
            const N = Wm(b);
            return Wm(w).reduce((z, B, I) => {
               var P, q;
               const O = ((q = (P = B.children) == null ? void 0 : P[0]) == null ? void 0 : q.content) && i.services.interpolator.interpolate(B.children[0].content, v, i.language);
               if (B.type === "tag") {
                  let Q = N[parseInt(B.name, 10)];
                  !Q && e && (Q = e[B.name]), C.length === 1 && !Q && (Q = C[0][B.name]), Q || (Q = {});
                  const $ = Object.keys(B.attrs).length !== 0 ? dW({
                        props: B.attrs
                     }, Q) : Q,
                     ae = j.isValidElement($),
                     fe = ae && JM(B, !0) && !B.voidElement,
                     k = c && Wf($) && $.dummy && !ae,
                     Z = Wf(e) && Object.hasOwnProperty.call(e, B.name);
                  if (el($)) {
                     const J = i.services.interpolator.interpolate($, v, i.language);
                     z.push(J)
                  } else if (JM($) || fe) {
                     const J = x($, B, C);
                     S($, J, z, I)
                  } else if (k) {
                     const J = E(N, B.children, C);
                     S($, J, z, I)
                  } else if (Number.isNaN(parseFloat(B.name)))
                     if (Z) {
                        const J = x($, B, C);
                        S($, J, z, I, B.voidElement)
                     } else if (s.transSupportBasicHtmlNodes && l.indexOf(B.name) > -1)
                     if (B.voidElement) z.push(j.createElement(B.name, {
                        key: `${B.name}-${I}`
                     }));
                     else {
                        const J = E(N, B.children, C);
                        z.push(j.createElement(B.name, {
                           key: `${B.name}-${I}`
                        }, J))
                     }
                  else if (B.voidElement) z.push(`<${B.name} />`);
                  else {
                     const J = E(N, B.children, C);
                     z.push(`<${B.name}>${J}</${B.name}>`)
                  } else if (Wf($) && !ae) {
                     const J = B.children[0] ? O : null;
                     J && z.push(J)
                  } else S($, O, z, I, B.children.length !== 1 || !O)
               } else if (B.type === "text") {
                  const Q = s.transWrapTextNodes,
                     $ = a ? s.unescape(i.services.interpolator.interpolate(B.content, v, i.language)) : i.services.interpolator.interpolate(B.content, v, i.language);
                  Q ? z.push(j.createElement(Q, {
                     key: `${B.name}-${I}`
                  }, $)) : z.push($)
               }
               return z
            }, [])
         },
         T = E([{
            dummy: !0,
            children: n || []
         }], g, Wm(n || []));
      return $M(T[0])
   },
   lz = (n, e, t) => {
      const i = n.key || e,
         s = j.cloneElement(n, {
            key: i
         });
      if (!s.props || !s.props.children || t.indexOf(`${e}/>`) < 0 && t.indexOf(`${e} />`) < 0) return s;

      function r() {
         return j.createElement(j.Fragment, null, s)
      }
      return j.createElement(r, {
         key: i
      })
   },
   mW = (n, e) => n.map((t, i) => lz(t, i, e)),
   gW = (n, e) => {
      const t = {};
      return Object.keys(n).forEach(i => {
         Object.assign(t, {
            [i]: lz(n[i], i, e)
         })
      }), t
   },
   vW = (n, e, t, i) => n ? Array.isArray(n) ? mW(n, e) : Wf(n) ? gW(n, e) : (Gy(t, "TRANS_INVALID_COMPONENTS", '<Trans /> "components" prop expects an object or array', {
      i18nKey: i
   }), null) : null,
   yW = n => !Wf(n) || Array.isArray(n) ? !1 : Object.keys(n).reduce((e, t) => e && Number.isNaN(Number.parseFloat(t)), !0);

function xW({
   children: n,
   count: e,
   parent: t,
   i18nKey: i,
   context: s,
   tOptions: r = {},
   values: a,
   defaults: l,
   components: c,
   ns: h,
   i18n: m,
   t: g,
   shouldUnescape: v,
   ...x
}) {
   var ae, fe, k, Z, J, pe;
   const S = m || c2();
   if (!S) return Gy(S, "NO_I18NEXT_INSTANCE", "Trans: You need to pass in an i18next instance using i18nextReactModule", {
      i18nKey: i
   }), n;
   const E = g || S.t.bind(S) || (F => F),
      T = {
         ...rz(),
         ...(ae = S.options) == null ? void 0 : ae.react
      };
   let b = h || E.ns || ((fe = S.options) == null ? void 0 : fe.defaultNS);
   b = el(b) ? [b] : b || ["translation"];
   const w = oz(n, T, S, i),
      C = l || w || T.transEmptyNodeValue || i,
      {
         hashTransKey: N
      } = T,
      U = i || (N ? N(w || C) : w || C);
   (Z = (k = S.options) == null ? void 0 : k.interpolation) != null && Z.defaultVariables && (a = a && Object.keys(a).length > 0 ? {
      ...a,
      ...S.options.interpolation.defaultVariables
   } : {
      ...S.options.interpolation.defaultVariables
   });
   const z = a || e !== void 0 && !((pe = (J = S.options) == null ? void 0 : J.interpolation) != null && pe.alwaysFormat) || !n ? r.interpolation : {
         interpolation: {
            ...r.interpolation,
            prefix: "#$?",
            suffix: "?$#"
         }
      },
      B = {
         ...r,
         context: s || r.context,
         count: e,
         ...a,
         ...z,
         defaultValue: C,
         ns: b
      },
      I = U ? E(U, B) : C,
      O = vW(c, I, S, i);
   let P = O || n,
      q = null;
   yW(O) && (q = O, P = n);
   const Q = pW(P, q, I, S, T, B, v),
      $ = t ?? T.defaultTransParent;
   return $ ? j.createElement($, x, Q) : Q
}
const _W = {
      type: "3rdParty",
      init(n) {
         cW(n.options.react), fW(n)
      }
   },
   uz = j.createContext();
class SW {
   constructor() {
      this.usedNamespaces = {}
   }
   addUsedNamespaces(e) {
      e.forEach(t => {
         this.usedNamespaces[t] || (this.usedNamespaces[t] = !0)
      })
   }
   getUsedNamespaces() {
      return Object.keys(this.usedNamespaces)
   }
}

function Mc({
   children: n,
   count: e,
   parent: t,
   i18nKey: i,
   context: s,
   tOptions: r = {},
   values: a,
   defaults: l,
   components: c,
   ns: h,
   i18n: m,
   t: g,
   shouldUnescape: v,
   ...x
}) {
   var w;
   const {
      i18n: S,
      defaultNS: E
   } = j.useContext(uz) || {}, T = m || S || c2(), b = g || (T == null ? void 0 : T.t.bind(T));
   return xW({
      children: n,
      count: e,
      parent: t,
      i18nKey: i,
      context: s,
      tOptions: r,
      values: a,
      defaults: l,
      components: c,
      ns: h || (b == null ? void 0 : b.ns) || E || ((w = T == null ? void 0 : T.options) == null ? void 0 : w.defaultNS),
      i18n: T,
      t: g,
      shouldUnescape: v,
      ...x
   })
}
const bW = (n, e) => {
      const t = j.useRef();
      return j.useEffect(() => {
         t.current = n
      }, [n, e]), t.current
   },
   cz = (n, e, t, i) => n.getFixedT(e, t, i),
   TW = (n, e, t, i) => j.useCallback(cz(n, e, t, i), [n, e, t, i]),
   rs = (n, e = {}) => {
      var N, U, z, B;
      const {
         i18n: t
      } = e, {
         i18n: i,
         defaultNS: s
      } = j.useContext(uz) || {}, r = t || i || c2();
      if (r && !r.reportNamespaces && (r.reportNamespaces = new SW), !r) {
         Gy(r, "NO_I18NEXT_INSTANCE", "useTranslation: You will need to pass in an i18next instance by using initReactI18next");
         const I = (P, q) => el(q) ? q : Wf(q) && el(q.defaultValue) ? q.defaultValue : Array.isArray(P) ? P[P.length - 1] : P,
            O = [I, {}, !1];
         return O.t = I, O.i18n = {}, O.ready = !1, O
      }(N = r.options.react) != null && N.wait && Gy(r, "DEPRECATED_OPTION", "useTranslation: It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");
      const a = {
            ...rz(),
            ...r.options.react,
            ...e
         },
         {
            useSuspense: l,
            keyPrefix: c
         } = a;
      let h = s || ((U = r.options) == null ? void 0 : U.defaultNS);
      h = el(h) ? [h] : h || ["translation"], (B = (z = r.reportNamespaces).addUsedNamespaces) == null || B.call(z, h);
      const m = (r.isInitialized || r.initializedStoreOnce) && h.every(I => rW(I, r, a)),
         g = TW(r, e.lng || null, a.nsMode === "fallback" ? h : h[0], c),
         v = () => g,
         x = () => cz(r, e.lng || null, a.nsMode === "fallback" ? h : h[0], c),
         [S, E] = j.useState(v);
      let T = h.join();
      e.lng && (T = `${e.lng}${T}`);
      const b = bW(T),
         w = j.useRef(!0);
      j.useEffect(() => {
         const {
            bindI18n: I,
            bindI18nStore: O
         } = a;
         w.current = !0, !m && !l && (e.lng ? MN(r, e.lng, h, () => {
            w.current && E(x)
         }) : lw(r, h, () => {
            w.current && E(x)
         })), m && b && b !== T && w.current && E(x);
         const P = () => {
            w.current && E(x)
         };
         return I && (r == null || r.on(I, P)), O && (r == null || r.store.on(O, P)), () => {
            w.current = !1, r && (I == null || I.split(" ").forEach(q => r.off(q, P))), O && r && O.split(" ").forEach(q => r.store.off(q, P))
         }
      }, [r, T]), j.useEffect(() => {
         w.current && m && E(v)
      }, [r, c, m]);
      const C = [S, r, m];
      if (C.t = S, C.i18n = r, C.ready = m, m || !m && !l) return C;
      throw new Promise(I => {
         e.lng ? MN(r, e.lng, h, () => I()) : lw(r, h, () => I())
      })
   };

function PT({
   pageKey: n
}) {
   const {
      t: e
   } = rs(), t = e(`seo.${n}.title`), i = e(`seo.${n}.description`);
   return j.useEffect(() => {
      const s = document.head,
         r = s.querySelector("title");
      r && r.remove();
      const a = s.querySelector('meta[name="description"]');
      a && a.remove()
   }, []), H.jsxs(H.Fragment, {
      children: [H.jsx(SV, {
         children: t
      }), H.jsx(bV, {
         name: "description",
         content: i
      })]
   })
}
let x0 = 0;
const EW = l2(n => (qm.onStart = (e, t, i) => {
      n({
         active: !0,
         item: e,
         loaded: t,
         total: i,
         progress: (t - x0) / (i - x0) * 100
      })
   }, qm.onLoad = () => {
      n({
         active: !1
      })
   }, qm.onError = e => n(t => ({
      errors: [...t.errors, e]
   })), qm.onProgress = (e, t, i) => {
      t === i && (x0 = i), n({
         active: !0,
         item: e,
         loaded: t,
         total: i,
         progress: (t - x0) / (i - x0) * 100 || 100
      })
   }, {
      errors: [],
      active: !1,
      progress: 0,
      item: "",
      loaded: 0,
      total: 0
   })),
   f2 = j.createContext({});

function h2(n) {
   const e = j.useRef(null);
   return e.current === null && (e.current = n()), e.current
}
const d2 = typeof window < "u",
   fz = d2 ? j.useLayoutEffect : j.useEffect,
   LT = j.createContext(null);

function p2(n, e) {
   n.indexOf(e) === -1 && n.push(e)
}

function m2(n, e) {
   const t = n.indexOf(e);
   t > -1 && n.splice(t, 1)
}
const Lc = (n, e, t) => t > e ? e : t < n ? n : t;
let g2 = () => {};
const Bc = {},
   hz = n => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(n);

function dz(n) {
   return typeof n == "object" && n !== null
}
const pz = n => /^0[^.\s]+$/u.test(n);

function v2(n) {
   let e;
   return () => (e === void 0 && (e = n()), e)
}
const tl = n => n,
   MW = (n, e) => t => e(n(t)),
   Ex = (...n) => n.reduce(MW),
   ky = (n, e, t) => {
      const i = e - n;
      return i === 0 ? 1 : (t - n) / i
   };
class y2 {
   constructor() {
      this.subscriptions = []
   }
   add(e) {
      return p2(this.subscriptions, e), () => m2(this.subscriptions, e)
   }
   notify(e, t, i) {
      const s = this.subscriptions.length;
      if (s)
         if (s === 1) this.subscriptions[0](e, t, i);
         else
            for (let r = 0; r < s; r++) {
               const a = this.subscriptions[r];
               a && a(e, t, i)
            }
   }
   getSize() {
      return this.subscriptions.length
   }
   clear() {
      this.subscriptions.length = 0
   }
}
const Bu = n => n * 1e3,
   zu = n => n / 1e3;

function mz(n, e) {
   return e ? n * (1e3 / e) : 0
}
const gz = (n, e, t) => (((1 - 3 * t + 3 * e) * n + (3 * t - 6 * e)) * n + 3 * e) * n,
   AW = 1e-7,
   wW = 12;

function RW(n, e, t, i, s) {
   let r, a, l = 0;
   do a = e + (t - e) / 2, r = gz(a, i, s) - n, r > 0 ? t = a : e = a; while (Math.abs(r) > AW && ++l < wW);
   return a
}

function Mx(n, e, t, i) {
   if (n === e && t === i) return tl;
   const s = r => RW(r, 0, 1, n, t);
   return r => r === 0 || r === 1 ? r : gz(s(r), e, i)
}
const vz = n => e => e <= .5 ? n(2 * e) / 2 : (2 - n(2 * (1 - e))) / 2,
   yz = n => e => 1 - n(1 - e),
   xz = Mx(.33, 1.53, .69, .99),
   x2 = yz(xz),
   _z = vz(x2),
   Sz = n => (n *= 2) < 1 ? .5 * x2(n) : .5 * (2 - Math.pow(2, -10 * (n - 1))),
   _2 = n => 1 - Math.sin(Math.acos(n)),
   bz = yz(_2),
   Tz = vz(_2),
   CW = Mx(.42, 0, 1, 1),
   DW = Mx(0, 0, .58, 1),
   Ez = Mx(.42, 0, .58, 1),
   NW = n => Array.isArray(n) && typeof n[0] != "number",
   Mz = n => Array.isArray(n) && typeof n[0] == "number",
   OW = {
      linear: tl,
      easeIn: CW,
      easeInOut: Ez,
      easeOut: DW,
      circIn: _2,
      circInOut: Tz,
      circOut: bz,
      backIn: x2,
      backInOut: _z,
      backOut: xz,
      anticipate: Sz
   },
   UW = n => typeof n == "string",
   AN = n => {
      if (Mz(n)) {
         g2(n.length === 4);
         const [e, t, i, s] = n;
         return Mx(e, t, i, s)
      } else if (UW(n)) return OW[n];
      return n
   },
   $S = ["setup", "read", "resolveKeyframes", "preUpdate", "update", "preRender", "render", "postRender"],
   wN = {
      value: null
   };

function PW(n, e) {
   let t = new Set,
      i = new Set,
      s = !1,
      r = !1;
   const a = new WeakSet;
   let l = {
         delta: 0,
         timestamp: 0,
         isProcessing: !1
      },
      c = 0;

   function h(g) {
      a.has(g) && (m.schedule(g), n()), c++, g(l)
   }
   const m = {
      schedule: (g, v = !1, x = !1) => {
         const E = x && s ? t : i;
         return v && a.add(g), E.has(g) || E.add(g), g
      },
      cancel: g => {
         i.delete(g), a.delete(g)
      },
      process: g => {
         if (l = g, s) {
            r = !0;
            return
         }
         s = !0, [t, i] = [i, t], t.forEach(h), e && wN.value && wN.value.frameloop[e].push(c), c = 0, t.clear(), s = !1, r && (r = !1, m.process(g))
      }
   };
   return m
}
const LW = 40;

function Az(n, e) {
   let t = !1,
      i = !0;
   const s = {
         delta: 0,
         timestamp: 0,
         isProcessing: !1
      },
      r = () => t = !0,
      a = $S.reduce((C, N) => (C[N] = PW(r, e ? N : void 0), C), {}),
      {
         setup: l,
         read: c,
         resolveKeyframes: h,
         preUpdate: m,
         update: g,
         preRender: v,
         render: x,
         postRender: S
      } = a,
      E = () => {
         const C = Bc.useManualTiming ? s.timestamp : performance.now();
         t = !1, Bc.useManualTiming || (s.delta = i ? 1e3 / 60 : Math.max(Math.min(C - s.timestamp, LW), 1)), s.timestamp = C, s.isProcessing = !0, l.process(s), c.process(s), h.process(s), m.process(s), g.process(s), v.process(s), x.process(s), S.process(s), s.isProcessing = !1, t && e && (i = !1, n(E))
      },
      T = () => {
         t = !0, i = !0, s.isProcessing || n(E)
      };
   return {
      schedule: $S.reduce((C, N) => {
         const U = a[N];
         return C[N] = (z, B = !1, I = !1) => (t || T(), U.schedule(z, B, I)), C
      }, {}),
      cancel: C => {
         for (let N = 0; N < $S.length; N++) a[$S[N]].cancel(C)
      },
      state: s,
      steps: a
   }
}
const {
   schedule: Ii,
   cancel: ah,
   state: mr,
   steps: eA
} = Az(typeof requestAnimationFrame < "u" ? requestAnimationFrame : tl, !0);
let Ab;

function BW() {
   Ab = void 0
}
const La = {
      now: () => (Ab === void 0 && La.set(mr.isProcessing || Bc.useManualTiming ? mr.timestamp : performance.now()), Ab),
      set: n => {
         Ab = n, queueMicrotask(BW)
      }
   },
   wz = n => e => typeof e == "string" && e.startsWith(n),
   S2 = wz("--"),
   zW = wz("var(--"),
   b2 = n => zW(n) ? IW.test(n.split("/*")[0].trim()) : !1,
   IW = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu,
   Fg = {
      test: n => typeof n == "number",
      parse: parseFloat,
      transform: n => n
   },
   jy = {
      ...Fg,
      transform: n => Lc(0, 1, n)
   },
   eb = {
      ...Fg,
      default: 1
   },
   K0 = n => Math.round(n * 1e5) / 1e5,
   T2 = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;

function FW(n) {
   return n == null
}
const HW = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu,
   E2 = (n, e) => t => !!(typeof t == "string" && HW.test(t) && t.startsWith(n) || e && !FW(t) && Object.prototype.hasOwnProperty.call(t, e)),
   Rz = (n, e, t) => i => {
      if (typeof i != "string") return i;
      const [s, r, a, l] = i.match(T2);
      return {
         [n]: parseFloat(s),
         [e]: parseFloat(r),
         [t]: parseFloat(a),
         alpha: l !== void 0 ? parseFloat(l) : 1
      }
   },
   VW = n => Lc(0, 255, n),
   tA = {
      ...Fg,
      transform: n => Math.round(VW(n))
   },
   Pd = {
      test: E2("rgb", "red"),
      parse: Rz("red", "green", "blue"),
      transform: ({
         red: n,
         green: e,
         blue: t,
         alpha: i = 1
      }) => "rgba(" + tA.transform(n) + ", " + tA.transform(e) + ", " + tA.transform(t) + ", " + K0(jy.transform(i)) + ")"
   };

function GW(n) {
   let e = "",
      t = "",
      i = "",
      s = "";
   return n.length > 5 ? (e = n.substring(1, 3), t = n.substring(3, 5), i = n.substring(5, 7), s = n.substring(7, 9)) : (e = n.substring(1, 2), t = n.substring(2, 3), i = n.substring(3, 4), s = n.substring(4, 5), e += e, t += t, i += i, s += s), {
      red: parseInt(e, 16),
      green: parseInt(t, 16),
      blue: parseInt(i, 16),
      alpha: s ? parseInt(s, 16) / 255 : 1
   }
}
const cw = {
      test: E2("#"),
      parse: GW,
      transform: Pd.transform
   },
   Ax = n => ({
      test: e => typeof e == "string" && e.endsWith(n) && e.split(" ").length === 1,
      parse: parseFloat,
      transform: e => `${e}${n}`
   }),
   Vf = Ax("deg"),
   Iu = Ax("%"),
   Jt = Ax("px"),
   kW = Ax("vh"),
   jW = Ax("vw"),
   RN = {
      ...Iu,
      parse: n => Iu.parse(n) / 100,
      transform: n => Iu.transform(n * 100)
   },
   Ym = {
      test: E2("hsl", "hue"),
      parse: Rz("hue", "saturation", "lightness"),
      transform: ({
         hue: n,
         saturation: e,
         lightness: t,
         alpha: i = 1
      }) => "hsla(" + Math.round(n) + ", " + Iu.transform(K0(e)) + ", " + Iu.transform(K0(t)) + ", " + K0(jy.transform(i)) + ")"
   },
   As = {
      test: n => Pd.test(n) || cw.test(n) || Ym.test(n),
      parse: n => Pd.test(n) ? Pd.parse(n) : Ym.test(n) ? Ym.parse(n) : cw.parse(n),
      transform: n => typeof n == "string" ? n : n.hasOwnProperty("red") ? Pd.transform(n) : Ym.transform(n),
      getAnimatableNone: n => {
         const e = As.parse(n);
         return e.alpha = 0, As.transform(e)
      }
   },
   qW = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;

function XW(n) {
   var e, t;
   return isNaN(n) && typeof n == "string" && (((e = n.match(T2)) == null ? void 0 : e.length) || 0) + (((t = n.match(qW)) == null ? void 0 : t.length) || 0) > 0
}
const Cz = "number",
   Dz = "color",
   WW = "var",
   YW = "var(",
   CN = "${}",
   KW = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;

function qy(n) {
   const e = n.toString(),
      t = [],
      i = {
         color: [],
         number: [],
         var: []
      },
      s = [];
   let r = 0;
   const l = e.replace(KW, c => (As.test(c) ? (i.color.push(r), s.push(Dz), t.push(As.parse(c))) : c.startsWith(YW) ? (i.var.push(r), s.push(WW), t.push(c)) : (i.number.push(r), s.push(Cz), t.push(parseFloat(c))), ++r, CN)).split(CN);
   return {
      values: t,
      split: l,
      indexes: i,
      types: s
   }
}

function Nz(n) {
   return qy(n).values
}

function Oz(n) {
   const {
      split: e,
      types: t
   } = qy(n), i = e.length;
   return s => {
      let r = "";
      for (let a = 0; a < i; a++)
         if (r += e[a], s[a] !== void 0) {
            const l = t[a];
            l === Cz ? r += K0(s[a]) : l === Dz ? r += As.transform(s[a]) : r += s[a]
         } return r
   }
}
const ZW = n => typeof n == "number" ? 0 : As.test(n) ? As.getAnimatableNone(n) : n;

function QW(n) {
   const e = Nz(n);
   return Oz(n)(e.map(ZW))
}
const oh = {
   test: XW,
   parse: Nz,
   createTransformer: Oz,
   getAnimatableNone: QW
};

function nA(n, e, t) {
   return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? n + (e - n) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? n + (e - n) * (2 / 3 - t) * 6 : n
}

function JW({
   hue: n,
   saturation: e,
   lightness: t,
   alpha: i
}) {
   n /= 360, e /= 100, t /= 100;
   let s = 0,
      r = 0,
      a = 0;
   if (!e) s = r = a = t;
   else {
      const l = t < .5 ? t * (1 + e) : t + e - t * e,
         c = 2 * t - l;
      s = nA(c, l, n + 1 / 3), r = nA(c, l, n), a = nA(c, l, n - 1 / 3)
   }
   return {
      red: Math.round(s * 255),
      green: Math.round(r * 255),
      blue: Math.round(a * 255),
      alpha: i
   }
}

function w1(n, e) {
   return t => t > 0 ? e : n
}
const Yi = (n, e, t) => n + (e - n) * t,
   iA = (n, e, t) => {
      const i = n * n,
         s = t * (e * e - i) + i;
      return s < 0 ? 0 : Math.sqrt(s)
   },
   $W = [cw, Pd, Ym],
   eY = n => $W.find(e => e.test(n));

function DN(n) {
   const e = eY(n);
   if (!e) return !1;
   let t = e.parse(n);
   return e === Ym && (t = JW(t)), t
}
const NN = (n, e) => {
      const t = DN(n),
         i = DN(e);
      if (!t || !i) return w1(n, e);
      const s = {
         ...t
      };
      return r => (s.red = iA(t.red, i.red, r), s.green = iA(t.green, i.green, r), s.blue = iA(t.blue, i.blue, r), s.alpha = Yi(t.alpha, i.alpha, r), Pd.transform(s))
   },
   fw = new Set(["none", "hidden"]);

function tY(n, e) {
   return fw.has(n) ? t => t <= 0 ? n : e : t => t >= 1 ? e : n
}

function nY(n, e) {
   return t => Yi(n, e, t)
}

function M2(n) {
   return typeof n == "number" ? nY : typeof n == "string" ? b2(n) ? w1 : As.test(n) ? NN : rY : Array.isArray(n) ? Uz : typeof n == "object" ? As.test(n) ? NN : iY : w1
}

function Uz(n, e) {
   const t = [...n],
      i = t.length,
      s = n.map((r, a) => M2(r)(r, e[a]));
   return r => {
      for (let a = 0; a < i; a++) t[a] = s[a](r);
      return t
   }
}

function iY(n, e) {
   const t = {
         ...n,
         ...e
      },
      i = {};
   for (const s in t) n[s] !== void 0 && e[s] !== void 0 && (i[s] = M2(n[s])(n[s], e[s]));
   return s => {
      for (const r in i) t[r] = i[r](s);
      return t
   }
}

function sY(n, e) {
   const t = [],
      i = {
         color: 0,
         var: 0,
         number: 0
      };
   for (let s = 0; s < e.values.length; s++) {
      const r = e.types[s],
         a = n.indexes[r][i[r]],
         l = n.values[a] ?? 0;
      t[s] = l, i[r]++
   }
   return t
}
const rY = (n, e) => {
   const t = oh.createTransformer(e),
      i = qy(n),
      s = qy(e);
   return i.indexes.var.length === s.indexes.var.length && i.indexes.color.length === s.indexes.color.length && i.indexes.number.length >= s.indexes.number.length ? fw.has(n) && !s.values.length || fw.has(e) && !i.values.length ? tY(n, e) : Ex(Uz(sY(i, s), s.values), t) : w1(n, e)
};

function Pz(n, e, t) {
   return typeof n == "number" && typeof e == "number" && typeof t == "number" ? Yi(n, e, t) : M2(n)(n, e)
}
const aY = n => {
      const e = ({
         timestamp: t
      }) => n(t);
      return {
         start: (t = !0) => Ii.update(e, t),
         stop: () => ah(e),
         now: () => mr.isProcessing ? mr.timestamp : La.now()
      }
   },
   Lz = (n, e, t = 10) => {
      let i = "";
      const s = Math.max(Math.round(e / t), 2);
      for (let r = 0; r < s; r++) i += Math.round(n(r / (s - 1)) * 1e4) / 1e4 + ", ";
      return `linear(${i.substring(0,i.length-2)})`
   },
   R1 = 2e4;

function A2(n) {
   let e = 0;
   const t = 50;
   let i = n.next(e);
   for (; !i.done && e < R1;) e += t, i = n.next(e);
   return e >= R1 ? 1 / 0 : e
}

function oY(n, e = 100, t) {
   const i = t({
         ...n,
         keyframes: [0, e]
      }),
      s = Math.min(A2(i), R1);
   return {
      type: "keyframes",
      ease: r => i.next(s * r).value / e,
      duration: zu(s)
   }
}
const lY = 5;

function Bz(n, e, t) {
   const i = Math.max(e - lY, 0);
   return mz(t - n(i), e - i)
}
const ns = {
      stiffness: 100,
      damping: 10,
      mass: 1,
      velocity: 0,
      duration: 800,
      bounce: .3,
      visualDuration: .3,
      restSpeed: {
         granular: .01,
         default: 2
      },
      restDelta: {
         granular: .005,
         default: .5
      },
      minDuration: .01,
      maxDuration: 10,
      minDamping: .05,
      maxDamping: 1
   },
   sA = .001;

function uY({
   duration: n = ns.duration,
   bounce: e = ns.bounce,
   velocity: t = ns.velocity,
   mass: i = ns.mass
}) {
   let s, r, a = 1 - e;
   a = Lc(ns.minDamping, ns.maxDamping, a), n = Lc(ns.minDuration, ns.maxDuration, zu(n)), a < 1 ? (s = h => {
      const m = h * a,
         g = m * n,
         v = m - t,
         x = hw(h, a),
         S = Math.exp(-g);
      return sA - v / x * S
   }, r = h => {
      const g = h * a * n,
         v = g * t + t,
         x = Math.pow(a, 2) * Math.pow(h, 2) * n,
         S = Math.exp(-g),
         E = hw(Math.pow(h, 2), a);
      return (-s(h) + sA > 0 ? -1 : 1) * ((v - x) * S) / E
   }) : (s = h => {
      const m = Math.exp(-h * n),
         g = (h - t) * n + 1;
      return -sA + m * g
   }, r = h => {
      const m = Math.exp(-h * n),
         g = (t - h) * (n * n);
      return m * g
   });
   const l = 5 / n,
      c = fY(s, r, l);
   if (n = Bu(n), isNaN(c)) return {
      stiffness: ns.stiffness,
      damping: ns.damping,
      duration: n
   }; {
      const h = Math.pow(c, 2) * i;
      return {
         stiffness: h,
         damping: a * 2 * Math.sqrt(i * h),
         duration: n
      }
   }
}
const cY = 12;

function fY(n, e, t) {
   let i = t;
   for (let s = 1; s < cY; s++) i = i - n(i) / e(i);
   return i
}

function hw(n, e) {
   return n * Math.sqrt(1 - e * e)
}
const hY = ["duration", "bounce"],
   dY = ["stiffness", "damping", "mass"];

function ON(n, e) {
   return e.some(t => n[t] !== void 0)
}

function pY(n) {
   let e = {
      velocity: ns.velocity,
      stiffness: ns.stiffness,
      damping: ns.damping,
      mass: ns.mass,
      isResolvedFromDuration: !1,
      ...n
   };
   if (!ON(n, dY) && ON(n, hY))
      if (n.visualDuration) {
         const t = n.visualDuration,
            i = 2 * Math.PI / (t * 1.2),
            s = i * i,
            r = 2 * Lc(.05, 1, 1 - (n.bounce || 0)) * Math.sqrt(s);
         e = {
            ...e,
            mass: ns.mass,
            stiffness: s,
            damping: r
         }
      } else {
         const t = uY(n);
         e = {
            ...e,
            ...t,
            mass: ns.mass
         }, e.isResolvedFromDuration = !0
      } return e
}

function C1(n = ns.visualDuration, e = ns.bounce) {
   const t = typeof n != "object" ? {
      visualDuration: n,
      keyframes: [0, 1],
      bounce: e
   } : n;
   let {
      restSpeed: i,
      restDelta: s
   } = t;
   const r = t.keyframes[0],
      a = t.keyframes[t.keyframes.length - 1],
      l = {
         done: !1,
         value: r
      },
      {
         stiffness: c,
         damping: h,
         mass: m,
         duration: g,
         velocity: v,
         isResolvedFromDuration: x
      } = pY({
         ...t,
         velocity: -zu(t.velocity || 0)
      }),
      S = v || 0,
      E = h / (2 * Math.sqrt(c * m)),
      T = a - r,
      b = zu(Math.sqrt(c / m)),
      w = Math.abs(T) < 5;
   i || (i = w ? ns.restSpeed.granular : ns.restSpeed.default), s || (s = w ? ns.restDelta.granular : ns.restDelta.default);
   let C;
   if (E < 1) {
      const U = hw(b, E);
      C = z => {
         const B = Math.exp(-E * b * z);
         return a - B * ((S + E * b * T) / U * Math.sin(U * z) + T * Math.cos(U * z))
      }
   } else if (E === 1) C = U => a - Math.exp(-b * U) * (T + (S + b * T) * U);
   else {
      const U = b * Math.sqrt(E * E - 1);
      C = z => {
         const B = Math.exp(-E * b * z),
            I = Math.min(U * z, 300);
         return a - B * ((S + E * b * T) * Math.sinh(I) + U * T * Math.cosh(I)) / U
      }
   }
   const N = {
      calculatedDuration: x && g || null,
      next: U => {
         const z = C(U);
         if (x) l.done = U >= g;
         else {
            let B = U === 0 ? S : 0;
            E < 1 && (B = U === 0 ? Bu(S) : Bz(C, U, z));
            const I = Math.abs(B) <= i,
               O = Math.abs(a - z) <= s;
            l.done = I && O
         }
         return l.value = l.done ? a : z, l
      },
      toString: () => {
         const U = Math.min(A2(N), R1),
            z = Lz(B => N.next(U * B).value, U, 30);
         return U + "ms " + z
      },
      toTransition: () => {}
   };
   return N
}
C1.applyToOptions = n => {
   const e = oY(n, 100, C1);
   return n.ease = e.ease, n.duration = Bu(e.duration), n.type = "keyframes", n
};

function dw({
   keyframes: n,
   velocity: e = 0,
   power: t = .8,
   timeConstant: i = 325,
   bounceDamping: s = 10,
   bounceStiffness: r = 500,
   modifyTarget: a,
   min: l,
   max: c,
   restDelta: h = .5,
   restSpeed: m
}) {
   const g = n[0],
      v = {
         done: !1,
         value: g
      },
      x = I => l !== void 0 && I < l || c !== void 0 && I > c,
      S = I => l === void 0 ? c : c === void 0 || Math.abs(l - I) < Math.abs(c - I) ? l : c;
   let E = t * e;
   const T = g + E,
      b = a === void 0 ? T : a(T);
   b !== T && (E = b - g);
   const w = I => -E * Math.exp(-I / i),
      C = I => b + w(I),
      N = I => {
         const O = w(I),
            P = C(I);
         v.done = Math.abs(O) <= h, v.value = v.done ? b : P
      };
   let U, z;
   const B = I => {
      x(v.value) && (U = I, z = C1({
         keyframes: [v.value, S(v.value)],
         velocity: Bz(C, I, v.value),
         damping: s,
         stiffness: r,
         restDelta: h,
         restSpeed: m
      }))
   };
   return B(0), {
      calculatedDuration: null,
      next: I => {
         let O = !1;
         return !z && U === void 0 && (O = !0, N(I), B(I)), U !== void 0 && I >= U ? z.next(I - U) : (!O && N(I), v)
      }
   }
}

function mY(n, e, t) {
   const i = [],
      s = t || Bc.mix || Pz,
      r = n.length - 1;
   for (let a = 0; a < r; a++) {
      let l = s(n[a], n[a + 1]);
      if (e) {
         const c = Array.isArray(e) ? e[a] || tl : e;
         l = Ex(c, l)
      }
      i.push(l)
   }
   return i
}

function gY(n, e, {
   clamp: t = !0,
   ease: i,
   mixer: s
} = {}) {
   const r = n.length;
   if (g2(r === e.length), r === 1) return () => e[0];
   if (r === 2 && e[0] === e[1]) return () => e[1];
   const a = n[0] === n[1];
   n[0] > n[r - 1] && (n = [...n].reverse(), e = [...e].reverse());
   const l = mY(e, i, s),
      c = l.length,
      h = m => {
         if (a && m < n[0]) return e[0];
         let g = 0;
         if (c > 1)
            for (; g < n.length - 2 && !(m < n[g + 1]); g++);
         const v = ky(n[g], n[g + 1], m);
         return l[g](v)
      };
   return t ? m => h(Lc(n[0], n[r - 1], m)) : h
}

function vY(n, e) {
   const t = n[n.length - 1];
   for (let i = 1; i <= e; i++) {
      const s = ky(0, e, i);
      n.push(Yi(t, 1, s))
   }
}

function yY(n) {
   const e = [0];
   return vY(e, n.length - 1), e
}

function xY(n, e) {
   return n.map(t => t * e)
}

function _Y(n, e) {
   return n.map(() => e || Ez).splice(0, n.length - 1)
}

function Z0({
   duration: n = 300,
   keyframes: e,
   times: t,
   ease: i = "easeInOut"
}) {
   const s = NW(i) ? i.map(AN) : AN(i),
      r = {
         done: !1,
         value: e[0]
      },
      a = xY(t && t.length === e.length ? t : yY(e), n),
      l = gY(a, e, {
         ease: Array.isArray(s) ? s : _Y(e, s)
      });
   return {
      calculatedDuration: n,
      next: c => (r.value = l(c), r.done = c >= n, r)
   }
}
const SY = n => n !== null;

function w2(n, {
   repeat: e,
   repeatType: t = "loop"
}, i, s = 1) {
   const r = n.filter(SY),
      l = s < 0 || e && t !== "loop" && e % 2 === 1 ? 0 : r.length - 1;
   return !l || i === void 0 ? r[l] : i
}
const bY = {
   decay: dw,
   inertia: dw,
   tween: Z0,
   keyframes: Z0,
   spring: C1
};

function zz(n) {
   typeof n.type == "string" && (n.type = bY[n.type])
}
class R2 {
   constructor() {
      this.updateFinished()
   }
   get finished() {
      return this._finished
   }
   updateFinished() {
      this._finished = new Promise(e => {
         this.resolve = e
      })
   }
   notifyFinished() {
      this.resolve()
   }
   then(e, t) {
      return this.finished.then(e, t)
   }
}
const TY = n => n / 100;
class C2 extends R2 {
   constructor(e) {
      super(), this.state = "idle", this.startTime = null, this.isStopped = !1, this.currentTime = 0, this.holdTime = null, this.playbackSpeed = 1, this.stop = () => {
         var i, s;
         const {
            motionValue: t
         } = this.options;
         t && t.updatedAt !== La.now() && this.tick(La.now()), this.isStopped = !0, this.state !== "idle" && (this.teardown(), (s = (i = this.options).onStop) == null || s.call(i))
      }, this.options = e, this.initAnimation(), this.play(), e.autoplay === !1 && this.pause()
   }
   initAnimation() {
      const {
         options: e
      } = this;
      zz(e);
      const {
         type: t = Z0,
         repeat: i = 0,
         repeatDelay: s = 0,
         repeatType: r,
         velocity: a = 0
      } = e;
      let {
         keyframes: l
      } = e;
      const c = t || Z0;
      c !== Z0 && typeof l[0] != "number" && (this.mixKeyframes = Ex(TY, Pz(l[0], l[1])), l = [0, 100]);
      const h = c({
         ...e,
         keyframes: l
      });
      r === "mirror" && (this.mirroredGenerator = c({
         ...e,
         keyframes: [...l].reverse(),
         velocity: -a
      })), h.calculatedDuration === null && (h.calculatedDuration = A2(h));
      const {
         calculatedDuration: m
      } = h;
      this.calculatedDuration = m, this.resolvedDuration = m + s, this.totalDuration = this.resolvedDuration * (i + 1) - s, this.generator = h
   }
   updateTime(e) {
      const t = Math.round(e - this.startTime) * this.playbackSpeed;
      this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = t
   }
   tick(e, t = !1) {
      const {
         generator: i,
         totalDuration: s,
         mixKeyframes: r,
         mirroredGenerator: a,
         resolvedDuration: l,
         calculatedDuration: c
      } = this;
      if (this.startTime === null) return i.next(0);
      const {
         delay: h = 0,
         keyframes: m,
         repeat: g,
         repeatType: v,
         repeatDelay: x,
         type: S,
         onUpdate: E,
         finalKeyframe: T
      } = this.options;
      this.speed > 0 ? this.startTime = Math.min(this.startTime, e) : this.speed < 0 && (this.startTime = Math.min(e - s / this.speed, this.startTime)), t ? this.currentTime = e : this.updateTime(e);
      const b = this.currentTime - h * (this.playbackSpeed >= 0 ? 1 : -1),
         w = this.playbackSpeed >= 0 ? b < 0 : b > s;
      this.currentTime = Math.max(b, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = s);
      let C = this.currentTime,
         N = i;
      if (g) {
         const I = Math.min(this.currentTime, s) / l;
         let O = Math.floor(I),
            P = I % 1;
         !P && I >= 1 && (P = 1), P === 1 && O--, O = Math.min(O, g + 1), !!(O % 2) && (v === "reverse" ? (P = 1 - P, x && (P -= x / l)) : v === "mirror" && (N = a)), C = Lc(0, 1, P) * l
      }
      const U = w ? {
         done: !1,
         value: m[0]
      } : N.next(C);
      r && (U.value = r(U.value));
      let {
         done: z
      } = U;
      !w && c !== null && (z = this.playbackSpeed >= 0 ? this.currentTime >= s : this.currentTime <= 0);
      const B = this.holdTime === null && (this.state === "finished" || this.state === "running" && z);
      return B && S !== dw && (U.value = w2(m, this.options, T, this.speed)), E && E(U.value), B && this.finish(), U
   }
   then(e, t) {
      return this.finished.then(e, t)
   }
   get duration() {
      return zu(this.calculatedDuration)
   }
   get time() {
      return zu(this.currentTime)
   }
   set time(e) {
      var t;
      e = Bu(e), this.currentTime = e, this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0 ? this.holdTime = e : this.driver && (this.startTime = this.driver.now() - e / this.playbackSpeed), (t = this.driver) == null || t.start(!1)
   }
   get speed() {
      return this.playbackSpeed
   }
   set speed(e) {
      this.updateTime(La.now());
      const t = this.playbackSpeed !== e;
      this.playbackSpeed = e, t && (this.time = zu(this.currentTime))
   }
   play() {
      var s, r;
      if (this.isStopped) return;
      const {
         driver: e = aY,
         startTime: t
      } = this.options;
      this.driver || (this.driver = e(a => this.tick(a))), (r = (s = this.options).onPlay) == null || r.call(s);
      const i = this.driver.now();
      this.state === "finished" ? (this.updateFinished(), this.startTime = i) : this.holdTime !== null ? this.startTime = i - this.holdTime : this.startTime || (this.startTime = t ?? i), this.state === "finished" && this.speed < 0 && (this.startTime += this.calculatedDuration), this.holdTime = null, this.state = "running", this.driver.start()
   }
   pause() {
      this.state = "paused", this.updateTime(La.now()), this.holdTime = this.currentTime
   }
   complete() {
      this.state !== "running" && this.play(), this.state = "finished", this.holdTime = null
   }
   finish() {
      var e, t;
      this.notifyFinished(), this.teardown(), this.state = "finished", (t = (e = this.options).onComplete) == null || t.call(e)
   }
   cancel() {
      var e, t;
      this.holdTime = null, this.startTime = 0, this.tick(0), this.teardown(), (t = (e = this.options).onCancel) == null || t.call(e)
   }
   teardown() {
      this.state = "idle", this.stopDriver(), this.startTime = this.holdTime = null
   }
   stopDriver() {
      this.driver && (this.driver.stop(), this.driver = void 0)
   }
   sample(e) {
      return this.startTime = 0, this.tick(e, !0)
   }
   attachTimeline(e) {
      var t;
      return this.options.allowFlatten && (this.options.type = "keyframes", this.options.ease = "linear", this.initAnimation()), (t = this.driver) == null || t.stop(), e.observe(this)
   }
}

function EY(n) {
   for (let e = 1; e < n.length; e++) n[e] ?? (n[e] = n[e - 1])
}
const Ld = n => n * 180 / Math.PI,
   pw = n => {
      const e = Ld(Math.atan2(n[1], n[0]));
      return mw(e)
   },
   MY = {
      x: 4,
      y: 5,
      translateX: 4,
      translateY: 5,
      scaleX: 0,
      scaleY: 3,
      scale: n => (Math.abs(n[0]) + Math.abs(n[3])) / 2,
      rotate: pw,
      rotateZ: pw,
      skewX: n => Ld(Math.atan(n[1])),
      skewY: n => Ld(Math.atan(n[2])),
      skew: n => (Math.abs(n[1]) + Math.abs(n[2])) / 2
   },
   mw = n => (n = n % 360, n < 0 && (n += 360), n),
   UN = pw,
   PN = n => Math.sqrt(n[0] * n[0] + n[1] * n[1]),
   LN = n => Math.sqrt(n[4] * n[4] + n[5] * n[5]),
   AY = {
      x: 12,
      y: 13,
      z: 14,
      translateX: 12,
      translateY: 13,
      translateZ: 14,
      scaleX: PN,
      scaleY: LN,
      scale: n => (PN(n) + LN(n)) / 2,
      rotateX: n => mw(Ld(Math.atan2(n[6], n[5]))),
      rotateY: n => mw(Ld(Math.atan2(-n[2], n[0]))),
      rotateZ: UN,
      rotate: UN,
      skewX: n => Ld(Math.atan(n[4])),
      skewY: n => Ld(Math.atan(n[1])),
      skew: n => (Math.abs(n[1]) + Math.abs(n[4])) / 2
   };

function gw(n) {
   return n.includes("scale") ? 1 : 0
}

function vw(n, e) {
   if (!n || n === "none") return gw(e);
   const t = n.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);
   let i, s;
   if (t) i = AY, s = t;
   else {
      const l = n.match(/^matrix\(([-\d.e\s,]+)\)$/u);
      i = MY, s = l
   }
   if (!s) return gw(e);
   const r = i[e],
      a = s[1].split(",").map(RY);
   return typeof r == "function" ? r(a) : a[r]
}
const wY = (n, e) => {
   const {
      transform: t = "none"
   } = getComputedStyle(n);
   return vw(t, e)
};

function RY(n) {
   return parseFloat(n.trim())
}
const Hg = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"],
   Vg = new Set(Hg),
   BN = n => n === Fg || n === Jt,
   CY = new Set(["x", "y", "z"]),
   DY = Hg.filter(n => !CY.has(n));

function NY(n) {
   const e = [];
   return DY.forEach(t => {
      const i = n.getValue(t);
      i !== void 0 && (e.push([t, i.get()]), i.set(t.startsWith("scale") ? 1 : 0))
   }), e
}
const Gd = {
   width: ({
      x: n
   }, {
      paddingLeft: e = "0",
      paddingRight: t = "0"
   }) => n.max - n.min - parseFloat(e) - parseFloat(t),
   height: ({
      y: n
   }, {
      paddingTop: e = "0",
      paddingBottom: t = "0"
   }) => n.max - n.min - parseFloat(e) - parseFloat(t),
   top: (n, {
      top: e
   }) => parseFloat(e),
   left: (n, {
      left: e
   }) => parseFloat(e),
   bottom: ({
      y: n
   }, {
      top: e
   }) => parseFloat(e) + (n.max - n.min),
   right: ({
      x: n
   }, {
      left: e
   }) => parseFloat(e) + (n.max - n.min),
   x: (n, {
      transform: e
   }) => vw(e, "x"),
   y: (n, {
      transform: e
   }) => vw(e, "y")
};
Gd.translateX = Gd.x;
Gd.translateY = Gd.y;
const kd = new Set;
let yw = !1,
   xw = !1,
   _w = !1;

function Iz() {
   if (xw) {
      const n = Array.from(kd).filter(i => i.needsMeasurement),
         e = new Set(n.map(i => i.element)),
         t = new Map;
      e.forEach(i => {
         const s = NY(i);
         s.length && (t.set(i, s), i.render())
      }), n.forEach(i => i.measureInitialState()), e.forEach(i => {
         i.render();
         const s = t.get(i);
         s && s.forEach(([r, a]) => {
            var l;
            (l = i.getValue(r)) == null || l.set(a)
         })
      }), n.forEach(i => i.measureEndState()), n.forEach(i => {
         i.suspendedScrollY !== void 0 && window.scrollTo(0, i.suspendedScrollY)
      })
   }
   xw = !1, yw = !1, kd.forEach(n => n.complete(_w)), kd.clear()
}

function Fz() {
   kd.forEach(n => {
      n.readKeyframes(), n.needsMeasurement && (xw = !0)
   })
}

function OY() {
   _w = !0, Fz(), Iz(), _w = !1
}
class D2 {
   constructor(e, t, i, s, r, a = !1) {
      this.state = "pending", this.isAsync = !1, this.needsMeasurement = !1, this.unresolvedKeyframes = [...e], this.onComplete = t, this.name = i, this.motionValue = s, this.element = r, this.isAsync = a
   }
   scheduleResolve() {
      this.state = "scheduled", this.isAsync ? (kd.add(this), yw || (yw = !0, Ii.read(Fz), Ii.resolveKeyframes(Iz))) : (this.readKeyframes(), this.complete())
   }
   readKeyframes() {
      const {
         unresolvedKeyframes: e,
         name: t,
         element: i,
         motionValue: s
      } = this;
      if (e[0] === null) {
         const r = s == null ? void 0 : s.get(),
            a = e[e.length - 1];
         if (r !== void 0) e[0] = r;
         else if (i && t) {
            const l = i.readValue(t, a);
            l != null && (e[0] = l)
         }
         e[0] === void 0 && (e[0] = a), s && r === void 0 && s.set(e[0])
      }
      EY(e)
   }
   setFinalKeyframe() {}
   measureInitialState() {}
   renderEndStyles() {}
   measureEndState() {}
   complete(e = !1) {
      this.state = "complete", this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, e), kd.delete(this)
   }
   cancel() {
      this.state === "scheduled" && (kd.delete(this), this.state = "pending")
   }
   resume() {
      this.state === "pending" && this.scheduleResolve()
   }
}
const UY = n => n.startsWith("--");

function PY(n, e, t) {
   UY(e) ? n.style.setProperty(e, t) : n.style[e] = t
}
const LY = v2(() => window.ScrollTimeline !== void 0),
   BY = {};

function zY(n, e) {
   const t = v2(n);
   return () => BY[e] ?? t()
}
const Hz = zY(() => {
      try {
         document.createElement("div").animate({
            opacity: 0
         }, {
            easing: "linear(0, 1)"
         })
      } catch {
         return !1
      }
      return !0
   }, "linearEasing"),
   D0 = ([n, e, t, i]) => `cubic-bezier(${n}, ${e}, ${t}, ${i})`,
   zN = {
      linear: "linear",
      ease: "ease",
      easeIn: "ease-in",
      easeOut: "ease-out",
      easeInOut: "ease-in-out",
      circIn: D0([0, .65, .55, 1]),
      circOut: D0([.55, 0, 1, .45]),
      backIn: D0([.31, .01, .66, -.59]),
      backOut: D0([.33, 1.53, .69, .99])
   };

function Vz(n, e) {
   if (n) return typeof n == "function" ? Hz() ? Lz(n, e) : "ease-out" : Mz(n) ? D0(n) : Array.isArray(n) ? n.map(t => Vz(t, e) || zN.easeOut) : zN[n]
}

function IY(n, e, t, {
   delay: i = 0,
   duration: s = 300,
   repeat: r = 0,
   repeatType: a = "loop",
   ease: l = "easeOut",
   times: c
} = {}, h = void 0) {
   const m = {
      [e]: t
   };
   c && (m.offset = c);
   const g = Vz(l, s);
   Array.isArray(g) && (m.easing = g);
   const v = {
      delay: i,
      duration: s,
      easing: Array.isArray(g) ? "linear" : g,
      fill: "both",
      iterations: r + 1,
      direction: a === "reverse" ? "alternate" : "normal"
   };
   return h && (v.pseudoElement = h), n.animate(m, v)
}

function Gz(n) {
   return typeof n == "function" && "applyToOptions" in n
}

function FY({
   type: n,
   ...e
}) {
   return Gz(n) && Hz() ? n.applyToOptions(e) : (e.duration ?? (e.duration = 300), e.ease ?? (e.ease = "easeOut"), e)
}
class HY extends R2 {
   constructor(e) {
      if (super(), this.finishedTime = null, this.isStopped = !1, !e) return;
      const {
         element: t,
         name: i,
         keyframes: s,
         pseudoElement: r,
         allowFlatten: a = !1,
         finalKeyframe: l,
         onComplete: c
      } = e;
      this.isPseudoElement = !!r, this.allowFlatten = a, this.options = e, g2(typeof e.type != "string");
      const h = FY(e);
      this.animation = IY(t, i, s, h, r), h.autoplay === !1 && this.animation.pause(), this.animation.onfinish = () => {
         if (this.finishedTime = this.time, !r) {
            const m = w2(s, this.options, l, this.speed);
            this.updateMotionValue ? this.updateMotionValue(m) : PY(t, i, m), this.animation.cancel()
         }
         c == null || c(), this.notifyFinished()
      }
   }
   play() {
      this.isStopped || (this.animation.play(), this.state === "finished" && this.updateFinished())
   }
   pause() {
      this.animation.pause()
   }
   complete() {
      var e, t;
      (t = (e = this.animation).finish) == null || t.call(e)
   }
   cancel() {
      try {
         this.animation.cancel()
      } catch {}
   }
   stop() {
      if (this.isStopped) return;
      this.isStopped = !0;
      const {
         state: e
      } = this;
      e === "idle" || e === "finished" || (this.updateMotionValue ? this.updateMotionValue() : this.commitStyles(), this.isPseudoElement || this.cancel())
   }
   commitStyles() {
      var e, t;
      this.isPseudoElement || (t = (e = this.animation).commitStyles) == null || t.call(e)
   }
   get duration() {
      var t, i;
      const e = ((i = (t = this.animation.effect) == null ? void 0 : t.getComputedTiming) == null ? void 0 : i.call(t).duration) || 0;
      return zu(Number(e))
   }
   get time() {
      return zu(Number(this.animation.currentTime) || 0)
   }
   set time(e) {
      this.finishedTime = null, this.animation.currentTime = Bu(e)
   }
   get speed() {
      return this.animation.playbackRate
   }
   set speed(e) {
      e < 0 && (this.finishedTime = null), this.animation.playbackRate = e
   }
   get state() {
      return this.finishedTime !== null ? "finished" : this.animation.playState
   }
   get startTime() {
      return Number(this.animation.startTime)
   }
   set startTime(e) {
      this.animation.startTime = e
   }
   attachTimeline({
      timeline: e,
      observe: t
   }) {
      var i;
      return this.allowFlatten && ((i = this.animation.effect) == null || i.updateTiming({
         easing: "linear"
      })), this.animation.onfinish = null, e && LY() ? (this.animation.timeline = e, tl) : t(this)
   }
}
const kz = {
   anticipate: Sz,
   backInOut: _z,
   circInOut: Tz
};

function VY(n) {
   return n in kz
}

function GY(n) {
   typeof n.ease == "string" && VY(n.ease) && (n.ease = kz[n.ease])
}
const IN = 10;
class kY extends HY {
   constructor(e) {
      GY(e), zz(e), super(e), e.startTime && (this.startTime = e.startTime), this.options = e
   }
   updateMotionValue(e) {
      const {
         motionValue: t,
         onUpdate: i,
         onComplete: s,
         element: r,
         ...a
      } = this.options;
      if (!t) return;
      if (e !== void 0) {
         t.set(e);
         return
      }
      const l = new C2({
            ...a,
            autoplay: !1
         }),
         c = Bu(this.finishedTime ?? this.time);
      t.setWithVelocity(l.sample(c - IN).value, l.sample(c).value, IN), l.stop()
   }
}
const FN = (n, e) => e === "zIndex" ? !1 : !!(typeof n == "number" || Array.isArray(n) || typeof n == "string" && (oh.test(n) || n === "0") && !n.startsWith("url("));

function jY(n) {
   const e = n[0];
   if (n.length === 1) return !0;
   for (let t = 0; t < n.length; t++)
      if (n[t] !== e) return !0
}

function qY(n, e, t, i) {
   const s = n[0];
   if (s === null) return !1;
   if (e === "display" || e === "visibility") return !0;
   const r = n[n.length - 1],
      a = FN(s, e),
      l = FN(r, e);
   return !a || !l ? !1 : jY(n) || (t === "spring" || Gz(t)) && i
}

function N2(n) {
   return dz(n) && "offsetHeight" in n
}
const XY = new Set(["opacity", "clipPath", "filter", "transform"]),
   WY = v2(() => Object.hasOwnProperty.call(Element.prototype, "animate"));

function YY(n) {
   var h;
   const {
      motionValue: e,
      name: t,
      repeatDelay: i,
      repeatType: s,
      damping: r,
      type: a
   } = n;
   if (!N2((h = e == null ? void 0 : e.owner) == null ? void 0 : h.current)) return !1;
   const {
      onUpdate: l,
      transformTemplate: c
   } = e.owner.getProps();
   return WY() && t && XY.has(t) && (t !== "transform" || !c) && !l && !i && s !== "mirror" && r !== 0 && a !== "inertia"
}
const KY = 40;
class ZY extends R2 {
   constructor({
      autoplay: e = !0,
      delay: t = 0,
      type: i = "keyframes",
      repeat: s = 0,
      repeatDelay: r = 0,
      repeatType: a = "loop",
      keyframes: l,
      name: c,
      motionValue: h,
      element: m,
      ...g
   }) {
      var S;
      super(), this.stop = () => {
         var E, T;
         this._animation && (this._animation.stop(), (E = this.stopTimeline) == null || E.call(this)), (T = this.keyframeResolver) == null || T.cancel()
      }, this.createdAt = La.now();
      const v = {
            autoplay: e,
            delay: t,
            type: i,
            repeat: s,
            repeatDelay: r,
            repeatType: a,
            name: c,
            motionValue: h,
            element: m,
            ...g
         },
         x = (m == null ? void 0 : m.KeyframeResolver) || D2;
      this.keyframeResolver = new x(l, (E, T, b) => this.onKeyframesResolved(E, T, v, !b), c, h, m), (S = this.keyframeResolver) == null || S.scheduleResolve()
   }
   onKeyframesResolved(e, t, i, s) {
      this.keyframeResolver = void 0;
      const {
         name: r,
         type: a,
         velocity: l,
         delay: c,
         isHandoff: h,
         onUpdate: m
      } = i;
      this.resolvedAt = La.now(), qY(e, r, a, l) || ((Bc.instantAnimations || !c) && (m == null || m(w2(e, i, t))), e[0] = e[e.length - 1], i.duration = 0, i.repeat = 0);
      const v = {
            startTime: s ? this.resolvedAt ? this.resolvedAt - this.createdAt > KY ? this.resolvedAt : this.createdAt : this.createdAt : void 0,
            finalKeyframe: t,
            ...i,
            keyframes: e
         },
         x = !h && YY(v) ? new kY({
            ...v,
            element: v.motionValue.owner.current
         }) : new C2(v);
      x.finished.then(() => this.notifyFinished()).catch(tl), this.pendingTimeline && (this.stopTimeline = x.attachTimeline(this.pendingTimeline), this.pendingTimeline = void 0), this._animation = x
   }
   get finished() {
      return this._animation ? this.animation.finished : this._finished
   }
   then(e, t) {
      return this.finished.finally(e).then(() => {})
   }
   get animation() {
      var e;
      return this._animation || ((e = this.keyframeResolver) == null || e.resume(), OY()), this._animation
   }
   get duration() {
      return this.animation.duration
   }
   get time() {
      return this.animation.time
   }
   set time(e) {
      this.animation.time = e
   }
   get speed() {
      return this.animation.speed
   }
   get state() {
      return this.animation.state
   }
   set speed(e) {
      this.animation.speed = e
   }
   get startTime() {
      return this.animation.startTime
   }
   attachTimeline(e) {
      return this._animation ? this.stopTimeline = this.animation.attachTimeline(e) : this.pendingTimeline = e, () => this.stop()
   }
   play() {
      this.animation.play()
   }
   pause() {
      this.animation.pause()
   }
   complete() {
      this.animation.complete()
   }
   cancel() {
      var e;
      this._animation && this.animation.cancel(), (e = this.keyframeResolver) == null || e.cancel()
   }
}
const QY = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;

function JY(n) {
   const e = QY.exec(n);
   if (!e) return [, ];
   const [, t, i, s] = e;
   return [`--${t??i}`, s]
}

function jz(n, e, t = 1) {
   const [i, s] = JY(n);
   if (!i) return;
   const r = window.getComputedStyle(e).getPropertyValue(i);
   if (r) {
      const a = r.trim();
      return hz(a) ? parseFloat(a) : a
   }
   return b2(s) ? jz(s, e, t + 1) : s
}

function O2(n, e) {
   return (n == null ? void 0 : n[e]) ?? (n == null ? void 0 : n.default) ?? n
}
const qz = new Set(["width", "height", "top", "left", "right", "bottom", ...Hg]),
   $Y = {
      test: n => n === "auto",
      parse: n => n
   },
   Xz = n => e => e.test(n),
   Wz = [Fg, Jt, Iu, Vf, jW, kW, $Y],
   HN = n => Wz.find(Xz(n));

function eK(n) {
   return typeof n == "number" ? n === 0 : n !== null ? n === "none" || n === "0" || pz(n) : !0
}
const tK = new Set(["brightness", "contrast", "saturate", "opacity"]);

function nK(n) {
   const [e, t] = n.slice(0, -1).split("(");
   if (e === "drop-shadow") return n;
   const [i] = t.match(T2) || [];
   if (!i) return n;
   const s = t.replace(i, "");
   let r = tK.has(e) ? 1 : 0;
   return i !== t && (r *= 100), e + "(" + r + s + ")"
}
const iK = /\b([a-z-]*)\(.*?\)/gu,
   Sw = {
      ...oh,
      getAnimatableNone: n => {
         const e = n.match(iK);
         return e ? e.map(nK).join(" ") : n
      }
   },
   VN = {
      ...Fg,
      transform: Math.round
   },
   sK = {
      rotate: Vf,
      rotateX: Vf,
      rotateY: Vf,
      rotateZ: Vf,
      scale: eb,
      scaleX: eb,
      scaleY: eb,
      scaleZ: eb,
      skew: Vf,
      skewX: Vf,
      skewY: Vf,
      distance: Jt,
      translateX: Jt,
      translateY: Jt,
      translateZ: Jt,
      x: Jt,
      y: Jt,
      z: Jt,
      perspective: Jt,
      transformPerspective: Jt,
      opacity: jy,
      originX: RN,
      originY: RN,
      originZ: Jt
   },
   U2 = {
      borderWidth: Jt,
      borderTopWidth: Jt,
      borderRightWidth: Jt,
      borderBottomWidth: Jt,
      borderLeftWidth: Jt,
      borderRadius: Jt,
      radius: Jt,
      borderTopLeftRadius: Jt,
      borderTopRightRadius: Jt,
      borderBottomRightRadius: Jt,
      borderBottomLeftRadius: Jt,
      width: Jt,
      maxWidth: Jt,
      height: Jt,
      maxHeight: Jt,
      top: Jt,
      right: Jt,
      bottom: Jt,
      left: Jt,
      padding: Jt,
      paddingTop: Jt,
      paddingRight: Jt,
      paddingBottom: Jt,
      paddingLeft: Jt,
      margin: Jt,
      marginTop: Jt,
      marginRight: Jt,
      marginBottom: Jt,
      marginLeft: Jt,
      backgroundPositionX: Jt,
      backgroundPositionY: Jt,
      ...sK,
      zIndex: VN,
      fillOpacity: jy,
      strokeOpacity: jy,
      numOctaves: VN
   },
   rK = {
      ...U2,
      color: As,
      backgroundColor: As,
      outlineColor: As,
      fill: As,
      stroke: As,
      borderColor: As,
      borderTopColor: As,
      borderRightColor: As,
      borderBottomColor: As,
      borderLeftColor: As,
      filter: Sw,
      WebkitFilter: Sw
   },
   Yz = n => rK[n];

function Kz(n, e) {
   let t = Yz(n);
   return t !== Sw && (t = oh), t.getAnimatableNone ? t.getAnimatableNone(e) : void 0
}
const aK = new Set(["auto", "none", "0"]);

function oK(n, e, t) {
   let i = 0,
      s;
   for (; i < n.length && !s;) {
      const r = n[i];
      typeof r == "string" && !aK.has(r) && qy(r).values.length && (s = n[i]), i++
   }
   if (s && t)
      for (const r of e) n[r] = Kz(t, s)
}
class lK extends D2 {
   constructor(e, t, i, s, r) {
      super(e, t, i, s, r, !0)
   }
   readKeyframes() {
      const {
         unresolvedKeyframes: e,
         element: t,
         name: i
      } = this;
      if (!t || !t.current) return;
      super.readKeyframes();
      for (let c = 0; c < e.length; c++) {
         let h = e[c];
         if (typeof h == "string" && (h = h.trim(), b2(h))) {
            const m = jz(h, t.current);
            m !== void 0 && (e[c] = m), c === e.length - 1 && (this.finalKeyframe = h)
         }
      }
      if (this.resolveNoneKeyframes(), !qz.has(i) || e.length !== 2) return;
      const [s, r] = e, a = HN(s), l = HN(r);
      if (a !== l)
         if (BN(a) && BN(l))
            for (let c = 0; c < e.length; c++) {
               const h = e[c];
               typeof h == "string" && (e[c] = parseFloat(h))
            } else Gd[i] && (this.needsMeasurement = !0)
   }
   resolveNoneKeyframes() {
      const {
         unresolvedKeyframes: e,
         name: t
      } = this, i = [];
      for (let s = 0; s < e.length; s++)(e[s] === null || eK(e[s])) && i.push(s);
      i.length && oK(e, i, t)
   }
   measureInitialState() {
      const {
         element: e,
         unresolvedKeyframes: t,
         name: i
      } = this;
      if (!e || !e.current) return;
      i === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = Gd[i](e.measureViewportBox(), window.getComputedStyle(e.current)), t[0] = this.measuredOrigin;
      const s = t[t.length - 1];
      s !== void 0 && e.getValue(i, s).jump(s, !1)
   }
   measureEndState() {
      var l;
      const {
         element: e,
         name: t,
         unresolvedKeyframes: i
      } = this;
      if (!e || !e.current) return;
      const s = e.getValue(t);
      s && s.jump(this.measuredOrigin, !1);
      const r = i.length - 1,
         a = i[r];
      i[r] = Gd[t](e.measureViewportBox(), window.getComputedStyle(e.current)), a !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = a), (l = this.removedTransforms) != null && l.length && this.removedTransforms.forEach(([c, h]) => {
         e.getValue(c).set(h)
      }), this.resolveNoneKeyframes()
   }
}

function uK(n, e, t) {
   if (n instanceof EventTarget) return [n];
   if (typeof n == "string") {
      let i = document;
      const s = (t == null ? void 0 : t[n]) ?? i.querySelectorAll(n);
      return s ? Array.from(s) : []
   }
   return Array.from(n)
}
const Zz = (n, e) => e && typeof n == "number" ? e.transform(n) : n,
   GN = 30,
   cK = n => !isNaN(parseFloat(n));
class fK {
   constructor(e, t = {}) {
      this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (i, s = !0) => {
         var a, l;
         const r = La.now();
         if (this.updatedAt !== r && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(i), this.current !== this.prev && ((a = this.events.change) == null || a.notify(this.current), this.dependents))
            for (const c of this.dependents) c.dirty();
         s && ((l = this.events.renderRequest) == null || l.notify(this.current))
      }, this.hasAnimated = !1, this.setCurrent(e), this.owner = t.owner
   }
   setCurrent(e) {
      this.current = e, this.updatedAt = La.now(), this.canTrackVelocity === null && e !== void 0 && (this.canTrackVelocity = cK(this.current))
   }
   setPrevFrameValue(e = this.current) {
      this.prevFrameValue = e, this.prevUpdatedAt = this.updatedAt
   }
   onChange(e) {
      return this.on("change", e)
   }
   on(e, t) {
      this.events[e] || (this.events[e] = new y2);
      const i = this.events[e].add(t);
      return e === "change" ? () => {
         i(), Ii.read(() => {
            this.events.change.getSize() || this.stop()
         })
      } : i
   }
   clearListeners() {
      for (const e in this.events) this.events[e].clear()
   }
   attach(e, t) {
      this.passiveEffect = e, this.stopPassiveEffect = t
   }
   set(e, t = !0) {
      !t || !this.passiveEffect ? this.updateAndNotify(e, t) : this.passiveEffect(e, this.updateAndNotify)
   }
   setWithVelocity(e, t, i) {
      this.set(t), this.prev = void 0, this.prevFrameValue = e, this.prevUpdatedAt = this.updatedAt - i
   }
   jump(e, t = !0) {
      this.updateAndNotify(e), this.prev = e, this.prevUpdatedAt = this.prevFrameValue = void 0, t && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect()
   }
   dirty() {
      var e;
      (e = this.events.change) == null || e.notify(this.current)
   }
   addDependent(e) {
      this.dependents || (this.dependents = new Set), this.dependents.add(e)
   }
   removeDependent(e) {
      this.dependents && this.dependents.delete(e)
   }
   get() {
      return this.current
   }
   getPrevious() {
      return this.prev
   }
   getVelocity() {
      const e = La.now();
      if (!this.canTrackVelocity || this.prevFrameValue === void 0 || e - this.updatedAt > GN) return 0;
      const t = Math.min(this.updatedAt - this.prevUpdatedAt, GN);
      return mz(parseFloat(this.current) - parseFloat(this.prevFrameValue), t)
   }
   start(e) {
      return this.stop(), new Promise(t => {
         this.hasAnimated = !0, this.animation = e(t), this.events.animationStart && this.events.animationStart.notify()
      }).then(() => {
         this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation()
      })
   }
   stop() {
      this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation()
   }
   isAnimating() {
      return !!this.animation
   }
   clearAnimation() {
      delete this.animation
   }
   destroy() {
      var e, t;
      (e = this.dependents) == null || e.clear(), (t = this.events.destroy) == null || t.notify(), this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect()
   }
}

function xg(n, e) {
   return new fK(n, e)
}
const {
   schedule: P2
} = Az(queueMicrotask, !1), Ul = {
   x: !1,
   y: !1
};

function Qz() {
   return Ul.x || Ul.y
}

function hK(n) {
   return n === "x" || n === "y" ? Ul[n] ? null : (Ul[n] = !0, () => {
      Ul[n] = !1
   }) : Ul.x || Ul.y ? null : (Ul.x = Ul.y = !0, () => {
      Ul.x = Ul.y = !1
   })
}

function Jz(n, e) {
   const t = uK(n),
      i = new AbortController,
      s = {
         passive: !0,
         ...e,
         signal: i.signal
      };
   return [t, s, () => i.abort()]
}

function kN(n) {
   return !(n.pointerType === "touch" || Qz())
}

function dK(n, e, t = {}) {
   const [i, s, r] = Jz(n, t), a = l => {
      if (!kN(l)) return;
      const {
         target: c
      } = l, h = e(c, l);
      if (typeof h != "function" || !c) return;
      const m = g => {
         kN(g) && (h(g), c.removeEventListener("pointerleave", m))
      };
      c.addEventListener("pointerleave", m, s)
   };
   return i.forEach(l => {
      l.addEventListener("pointerenter", a, s)
   }), r
}
const $z = (n, e) => e ? n === e ? !0 : $z(n, e.parentElement) : !1,
   L2 = n => n.pointerType === "mouse" ? typeof n.button != "number" || n.button <= 0 : n.isPrimary !== !1,
   pK = new Set(["BUTTON", "INPUT", "SELECT", "TEXTAREA", "A"]);

function mK(n) {
   return pK.has(n.tagName) || n.tabIndex !== -1
}
const wb = new WeakSet;

function jN(n) {
   return e => {
      e.key === "Enter" && n(e)
   }
}

function rA(n, e) {
   n.dispatchEvent(new PointerEvent("pointer" + e, {
      isPrimary: !0,
      bubbles: !0
   }))
}
const gK = (n, e) => {
   const t = n.currentTarget;
   if (!t) return;
   const i = jN(() => {
      if (wb.has(t)) return;
      rA(t, "down");
      const s = jN(() => {
            rA(t, "up")
         }),
         r = () => rA(t, "cancel");
      t.addEventListener("keyup", s, e), t.addEventListener("blur", r, e)
   });
   t.addEventListener("keydown", i, e), t.addEventListener("blur", () => t.removeEventListener("keydown", i), e)
};

function qN(n) {
   return L2(n) && !Qz()
}

function vK(n, e, t = {}) {
   const [i, s, r] = Jz(n, t), a = l => {
      const c = l.currentTarget;
      if (!qN(l)) return;
      wb.add(c);
      const h = e(c, l),
         m = (x, S) => {
            window.removeEventListener("pointerup", g), window.removeEventListener("pointercancel", v), wb.has(c) && wb.delete(c), qN(x) && typeof h == "function" && h(x, {
               success: S
            })
         },
         g = x => {
            m(x, c === window || c === document || t.useGlobalTarget || $z(c, x.target))
         },
         v = x => {
            m(x, !1)
         };
      window.addEventListener("pointerup", g, s), window.addEventListener("pointercancel", v, s)
   };
   return i.forEach(l => {
      (t.useGlobalTarget ? window : l).addEventListener("pointerdown", a, s), N2(l) && (l.addEventListener("focus", h => gK(h, s)), !mK(l) && !l.hasAttribute("tabindex") && (l.tabIndex = 0))
   }), r
}

function eI(n) {
   return dz(n) && "ownerSVGElement" in n
}

function yK(n) {
   return eI(n) && n.tagName === "svg"
}
const Br = n => !!(n && n.getVelocity),
   xK = [...Wz, As, oh],
   _K = n => xK.find(Xz(n)),
   B2 = j.createContext({
      transformPagePoint: n => n,
      isStatic: !1,
      reducedMotion: "never"
   });
class SK extends j.Component {
   getSnapshotBeforeUpdate(e) {
      const t = this.props.childRef.current;
      if (t && e.isPresent && !this.props.isPresent) {
         const i = t.offsetParent,
            s = N2(i) && i.offsetWidth || 0,
            r = this.props.sizeRef.current;
         r.height = t.offsetHeight || 0, r.width = t.offsetWidth || 0, r.top = t.offsetTop, r.left = t.offsetLeft, r.right = s - r.width - r.left
      }
      return null
   }
   componentDidUpdate() {}
   render() {
      return this.props.children
   }
}

function bK({
   children: n,
   isPresent: e,
   anchorX: t,
   root: i
}) {
   const s = j.useId(),
      r = j.useRef(null),
      a = j.useRef({
         width: 0,
         height: 0,
         top: 0,
         left: 0,
         right: 0
      }),
      {
         nonce: l
      } = j.useContext(B2);
   return j.useInsertionEffect(() => {
      const {
         width: c,
         height: h,
         top: m,
         left: g,
         right: v
      } = a.current;
      if (e || !r.current || !c || !h) return;
      const x = t === "left" ? `left: ${g}` : `right: ${v}`;
      r.current.dataset.motionPopId = s;
      const S = document.createElement("style");
      l && (S.nonce = l);
      const E = i ?? document.head;
      return E.appendChild(S), S.sheet && S.sheet.insertRule(`
          [data-motion-pop-id="${s}"] {
            position: absolute !important;
            width: ${c}px !important;
            height: ${h}px !important;
            ${x}px !important;
            top: ${m}px !important;
          }
        `), () => {
         E.removeChild(S), E.contains(S) && E.removeChild(S)
      }
   }, [e]), H.jsx(SK, {
      isPresent: e,
      childRef: r,
      sizeRef: a,
      children: j.cloneElement(n, {
         ref: r
      })
   })
}
const TK = ({
   children: n,
   initial: e,
   isPresent: t,
   onExitComplete: i,
   custom: s,
   presenceAffectsLayout: r,
   mode: a,
   anchorX: l,
   root: c
}) => {
   const h = h2(EK),
      m = j.useId();
   let g = !0,
      v = j.useMemo(() => (g = !1, {
         id: m,
         initial: e,
         isPresent: t,
         custom: s,
         onExitComplete: x => {
            h.set(x, !0);
            for (const S of h.values())
               if (!S) return;
            i && i()
         },
         register: x => (h.set(x, !1), () => h.delete(x))
      }), [t, h, i]);
   return r && g && (v = {
      ...v
   }), j.useMemo(() => {
      h.forEach((x, S) => h.set(S, !1))
   }, [t]), j.useEffect(() => {
      !t && !h.size && i && i()
   }, [t]), a === "popLayout" && (n = H.jsx(bK, {
      isPresent: t,
      anchorX: l,
      root: c,
      children: n
   })), H.jsx(LT.Provider, {
      value: v,
      children: n
   })
};

function EK() {
   return new Map
}

function tI(n = !0) {
   const e = j.useContext(LT);
   if (e === null) return [!0, null];
   const {
      isPresent: t,
      onExitComplete: i,
      register: s
   } = e, r = j.useId();
   j.useEffect(() => {
      if (n) return s(r)
   }, [n]);
   const a = j.useCallback(() => n && i && i(r), [r, i, n]);
   return !t && i ? [!1, a] : [!0]
}
const tb = n => n.key || "";

function XN(n) {
   const e = [];
   return j.Children.forEach(n, t => {
      j.isValidElement(t) && e.push(t)
   }), e
}
const nI = ({
      children: n,
      custom: e,
      initial: t = !0,
      onExitComplete: i,
      presenceAffectsLayout: s = !0,
      mode: r = "sync",
      propagate: a = !1,
      anchorX: l = "left",
      root: c
   }) => {
      const [h, m] = tI(a), g = j.useMemo(() => XN(n), [n]), v = a && !h ? [] : g.map(tb), x = j.useRef(!0), S = j.useRef(g), E = h2(() => new Map), [T, b] = j.useState(g), [w, C] = j.useState(g);
      fz(() => {
         x.current = !1, S.current = g;
         for (let z = 0; z < w.length; z++) {
            const B = tb(w[z]);
            v.includes(B) ? E.delete(B) : E.get(B) !== !0 && E.set(B, !1)
         }
      }, [w, v.length, v.join("-")]);
      const N = [];
      if (g !== T) {
         let z = [...g];
         for (let B = 0; B < w.length; B++) {
            const I = w[B],
               O = tb(I);
            v.includes(O) || (z.splice(B, 0, I), N.push(I))
         }
         return r === "wait" && N.length && (z = N), C(XN(z)), b(g), null
      }
      const {
         forceRender: U
      } = j.useContext(f2);
      return H.jsx(H.Fragment, {
         children: w.map(z => {
            const B = tb(z),
               I = a && !h ? !1 : g === w || v.includes(B),
               O = () => {
                  if (E.has(B)) E.set(B, !0);
                  else return;
                  let P = !0;
                  E.forEach(q => {
                     q || (P = !1)
                  }), P && (U == null || U(), C(S.current), a && (m == null || m()), i && i())
               };
            return H.jsx(TK, {
               isPresent: I,
               initial: !x.current || t ? void 0 : !1,
               custom: e,
               presenceAffectsLayout: s,
               mode: r,
               root: c,
               onExitComplete: I ? void 0 : O,
               anchorX: l,
               children: z
            }, B)
         })
      })
   },
   iI = j.createContext({
      strict: !1
   }),
   WN = {
      animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"],
      exit: ["exit"],
      drag: ["drag", "dragControls"],
      focus: ["whileFocus"],
      hover: ["whileHover", "onHoverStart", "onHoverEnd"],
      tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
      pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
      inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
      layout: ["layout", "layoutId"]
   },
   _g = {};
for (const n in WN) _g[n] = {
   isEnabled: e => WN[n].some(t => !!e[t])
};

function MK(n) {
   for (const e in n) _g[e] = {
      ..._g[e],
      ...n[e]
   }
}
const AK = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]);

function D1(n) {
   return n.startsWith("while") || n.startsWith("drag") && n !== "draggable" || n.startsWith("layout") || n.startsWith("onTap") || n.startsWith("onPan") || n.startsWith("onLayout") || AK.has(n)
}
let sI = n => !D1(n);

function wK(n) {
   typeof n == "function" && (sI = e => e.startsWith("on") ? !D1(e) : n(e))
}
try {
   wK(require("@emotion/is-prop-valid").default)
} catch {}

function RK(n, e, t) {
   const i = {};
   for (const s in n) s === "values" && typeof n.values == "object" || (sI(s) || t === !0 && D1(s) || !e && !D1(s) || n.draggable && s.startsWith("onDrag")) && (i[s] = n[s]);
   return i
}

function CK(n) {
   if (typeof Proxy > "u") return n;
   const e = new Map,
      t = (...i) => n(...i);
   return new Proxy(t, {
      get: (i, s) => s === "create" ? n : (e.has(s) || e.set(s, n(s)), e.get(s))
   })
}
const BT = j.createContext({});

function zT(n) {
   return n !== null && typeof n == "object" && typeof n.start == "function"
}

function Xy(n) {
   return typeof n == "string" || Array.isArray(n)
}
const z2 = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"],
   I2 = ["initial", ...z2];

function IT(n) {
   return zT(n.animate) || I2.some(e => Xy(n[e]))
}

function rI(n) {
   return !!(IT(n) || n.variants)
}

function DK(n, e) {
   if (IT(n)) {
      const {
         initial: t,
         animate: i
      } = n;
      return {
         initial: t === !1 || Xy(t) ? t : void 0,
         animate: Xy(i) ? i : void 0
      }
   }
   return n.inherit !== !1 ? e : {}
}

function NK(n) {
   const {
      initial: e,
      animate: t
   } = DK(n, j.useContext(BT));
   return j.useMemo(() => ({
      initial: e,
      animate: t
   }), [YN(e), YN(t)])
}

function YN(n) {
   return Array.isArray(n) ? n.join(" ") : n
}
const OK = Symbol.for("motionComponentSymbol");

function Km(n) {
   return n && typeof n == "object" && Object.prototype.hasOwnProperty.call(n, "current")
}

function UK(n, e, t) {
   return j.useCallback(i => {
      i && n.onMount && n.onMount(i), e && (i ? e.mount(i) : e.unmount()), t && (typeof t == "function" ? t(i) : Km(t) && (t.current = i))
   }, [e])
}
const F2 = n => n.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(),
   PK = "framerAppearId",
   aI = "data-" + F2(PK),
   oI = j.createContext({});

function LK(n, e, t, i, s) {
   var E, T;
   const {
      visualElement: r
   } = j.useContext(BT), a = j.useContext(iI), l = j.useContext(LT), c = j.useContext(B2).reducedMotion, h = j.useRef(null);
   i = i || a.renderer, !h.current && i && (h.current = i(n, {
      visualState: e,
      parent: r,
      props: t,
      presenceContext: l,
      blockInitialAnimation: l ? l.initial === !1 : !1,
      reducedMotionConfig: c
   }));
   const m = h.current,
      g = j.useContext(oI);
   m && !m.projection && s && (m.type === "html" || m.type === "svg") && BK(h.current, t, s, g);
   const v = j.useRef(!1);
   j.useInsertionEffect(() => {
      m && v.current && m.update(t, l)
   });
   const x = t[aI],
      S = j.useRef(!!x && !((E = window.MotionHandoffIsComplete) != null && E.call(window, x)) && ((T = window.MotionHasOptimisedAnimation) == null ? void 0 : T.call(window, x)));
   return fz(() => {
      m && (v.current = !0, window.MotionIsMounted = !0, m.updateFeatures(), P2.render(m.render), S.current && m.animationState && m.animationState.animateChanges())
   }), j.useEffect(() => {
      m && (!S.current && m.animationState && m.animationState.animateChanges(), S.current && (queueMicrotask(() => {
         var b;
         (b = window.MotionHandoffMarkAsComplete) == null || b.call(window, x)
      }), S.current = !1))
   }), m
}

function BK(n, e, t, i) {
   const {
      layoutId: s,
      layout: r,
      drag: a,
      dragConstraints: l,
      layoutScroll: c,
      layoutRoot: h,
      layoutCrossfade: m
   } = e;
   n.projection = new t(n.latestValues, e["data-framer-portal-id"] ? void 0 : lI(n.parent)), n.projection.setOptions({
      layoutId: s,
      layout: r,
      alwaysMeasureLayout: !!a || l && Km(l),
      visualElement: n,
      animationType: typeof r == "string" ? r : "both",
      initialPromotionConfig: i,
      crossfade: m,
      layoutScroll: c,
      layoutRoot: h
   })
}

function lI(n) {
   if (n) return n.options.allowProjection !== !1 ? n.projection : lI(n.parent)
}

function zK({
   preloadedFeatures: n,
   createVisualElement: e,
   useRender: t,
   useVisualState: i,
   Component: s
}) {
   n && MK(n);

   function r(l, c) {
      let h;
      const m = {
            ...j.useContext(B2),
            ...l,
            layoutId: IK(l)
         },
         {
            isStatic: g
         } = m,
         v = NK(l),
         x = i(l, g);
      if (!g && d2) {
         FK();
         const S = HK(m);
         h = S.MeasureLayout, v.visualElement = LK(s, x, m, e, S.ProjectionNode)
      }
      return H.jsxs(BT.Provider, {
         value: v,
         children: [h && v.visualElement ? H.jsx(h, {
            visualElement: v.visualElement,
            ...m
         }) : null, t(s, l, UK(x, v.visualElement, c), x, g, v.visualElement)]
      })
   }
   r.displayName = `motion.${typeof s=="string"?s:`create(${s.displayName??s.name??""})`}`;
   const a = j.forwardRef(r);
   return a[OK] = s, a
}

function IK({
   layoutId: n
}) {
   const e = j.useContext(f2).id;
   return e && n !== void 0 ? e + "-" + n : n
}

function FK(n, e) {
   j.useContext(iI).strict
}

function HK(n) {
   const {
      drag: e,
      layout: t
   } = _g;
   if (!e && !t) return {};
   const i = {
      ...e,
      ...t
   };
   return {
      MeasureLayout: e != null && e.isEnabled(n) || t != null && t.isEnabled(n) ? i.MeasureLayout : void 0,
      ProjectionNode: i.ProjectionNode
   }
}
const Wy = {};

function VK(n) {
   for (const e in n) Wy[e] = n[e], S2(e) && (Wy[e].isCSSVariable = !0)
}

function uI(n, {
   layout: e,
   layoutId: t
}) {
   return Vg.has(n) || n.startsWith("origin") || (e || t !== void 0) && (!!Wy[n] || n === "opacity")
}
const GK = {
      x: "translateX",
      y: "translateY",
      z: "translateZ",
      transformPerspective: "perspective"
   },
   kK = Hg.length;

function jK(n, e, t) {
   let i = "",
      s = !0;
   for (let r = 0; r < kK; r++) {
      const a = Hg[r],
         l = n[a];
      if (l === void 0) continue;
      let c = !0;
      if (typeof l == "number" ? c = l === (a.startsWith("scale") ? 1 : 0) : c = parseFloat(l) === 0, !c || t) {
         const h = Zz(l, U2[a]);
         if (!c) {
            s = !1;
            const m = GK[a] || a;
            i += `${m}(${h}) `
         }
         t && (e[a] = h)
      }
   }
   return i = i.trim(), t ? i = t(e, s ? "" : i) : s && (i = "none"), i
}

function H2(n, e, t) {
   const {
      style: i,
      vars: s,
      transformOrigin: r
   } = n;
   let a = !1,
      l = !1;
   for (const c in e) {
      const h = e[c];
      if (Vg.has(c)) {
         a = !0;
         continue
      } else if (S2(c)) {
         s[c] = h;
         continue
      } else {
         const m = Zz(h, U2[c]);
         c.startsWith("origin") ? (l = !0, r[c] = m) : i[c] = m
      }
   }
   if (e.transform || (a || t ? i.transform = jK(e, n.transform, t) : i.transform && (i.transform = "none")), l) {
      const {
         originX: c = "50%",
         originY: h = "50%",
         originZ: m = 0
      } = r;
      i.transformOrigin = `${c} ${h} ${m}`
   }
}
const V2 = () => ({
   style: {},
   transform: {},
   transformOrigin: {},
   vars: {}
});

function cI(n, e, t) {
   for (const i in e) !Br(e[i]) && !uI(i, t) && (n[i] = e[i])
}

function qK({
   transformTemplate: n
}, e) {
   return j.useMemo(() => {
      const t = V2();
      return H2(t, e, n), Object.assign({}, t.vars, t.style)
   }, [e])
}

function XK(n, e) {
   const t = n.style || {},
      i = {};
   return cI(i, t, n), Object.assign(i, qK(n, e)), i
}

function WK(n, e) {
   const t = {},
      i = XK(n, e);
   return n.drag && n.dragListener !== !1 && (t.draggable = !1, i.userSelect = i.WebkitUserSelect = i.WebkitTouchCallout = "none", i.touchAction = n.drag === !0 ? "none" : `pan-${n.drag==="x"?"y":"x"}`), n.tabIndex === void 0 && (n.onTap || n.onTapStart || n.whileTap) && (t.tabIndex = 0), t.style = i, t
}
const YK = {
      offset: "stroke-dashoffset",
      array: "stroke-dasharray"
   },
   KK = {
      offset: "strokeDashoffset",
      array: "strokeDasharray"
   };

function ZK(n, e, t = 1, i = 0, s = !0) {
   n.pathLength = 1;
   const r = s ? YK : KK;
   n[r.offset] = Jt.transform(-i);
   const a = Jt.transform(e),
      l = Jt.transform(t);
   n[r.array] = `${a} ${l}`
}

function fI(n, {
   attrX: e,
   attrY: t,
   attrScale: i,
   pathLength: s,
   pathSpacing: r = 1,
   pathOffset: a = 0,
   ...l
}, c, h, m) {
   if (H2(n, l, h), c) {
      n.style.viewBox && (n.attrs.viewBox = n.style.viewBox);
      return
   }
   n.attrs = n.style, n.style = {};
   const {
      attrs: g,
      style: v
   } = n;
   g.transform && (v.transform = g.transform, delete g.transform), (v.transform || g.transformOrigin) && (v.transformOrigin = g.transformOrigin ?? "50% 50%", delete g.transformOrigin), v.transform && (v.transformBox = (m == null ? void 0 : m.transformBox) ?? "fill-box", delete g.transformBox), e !== void 0 && (g.x = e), t !== void 0 && (g.y = t), i !== void 0 && (g.scale = i), s !== void 0 && ZK(g, s, r, a, !1)
}
const hI = () => ({
      ...V2(),
      attrs: {}
   }),
   dI = n => typeof n == "string" && n.toLowerCase() === "svg";

function QK(n, e, t, i) {
   const s = j.useMemo(() => {
      const r = hI();
      return fI(r, e, dI(i), n.transformTemplate, n.style), {
         ...r.attrs,
         style: {
            ...r.style
         }
      }
   }, [e]);
   if (n.style) {
      const r = {};
      cI(r, n.style, n), s.style = {
         ...r,
         ...s.style
      }
   }
   return s
}
const JK = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"];

function G2(n) {
   return typeof n != "string" || n.includes("-") ? !1 : !!(JK.indexOf(n) > -1 || /[A-Z]/u.test(n))
}

function $K(n = !1) {
   return (t, i, s, {
      latestValues: r
   }, a) => {
      const c = (G2(t) ? QK : WK)(i, r, a, t),
         h = RK(i, typeof t == "string", n),
         m = t !== j.Fragment ? {
            ...h,
            ...c,
            ref: s
         } : {},
         {
            children: g
         } = i,
         v = j.useMemo(() => Br(g) ? g.get() : g, [g]);
      return j.createElement(t, {
         ...m,
         children: v
      })
   }
}

function KN(n) {
   const e = [{}, {}];
   return n == null || n.values.forEach((t, i) => {
      e[0][i] = t.get(), e[1][i] = t.getVelocity()
   }), e
}

function k2(n, e, t, i) {
   if (typeof e == "function") {
      const [s, r] = KN(i);
      e = e(t !== void 0 ? t : n.custom, s, r)
   }
   if (typeof e == "string" && (e = n.variants && n.variants[e]), typeof e == "function") {
      const [s, r] = KN(i);
      e = e(t !== void 0 ? t : n.custom, s, r)
   }
   return e
}

function Rb(n) {
   return Br(n) ? n.get() : n
}

function eZ({
   scrapeMotionValuesFromProps: n,
   createRenderState: e
}, t, i, s) {
   return {
      latestValues: tZ(t, i, s, n),
      renderState: e()
   }
}
const pI = n => (e, t) => {
   const i = j.useContext(BT),
      s = j.useContext(LT),
      r = () => eZ(n, e, i, s);
   return t ? r() : h2(r)
};

function tZ(n, e, t, i) {
   const s = {},
      r = i(n, {});
   for (const v in r) s[v] = Rb(r[v]);
   let {
      initial: a,
      animate: l
   } = n;
   const c = IT(n),
      h = rI(n);
   e && h && !c && n.inherit !== !1 && (a === void 0 && (a = e.initial), l === void 0 && (l = e.animate));
   let m = t ? t.initial === !1 : !1;
   m = m || a === !1;
   const g = m ? l : a;
   if (g && typeof g != "boolean" && !zT(g)) {
      const v = Array.isArray(g) ? g : [g];
      for (let x = 0; x < v.length; x++) {
         const S = k2(n, v[x]);
         if (S) {
            const {
               transitionEnd: E,
               transition: T,
               ...b
            } = S;
            for (const w in b) {
               let C = b[w];
               if (Array.isArray(C)) {
                  const N = m ? C.length - 1 : 0;
                  C = C[N]
               }
               C !== null && (s[w] = C)
            }
            for (const w in E) s[w] = E[w]
         }
      }
   }
   return s
}

function j2(n, e, t) {
   var r;
   const {
      style: i
   } = n, s = {};
   for (const a in i)(Br(i[a]) || e.style && Br(e.style[a]) || uI(a, n) || ((r = t == null ? void 0 : t.getValue(a)) == null ? void 0 : r.liveStyle) !== void 0) && (s[a] = i[a]);
   return s
}
const nZ = {
   useVisualState: pI({
      scrapeMotionValuesFromProps: j2,
      createRenderState: V2
   })
};

function mI(n, e, t) {
   const i = j2(n, e, t);
   for (const s in n)
      if (Br(n[s]) || Br(e[s])) {
         const r = Hg.indexOf(s) !== -1 ? "attr" + s.charAt(0).toUpperCase() + s.substring(1) : s;
         i[r] = n[s]
      } return i
}
const iZ = {
   useVisualState: pI({
      scrapeMotionValuesFromProps: mI,
      createRenderState: hI
   })
};

function sZ(n, e) {
   return function (i, {
      forwardMotionProps: s
   } = {
      forwardMotionProps: !1
   }) {
      const a = {
         ...G2(i) ? iZ : nZ,
         preloadedFeatures: n,
         useRender: $K(s),
         createVisualElement: e,
         Component: i
      };
      return zK(a)
   }
}

function Yy(n, e, t) {
   const i = n.getProps();
   return k2(i, e, t !== void 0 ? t : i.custom, n)
}
const bw = n => Array.isArray(n);

function rZ(n, e, t) {
   n.hasValue(e) ? n.getValue(e).set(t) : n.addValue(e, xg(t))
}

function aZ(n) {
   return bw(n) ? n[n.length - 1] || 0 : n
}

function oZ(n, e) {
   const t = Yy(n, e);
   let {
      transitionEnd: i = {},
      transition: s = {},
      ...r
   } = t || {};
   r = {
      ...r,
      ...i
   };
   for (const a in r) {
      const l = aZ(r[a]);
      rZ(n, a, l)
   }
}

function lZ(n) {
   return !!(Br(n) && n.add)
}

function Tw(n, e) {
   const t = n.getValue("willChange");
   if (lZ(t)) return t.add(e);
   if (!t && Bc.WillChange) {
      const i = new Bc.WillChange("auto");
      n.addValue("willChange", i), i.add(e)
   }
}

function gI(n) {
   return n.props[aI]
}
const uZ = n => n !== null;

function cZ(n, {
   repeat: e,
   repeatType: t = "loop"
}, i) {
   const s = n.filter(uZ),
      r = e && t !== "loop" && e % 2 === 1 ? 0 : s.length - 1;
   return s[r]
}
const fZ = {
      type: "spring",
      stiffness: 500,
      damping: 25,
      restSpeed: 10
   },
   hZ = n => ({
      type: "spring",
      stiffness: 550,
      damping: n === 0 ? 2 * Math.sqrt(550) : 30,
      restSpeed: 10
   }),
   dZ = {
      type: "keyframes",
      duration: .8
   },
   pZ = {
      type: "keyframes",
      ease: [.25, .1, .35, 1],
      duration: .3
   },
   mZ = (n, {
      keyframes: e
   }) => e.length > 2 ? dZ : Vg.has(n) ? n.startsWith("scale") ? hZ(e[1]) : fZ : pZ;

function gZ({
   when: n,
   delay: e,
   delayChildren: t,
   staggerChildren: i,
   staggerDirection: s,
   repeat: r,
   repeatType: a,
   repeatDelay: l,
   from: c,
   elapsed: h,
   ...m
}) {
   return !!Object.keys(m).length
}
const q2 = (n, e, t, i = {}, s, r) => a => {
   const l = O2(i, n) || {},
      c = l.delay || i.delay || 0;
   let {
      elapsed: h = 0
   } = i;
   h = h - Bu(c);
   const m = {
      keyframes: Array.isArray(t) ? t : [null, t],
      ease: "easeOut",
      velocity: e.getVelocity(),
      ...l,
      delay: -h,
      onUpdate: v => {
         e.set(v), l.onUpdate && l.onUpdate(v)
      },
      onComplete: () => {
         a(), l.onComplete && l.onComplete()
      },
      name: n,
      motionValue: e,
      element: r ? void 0 : s
   };
   gZ(l) || Object.assign(m, mZ(n, m)), m.duration && (m.duration = Bu(m.duration)), m.repeatDelay && (m.repeatDelay = Bu(m.repeatDelay)), m.from !== void 0 && (m.keyframes[0] = m.from);
   let g = !1;
   if ((m.type === !1 || m.duration === 0 && !m.repeatDelay) && (m.duration = 0, m.delay === 0 && (g = !0)), (Bc.instantAnimations || Bc.skipAnimations) && (g = !0, m.duration = 0, m.delay = 0), m.allowFlatten = !l.type && !l.ease, g && !r && e.get() !== void 0) {
      const v = cZ(m.keyframes, l);
      if (v !== void 0) {
         Ii.update(() => {
            m.onUpdate(v), m.onComplete()
         });
         return
      }
   }
   return l.isSync ? new C2(m) : new ZY(m)
};

function vZ({
   protectedKeys: n,
   needsAnimating: e
}, t) {
   const i = n.hasOwnProperty(t) && e[t] !== !0;
   return e[t] = !1, i
}

function vI(n, e, {
   delay: t = 0,
   transitionOverride: i,
   type: s
} = {}) {
   let {
      transition: r = n.getDefaultTransition(),
      transitionEnd: a,
      ...l
   } = e;
   i && (r = i);
   const c = [],
      h = s && n.animationState && n.animationState.getState()[s];
   for (const m in l) {
      const g = n.getValue(m, n.latestValues[m] ?? null),
         v = l[m];
      if (v === void 0 || h && vZ(h, m)) continue;
      const x = {
            delay: t,
            ...O2(r || {}, m)
         },
         S = g.get();
      if (S !== void 0 && !g.isAnimating && !Array.isArray(v) && v === S && !x.velocity) continue;
      let E = !1;
      if (window.MotionHandoffAnimation) {
         const b = gI(n);
         if (b) {
            const w = window.MotionHandoffAnimation(b, m, Ii);
            w !== null && (x.startTime = w, E = !0)
         }
      }
      Tw(n, m), g.start(q2(m, g, v, n.shouldReduceMotion && qz.has(m) ? {
         type: !1
      } : x, n, E));
      const T = g.animation;
      T && c.push(T)
   }
   return a && Promise.all(c).then(() => {
      Ii.update(() => {
         a && oZ(n, a)
      })
   }), c
}

function Ew(n, e, t = {}) {
   var c;
   const i = Yy(n, e, t.type === "exit" ? (c = n.presenceContext) == null ? void 0 : c.custom : void 0);
   let {
      transition: s = n.getDefaultTransition() || {}
   } = i || {};
   t.transitionOverride && (s = t.transitionOverride);
   const r = i ? () => Promise.all(vI(n, i, t)) : () => Promise.resolve(),
      a = n.variantChildren && n.variantChildren.size ? (h = 0) => {
         const {
            delayChildren: m = 0,
            staggerChildren: g,
            staggerDirection: v
         } = s;
         return yZ(n, e, h, m, g, v, t)
      } : () => Promise.resolve(),
      {
         when: l
      } = s;
   if (l) {
      const [h, m] = l === "beforeChildren" ? [r, a] : [a, r];
      return h().then(() => m())
   } else return Promise.all([r(), a(t.delay)])
}

function yZ(n, e, t = 0, i = 0, s = 0, r = 1, a) {
   const l = [],
      c = n.variantChildren.size,
      h = (c - 1) * s,
      m = typeof i == "function",
      g = m ? v => i(v, c) : r === 1 ? (v = 0) => v * s : (v = 0) => h - v * s;
   return Array.from(n.variantChildren).sort(xZ).forEach((v, x) => {
      v.notify("AnimationStart", e), l.push(Ew(v, e, {
         ...a,
         delay: t + (m ? 0 : i) + g(x)
      }).then(() => v.notify("AnimationComplete", e)))
   }), Promise.all(l)
}

function xZ(n, e) {
   return n.sortNodePosition(e)
}

function _Z(n, e, t = {}) {
   n.notify("AnimationStart", e);
   let i;
   if (Array.isArray(e)) {
      const s = e.map(r => Ew(n, r, t));
      i = Promise.all(s)
   } else if (typeof e == "string") i = Ew(n, e, t);
   else {
      const s = typeof e == "function" ? Yy(n, e, t.custom) : e;
      i = Promise.all(vI(n, s, t))
   }
   return i.then(() => {
      n.notify("AnimationComplete", e)
   })
}

function yI(n, e) {
   if (!Array.isArray(e)) return !1;
   const t = e.length;
   if (t !== n.length) return !1;
   for (let i = 0; i < t; i++)
      if (e[i] !== n[i]) return !1;
   return !0
}
const SZ = I2.length;

function xI(n) {
   if (!n) return;
   if (!n.isControllingVariants) {
      const t = n.parent ? xI(n.parent) || {} : {};
      return n.props.initial !== void 0 && (t.initial = n.props.initial), t
   }
   const e = {};
   for (let t = 0; t < SZ; t++) {
      const i = I2[t],
         s = n.props[i];
      (Xy(s) || s === !1) && (e[i] = s)
   }
   return e
}
const bZ = [...z2].reverse(),
   TZ = z2.length;

function EZ(n) {
   return e => Promise.all(e.map(({
      animation: t,
      options: i
   }) => _Z(n, t, i)))
}

function MZ(n) {
   let e = EZ(n),
      t = ZN(),
      i = !0;
   const s = c => (h, m) => {
      var v;
      const g = Yy(n, m, c === "exit" ? (v = n.presenceContext) == null ? void 0 : v.custom : void 0);
      if (g) {
         const {
            transition: x,
            transitionEnd: S,
            ...E
         } = g;
         h = {
            ...h,
            ...E,
            ...S
         }
      }
      return h
   };

   function r(c) {
      e = c(n)
   }

   function a(c) {
      const {
         props: h
      } = n, m = xI(n.parent) || {}, g = [], v = new Set;
      let x = {},
         S = 1 / 0;
      for (let T = 0; T < TZ; T++) {
         const b = bZ[T],
            w = t[b],
            C = h[b] !== void 0 ? h[b] : m[b],
            N = Xy(C),
            U = b === c ? w.isActive : null;
         U === !1 && (S = T);
         let z = C === m[b] && C !== h[b] && N;
         if (z && i && n.manuallyAnimateOnMount && (z = !1), w.protectedKeys = {
               ...x
            }, !w.isActive && U === null || !C && !w.prevProp || zT(C) || typeof C == "boolean") continue;
         const B = AZ(w.prevProp, C);
         let I = B || b === c && w.isActive && !z && N || T > S && N,
            O = !1;
         const P = Array.isArray(C) ? C : [C];
         let q = P.reduce(s(b), {});
         U === !1 && (q = {});
         const {
            prevResolvedValues: Q = {}
         } = w, $ = {
            ...Q,
            ...q
         }, ae = Z => {
            I = !0, v.has(Z) && (O = !0, v.delete(Z)), w.needsAnimating[Z] = !0;
            const J = n.getValue(Z);
            J && (J.liveStyle = !1)
         };
         for (const Z in $) {
            const J = q[Z],
               pe = Q[Z];
            if (x.hasOwnProperty(Z)) continue;
            let F = !1;
            bw(J) && bw(pe) ? F = !yI(J, pe) : F = J !== pe, F ? J != null ? ae(Z) : v.add(Z) : J !== void 0 && v.has(Z) ? ae(Z) : w.protectedKeys[Z] = !0
         }
         w.prevProp = C, w.prevResolvedValues = q, w.isActive && (x = {
            ...x,
            ...q
         }), i && n.blockInitialAnimation && (I = !1), I && (!(z && B) || O) && g.push(...P.map(Z => ({
            animation: Z,
            options: {
               type: b
            }
         })))
      }
      if (v.size) {
         const T = {};
         if (typeof h.initial != "boolean") {
            const b = Yy(n, Array.isArray(h.initial) ? h.initial[0] : h.initial);
            b && b.transition && (T.transition = b.transition)
         }
         v.forEach(b => {
            const w = n.getBaseTarget(b),
               C = n.getValue(b);
            C && (C.liveStyle = !0), T[b] = w ?? null
         }), g.push({
            animation: T
         })
      }
      let E = !!g.length;
      return i && (h.initial === !1 || h.initial === h.animate) && !n.manuallyAnimateOnMount && (E = !1), i = !1, E ? e(g) : Promise.resolve()
   }

   function l(c, h) {
      var g;
      if (t[c].isActive === h) return Promise.resolve();
      (g = n.variantChildren) == null || g.forEach(v => {
         var x;
         return (x = v.animationState) == null ? void 0 : x.setActive(c, h)
      }), t[c].isActive = h;
      const m = a(c);
      for (const v in t) t[v].protectedKeys = {};
      return m
   }
   return {
      animateChanges: a,
      setActive: l,
      setAnimateFunction: r,
      getState: () => t,
      reset: () => {
         t = ZN(), i = !0
      }
   }
}

function AZ(n, e) {
   return typeof e == "string" ? e !== n : Array.isArray(e) ? !yI(e, n) : !1
}

function _d(n = !1) {
   return {
      isActive: n,
      protectedKeys: {},
      needsAnimating: {},
      prevResolvedValues: {}
   }
}

function ZN() {
   return {
      animate: _d(!0),
      whileInView: _d(),
      whileHover: _d(),
      whileTap: _d(),
      whileDrag: _d(),
      whileFocus: _d(),
      exit: _d()
   }
}
class ph {
   constructor(e) {
      this.isMounted = !1, this.node = e
   }
   update() {}
}
class wZ extends ph {
   constructor(e) {
      super(e), e.animationState || (e.animationState = MZ(e))
   }
   updateAnimationControlsSubscription() {
      const {
         animate: e
      } = this.node.getProps();
      zT(e) && (this.unmountControls = e.subscribe(this.node))
   }
   mount() {
      this.updateAnimationControlsSubscription()
   }
   update() {
      const {
         animate: e
      } = this.node.getProps(), {
         animate: t
      } = this.node.prevProps || {};
      e !== t && this.updateAnimationControlsSubscription()
   }
   unmount() {
      var e;
      this.node.animationState.reset(), (e = this.unmountControls) == null || e.call(this)
   }
}
let RZ = 0;
class CZ extends ph {
   constructor() {
      super(...arguments), this.id = RZ++
   }
   update() {
      if (!this.node.presenceContext) return;
      const {
         isPresent: e,
         onExitComplete: t
      } = this.node.presenceContext, {
         isPresent: i
      } = this.node.prevPresenceContext || {};
      if (!this.node.animationState || e === i) return;
      const s = this.node.animationState.setActive("exit", !e);
      t && !e && s.then(() => {
         t(this.id)
      })
   }
   mount() {
      const {
         register: e,
         onExitComplete: t
      } = this.node.presenceContext || {};
      t && t(this.id), e && (this.unmount = e(this.id))
   }
   unmount() {}
}
const DZ = {
   animation: {
      Feature: wZ
   },
   exit: {
      Feature: CZ
   }
};

function Ky(n, e, t, i = {
   passive: !0
}) {
   return n.addEventListener(e, t, i), () => n.removeEventListener(e, t)
}

function wx(n) {
   return {
      point: {
         x: n.pageX,
         y: n.pageY
      }
   }
}
const NZ = n => e => L2(e) && n(e, wx(e));

function Q0(n, e, t, i) {
   return Ky(n, e, NZ(t), i)
}

function _I({
   top: n,
   left: e,
   right: t,
   bottom: i
}) {
   return {
      x: {
         min: e,
         max: t
      },
      y: {
         min: n,
         max: i
      }
   }
}

function OZ({
   x: n,
   y: e
}) {
   return {
      top: e.min,
      right: n.max,
      bottom: e.max,
      left: n.min
   }
}

function UZ(n, e) {
   if (!e) return n;
   const t = e({
         x: n.left,
         y: n.top
      }),
      i = e({
         x: n.right,
         y: n.bottom
      });
   return {
      top: t.y,
      left: t.x,
      bottom: i.y,
      right: i.x
   }
}
const SI = 1e-4,
   PZ = 1 - SI,
   LZ = 1 + SI,
   bI = .01,
   BZ = 0 - bI,
   zZ = 0 + bI;

function da(n) {
   return n.max - n.min
}

function IZ(n, e, t) {
   return Math.abs(n - e) <= t
}

function QN(n, e, t, i = .5) {
   n.origin = i, n.originPoint = Yi(e.min, e.max, n.origin), n.scale = da(t) / da(e), n.translate = Yi(t.min, t.max, n.origin) - n.originPoint, (n.scale >= PZ && n.scale <= LZ || isNaN(n.scale)) && (n.scale = 1), (n.translate >= BZ && n.translate <= zZ || isNaN(n.translate)) && (n.translate = 0)
}

function J0(n, e, t, i) {
   QN(n.x, e.x, t.x, i ? i.originX : void 0), QN(n.y, e.y, t.y, i ? i.originY : void 0)
}

function JN(n, e, t) {
   n.min = t.min + e.min, n.max = n.min + da(e)
}

function FZ(n, e, t) {
   JN(n.x, e.x, t.x), JN(n.y, e.y, t.y)
}

function $N(n, e, t) {
   n.min = e.min - t.min, n.max = n.min + da(e)
}

function $0(n, e, t) {
   $N(n.x, e.x, t.x), $N(n.y, e.y, t.y)
}
const eO = () => ({
      translate: 0,
      scale: 1,
      origin: 0,
      originPoint: 0
   }),
   Zm = () => ({
      x: eO(),
      y: eO()
   }),
   tO = () => ({
      min: 0,
      max: 0
   }),
   fs = () => ({
      x: tO(),
      y: tO()
   });

function qo(n) {
   return [n("x"), n("y")]
}

function aA(n) {
   return n === void 0 || n === 1
}

function Mw({
   scale: n,
   scaleX: e,
   scaleY: t
}) {
   return !aA(n) || !aA(e) || !aA(t)
}

function Md(n) {
   return Mw(n) || TI(n) || n.z || n.rotate || n.rotateX || n.rotateY || n.skewX || n.skewY
}

function TI(n) {
   return nO(n.x) || nO(n.y)
}

function nO(n) {
   return n && n !== "0%"
}

function N1(n, e, t) {
   const i = n - t,
      s = e * i;
   return t + s
}

function iO(n, e, t, i, s) {
   return s !== void 0 && (n = N1(n, s, i)), N1(n, t, i) + e
}

function Aw(n, e = 0, t = 1, i, s) {
   n.min = iO(n.min, e, t, i, s), n.max = iO(n.max, e, t, i, s)
}

function EI(n, {
   x: e,
   y: t
}) {
   Aw(n.x, e.translate, e.scale, e.originPoint), Aw(n.y, t.translate, t.scale, t.originPoint)
}
const sO = .999999999999,
   rO = 1.0000000000001;

function HZ(n, e, t, i = !1) {
   const s = t.length;
   if (!s) return;
   e.x = e.y = 1;
   let r, a;
   for (let l = 0; l < s; l++) {
      r = t[l], a = r.projectionDelta;
      const {
         visualElement: c
      } = r.options;
      c && c.props.style && c.props.style.display === "contents" || (i && r.options.layoutScroll && r.scroll && r !== r.root && Jm(n, {
         x: -r.scroll.offset.x,
         y: -r.scroll.offset.y
      }), a && (e.x *= a.x.scale, e.y *= a.y.scale, EI(n, a)), i && Md(r.latestValues) && Jm(n, r.latestValues))
   }
   e.x < rO && e.x > sO && (e.x = 1), e.y < rO && e.y > sO && (e.y = 1)
}

function Qm(n, e) {
   n.min = n.min + e, n.max = n.max + e
}

function aO(n, e, t, i, s = .5) {
   const r = Yi(n.min, n.max, s);
   Aw(n, e, t, r, i)
}

function Jm(n, e) {
   aO(n.x, e.x, e.scaleX, e.scale, e.originX), aO(n.y, e.y, e.scaleY, e.scale, e.originY)
}

function MI(n, e) {
   return _I(UZ(n.getBoundingClientRect(), e))
}

function VZ(n, e, t) {
   const i = MI(n, t),
      {
         scroll: s
      } = e;
   return s && (Qm(i.x, s.offset.x), Qm(i.y, s.offset.y)), i
}
const AI = ({
      current: n
   }) => n ? n.ownerDocument.defaultView : null,
   oO = (n, e) => Math.abs(n - e);

function GZ(n, e) {
   const t = oO(n.x, e.x),
      i = oO(n.y, e.y);
   return Math.sqrt(t ** 2 + i ** 2)
}
class wI {
   constructor(e, t, {
      transformPagePoint: i,
      contextWindow: s = window,
      dragSnapToOrigin: r = !1,
      distanceThreshold: a = 3
   } = {}) {
      if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => {
            if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;
            const v = lA(this.lastMoveEventInfo, this.history),
               x = this.startEvent !== null,
               S = GZ(v.offset, {
                  x: 0,
                  y: 0
               }) >= this.distanceThreshold;
            if (!x && !S) return;
            const {
               point: E
            } = v, {
               timestamp: T
            } = mr;
            this.history.push({
               ...E,
               timestamp: T
            });
            const {
               onStart: b,
               onMove: w
            } = this.handlers;
            x || (b && b(this.lastMoveEvent, v), this.startEvent = this.lastMoveEvent), w && w(this.lastMoveEvent, v)
         }, this.handlePointerMove = (v, x) => {
            this.lastMoveEvent = v, this.lastMoveEventInfo = oA(x, this.transformPagePoint), Ii.update(this.updatePoint, !0)
         }, this.handlePointerUp = (v, x) => {
            this.end();
            const {
               onEnd: S,
               onSessionEnd: E,
               resumeAnimation: T
            } = this.handlers;
            if (this.dragSnapToOrigin && T && T(), !(this.lastMoveEvent && this.lastMoveEventInfo)) return;
            const b = lA(v.type === "pointercancel" ? this.lastMoveEventInfo : oA(x, this.transformPagePoint), this.history);
            this.startEvent && S && S(v, b), E && E(v, b)
         }, !L2(e)) return;
      this.dragSnapToOrigin = r, this.handlers = t, this.transformPagePoint = i, this.distanceThreshold = a, this.contextWindow = s || window;
      const l = wx(e),
         c = oA(l, this.transformPagePoint),
         {
            point: h
         } = c,
         {
            timestamp: m
         } = mr;
      this.history = [{
         ...h,
         timestamp: m
      }];
      const {
         onSessionStart: g
      } = t;
      g && g(e, lA(c, this.history)), this.removeListeners = Ex(Q0(this.contextWindow, "pointermove", this.handlePointerMove), Q0(this.contextWindow, "pointerup", this.handlePointerUp), Q0(this.contextWindow, "pointercancel", this.handlePointerUp))
   }
   updateHandlers(e) {
      this.handlers = e
   }
   end() {
      this.removeListeners && this.removeListeners(), ah(this.updatePoint)
   }
}

function oA(n, e) {
   return e ? {
      point: e(n.point)
   } : n
}

function lO(n, e) {
   return {
      x: n.x - e.x,
      y: n.y - e.y
   }
}

function lA({
   point: n
}, e) {
   return {
      point: n,
      delta: lO(n, RI(e)),
      offset: lO(n, kZ(e)),
      velocity: jZ(e, .1)
   }
}

function kZ(n) {
   return n[0]
}

function RI(n) {
   return n[n.length - 1]
}

function jZ(n, e) {
   if (n.length < 2) return {
      x: 0,
      y: 0
   };
   let t = n.length - 1,
      i = null;
   const s = RI(n);
   for (; t >= 0 && (i = n[t], !(s.timestamp - i.timestamp > Bu(e)));) t--;
   if (!i) return {
      x: 0,
      y: 0
   };
   const r = zu(s.timestamp - i.timestamp);
   if (r === 0) return {
      x: 0,
      y: 0
   };
   const a = {
      x: (s.x - i.x) / r,
      y: (s.y - i.y) / r
   };
   return a.x === 1 / 0 && (a.x = 0), a.y === 1 / 0 && (a.y = 0), a
}

function qZ(n, {
   min: e,
   max: t
}, i) {
   return e !== void 0 && n < e ? n = i ? Yi(e, n, i.min) : Math.max(n, e) : t !== void 0 && n > t && (n = i ? Yi(t, n, i.max) : Math.min(n, t)), n
}

function uO(n, e, t) {
   return {
      min: e !== void 0 ? n.min + e : void 0,
      max: t !== void 0 ? n.max + t - (n.max - n.min) : void 0
   }
}

function XZ(n, {
   top: e,
   left: t,
   bottom: i,
   right: s
}) {
   return {
      x: uO(n.x, t, s),
      y: uO(n.y, e, i)
   }
}

function cO(n, e) {
   let t = e.min - n.min,
      i = e.max - n.max;
   return e.max - e.min < n.max - n.min && ([t, i] = [i, t]), {
      min: t,
      max: i
   }
}

function WZ(n, e) {
   return {
      x: cO(n.x, e.x),
      y: cO(n.y, e.y)
   }
}

function YZ(n, e) {
   let t = .5;
   const i = da(n),
      s = da(e);
   return s > i ? t = ky(e.min, e.max - i, n.min) : i > s && (t = ky(n.min, n.max - s, e.min)), Lc(0, 1, t)
}

function KZ(n, e) {
   const t = {};
   return e.min !== void 0 && (t.min = e.min - n.min), e.max !== void 0 && (t.max = e.max - n.min), t
}
const ww = .35;

function ZZ(n = ww) {
   return n === !1 ? n = 0 : n === !0 && (n = ww), {
      x: fO(n, "left", "right"),
      y: fO(n, "top", "bottom")
   }
}

function fO(n, e, t) {
   return {
      min: hO(n, e),
      max: hO(n, t)
   }
}

function hO(n, e) {
   return typeof n == "number" ? n : n[e] || 0
}
const QZ = new WeakMap;
class JZ {
   constructor(e) {
      this.openDragLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = {
         x: 0,
         y: 0
      }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = fs(), this.latestPointerEvent = null, this.latestPanInfo = null, this.visualElement = e
   }
   start(e, {
      snapToCursor: t = !1,
      distanceThreshold: i
   } = {}) {
      const {
         presenceContext: s
      } = this.visualElement;
      if (s && s.isPresent === !1) return;
      const r = g => {
            const {
               dragSnapToOrigin: v
            } = this.getProps();
            v ? this.pauseAnimation() : this.stopAnimation(), t && this.snapToCursor(wx(g).point)
         },
         a = (g, v) => {
            const {
               drag: x,
               dragPropagation: S,
               onDragStart: E
            } = this.getProps();
            if (x && !S && (this.openDragLock && this.openDragLock(), this.openDragLock = hK(x), !this.openDragLock)) return;
            this.latestPointerEvent = g, this.latestPanInfo = v, this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), qo(b => {
               let w = this.getAxisMotionValue(b).get() || 0;
               if (Iu.test(w)) {
                  const {
                     projection: C
                  } = this.visualElement;
                  if (C && C.layout) {
                     const N = C.layout.layoutBox[b];
                     N && (w = da(N) * (parseFloat(w) / 100))
                  }
               }
               this.originPoint[b] = w
            }), E && Ii.postRender(() => E(g, v)), Tw(this.visualElement, "transform");
            const {
               animationState: T
            } = this.visualElement;
            T && T.setActive("whileDrag", !0)
         },
         l = (g, v) => {
            this.latestPointerEvent = g, this.latestPanInfo = v;
            const {
               dragPropagation: x,
               dragDirectionLock: S,
               onDirectionLock: E,
               onDrag: T
            } = this.getProps();
            if (!x && !this.openDragLock) return;
            const {
               offset: b
            } = v;
            if (S && this.currentDirection === null) {
               this.currentDirection = $Z(b), this.currentDirection !== null && E && E(this.currentDirection);
               return
            }
            this.updateAxis("x", v.point, b), this.updateAxis("y", v.point, b), this.visualElement.render(), T && T(g, v)
         },
         c = (g, v) => {
            this.latestPointerEvent = g, this.latestPanInfo = v, this.stop(g, v), this.latestPointerEvent = null, this.latestPanInfo = null
         },
         h = () => qo(g => {
            var v;
            return this.getAnimationState(g) === "paused" && ((v = this.getAxisMotionValue(g).animation) == null ? void 0 : v.play())
         }),
         {
            dragSnapToOrigin: m
         } = this.getProps();
      this.panSession = new wI(e, {
         onSessionStart: r,
         onStart: a,
         onMove: l,
         onSessionEnd: c,
         resumeAnimation: h
      }, {
         transformPagePoint: this.visualElement.getTransformPagePoint(),
         dragSnapToOrigin: m,
         distanceThreshold: i,
         contextWindow: AI(this.visualElement)
      })
   }
   stop(e, t) {
      const i = e || this.latestPointerEvent,
         s = t || this.latestPanInfo,
         r = this.isDragging;
      if (this.cancel(), !r || !s || !i) return;
      const {
         velocity: a
      } = s;
      this.startAnimation(a);
      const {
         onDragEnd: l
      } = this.getProps();
      l && Ii.postRender(() => l(i, s))
   }
   cancel() {
      this.isDragging = !1;
      const {
         projection: e,
         animationState: t
      } = this.visualElement;
      e && (e.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0;
      const {
         dragPropagation: i
      } = this.getProps();
      !i && this.openDragLock && (this.openDragLock(), this.openDragLock = null), t && t.setActive("whileDrag", !1)
   }
   updateAxis(e, t, i) {
      const {
         drag: s
      } = this.getProps();
      if (!i || !nb(e, s, this.currentDirection)) return;
      const r = this.getAxisMotionValue(e);
      let a = this.originPoint[e] + i[e];
      this.constraints && this.constraints[e] && (a = qZ(a, this.constraints[e], this.elastic[e])), r.set(a)
   }
   resolveConstraints() {
      var r;
      const {
         dragConstraints: e,
         dragElastic: t
      } = this.getProps(), i = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (r = this.visualElement.projection) == null ? void 0 : r.layout, s = this.constraints;
      e && Km(e) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : e && i ? this.constraints = XZ(i.layoutBox, e) : this.constraints = !1, this.elastic = ZZ(t), s !== this.constraints && i && this.constraints && !this.hasMutatedConstraints && qo(a => {
         this.constraints !== !1 && this.getAxisMotionValue(a) && (this.constraints[a] = KZ(i.layoutBox[a], this.constraints[a]))
      })
   }
   resolveRefConstraints() {
      const {
         dragConstraints: e,
         onMeasureDragConstraints: t
      } = this.getProps();
      if (!e || !Km(e)) return !1;
      const i = e.current,
         {
            projection: s
         } = this.visualElement;
      if (!s || !s.layout) return !1;
      const r = VZ(i, s.root, this.visualElement.getTransformPagePoint());
      let a = WZ(s.layout.layoutBox, r);
      if (t) {
         const l = t(OZ(a));
         this.hasMutatedConstraints = !!l, l && (a = _I(l))
      }
      return a
   }
   startAnimation(e) {
      const {
         drag: t,
         dragMomentum: i,
         dragElastic: s,
         dragTransition: r,
         dragSnapToOrigin: a,
         onDragTransitionEnd: l
      } = this.getProps(), c = this.constraints || {}, h = qo(m => {
         if (!nb(m, t, this.currentDirection)) return;
         let g = c && c[m] || {};
         a && (g = {
            min: 0,
            max: 0
         });
         const v = s ? 200 : 1e6,
            x = s ? 40 : 1e7,
            S = {
               type: "inertia",
               velocity: i ? e[m] : 0,
               bounceStiffness: v,
               bounceDamping: x,
               timeConstant: 750,
               restDelta: 1,
               restSpeed: 10,
               ...r,
               ...g
            };
         return this.startAxisValueAnimation(m, S)
      });
      return Promise.all(h).then(l)
   }
   startAxisValueAnimation(e, t) {
      const i = this.getAxisMotionValue(e);
      return Tw(this.visualElement, e), i.start(q2(e, i, 0, t, this.visualElement, !1))
   }
   stopAnimation() {
      qo(e => this.getAxisMotionValue(e).stop())
   }
   pauseAnimation() {
      qo(e => {
         var t;
         return (t = this.getAxisMotionValue(e).animation) == null ? void 0 : t.pause()
      })
   }
   getAnimationState(e) {
      var t;
      return (t = this.getAxisMotionValue(e).animation) == null ? void 0 : t.state
   }
   getAxisMotionValue(e) {
      const t = `_drag${e.toUpperCase()}`,
         i = this.visualElement.getProps(),
         s = i[t];
      return s || this.visualElement.getValue(e, (i.initial ? i.initial[e] : void 0) || 0)
   }
   snapToCursor(e) {
      qo(t => {
         const {
            drag: i
         } = this.getProps();
         if (!nb(t, i, this.currentDirection)) return;
         const {
            projection: s
         } = this.visualElement, r = this.getAxisMotionValue(t);
         if (s && s.layout) {
            const {
               min: a,
               max: l
            } = s.layout.layoutBox[t];
            r.set(e[t] - Yi(a, l, .5))
         }
      })
   }
   scalePositionWithinConstraints() {
      if (!this.visualElement.current) return;
      const {
         drag: e,
         dragConstraints: t
      } = this.getProps(), {
         projection: i
      } = this.visualElement;
      if (!Km(t) || !i || !this.constraints) return;
      this.stopAnimation();
      const s = {
         x: 0,
         y: 0
      };
      qo(a => {
         const l = this.getAxisMotionValue(a);
         if (l && this.constraints !== !1) {
            const c = l.get();
            s[a] = YZ({
               min: c,
               max: c
            }, this.constraints[a])
         }
      });
      const {
         transformTemplate: r
      } = this.visualElement.getProps();
      this.visualElement.current.style.transform = r ? r({}, "") : "none", i.root && i.root.updateScroll(), i.updateLayout(), this.resolveConstraints(), qo(a => {
         if (!nb(a, e, null)) return;
         const l = this.getAxisMotionValue(a),
            {
               min: c,
               max: h
            } = this.constraints[a];
         l.set(Yi(c, h, s[a]))
      })
   }
   addListeners() {
      if (!this.visualElement.current) return;
      QZ.set(this.visualElement, this);
      const e = this.visualElement.current,
         t = Q0(e, "pointerdown", c => {
            const {
               drag: h,
               dragListener: m = !0
            } = this.getProps();
            h && m && this.start(c)
         }),
         i = () => {
            const {
               dragConstraints: c
            } = this.getProps();
            Km(c) && c.current && (this.constraints = this.resolveRefConstraints())
         },
         {
            projection: s
         } = this.visualElement,
         r = s.addEventListener("measure", i);
      s && !s.layout && (s.root && s.root.updateScroll(), s.updateLayout()), Ii.read(i);
      const a = Ky(window, "resize", () => this.scalePositionWithinConstraints()),
         l = s.addEventListener("didUpdate", ({
            delta: c,
            hasLayoutChanged: h
         }) => {
            this.isDragging && h && (qo(m => {
               const g = this.getAxisMotionValue(m);
               g && (this.originPoint[m] += c[m].translate, g.set(g.get() + c[m].translate))
            }), this.visualElement.render())
         });
      return () => {
         a(), t(), r(), l && l()
      }
   }
   getProps() {
      const e = this.visualElement.getProps(),
         {
            drag: t = !1,
            dragDirectionLock: i = !1,
            dragPropagation: s = !1,
            dragConstraints: r = !1,
            dragElastic: a = ww,
            dragMomentum: l = !0
         } = e;
      return {
         ...e,
         drag: t,
         dragDirectionLock: i,
         dragPropagation: s,
         dragConstraints: r,
         dragElastic: a,
         dragMomentum: l
      }
   }
}

function nb(n, e, t) {
   return (e === !0 || e === n) && (t === null || t === n)
}

function $Z(n, e = 10) {
   let t = null;
   return Math.abs(n.y) > e ? t = "y" : Math.abs(n.x) > e && (t = "x"), t
}
class eQ extends ph {
   constructor(e) {
      super(e), this.removeGroupControls = tl, this.removeListeners = tl, this.controls = new JZ(e)
   }
   mount() {
      const {
         dragControls: e
      } = this.node.getProps();
      e && (this.removeGroupControls = e.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || tl
   }
   unmount() {
      this.removeGroupControls(), this.removeListeners()
   }
}
const dO = n => (e, t) => {
   n && Ii.postRender(() => n(e, t))
};
class tQ extends ph {
   constructor() {
      super(...arguments), this.removePointerDownListener = tl
   }
   onPointerDown(e) {
      this.session = new wI(e, this.createPanHandlers(), {
         transformPagePoint: this.node.getTransformPagePoint(),
         contextWindow: AI(this.node)
      })
   }
   createPanHandlers() {
      const {
         onPanSessionStart: e,
         onPanStart: t,
         onPan: i,
         onPanEnd: s
      } = this.node.getProps();
      return {
         onSessionStart: dO(e),
         onStart: dO(t),
         onMove: i,
         onEnd: (r, a) => {
            delete this.session, s && Ii.postRender(() => s(r, a))
         }
      }
   }
   mount() {
      this.removePointerDownListener = Q0(this.node.current, "pointerdown", e => this.onPointerDown(e))
   }
   update() {
      this.session && this.session.updateHandlers(this.createPanHandlers())
   }
   unmount() {
      this.removePointerDownListener(), this.session && this.session.end()
   }
}
const Cb = {
   hasAnimatedSinceResize: !0,
   hasEverUpdated: !1
};

function pO(n, e) {
   return e.max === e.min ? 0 : n / (e.max - e.min) * 100
}
const _0 = {
      correct: (n, e) => {
         if (!e.target) return n;
         if (typeof n == "string")
            if (Jt.test(n)) n = parseFloat(n);
            else return n;
         const t = pO(n, e.target.x),
            i = pO(n, e.target.y);
         return `${t}% ${i}%`
      }
   },
   nQ = {
      correct: (n, {
         treeScale: e,
         projectionDelta: t
      }) => {
         const i = n,
            s = oh.parse(n);
         if (s.length > 5) return i;
         const r = oh.createTransformer(n),
            a = typeof s[0] != "number" ? 1 : 0,
            l = t.x.scale * e.x,
            c = t.y.scale * e.y;
         s[0 + a] /= l, s[1 + a] /= c;
         const h = Yi(l, c, .5);
         return typeof s[2 + a] == "number" && (s[2 + a] /= h), typeof s[3 + a] == "number" && (s[3 + a] /= h), r(s)
      }
   };
let mO = !1;
class iQ extends j.Component {
   componentDidMount() {
      const {
         visualElement: e,
         layoutGroup: t,
         switchLayoutGroup: i,
         layoutId: s
      } = this.props, {
         projection: r
      } = e;
      VK(sQ), r && (t.group && t.group.add(r), i && i.register && s && i.register(r), mO && r.root.didUpdate(), r.addEventListener("animationComplete", () => {
         this.safeToRemove()
      }), r.setOptions({
         ...r.options,
         onExitComplete: () => this.safeToRemove()
      })), Cb.hasEverUpdated = !0
   }
   getSnapshotBeforeUpdate(e) {
      const {
         layoutDependency: t,
         visualElement: i,
         drag: s,
         isPresent: r
      } = this.props, {
         projection: a
      } = i;
      return a && (a.isPresent = r, mO = !0, s || e.layoutDependency !== t || t === void 0 || e.isPresent !== r ? a.willUpdate() : this.safeToRemove(), e.isPresent !== r && (r ? a.promote() : a.relegate() || Ii.postRender(() => {
         const l = a.getStack();
         (!l || !l.members.length) && this.safeToRemove()
      }))), null
   }
   componentDidUpdate() {
      const {
         projection: e
      } = this.props.visualElement;
      e && (e.root.didUpdate(), P2.postRender(() => {
         !e.currentAnimation && e.isLead() && this.safeToRemove()
      }))
   }
   componentWillUnmount() {
      const {
         visualElement: e,
         layoutGroup: t,
         switchLayoutGroup: i
      } = this.props, {
         projection: s
      } = e;
      s && (s.scheduleCheckAfterUnmount(), t && t.group && t.group.remove(s), i && i.deregister && i.deregister(s))
   }
   safeToRemove() {
      const {
         safeToRemove: e
      } = this.props;
      e && e()
   }
   render() {
      return null
   }
}

function CI(n) {
   const [e, t] = tI(), i = j.useContext(f2);
   return H.jsx(iQ, {
      ...n,
      layoutGroup: i,
      switchLayoutGroup: j.useContext(oI),
      isPresent: e,
      safeToRemove: t
   })
}
const sQ = {
   borderRadius: {
      ..._0,
      applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"]
   },
   borderTopLeftRadius: _0,
   borderTopRightRadius: _0,
   borderBottomLeftRadius: _0,
   borderBottomRightRadius: _0,
   boxShadow: nQ
};

function rQ(n, e, t) {
   const i = Br(n) ? n : xg(n);
   return i.start(q2("", i, e, t)), i.animation
}
const aQ = (n, e) => n.depth - e.depth;
class oQ {
   constructor() {
      this.children = [], this.isDirty = !1
   }
   add(e) {
      p2(this.children, e), this.isDirty = !0
   }
   remove(e) {
      m2(this.children, e), this.isDirty = !0
   }
   forEach(e) {
      this.isDirty && this.children.sort(aQ), this.isDirty = !1, this.children.forEach(e)
   }
}

function lQ(n, e) {
   const t = La.now(),
      i = ({
         timestamp: s
      }) => {
         const r = s - t;
         r >= e && (ah(i), n(r - e))
      };
   return Ii.setup(i, !0), () => ah(i)
}
const DI = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"],
   uQ = DI.length,
   gO = n => typeof n == "string" ? parseFloat(n) : n,
   vO = n => typeof n == "number" || Jt.test(n);

function cQ(n, e, t, i, s, r) {
   s ? (n.opacity = Yi(0, t.opacity ?? 1, fQ(i)), n.opacityExit = Yi(e.opacity ?? 1, 0, hQ(i))) : r && (n.opacity = Yi(e.opacity ?? 1, t.opacity ?? 1, i));
   for (let a = 0; a < uQ; a++) {
      const l = `border${DI[a]}Radius`;
      let c = yO(e, l),
         h = yO(t, l);
      if (c === void 0 && h === void 0) continue;
      c || (c = 0), h || (h = 0), c === 0 || h === 0 || vO(c) === vO(h) ? (n[l] = Math.max(Yi(gO(c), gO(h), i), 0), (Iu.test(h) || Iu.test(c)) && (n[l] += "%")) : n[l] = h
   }(e.rotate || t.rotate) && (n.rotate = Yi(e.rotate || 0, t.rotate || 0, i))
}

function yO(n, e) {
   return n[e] !== void 0 ? n[e] : n.borderRadius
}
const fQ = NI(0, .5, bz),
   hQ = NI(.5, .95, tl);

function NI(n, e, t) {
   return i => i < n ? 0 : i > e ? 1 : t(ky(n, e, i))
}

function xO(n, e) {
   n.min = e.min, n.max = e.max
}

function Go(n, e) {
   xO(n.x, e.x), xO(n.y, e.y)
}

function _O(n, e) {
   n.translate = e.translate, n.scale = e.scale, n.originPoint = e.originPoint, n.origin = e.origin
}

function SO(n, e, t, i, s) {
   return n -= e, n = N1(n, 1 / t, i), s !== void 0 && (n = N1(n, 1 / s, i)), n
}

function dQ(n, e = 0, t = 1, i = .5, s, r = n, a = n) {
   if (Iu.test(e) && (e = parseFloat(e), e = Yi(a.min, a.max, e / 100) - a.min), typeof e != "number") return;
   let l = Yi(r.min, r.max, i);
   n === r && (l -= e), n.min = SO(n.min, e, t, l, s), n.max = SO(n.max, e, t, l, s)
}

function bO(n, e, [t, i, s], r, a) {
   dQ(n, e[t], e[i], e[s], e.scale, r, a)
}
const pQ = ["x", "scaleX", "originX"],
   mQ = ["y", "scaleY", "originY"];

function TO(n, e, t, i) {
   bO(n.x, e, pQ, t ? t.x : void 0, i ? i.x : void 0), bO(n.y, e, mQ, t ? t.y : void 0, i ? i.y : void 0)
}

function EO(n) {
   return n.translate === 0 && n.scale === 1
}

function OI(n) {
   return EO(n.x) && EO(n.y)
}

function MO(n, e) {
   return n.min === e.min && n.max === e.max
}

function gQ(n, e) {
   return MO(n.x, e.x) && MO(n.y, e.y)
}

function AO(n, e) {
   return Math.round(n.min) === Math.round(e.min) && Math.round(n.max) === Math.round(e.max)
}

function UI(n, e) {
   return AO(n.x, e.x) && AO(n.y, e.y)
}

function wO(n) {
   return da(n.x) / da(n.y)
}

function RO(n, e) {
   return n.translate === e.translate && n.scale === e.scale && n.originPoint === e.originPoint
}
class vQ {
   constructor() {
      this.members = []
   }
   add(e) {
      p2(this.members, e), e.scheduleRender()
   }
   remove(e) {
      if (m2(this.members, e), e === this.prevLead && (this.prevLead = void 0), e === this.lead) {
         const t = this.members[this.members.length - 1];
         t && this.promote(t)
      }
   }
   relegate(e) {
      const t = this.members.findIndex(s => e === s);
      if (t === 0) return !1;
      let i;
      for (let s = t; s >= 0; s--) {
         const r = this.members[s];
         if (r.isPresent !== !1) {
            i = r;
            break
         }
      }
      return i ? (this.promote(i), !0) : !1
   }
   promote(e, t) {
      const i = this.lead;
      if (e !== i && (this.prevLead = i, this.lead = e, e.show(), i)) {
         i.instance && i.scheduleRender(), e.scheduleRender(), e.resumeFrom = i, t && (e.resumeFrom.preserveOpacity = !0), i.snapshot && (e.snapshot = i.snapshot, e.snapshot.latestValues = i.animationValues || i.latestValues), e.root && e.root.isUpdating && (e.isLayoutDirty = !0);
         const {
            crossfade: s
         } = e.options;
         s === !1 && i.hide()
      }
   }
   exitAnimationComplete() {
      this.members.forEach(e => {
         const {
            options: t,
            resumingFrom: i
         } = e;
         t.onExitComplete && t.onExitComplete(), i && i.options.onExitComplete && i.options.onExitComplete()
      })
   }
   scheduleRender() {
      this.members.forEach(e => {
         e.instance && e.scheduleRender(!1)
      })
   }
   removeLeadSnapshot() {
      this.lead && this.lead.snapshot && (this.lead.snapshot = void 0)
   }
}

function yQ(n, e, t) {
   let i = "";
   const s = n.x.translate / e.x,
      r = n.y.translate / e.y,
      a = (t == null ? void 0 : t.z) || 0;
   if ((s || r || a) && (i = `translate3d(${s}px, ${r}px, ${a}px) `), (e.x !== 1 || e.y !== 1) && (i += `scale(${1/e.x}, ${1/e.y}) `), t) {
      const {
         transformPerspective: h,
         rotate: m,
         rotateX: g,
         rotateY: v,
         skewX: x,
         skewY: S
      } = t;
      h && (i = `perspective(${h}px) ${i}`), m && (i += `rotate(${m}deg) `), g && (i += `rotateX(${g}deg) `), v && (i += `rotateY(${v}deg) `), x && (i += `skewX(${x}deg) `), S && (i += `skewY(${S}deg) `)
   }
   const l = n.x.scale * e.x,
      c = n.y.scale * e.y;
   return (l !== 1 || c !== 1) && (i += `scale(${l}, ${c})`), i || "none"
}
const uA = ["", "X", "Y", "Z"],
   xQ = 1e3;
let _Q = 0;

function cA(n, e, t, i) {
   const {
      latestValues: s
   } = e;
   s[n] && (t[n] = s[n], e.setStaticValue(n, 0), i && (i[n] = 0))
}

function PI(n) {
   if (n.hasCheckedOptimisedAppear = !0, n.root === n) return;
   const {
      visualElement: e
   } = n.options;
   if (!e) return;
   const t = gI(e);
   if (window.MotionHasOptimisedAnimation(t, "transform")) {
      const {
         layout: s,
         layoutId: r
      } = n.options;
      window.MotionCancelOptimisedAnimation(t, "transform", Ii, !(s || r))
   }
   const {
      parent: i
   } = n;
   i && !i.hasCheckedOptimisedAppear && PI(i)
}

function LI({
   attachResizeListener: n,
   defaultParent: e,
   measureScroll: t,
   checkIsScrollRoot: i,
   resetTransform: s
}) {
   return class {
      constructor(a = {}, l = e == null ? void 0 : e()) {
         this.id = _Q++, this.animationId = 0, this.animationCommitId = 0, this.children = new Set, this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = {
            x: 1,
            y: 1
         }, this.eventHandlers = new Map, this.hasTreeAnimated = !1, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => {
            this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots())
         }, this.updateProjection = () => {
            this.projectionUpdateScheduled = !1, this.nodes.forEach(TQ), this.nodes.forEach(wQ), this.nodes.forEach(RQ), this.nodes.forEach(EQ)
         }, this.resolvedRelativeTargetAt = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = new Map, this.latestValues = a, this.root = l ? l.root || l : this, this.path = l ? [...l.path, l] : [], this.parent = l, this.depth = l ? l.depth + 1 : 0;
         for (let c = 0; c < this.path.length; c++) this.path[c].shouldResetTransform = !0;
         this.root === this && (this.nodes = new oQ)
      }
      addEventListener(a, l) {
         return this.eventHandlers.has(a) || this.eventHandlers.set(a, new y2), this.eventHandlers.get(a).add(l)
      }
      notifyListeners(a, ...l) {
         const c = this.eventHandlers.get(a);
         c && c.notify(...l)
      }
      hasListeners(a) {
         return this.eventHandlers.has(a)
      }
      mount(a) {
         if (this.instance) return;
         this.isSVG = eI(a) && !yK(a), this.instance = a;
         const {
            layoutId: l,
            layout: c,
            visualElement: h
         } = this.options;
         if (h && !h.current && h.mount(a), this.root.nodes.add(this), this.parent && this.parent.children.add(this), this.root.hasTreeAnimated && (c || l) && (this.isLayoutDirty = !0), n) {
            let m, g = 0;
            const v = () => this.root.updateBlockedByResize = !1;
            Ii.read(() => {
               g = window.innerWidth
            }), n(a, () => {
               const x = window.innerWidth;
               x !== g && (g = x, this.root.updateBlockedByResize = !0, m && m(), m = lQ(v, 250), Cb.hasAnimatedSinceResize && (Cb.hasAnimatedSinceResize = !1, this.nodes.forEach(NO)))
            })
         }
         l && this.root.registerSharedNode(l, this), this.options.animate !== !1 && h && (l || c) && this.addEventListener("didUpdate", ({
            delta: m,
            hasLayoutChanged: g,
            hasRelativeLayoutChanged: v,
            layout: x
         }) => {
            if (this.isTreeAnimationBlocked()) {
               this.target = void 0, this.relativeTarget = void 0;
               return
            }
            const S = this.options.transition || h.getDefaultTransition() || UQ,
               {
                  onLayoutAnimationStart: E,
                  onLayoutAnimationComplete: T
               } = h.getProps(),
               b = !this.targetLayout || !UI(this.targetLayout, x),
               w = !g && v;
            if (this.options.layoutRoot || this.resumeFrom || w || g && (b || !this.currentAnimation)) {
               this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0);
               const C = {
                  ...O2(S, "layout"),
                  onPlay: E,
                  onComplete: T
               };
               (h.shouldReduceMotion || this.options.layoutRoot) && (C.delay = 0, C.type = !1), this.startAnimation(C), this.setAnimationOrigin(m, w)
            } else g || NO(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
            this.targetLayout = x
         })
      }
      unmount() {
         this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
         const a = this.getStack();
         a && a.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, this.eventHandlers.clear(), ah(this.updateProjection)
      }
      blockUpdate() {
         this.updateManuallyBlocked = !0
      }
      unblockUpdate() {
         this.updateManuallyBlocked = !1
      }
      isUpdateBlocked() {
         return this.updateManuallyBlocked || this.updateBlockedByResize
      }
      isTreeAnimationBlocked() {
         return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1
      }
      startUpdate() {
         this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(CQ), this.animationId++)
      }
      getTransformTemplate() {
         const {
            visualElement: a
         } = this.options;
         return a && a.getProps().transformTemplate
      }
      willUpdate(a = !0) {
         if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) {
            this.options.onExitComplete && this.options.onExitComplete();
            return
         }
         if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && PI(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty) return;
         this.isLayoutDirty = !0;
         for (let m = 0; m < this.path.length; m++) {
            const g = this.path[m];
            g.shouldResetTransform = !0, g.updateScroll("snapshot"), g.options.layoutRoot && g.willUpdate(!1)
         }
         const {
            layoutId: l,
            layout: c
         } = this.options;
         if (l === void 0 && !c) return;
         const h = this.getTransformTemplate();
         this.prevTransformTemplateValue = h ? h(this.latestValues, "") : void 0, this.updateSnapshot(), a && this.notifyListeners("willUpdate")
      }
      update() {
         if (this.updateScheduled = !1, this.isUpdateBlocked()) {
            this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(CO);
            return
         }
         if (this.animationId <= this.animationCommitId) {
            this.nodes.forEach(DO);
            return
         }
         this.animationCommitId = this.animationId, this.isUpdating ? (this.isUpdating = !1, this.nodes.forEach(AQ), this.nodes.forEach(SQ), this.nodes.forEach(bQ)) : this.nodes.forEach(DO), this.clearAllSnapshots();
         const l = La.now();
         mr.delta = Lc(0, 1e3 / 60, l - mr.timestamp), mr.timestamp = l, mr.isProcessing = !0, eA.update.process(mr), eA.preRender.process(mr), eA.render.process(mr), mr.isProcessing = !1
      }
      didUpdate() {
         this.updateScheduled || (this.updateScheduled = !0, P2.read(this.scheduleUpdate))
      }
      clearAllSnapshots() {
         this.nodes.forEach(MQ), this.sharedNodes.forEach(DQ)
      }
      scheduleUpdateProjection() {
         this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, Ii.preRender(this.updateProjection, !1, !0))
      }
      scheduleCheckAfterUnmount() {
         Ii.postRender(() => {
            this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed()
         })
      }
      updateSnapshot() {
         this.snapshot || !this.instance || (this.snapshot = this.measure(), this.snapshot && !da(this.snapshot.measuredBox.x) && !da(this.snapshot.measuredBox.y) && (this.snapshot = void 0))
      }
      updateLayout() {
         if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)) return;
         if (this.resumeFrom && !this.resumeFrom.instance)
            for (let c = 0; c < this.path.length; c++) this.path[c].updateScroll();
         const a = this.layout;
         this.layout = this.measure(!1), this.layoutCorrected = fs(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
         const {
            visualElement: l
         } = this.options;
         l && l.notify("LayoutMeasure", this.layout.layoutBox, a ? a.layoutBox : void 0)
      }
      updateScroll(a = "measure") {
         let l = !!(this.options.layoutScroll && this.instance);
         if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === a && (l = !1), l && this.instance) {
            const c = i(this.instance);
            this.scroll = {
               animationId: this.root.animationId,
               phase: a,
               isRoot: c,
               offset: t(this.instance),
               wasRoot: this.scroll ? this.scroll.isRoot : c
            }
         }
      }
      resetTransform() {
         if (!s) return;
         const a = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout,
            l = this.projectionDelta && !OI(this.projectionDelta),
            c = this.getTransformTemplate(),
            h = c ? c(this.latestValues, "") : void 0,
            m = h !== this.prevTransformTemplateValue;
         a && this.instance && (l || Md(this.latestValues) || m) && (s(this.instance, h), this.shouldResetTransform = !1, this.scheduleRender())
      }
      measure(a = !0) {
         const l = this.measurePageBox();
         let c = this.removeElementScroll(l);
         return a && (c = this.removeTransform(c)), PQ(c), {
            animationId: this.root.animationId,
            measuredBox: l,
            layoutBox: c,
            latestValues: {},
            source: this.id
         }
      }
      measurePageBox() {
         var h;
         const {
            visualElement: a
         } = this.options;
         if (!a) return fs();
         const l = a.measureViewportBox();
         if (!(((h = this.scroll) == null ? void 0 : h.wasRoot) || this.path.some(LQ))) {
            const {
               scroll: m
            } = this.root;
            m && (Qm(l.x, m.offset.x), Qm(l.y, m.offset.y))
         }
         return l
      }
      removeElementScroll(a) {
         var c;
         const l = fs();
         if (Go(l, a), (c = this.scroll) != null && c.wasRoot) return l;
         for (let h = 0; h < this.path.length; h++) {
            const m = this.path[h],
               {
                  scroll: g,
                  options: v
               } = m;
            m !== this.root && g && v.layoutScroll && (g.wasRoot && Go(l, a), Qm(l.x, g.offset.x), Qm(l.y, g.offset.y))
         }
         return l
      }
      applyTransform(a, l = !1) {
         const c = fs();
         Go(c, a);
         for (let h = 0; h < this.path.length; h++) {
            const m = this.path[h];
            !l && m.options.layoutScroll && m.scroll && m !== m.root && Jm(c, {
               x: -m.scroll.offset.x,
               y: -m.scroll.offset.y
            }), Md(m.latestValues) && Jm(c, m.latestValues)
         }
         return Md(this.latestValues) && Jm(c, this.latestValues), c
      }
      removeTransform(a) {
         const l = fs();
         Go(l, a);
         for (let c = 0; c < this.path.length; c++) {
            const h = this.path[c];
            if (!h.instance || !Md(h.latestValues)) continue;
            Mw(h.latestValues) && h.updateSnapshot();
            const m = fs(),
               g = h.measurePageBox();
            Go(m, g), TO(l, h.latestValues, h.snapshot ? h.snapshot.layoutBox : void 0, m)
         }
         return Md(this.latestValues) && TO(l, this.latestValues), l
      }
      setTargetDelta(a) {
         this.targetDelta = a, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0
      }
      setOptions(a) {
         this.options = {
            ...this.options,
            ...a,
            crossfade: a.crossfade !== void 0 ? a.crossfade : !0
         }
      }
      clearMeasurements() {
         this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1
      }
      forceRelativeParentToResolveTarget() {
         this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== mr.timestamp && this.relativeParent.resolveTargetDelta(!0)
      }
      resolveTargetDelta(a = !1) {
         var v;
         const l = this.getLead();
         this.isProjectionDirty || (this.isProjectionDirty = l.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = l.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = l.isSharedProjectionDirty);
         const c = !!this.resumingFrom || this !== l;
         if (!(a || c && this.isSharedProjectionDirty || this.isProjectionDirty || (v = this.parent) != null && v.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize)) return;
         const {
            layout: m,
            layoutId: g
         } = this.options;
         if (!(!this.layout || !(m || g))) {
            if (this.resolvedRelativeTargetAt = mr.timestamp, !this.targetDelta && !this.relativeTarget) {
               const x = this.getClosestProjectingParent();
               x && x.layout && this.animationProgress !== 1 ? (this.relativeParent = x, this.forceRelativeParentToResolveTarget(), this.relativeTarget = fs(), this.relativeTargetOrigin = fs(), $0(this.relativeTargetOrigin, this.layout.layoutBox, x.layout.layoutBox), Go(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
            }
            if (!(!this.relativeTarget && !this.targetDelta) && (this.target || (this.target = fs(), this.targetWithTransforms = fs()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), FZ(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : Go(this.target, this.layout.layoutBox), EI(this.target, this.targetDelta)) : Go(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget)) {
               this.attemptToResolveRelativeTarget = !1;
               const x = this.getClosestProjectingParent();
               x && !!x.resumingFrom == !!this.resumingFrom && !x.options.layoutScroll && x.target && this.animationProgress !== 1 ? (this.relativeParent = x, this.forceRelativeParentToResolveTarget(), this.relativeTarget = fs(), this.relativeTargetOrigin = fs(), $0(this.relativeTargetOrigin, this.target, x.target), Go(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
            }
         }
      }
      getClosestProjectingParent() {
         if (!(!this.parent || Mw(this.parent.latestValues) || TI(this.parent.latestValues))) return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent()
      }
      isProjecting() {
         return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout)
      }
      calcProjection() {
         var S;
         const a = this.getLead(),
            l = !!this.resumingFrom || this !== a;
         let c = !0;
         if ((this.isProjectionDirty || (S = this.parent) != null && S.isProjectionDirty) && (c = !1), l && (this.isSharedProjectionDirty || this.isTransformDirty) && (c = !1), this.resolvedRelativeTargetAt === mr.timestamp && (c = !1), c) return;
         const {
            layout: h,
            layoutId: m
         } = this.options;
         if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(h || m)) return;
         Go(this.layoutCorrected, this.layout.layoutBox);
         const g = this.treeScale.x,
            v = this.treeScale.y;
         HZ(this.layoutCorrected, this.treeScale, this.path, l), a.layout && !a.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (a.target = a.layout.layoutBox, a.targetWithTransforms = fs());
         const {
            target: x
         } = a;
         if (!x) {
            this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender());
            return
         }!this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (_O(this.prevProjectionDelta.x, this.projectionDelta.x), _O(this.prevProjectionDelta.y, this.projectionDelta.y)), J0(this.projectionDelta, this.layoutCorrected, x, this.latestValues), (this.treeScale.x !== g || this.treeScale.y !== v || !RO(this.projectionDelta.x, this.prevProjectionDelta.x) || !RO(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", x))
      }
      hide() {
         this.isVisible = !1
      }
      show() {
         this.isVisible = !0
      }
      scheduleRender(a = !0) {
         var l;
         if ((l = this.options.visualElement) == null || l.scheduleRender(), a) {
            const c = this.getStack();
            c && c.scheduleRender()
         }
         this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0)
      }
      createProjectionDeltas() {
         this.prevProjectionDelta = Zm(), this.projectionDelta = Zm(), this.projectionDeltaWithTransform = Zm()
      }
      setAnimationOrigin(a, l = !1) {
         const c = this.snapshot,
            h = c ? c.latestValues : {},
            m = {
               ...this.latestValues
            },
            g = Zm();
         (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !l;
         const v = fs(),
            x = c ? c.source : void 0,
            S = this.layout ? this.layout.source : void 0,
            E = x !== S,
            T = this.getStack(),
            b = !T || T.members.length <= 1,
            w = !!(E && !b && this.options.crossfade === !0 && !this.path.some(OQ));
         this.animationProgress = 0;
         let C;
         this.mixTargetDelta = N => {
            const U = N / 1e3;
            OO(g.x, a.x, U), OO(g.y, a.y, U), this.setTargetDelta(g), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && ($0(v, this.layout.layoutBox, this.relativeParent.layout.layoutBox), NQ(this.relativeTarget, this.relativeTargetOrigin, v, U), C && gQ(this.relativeTarget, C) && (this.isProjectionDirty = !1), C || (C = fs()), Go(C, this.relativeTarget)), E && (this.animationValues = m, cQ(m, h, this.latestValues, U, w, b)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = U
         }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0)
      }
      startAnimation(a) {
         var l, c, h;
         this.notifyListeners("animationStart"), (l = this.currentAnimation) == null || l.stop(), (h = (c = this.resumingFrom) == null ? void 0 : c.currentAnimation) == null || h.stop(), this.pendingAnimation && (ah(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = Ii.update(() => {
            Cb.hasAnimatedSinceResize = !0, this.motionValue || (this.motionValue = xg(0)), this.currentAnimation = rQ(this.motionValue, [0, 1e3], {
               ...a,
               velocity: 0,
               isSync: !0,
               onUpdate: m => {
                  this.mixTargetDelta(m), a.onUpdate && a.onUpdate(m)
               },
               onStop: () => {},
               onComplete: () => {
                  a.onComplete && a.onComplete(), this.completeAnimation()
               }
            }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0
         })
      }
      completeAnimation() {
         this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
         const a = this.getStack();
         a && a.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete")
      }
      finishAnimation() {
         this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(xQ), this.currentAnimation.stop()), this.completeAnimation()
      }
      applyTransformsToTarget() {
         const a = this.getLead();
         let {
            targetWithTransforms: l,
            target: c,
            layout: h,
            latestValues: m
         } = a;
         if (!(!l || !c || !h)) {
            if (this !== a && this.layout && h && BI(this.options.animationType, this.layout.layoutBox, h.layoutBox)) {
               c = this.target || fs();
               const g = da(this.layout.layoutBox.x);
               c.x.min = a.target.x.min, c.x.max = c.x.min + g;
               const v = da(this.layout.layoutBox.y);
               c.y.min = a.target.y.min, c.y.max = c.y.min + v
            }
            Go(l, c), Jm(l, m), J0(this.projectionDeltaWithTransform, this.layoutCorrected, l, m)
         }
      }
      registerSharedNode(a, l) {
         this.sharedNodes.has(a) || this.sharedNodes.set(a, new vQ), this.sharedNodes.get(a).add(l);
         const h = l.options.initialPromotionConfig;
         l.promote({
            transition: h ? h.transition : void 0,
            preserveFollowOpacity: h && h.shouldPreserveFollowOpacity ? h.shouldPreserveFollowOpacity(l) : void 0
         })
      }
      isLead() {
         const a = this.getStack();
         return a ? a.lead === this : !0
      }
      getLead() {
         var l;
         const {
            layoutId: a
         } = this.options;
         return a ? ((l = this.getStack()) == null ? void 0 : l.lead) || this : this
      }
      getPrevLead() {
         var l;
         const {
            layoutId: a
         } = this.options;
         return a ? (l = this.getStack()) == null ? void 0 : l.prevLead : void 0
      }
      getStack() {
         const {
            layoutId: a
         } = this.options;
         if (a) return this.root.sharedNodes.get(a)
      }
      promote({
         needsReset: a,
         transition: l,
         preserveFollowOpacity: c
      } = {}) {
         const h = this.getStack();
         h && h.promote(this, c), a && (this.projectionDelta = void 0, this.needsReset = !0), l && this.setOptions({
            transition: l
         })
      }
      relegate() {
         const a = this.getStack();
         return a ? a.relegate(this) : !1
      }
      resetSkewAndRotation() {
         const {
            visualElement: a
         } = this.options;
         if (!a) return;
         let l = !1;
         const {
            latestValues: c
         } = a;
         if ((c.z || c.rotate || c.rotateX || c.rotateY || c.rotateZ || c.skewX || c.skewY) && (l = !0), !l) return;
         const h = {};
         c.z && cA("z", a, h, this.animationValues);
         for (let m = 0; m < uA.length; m++) cA(`rotate${uA[m]}`, a, h, this.animationValues), cA(`skew${uA[m]}`, a, h, this.animationValues);
         a.render();
         for (const m in h) a.setStaticValue(m, h[m]), this.animationValues && (this.animationValues[m] = h[m]);
         a.scheduleRender()
      }
      applyProjectionStyles(a, l) {
         if (!this.instance || this.isSVG) return;
         if (!this.isVisible) {
            a.visibility = "hidden";
            return
         }
         const c = this.getTransformTemplate();
         if (this.needsReset) {
            this.needsReset = !1, a.visibility = "", a.opacity = "", a.pointerEvents = Rb(l == null ? void 0 : l.pointerEvents) || "", a.transform = c ? c(this.latestValues, "") : "none";
            return
         }
         const h = this.getLead();
         if (!this.projectionDelta || !this.layout || !h.target) {
            this.options.layoutId && (a.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, a.pointerEvents = Rb(l == null ? void 0 : l.pointerEvents) || ""), this.hasProjected && !Md(this.latestValues) && (a.transform = c ? c({}, "") : "none", this.hasProjected = !1);
            return
         }
         a.visibility = "";
         const m = h.animationValues || h.latestValues;
         this.applyTransformsToTarget();
         let g = yQ(this.projectionDeltaWithTransform, this.treeScale, m);
         c && (g = c(m, g)), a.transform = g;
         const {
            x: v,
            y: x
         } = this.projectionDelta;
         a.transformOrigin = `${v.origin*100}% ${x.origin*100}% 0`, h.animationValues ? a.opacity = h === this ? m.opacity ?? this.latestValues.opacity ?? 1 : this.preserveOpacity ? this.latestValues.opacity : m.opacityExit : a.opacity = h === this ? m.opacity !== void 0 ? m.opacity : "" : m.opacityExit !== void 0 ? m.opacityExit : 0;
         for (const S in Wy) {
            if (m[S] === void 0) continue;
            const {
               correct: E,
               applyTo: T,
               isCSSVariable: b
            } = Wy[S], w = g === "none" ? m[S] : E(m[S], h);
            if (T) {
               const C = T.length;
               for (let N = 0; N < C; N++) a[T[N]] = w
            } else b ? this.options.visualElement.renderState.vars[S] = w : a[S] = w
         }
         this.options.layoutId && (a.pointerEvents = h === this ? Rb(l == null ? void 0 : l.pointerEvents) || "" : "none")
      }
      clearSnapshot() {
         this.resumeFrom = this.snapshot = void 0
      }
      resetTree() {
         this.root.nodes.forEach(a => {
            var l;
            return (l = a.currentAnimation) == null ? void 0 : l.stop()
         }), this.root.nodes.forEach(CO), this.root.sharedNodes.clear()
      }
   }
}

function SQ(n) {
   n.updateLayout()
}

function bQ(n) {
   var t;
   const e = ((t = n.resumeFrom) == null ? void 0 : t.snapshot) || n.snapshot;
   if (n.isLead() && n.layout && e && n.hasListeners("didUpdate")) {
      const {
         layoutBox: i,
         measuredBox: s
      } = n.layout, {
         animationType: r
      } = n.options, a = e.source !== n.layout.source;
      r === "size" ? qo(g => {
         const v = a ? e.measuredBox[g] : e.layoutBox[g],
            x = da(v);
         v.min = i[g].min, v.max = v.min + x
      }) : BI(r, e.layoutBox, i) && qo(g => {
         const v = a ? e.measuredBox[g] : e.layoutBox[g],
            x = da(i[g]);
         v.max = v.min + x, n.relativeTarget && !n.currentAnimation && (n.isProjectionDirty = !0, n.relativeTarget[g].max = n.relativeTarget[g].min + x)
      });
      const l = Zm();
      J0(l, i, e.layoutBox);
      const c = Zm();
      a ? J0(c, n.applyTransform(s, !0), e.measuredBox) : J0(c, i, e.layoutBox);
      const h = !OI(l);
      let m = !1;
      if (!n.resumeFrom) {
         const g = n.getClosestProjectingParent();
         if (g && !g.resumeFrom) {
            const {
               snapshot: v,
               layout: x
            } = g;
            if (v && x) {
               const S = fs();
               $0(S, e.layoutBox, v.layoutBox);
               const E = fs();
               $0(E, i, x.layoutBox), UI(S, E) || (m = !0), g.options.layoutRoot && (n.relativeTarget = E, n.relativeTargetOrigin = S, n.relativeParent = g)
            }
         }
      }
      n.notifyListeners("didUpdate", {
         layout: i,
         snapshot: e,
         delta: c,
         layoutDelta: l,
         hasLayoutChanged: h,
         hasRelativeLayoutChanged: m
      })
   } else if (n.isLead()) {
      const {
         onExitComplete: i
      } = n.options;
      i && i()
   }
   n.options.transition = void 0
}

function TQ(n) {
   n.parent && (n.isProjecting() || (n.isProjectionDirty = n.parent.isProjectionDirty), n.isSharedProjectionDirty || (n.isSharedProjectionDirty = !!(n.isProjectionDirty || n.parent.isProjectionDirty || n.parent.isSharedProjectionDirty)), n.isTransformDirty || (n.isTransformDirty = n.parent.isTransformDirty))
}

function EQ(n) {
   n.isProjectionDirty = n.isSharedProjectionDirty = n.isTransformDirty = !1
}

function MQ(n) {
   n.clearSnapshot()
}

function CO(n) {
   n.clearMeasurements()
}

function DO(n) {
   n.isLayoutDirty = !1
}

function AQ(n) {
   const {
      visualElement: e
   } = n.options;
   e && e.getProps().onBeforeLayoutMeasure && e.notify("BeforeLayoutMeasure"), n.resetTransform()
}

function NO(n) {
   n.finishAnimation(), n.targetDelta = n.relativeTarget = n.target = void 0, n.isProjectionDirty = !0
}

function wQ(n) {
   n.resolveTargetDelta()
}

function RQ(n) {
   n.calcProjection()
}

function CQ(n) {
   n.resetSkewAndRotation()
}

function DQ(n) {
   n.removeLeadSnapshot()
}

function OO(n, e, t) {
   n.translate = Yi(e.translate, 0, t), n.scale = Yi(e.scale, 1, t), n.origin = e.origin, n.originPoint = e.originPoint
}

function UO(n, e, t, i) {
   n.min = Yi(e.min, t.min, i), n.max = Yi(e.max, t.max, i)
}

function NQ(n, e, t, i) {
   UO(n.x, e.x, t.x, i), UO(n.y, e.y, t.y, i)
}

function OQ(n) {
   return n.animationValues && n.animationValues.opacityExit !== void 0
}
const UQ = {
      duration: .45,
      ease: [.4, 0, .1, 1]
   },
   PO = n => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(n),
   LO = PO("applewebkit/") && !PO("chrome/") ? Math.round : tl;

function BO(n) {
   n.min = LO(n.min), n.max = LO(n.max)
}

function PQ(n) {
   BO(n.x), BO(n.y)
}

function BI(n, e, t) {
   return n === "position" || n === "preserve-aspect" && !IZ(wO(e), wO(t), .2)
}

function LQ(n) {
   var e;
   return n !== n.root && ((e = n.scroll) == null ? void 0 : e.wasRoot)
}
const BQ = LI({
      attachResizeListener: (n, e) => Ky(n, "resize", e),
      measureScroll: () => ({
         x: document.documentElement.scrollLeft || document.body.scrollLeft,
         y: document.documentElement.scrollTop || document.body.scrollTop
      }),
      checkIsScrollRoot: () => !0
   }),
   fA = {
      current: void 0
   },
   zI = LI({
      measureScroll: n => ({
         x: n.scrollLeft,
         y: n.scrollTop
      }),
      defaultParent: () => {
         if (!fA.current) {
            const n = new BQ({});
            n.mount(window), n.setOptions({
               layoutScroll: !0
            }), fA.current = n
         }
         return fA.current
      },
      resetTransform: (n, e) => {
         n.style.transform = e !== void 0 ? e : "none"
      },
      checkIsScrollRoot: n => window.getComputedStyle(n).position === "fixed"
   }),
   zQ = {
      pan: {
         Feature: tQ
      },
      drag: {
         Feature: eQ,
         ProjectionNode: zI,
         MeasureLayout: CI
      }
   };

function zO(n, e, t) {
   const {
      props: i
   } = n;
   n.animationState && i.whileHover && n.animationState.setActive("whileHover", t === "Start");
   const s = "onHover" + t,
      r = i[s];
   r && Ii.postRender(() => r(e, wx(e)))
}
class IQ extends ph {
   mount() {
      const {
         current: e
      } = this.node;
      e && (this.unmount = dK(e, (t, i) => (zO(this.node, i, "Start"), s => zO(this.node, s, "End"))))
   }
   unmount() {}
}
class FQ extends ph {
   constructor() {
      super(...arguments), this.isActive = !1
   }
   onFocus() {
      let e = !1;
      try {
         e = this.node.current.matches(":focus-visible")
      } catch {
         e = !0
      }!e || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0)
   }
   onBlur() {
      !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1)
   }
   mount() {
      this.unmount = Ex(Ky(this.node.current, "focus", () => this.onFocus()), Ky(this.node.current, "blur", () => this.onBlur()))
   }
   unmount() {}
}

function IO(n, e, t) {
   const {
      props: i
   } = n;
   if (n.current instanceof HTMLButtonElement && n.current.disabled) return;
   n.animationState && i.whileTap && n.animationState.setActive("whileTap", t === "Start");
   const s = "onTap" + (t === "End" ? "" : t),
      r = i[s];
   r && Ii.postRender(() => r(e, wx(e)))
}
class HQ extends ph {
   mount() {
      const {
         current: e
      } = this.node;
      e && (this.unmount = vK(e, (t, i) => (IO(this.node, i, "Start"), (s, {
         success: r
      }) => IO(this.node, s, r ? "End" : "Cancel")), {
         useGlobalTarget: this.node.props.globalTapTarget
      }))
   }
   unmount() {}
}
const Rw = new WeakMap,
   hA = new WeakMap,
   VQ = n => {
      const e = Rw.get(n.target);
      e && e(n)
   },
   GQ = n => {
      n.forEach(VQ)
   };

function kQ({
   root: n,
   ...e
}) {
   const t = n || document;
   hA.has(t) || hA.set(t, {});
   const i = hA.get(t),
      s = JSON.stringify(e);
   return i[s] || (i[s] = new IntersectionObserver(GQ, {
      root: n,
      ...e
   })), i[s]
}

function jQ(n, e, t) {
   const i = kQ(e);
   return Rw.set(n, t), i.observe(n), () => {
      Rw.delete(n), i.unobserve(n)
   }
}
const qQ = {
   some: 0,
   all: 1
};
class XQ extends ph {
   constructor() {
      super(...arguments), this.hasEnteredView = !1, this.isInView = !1
   }
   startObserver() {
      this.unmount();
      const {
         viewport: e = {}
      } = this.node.getProps(), {
         root: t,
         margin: i,
         amount: s = "some",
         once: r
      } = e, a = {
         root: t ? t.current : void 0,
         rootMargin: i,
         threshold: typeof s == "number" ? s : qQ[s]
      }, l = c => {
         const {
            isIntersecting: h
         } = c;
         if (this.isInView === h || (this.isInView = h, r && !h && this.hasEnteredView)) return;
         h && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", h);
         const {
            onViewportEnter: m,
            onViewportLeave: g
         } = this.node.getProps(), v = h ? m : g;
         v && v(c)
      };
      return jQ(this.node.current, a, l)
   }
   mount() {
      this.startObserver()
   }
   update() {
      if (typeof IntersectionObserver > "u") return;
      const {
         props: e,
         prevProps: t
      } = this.node;
      ["amount", "margin", "root"].some(WQ(e, t)) && this.startObserver()
   }
   unmount() {}
}

function WQ({
   viewport: n = {}
}, {
   viewport: e = {}
} = {}) {
   return t => n[t] !== e[t]
}
const YQ = {
      inView: {
         Feature: XQ
      },
      tap: {
         Feature: HQ
      },
      focus: {
         Feature: FQ
      },
      hover: {
         Feature: IQ
      }
   },
   KQ = {
      layout: {
         ProjectionNode: zI,
         MeasureLayout: CI
      }
   },
   Cw = {
      current: null
   },
   II = {
      current: !1
   };

function ZQ() {
   if (II.current = !0, !!d2)
      if (window.matchMedia) {
         const n = window.matchMedia("(prefers-reduced-motion)"),
            e = () => Cw.current = n.matches;
         n.addEventListener("change", e), e()
      } else Cw.current = !1
}
const QQ = new WeakMap;

function JQ(n, e, t) {
   for (const i in e) {
      const s = e[i],
         r = t[i];
      if (Br(s)) n.addValue(i, s);
      else if (Br(r)) n.addValue(i, xg(s, {
         owner: n
      }));
      else if (r !== s)
         if (n.hasValue(i)) {
            const a = n.getValue(i);
            a.liveStyle === !0 ? a.jump(s) : a.hasAnimated || a.set(s)
         } else {
            const a = n.getStaticValue(i);
            n.addValue(i, xg(a !== void 0 ? a : s, {
               owner: n
            }))
         }
   }
   for (const i in t) e[i] === void 0 && n.removeValue(i);
   return e
}
const FO = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"];
class $Q {
   scrapeMotionValuesFromProps(e, t, i) {
      return {}
   }
   constructor({
      parent: e,
      props: t,
      presenceContext: i,
      reducedMotionConfig: s,
      blockInitialAnimation: r,
      visualState: a
   }, l = {}) {
      this.current = null, this.children = new Set, this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = new Map, this.KeyframeResolver = D2, this.features = {}, this.valueSubscriptions = new Map, this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
         this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection))
      }, this.renderScheduledAt = 0, this.scheduleRender = () => {
         const v = La.now();
         this.renderScheduledAt < v && (this.renderScheduledAt = v, Ii.render(this.render, !1, !0))
      };
      const {
         latestValues: c,
         renderState: h
      } = a;
      this.latestValues = c, this.baseTarget = {
         ...c
      }, this.initialValues = t.initial ? {
         ...c
      } : {}, this.renderState = h, this.parent = e, this.props = t, this.presenceContext = i, this.depth = e ? e.depth + 1 : 0, this.reducedMotionConfig = s, this.options = l, this.blockInitialAnimation = !!r, this.isControllingVariants = IT(t), this.isVariantNode = rI(t), this.isVariantNode && (this.variantChildren = new Set), this.manuallyAnimateOnMount = !!(e && e.current);
      const {
         willChange: m,
         ...g
      } = this.scrapeMotionValuesFromProps(t, {}, this);
      for (const v in g) {
         const x = g[v];
         c[v] !== void 0 && Br(x) && x.set(c[v], !1)
      }
   }
   mount(e) {
      this.current = e, QQ.set(e, this), this.projection && !this.projection.instance && this.projection.mount(e), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((t, i) => this.bindToMotionValue(i, t)), II.current || ZQ(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : Cw.current, this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext)
   }
   unmount() {
      this.projection && this.projection.unmount(), ah(this.notifyUpdate), ah(this.render), this.valueSubscriptions.forEach(e => e()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this);
      for (const e in this.events) this.events[e].clear();
      for (const e in this.features) {
         const t = this.features[e];
         t && (t.unmount(), t.isMounted = !1)
      }
      this.current = null
   }
   bindToMotionValue(e, t) {
      this.valueSubscriptions.has(e) && this.valueSubscriptions.get(e)();
      const i = Vg.has(e);
      i && this.onBindTransform && this.onBindTransform();
      const s = t.on("change", l => {
            this.latestValues[e] = l, this.props.onUpdate && Ii.preRender(this.notifyUpdate), i && this.projection && (this.projection.isTransformDirty = !0)
         }),
         r = t.on("renderRequest", this.scheduleRender);
      let a;
      window.MotionCheckAppearSync && (a = window.MotionCheckAppearSync(this, e, t)), this.valueSubscriptions.set(e, () => {
         s(), r(), a && a(), t.owner && t.stop()
      })
   }
   sortNodePosition(e) {
      return !this.current || !this.sortInstanceNodePosition || this.type !== e.type ? 0 : this.sortInstanceNodePosition(this.current, e.current)
   }
   updateFeatures() {
      let e = "animation";
      for (e in _g) {
         const t = _g[e];
         if (!t) continue;
         const {
            isEnabled: i,
            Feature: s
         } = t;
         if (!this.features[e] && s && i(this.props) && (this.features[e] = new s(this)), this.features[e]) {
            const r = this.features[e];
            r.isMounted ? r.update() : (r.mount(), r.isMounted = !0)
         }
      }
   }
   triggerBuild() {
      this.build(this.renderState, this.latestValues, this.props)
   }
   measureViewportBox() {
      return this.current ? this.measureInstanceViewportBox(this.current, this.props) : fs()
   }
   getStaticValue(e) {
      return this.latestValues[e]
   }
   setStaticValue(e, t) {
      this.latestValues[e] = t
   }
   update(e, t) {
      (e.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = e, this.prevPresenceContext = this.presenceContext, this.presenceContext = t;
      for (let i = 0; i < FO.length; i++) {
         const s = FO[i];
         this.propEventSubscriptions[s] && (this.propEventSubscriptions[s](), delete this.propEventSubscriptions[s]);
         const r = "on" + s,
            a = e[r];
         a && (this.propEventSubscriptions[s] = this.on(s, a))
      }
      this.prevMotionValues = JQ(this, this.scrapeMotionValuesFromProps(e, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue()
   }
   getProps() {
      return this.props
   }
   getVariant(e) {
      return this.props.variants ? this.props.variants[e] : void 0
   }
   getDefaultTransition() {
      return this.props.transition
   }
   getTransformPagePoint() {
      return this.props.transformPagePoint
   }
   getClosestVariantNode() {
      return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0
   }
   addVariantChild(e) {
      const t = this.getClosestVariantNode();
      if (t) return t.variantChildren && t.variantChildren.add(e), () => t.variantChildren.delete(e)
   }
   addValue(e, t) {
      const i = this.values.get(e);
      t !== i && (i && this.removeValue(e), this.bindToMotionValue(e, t), this.values.set(e, t), this.latestValues[e] = t.get())
   }
   removeValue(e) {
      this.values.delete(e);
      const t = this.valueSubscriptions.get(e);
      t && (t(), this.valueSubscriptions.delete(e)), delete this.latestValues[e], this.removeValueFromRenderState(e, this.renderState)
   }
   hasValue(e) {
      return this.values.has(e)
   }
   getValue(e, t) {
      if (this.props.values && this.props.values[e]) return this.props.values[e];
      let i = this.values.get(e);
      return i === void 0 && t !== void 0 && (i = xg(t === null ? void 0 : t, {
         owner: this
      }), this.addValue(e, i)), i
   }
   readValue(e, t) {
      let i = this.latestValues[e] !== void 0 || !this.current ? this.latestValues[e] : this.getBaseTargetFromProps(this.props, e) ?? this.readValueFromInstance(this.current, e, this.options);
      return i != null && (typeof i == "string" && (hz(i) || pz(i)) ? i = parseFloat(i) : !_K(i) && oh.test(t) && (i = Kz(e, t)), this.setBaseTarget(e, Br(i) ? i.get() : i)), Br(i) ? i.get() : i
   }
   setBaseTarget(e, t) {
      this.baseTarget[e] = t
   }
   getBaseTarget(e) {
      var r;
      const {
         initial: t
      } = this.props;
      let i;
      if (typeof t == "string" || typeof t == "object") {
         const a = k2(this.props, t, (r = this.presenceContext) == null ? void 0 : r.custom);
         a && (i = a[e])
      }
      if (t && i !== void 0) return i;
      const s = this.getBaseTargetFromProps(this.props, e);
      return s !== void 0 && !Br(s) ? s : this.initialValues[e] !== void 0 && i === void 0 ? void 0 : this.baseTarget[e]
   }
   on(e, t) {
      return this.events[e] || (this.events[e] = new y2), this.events[e].add(t)
   }
   notify(e, ...t) {
      this.events[e] && this.events[e].notify(...t)
   }
}
class FI extends $Q {
   constructor() {
      super(...arguments), this.KeyframeResolver = lK
   }
   sortInstanceNodePosition(e, t) {
      return e.compareDocumentPosition(t) & 2 ? 1 : -1
   }
   getBaseTargetFromProps(e, t) {
      return e.style ? e.style[t] : void 0
   }
   removeValueFromRenderState(e, {
      vars: t,
      style: i
   }) {
      delete t[e], delete i[e]
   }
   handleChildMotionValue() {
      this.childSubscription && (this.childSubscription(), delete this.childSubscription);
      const {
         children: e
      } = this.props;
      Br(e) && (this.childSubscription = e.on("change", t => {
         this.current && (this.current.textContent = `${t}`)
      }))
   }
}

function HI(n, {
   style: e,
   vars: t
}, i, s) {
   const r = n.style;
   let a;
   for (a in e) r[a] = e[a];
   s == null || s.applyProjectionStyles(r, i);
   for (a in t) r.setProperty(a, t[a])
}

function eJ(n) {
   return window.getComputedStyle(n)
}
class tJ extends FI {
   constructor() {
      super(...arguments), this.type = "html", this.renderInstance = HI
   }
   readValueFromInstance(e, t) {
      var i;
      if (Vg.has(t)) return (i = this.projection) != null && i.isProjecting ? gw(t) : wY(e, t); {
         const s = eJ(e),
            r = (S2(t) ? s.getPropertyValue(t) : s[t]) || 0;
         return typeof r == "string" ? r.trim() : r
      }
   }
   measureInstanceViewportBox(e, {
      transformPagePoint: t
   }) {
      return MI(e, t)
   }
   build(e, t, i) {
      H2(e, t, i.transformTemplate)
   }
   scrapeMotionValuesFromProps(e, t, i) {
      return j2(e, t, i)
   }
}
const VI = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]);

function nJ(n, e, t, i) {
   HI(n, e, void 0, i);
   for (const s in e.attrs) n.setAttribute(VI.has(s) ? s : F2(s), e.attrs[s])
}
class iJ extends FI {
   constructor() {
      super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = fs
   }
   getBaseTargetFromProps(e, t) {
      return e[t]
   }
   readValueFromInstance(e, t) {
      if (Vg.has(t)) {
         const i = Yz(t);
         return i && i.default || 0
      }
      return t = VI.has(t) ? t : F2(t), e.getAttribute(t)
   }
   scrapeMotionValuesFromProps(e, t, i) {
      return mI(e, t, i)
   }
   build(e, t, i) {
      fI(e, t, this.isSVGTag, i.transformTemplate, i.style)
   }
   renderInstance(e, t, i, s) {
      nJ(e, t, i, s)
   }
   mount(e) {
      this.isSVGTag = dI(e.tagName), super.mount(e)
   }
}
const sJ = (n, e) => G2(n) ? new iJ(e) : new tJ(e, {
      allowProjection: n !== j.Fragment
   }),
   rJ = sZ({
      ...DZ,
      ...YQ,
      ...zQ,
      ...KQ
   }, sJ),
   Db = CK(rJ);

function aJ({
   componentProgress: n,
   isThreeLoaded: e
}) {
   const [t, i] = j.useState(!0), [s, r] = j.useState(0), [a, l] = j.useState(0), [c, h] = j.useState(!1), [m, g] = j.useState(!1);
   j.useEffect(() => {
      const S = () => {
         h(window.innerWidth < 768), g(window.innerHeight > window.innerWidth && window.innerWidth >= 768)
      };
      return S(), window.addEventListener("resize", S), () => window.removeEventListener("resize", S)
   }, []), j.useEffect(() => {
      const S = setTimeout(() => {
         l(n)
      }, 50);
      return () => clearTimeout(S)
   }, [n]), j.useEffect(() => {
      if (c || m) return;
      const S = E => {
         const T = window.innerWidth / 2,
            b = window.innerHeight / 2,
            w = E.clientX - T,
            C = E.clientY - b,
            N = Math.atan2(C, w) * 180 / Math.PI;
         r(N + 90)
      };
      return window.addEventListener("mousemove", S), () => window.removeEventListener("mousemove", S)
   }, [c, m]), j.useEffect(() => {
      if (e) {
         const S = setTimeout(() => {
            i(!1)
         }, 300);
         return () => clearTimeout(S)
      }
   }, [e]);
   const v = c ? "40vh" : m ? "42vh" : "56svh",
      x = c ? "80px" : m ? "120px" : "140px";
   return H.jsx(nI, {
      children: t && H.jsxs(Db.div, {
         initial: {
            opacity: 1
         },
         animate: {
            opacity: 1
         },
         exit: {
            opacity: 0
         },
         transition: {
            duration: .8,
            ease: "easeInOut"
         },
         style: {
            position: "fixed",
            top: 0,
            left: 0,
            width: "100vw",
            height: "100svh",
            backgroundColor: "#090909",
            color: "#fff",
            display: "flex",
            justifyContent: "center",
            alignItems: "center",
            zIndex: 9999,
            letterSpacing: "0.1em"
         },
         children: [H.jsx("div", {
            style: {
               position: "fixed",
               top: "50%",
               left: "50%",
               transform: "translate(-50%, -50%)",
               width: v,
               height: v,
               borderRadius: "50%",
               backgroundColor: "#090909",
               zIndex: -1
            }
         }), H.jsx("div", {
            style: {
               position: "fixed",
               top: "50%",
               left: "50%",
               transform: "translate(-50%, -50%)",
               width: `calc(${v} + 1vh)`,
               height: `calc(${v} + 1vh)`,
               borderRadius: "50%",
               background: `linear-gradient(${s}deg, black, white)`,
               pointerEvents: "none",
               transition: "background 0.1s linear",
               opacity: .4,
               zIndex: -2
            }
         }), H.jsxs("div", {
            style: {
               display: "grid",
               placeItems: "center",
               gridTemplateRows: "1fr auto 1fr",
               height: v,
               width: v,
               position: "relative",
               zIndex: 1,
               textAlign: "center",
               gap: "20px"
            },
            children: [H.jsxs("div", {
               style: {
                  display: "flex",
                  flexDirection: "column",
                  alignItems: "center",
                  gap: "8px"
               },
               children: [H.jsx("div", {
                  style: {
                     fontSize: c ? "0.85rem" : "1rem",
                     opacity: .7,
                     lineHeight: 1.2,
                     fontWeight: 300
                  },
                  children: "Se ncarc..."
               }), H.jsx("div", {
                  style: {
                     fontSize: c ? "1.5rem" : "2rem",
                     opacity: .9,
                     lineHeight: 1,
                     fontWeight: 500
                  },
                  children: Math.floor(a) + "%"
               })]
            }), H.jsx("img", {
               src: "logo/iso.svg",
               alt: "Logo",
               style: {
                  height: x
               }
            }), H.jsx("div", {
               style: {
                  fontSize: c ? "0.75rem" : "0.85rem",
                  opacity: .5,
                  lineHeight: 1.2,
                  fontWeight: 300
               },
               children: "Loading..."
            })]
         })]
      })
   })
}

function bc(n) {
   if (n === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
   return n
}

function GI(n, e) {
   n.prototype = Object.create(e.prototype), n.prototype.constructor = n, n.__proto__ = e
}
/*!
 * GSAP 3.13.0
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license
 * @author: Jack Doyle, jack@greensock.com
 */
var mo = {
      autoSleep: 120,
      force3D: "auto",
      nullTargetWarn: 1,
      units: {
         lineHeight: ""
      }
   },
   Sg = {
      duration: .5,
      overwrite: !1,
      delay: 0
   },
   X2, vr, zi, Zo = 1e8,
   bi = 1 / Zo,
   Dw = Math.PI * 2,
   oJ = Dw / 4,
   lJ = 0,
   kI = Math.sqrt,
   uJ = Math.cos,
   cJ = Math.sin,
   ir = function (e) {
      return typeof e == "string"
   },
   is = function (e) {
      return typeof e == "function"
   },
   zc = function (e) {
      return typeof e == "number"
   },
   W2 = function (e) {
      return typeof e > "u"
   },
   ku = function (e) {
      return typeof e == "object"
   },
   za = function (e) {
      return e !== !1
   },
   Y2 = function () {
      return typeof window < "u"
   },
   ib = function (e) {
      return is(e) || ir(e)
   },
   jI = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function () {},
   Ir = Array.isArray,
   Nw = /(?:-?\.?\d|\.)+/gi,
   qI = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
   $m = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
   dA = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
   XI = /[+-]=-?[.\d]+/,
   WI = /[^,'"\[\]\s]+/gi,
   fJ = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
   Xi, wu, Ow, K2, vo = {},
   O1 = {},
   YI, KI = function (e) {
      return (O1 = bg(e, vo)) && ka
   },
   Z2 = function (e, t) {
      return console.warn("Invalid property", e, "set to", t, "Missing plugin? gsap.registerPlugin()")
   },
   Zy = function (e, t) {
      return !t && console.warn(e)
   },
   ZI = function (e, t) {
      return e && (vo[e] = t) && O1 && (O1[e] = t) || vo
   },
   Qy = function () {
      return 0
   },
   hJ = {
      suppressEvents: !0,
      isStart: !0,
      kill: !1
   },
   Nb = {
      suppressEvents: !0,
      kill: !1
   },
   dJ = {
      suppressEvents: !0
   },
   Q2 = {},
   $f = [],
   Uw = {},
   QI, oo = {},
   pA = {},
   HO = 30,
   Ob = [],
   J2 = "",
   $2 = function (e) {
      var t = e[0],
         i, s;
      if (ku(t) || is(t) || (e = [e]), !(i = (t._gsap || {}).harness)) {
         for (s = Ob.length; s-- && !Ob[s].targetTest(t););
         i = Ob[s]
      }
      for (s = e.length; s--;) e[s] && (e[s]._gsap || (e[s]._gsap = new S4(e[s], i))) || e.splice(s, 1);
      return e
   },
   jd = function (e) {
      return e._gsap || $2(Qo(e))[0]._gsap
   },
   JI = function (e, t, i) {
      return (i = e[t]) && is(i) ? e[t]() : W2(i) && e.getAttribute && e.getAttribute(t) || i
   },
   Ia = function (e, t) {
      return (e = e.split(",")).forEach(t) || e
   },
   hs = function (e) {
      return Math.round(e * 1e5) / 1e5 || 0
   },
   Rs = function (e) {
      return Math.round(e * 1e7) / 1e7 || 0
   },
   ig = function (e, t) {
      var i = t.charAt(0),
         s = parseFloat(t.substr(2));
      return e = parseFloat(e), i === "+" ? e + s : i === "-" ? e - s : i === "*" ? e * s : e / s
   },
   pJ = function (e, t) {
      for (var i = t.length, s = 0; e.indexOf(t[s]) < 0 && ++s < i;);
      return s < i
   },
   U1 = function () {
      var e = $f.length,
         t = $f.slice(0),
         i, s;
      for (Uw = {}, $f.length = 0, i = 0; i < e; i++) s = t[i], s && s._lazy && (s.render(s._lazy[0], s._lazy[1], !0)._lazy = 0)
   },
   eC = function (e) {
      return !!(e._initted || e._startAt || e.add)
   },
   $I = function (e, t, i, s) {
      $f.length && !vr && U1(), e.render(t, i, !!(vr && t < 0 && eC(e))), $f.length && !vr && U1()
   },
   e4 = function (e) {
      var t = parseFloat(e);
      return (t || t === 0) && (e + "").match(WI).length < 2 ? t : ir(e) ? e.trim() : e
   },
   t4 = function (e) {
      return e
   },
   yo = function (e, t) {
      for (var i in t) i in e || (e[i] = t[i]);
      return e
   },
   mJ = function (e) {
      return function (t, i) {
         for (var s in i) s in t || s === "duration" && e || s === "ease" || (t[s] = i[s])
      }
   },
   bg = function (e, t) {
      for (var i in t) e[i] = t[i];
      return e
   },
   VO = function n(e, t) {
      for (var i in t) i !== "__proto__" && i !== "constructor" && i !== "prototype" && (e[i] = ku(t[i]) ? n(e[i] || (e[i] = {}), t[i]) : t[i]);
      return e
   },
   P1 = function (e, t) {
      var i = {},
         s;
      for (s in e) s in t || (i[s] = e[s]);
      return i
   },
   ey = function (e) {
      var t = e.parent || Xi,
         i = e.keyframes ? mJ(Ir(e.keyframes)) : yo;
      if (za(e.inherit))
         for (; t;) i(e, t.vars.defaults), t = t.parent || t._dp;
      return e
   },
   gJ = function (e, t) {
      for (var i = e.length, s = i === t.length; s && i-- && e[i] === t[i];);
      return i < 0
   },
   n4 = function (e, t, i, s, r) {
      var a = e[s],
         l;
      if (r)
         for (l = t[r]; a && a[r] > l;) a = a._prev;
      return a ? (t._next = a._next, a._next = t) : (t._next = e[i], e[i] = t), t._next ? t._next._prev = t : e[s] = t, t._prev = a, t.parent = t._dp = e, t
   },
   FT = function (e, t, i, s) {
      i === void 0 && (i = "_first"), s === void 0 && (s = "_last");
      var r = t._prev,
         a = t._next;
      r ? r._next = a : e[i] === t && (e[i] = a), a ? a._prev = r : e[s] === t && (e[s] = r), t._next = t._prev = t.parent = null
   },
   lh = function (e, t) {
      e.parent && (!t || e.parent.autoRemoveChildren) && e.parent.remove && e.parent.remove(e), e._act = 0
   },
   qd = function (e, t) {
      if (e && (!t || t._end > e._dur || t._start < 0))
         for (var i = e; i;) i._dirty = 1, i = i.parent;
      return e
   },
   vJ = function (e) {
      for (var t = e.parent; t && t.parent;) t._dirty = 1, t.totalDuration(), t = t.parent;
      return e
   },
   Pw = function (e, t, i, s) {
      return e._startAt && (vr ? e._startAt.revert(Nb) : e.vars.immediateRender && !e.vars.autoRevert || e._startAt.render(t, !0, s))
   },
   yJ = function n(e) {
      return !e || e._ts && n(e.parent)
   },
   GO = function (e) {
      return e._repeat ? Tg(e._tTime, e = e.duration() + e._rDelay) * e : 0
   },
   Tg = function (e, t) {
      var i = Math.floor(e = Rs(e / t));
      return e && i === e ? i - 1 : i
   },
   L1 = function (e, t) {
      return (e - t._start) * t._ts + (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur)
   },
   HT = function (e) {
      return e._end = Rs(e._start + (e._tDur / Math.abs(e._ts || e._rts || bi) || 0))
   },
   VT = function (e, t) {
      var i = e._dp;
      return i && i.smoothChildTiming && e._ts && (e._start = Rs(i._time - (e._ts > 0 ? t / e._ts : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)), HT(e), i._dirty || qd(i, e)), e
   },
   i4 = function (e, t) {
      var i;
      if ((t._time || !t._dur && t._initted || t._start < e._time && (t._dur || !t.add)) && (i = L1(e.rawTime(), t), (!t._dur || Rx(0, t.totalDuration(), i) - t._tTime > bi) && t.render(i, !0)), qd(e, t)._dp && e._initted && e._time >= e._dur && e._ts) {
         if (e._dur < e.duration())
            for (i = e; i._dp;) i.rawTime() >= 0 && i.totalTime(i._tTime), i = i._dp;
         e._zTime = -bi
      }
   },
   Cu = function (e, t, i, s) {
      return t.parent && lh(t), t._start = Rs((zc(i) ? i : i || e !== Xi ? Xo(e, i, t) : e._time) + t._delay), t._end = Rs(t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)), n4(e, t, "_first", "_last", e._sort ? "_start" : 0), Lw(t) || (e._recent = t), s || i4(e, t), e._ts < 0 && VT(e, e._tTime), e
   },
   s4 = function (e, t) {
      return (vo.ScrollTrigger || Z2("scrollTrigger", t)) && vo.ScrollTrigger.create(t, e)
   },
   r4 = function (e, t, i, s, r) {
      if (nC(e, t, r), !e._initted) return 1;
      if (!i && e._pt && !vr && (e._dur && e.vars.lazy !== !1 || !e._dur && e.vars.lazy) && QI !== uo.frame) return $f.push(e), e._lazy = [r, s], 1
   },
   xJ = function n(e) {
      var t = e.parent;
      return t && t._ts && t._initted && !t._lock && (t.rawTime() < 0 || n(t))
   },
   Lw = function (e) {
      var t = e.data;
      return t === "isFromStart" || t === "isStart"
   },
   _J = function (e, t, i, s) {
      var r = e.ratio,
         a = t < 0 || !t && (!e._start && xJ(e) && !(!e._initted && Lw(e)) || (e._ts < 0 || e._dp._ts < 0) && !Lw(e)) ? 0 : 1,
         l = e._rDelay,
         c = 0,
         h, m, g;
      if (l && e._repeat && (c = Rx(0, e._tDur, t), m = Tg(c, l), e._yoyo && m & 1 && (a = 1 - a), m !== Tg(e._tTime, l) && (r = 1 - a, e.vars.repeatRefresh && e._initted && e.invalidate())), a !== r || vr || s || e._zTime === bi || !t && e._zTime) {
         if (!e._initted && r4(e, t, s, i, c)) return;
         for (g = e._zTime, e._zTime = t || (i ? bi : 0), i || (i = t && !g), e.ratio = a, e._from && (a = 1 - a), e._time = 0, e._tTime = c, h = e._pt; h;) h.r(a, h.d), h = h._next;
         t < 0 && Pw(e, t, i, !0), e._onUpdate && !i && fo(e, "onUpdate"), c && e._repeat && !i && e.parent && fo(e, "onRepeat"), (t >= e._tDur || t < 0) && e.ratio === a && (a && lh(e, 1), !i && !vr && (fo(e, a ? "onComplete" : "onReverseComplete", !0), e._prom && e._prom()))
      } else e._zTime || (e._zTime = t)
   },
   SJ = function (e, t, i) {
      var s;
      if (i > t)
         for (s = e._first; s && s._start <= i;) {
            if (s.data === "isPause" && s._start > t) return s;
            s = s._next
         } else
            for (s = e._last; s && s._start >= i;) {
               if (s.data === "isPause" && s._start < t) return s;
               s = s._prev
            }
   },
   Eg = function (e, t, i, s) {
      var r = e._repeat,
         a = Rs(t) || 0,
         l = e._tTime / e._tDur;
      return l && !s && (e._time *= a / e._dur), e._dur = a, e._tDur = r ? r < 0 ? 1e10 : Rs(a * (r + 1) + e._rDelay * r) : a, l > 0 && !s && VT(e, e._tTime = e._tDur * l), e.parent && HT(e), i || qd(e.parent, e), e
   },
   kO = function (e) {
      return e instanceof ca ? qd(e) : Eg(e, e._dur)
   },
   bJ = {
      _start: 0,
      endTime: Qy,
      totalDuration: Qy
   },
   Xo = function n(e, t, i) {
      var s = e.labels,
         r = e._recent || bJ,
         a = e.duration() >= Zo ? r.endTime(!1) : e._dur,
         l, c, h;
      return ir(t) && (isNaN(t) || t in s) ? (c = t.charAt(0), h = t.substr(-1) === "%", l = t.indexOf("="), c === "<" || c === ">" ? (l >= 0 && (t = t.replace(/=/, "")), (c === "<" ? r._start : r.endTime(r._repeat >= 0)) + (parseFloat(t.substr(1)) || 0) * (h ? (l < 0 ? r : i).totalDuration() / 100 : 1)) : l < 0 ? (t in s || (s[t] = a), s[t]) : (c = parseFloat(t.charAt(l - 1) + t.substr(l + 1)), h && i && (c = c / 100 * (Ir(i) ? i[0] : i).totalDuration()), l > 1 ? n(e, t.substr(0, l - 1), i) + c : a + c)) : t == null ? a : +t
   },
   ty = function (e, t, i) {
      var s = zc(t[1]),
         r = (s ? 2 : 1) + (e < 2 ? 0 : 1),
         a = t[r],
         l, c;
      if (s && (a.duration = t[1]), a.parent = i, e) {
         for (l = a, c = i; c && !("immediateRender" in l);) l = c.vars.defaults || {}, c = za(c.vars.inherit) && c.parent;
         a.immediateRender = za(l.immediateRender), e < 2 ? a.runBackwards = 1 : a.startAt = t[r - 1]
      }
      return new ws(t[0], a, t[r + 1])
   },
   mh = function (e, t) {
      return e || e === 0 ? t(e) : t
   },
   Rx = function (e, t, i) {
      return i < e ? e : i > t ? t : i
   },
   Or = function (e, t) {
      return !ir(e) || !(t = fJ.exec(e)) ? "" : t[1]
   },
   TJ = function (e, t, i) {
      return mh(i, function (s) {
         return Rx(e, t, s)
      })
   },
   Bw = [].slice,
   a4 = function (e, t) {
      return e && ku(e) && "length" in e && (!t && !e.length || e.length - 1 in e && ku(e[0])) && !e.nodeType && e !== wu
   },
   EJ = function (e, t, i) {
      return i === void 0 && (i = []), e.forEach(function (s) {
         var r;
         return ir(s) && !t || a4(s, 1) ? (r = i).push.apply(r, Qo(s)) : i.push(s)
      }) || i
   },
   Qo = function (e, t, i) {
      return zi && !t && zi.selector ? zi.selector(e) : ir(e) && !i && (Ow || !Mg()) ? Bw.call((t || K2).querySelectorAll(e), 0) : Ir(e) ? EJ(e, i) : a4(e) ? Bw.call(e, 0) : e ? [e] : []
   },
   zw = function (e) {
      return e = Qo(e)[0] || Zy("Invalid scope") || {},
         function (t) {
            var i = e.current || e.nativeElement || e;
            return Qo(t, i.querySelectorAll ? i : i === e ? Zy("Invalid scope") || K2.createElement("div") : e)
         }
   },
   o4 = function (e) {
      return e.sort(function () {
         return .5 - Math.random()
      })
   },
   l4 = function (e) {
      if (is(e)) return e;
      var t = ku(e) ? e : {
            each: e
         },
         i = Xd(t.ease),
         s = t.from || 0,
         r = parseFloat(t.base) || 0,
         a = {},
         l = s > 0 && s < 1,
         c = isNaN(s) || l,
         h = t.axis,
         m = s,
         g = s;
      return ir(s) ? m = g = {
            center: .5,
            edges: .5,
            end: 1
         } [s] || 0 : !l && c && (m = s[0], g = s[1]),
         function (v, x, S) {
            var E = (S || t).length,
               T = a[E],
               b, w, C, N, U, z, B, I, O;
            if (!T) {
               if (O = t.grid === "auto" ? 0 : (t.grid || [1, Zo])[1], !O) {
                  for (B = -Zo; B < (B = S[O++].getBoundingClientRect().left) && O < E;);
                  O < E && O--
               }
               for (T = a[E] = [], b = c ? Math.min(O, E) * m - .5 : s % O, w = O === Zo ? 0 : c ? E * g / O - .5 : s / O | 0, B = 0, I = Zo, z = 0; z < E; z++) C = z % O - b, N = w - (z / O | 0), T[z] = U = h ? Math.abs(h === "y" ? N : C) : kI(C * C + N * N), U > B && (B = U), U < I && (I = U);
               s === "random" && o4(T), T.max = B - I, T.min = I, T.v = E = (parseFloat(t.amount) || parseFloat(t.each) * (O > E ? E - 1 : h ? h === "y" ? E / O : O : Math.max(O, E / O)) || 0) * (s === "edges" ? -1 : 1), T.b = E < 0 ? r - E : r, T.u = Or(t.amount || t.each) || 0, i = i && E < 0 ? y4(i) : i
            }
            return E = (T[v] - T.min) / T.max || 0, Rs(T.b + (i ? i(E) : E) * T.v) + T.u
         }
   },
   Iw = function (e) {
      var t = Math.pow(10, ((e + "").split(".")[1] || "").length);
      return function (i) {
         var s = Rs(Math.round(parseFloat(i) / e) * e * t);
         return (s - s % 1) / t + (zc(i) ? 0 : Or(i))
      }
   },
   u4 = function (e, t) {
      var i = Ir(e),
         s, r;
      return !i && ku(e) && (s = i = e.radius || Zo, e.values ? (e = Qo(e.values), (r = !zc(e[0])) && (s *= s)) : e = Iw(e.increment)), mh(t, i ? is(e) ? function (a) {
         return r = e(a), Math.abs(r - a) <= s ? r : a
      } : function (a) {
         for (var l = parseFloat(r ? a.x : a), c = parseFloat(r ? a.y : 0), h = Zo, m = 0, g = e.length, v, x; g--;) r ? (v = e[g].x - l, x = e[g].y - c, v = v * v + x * x) : v = Math.abs(e[g] - l), v < h && (h = v, m = g);
         return m = !s || h <= s ? e[m] : a, r || m === a || zc(a) ? m : m + Or(a)
      } : Iw(e))
   },
   c4 = function (e, t, i, s) {
      return mh(Ir(e) ? !t : i === !0 ? !!(i = 0) : !s, function () {
         return Ir(e) ? e[~~(Math.random() * e.length)] : (i = i || 1e-5) && (s = i < 1 ? Math.pow(10, (i + "").length - 2) : 1) && Math.floor(Math.round((e - i / 2 + Math.random() * (t - e + i * .99)) / i) * i * s) / s
      })
   },
   MJ = function () {
      for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];
      return function (s) {
         return t.reduce(function (r, a) {
            return a(r)
         }, s)
      }
   },
   AJ = function (e, t) {
      return function (i) {
         return e(parseFloat(i)) + (t || Or(i))
      }
   },
   wJ = function (e, t, i) {
      return h4(e, t, 0, 1, i)
   },
   f4 = function (e, t, i) {
      return mh(i, function (s) {
         return e[~~t(s)]
      })
   },
   RJ = function n(e, t, i) {
      var s = t - e;
      return Ir(e) ? f4(e, n(0, e.length), t) : mh(i, function (r) {
         return (s + (r - e) % s) % s + e
      })
   },
   CJ = function n(e, t, i) {
      var s = t - e,
         r = s * 2;
      return Ir(e) ? f4(e, n(0, e.length - 1), t) : mh(i, function (a) {
         return a = (r + (a - e) % r) % r || 0, e + (a > s ? r - a : a)
      })
   },
   Jy = function (e) {
      for (var t = 0, i = "", s, r, a, l; ~(s = e.indexOf("random(", t));) a = e.indexOf(")", s), l = e.charAt(s + 7) === "[", r = e.substr(s + 7, a - s - 7).match(l ? WI : Nw), i += e.substr(t, s - t) + c4(l ? r : +r[0], l ? 0 : +r[1], +r[2] || 1e-5), t = a + 1;
      return i + e.substr(t, e.length - t)
   },
   h4 = function (e, t, i, s, r) {
      var a = t - e,
         l = s - i;
      return mh(r, function (c) {
         return i + ((c - e) / a * l || 0)
      })
   },
   DJ = function n(e, t, i, s) {
      var r = isNaN(e + t) ? 0 : function (x) {
         return (1 - x) * e + x * t
      };
      if (!r) {
         var a = ir(e),
            l = {},
            c, h, m, g, v;
         if (i === !0 && (s = 1) && (i = null), a) e = {
            p: e
         }, t = {
            p: t
         };
         else if (Ir(e) && !Ir(t)) {
            for (m = [], g = e.length, v = g - 2, h = 1; h < g; h++) m.push(n(e[h - 1], e[h]));
            g--, r = function (S) {
               S *= g;
               var E = Math.min(v, ~~S);
               return m[E](S - E)
            }, i = t
         } else s || (e = bg(Ir(e) ? [] : {}, e));
         if (!m) {
            for (c in t) tC.call(l, e, c, "get", t[c]);
            r = function (S) {
               return rC(S, l) || (a ? e.p : e)
            }
         }
      }
      return mh(i, r)
   },
   jO = function (e, t, i) {
      var s = e.labels,
         r = Zo,
         a, l, c;
      for (a in s) l = s[a] - t, l < 0 == !!i && l && r > (l = Math.abs(l)) && (c = a, r = l);
      return c
   },
   fo = function (e, t, i) {
      var s = e.vars,
         r = s[t],
         a = zi,
         l = e._ctx,
         c, h, m;
      if (r) return c = s[t + "Params"], h = s.callbackScope || e, i && $f.length && U1(), l && (zi = l), m = c ? r.apply(h, c) : r.call(h), zi = a, m
   },
   N0 = function (e) {
      return lh(e), e.scrollTrigger && e.scrollTrigger.kill(!!vr), e.progress() < 1 && fo(e, "onInterrupt"), e
   },
   eg, d4 = [],
   p4 = function (e) {
      if (e)
         if (e = !e.name && e.default || e, Y2() || e.headless) {
            var t = e.name,
               i = is(e),
               s = t && !i && e.init ? function () {
                  this._props = []
               } : e,
               r = {
                  init: Qy,
                  render: rC,
                  add: tC,
                  kill: XJ,
                  modifier: qJ,
                  rawVars: 0
               },
               a = {
                  targetTest: 0,
                  get: 0,
                  getSetter: sC,
                  aliases: {},
                  register: 0
               };
            if (Mg(), e !== s) {
               if (oo[t]) return;
               yo(s, yo(P1(e, r), a)), bg(s.prototype, bg(r, P1(e, a))), oo[s.prop = t] = s, e.targetTest && (Ob.push(s), Q2[t] = 1), t = (t === "css" ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) + "Plugin"
            }
            ZI(t, s), e.register && e.register(ka, s, Fa)
         } else d4.push(e)
   },
   Si = 255,
   O0 = {
      aqua: [0, Si, Si],
      lime: [0, Si, 0],
      silver: [192, 192, 192],
      black: [0, 0, 0],
      maroon: [128, 0, 0],
      teal: [0, 128, 128],
      blue: [0, 0, Si],
      navy: [0, 0, 128],
      white: [Si, Si, Si],
      olive: [128, 128, 0],
      yellow: [Si, Si, 0],
      orange: [Si, 165, 0],
      gray: [128, 128, 128],
      purple: [128, 0, 128],
      green: [0, 128, 0],
      red: [Si, 0, 0],
      pink: [Si, 192, 203],
      cyan: [0, Si, Si],
      transparent: [Si, Si, Si, 0]
   },
   mA = function (e, t, i) {
      return e += e < 0 ? 1 : e > 1 ? -1 : 0, (e * 6 < 1 ? t + (i - t) * e * 6 : e < .5 ? i : e * 3 < 2 ? t + (i - t) * (2 / 3 - e) * 6 : t) * Si + .5 | 0
   },
   m4 = function (e, t, i) {
      var s = e ? zc(e) ? [e >> 16, e >> 8 & Si, e & Si] : 0 : O0.black,
         r, a, l, c, h, m, g, v, x, S;
      if (!s) {
         if (e.substr(-1) === "," && (e = e.substr(0, e.length - 1)), O0[e]) s = O0[e];
         else if (e.charAt(0) === "#") {
            if (e.length < 6 && (r = e.charAt(1), a = e.charAt(2), l = e.charAt(3), e = "#" + r + r + a + a + l + l + (e.length === 5 ? e.charAt(4) + e.charAt(4) : "")), e.length === 9) return s = parseInt(e.substr(1, 6), 16), [s >> 16, s >> 8 & Si, s & Si, parseInt(e.substr(7), 16) / 255];
            e = parseInt(e.substr(1), 16), s = [e >> 16, e >> 8 & Si, e & Si]
         } else if (e.substr(0, 3) === "hsl") {
            if (s = S = e.match(Nw), !t) c = +s[0] % 360 / 360, h = +s[1] / 100, m = +s[2] / 100, a = m <= .5 ? m * (h + 1) : m + h - m * h, r = m * 2 - a, s.length > 3 && (s[3] *= 1), s[0] = mA(c + 1 / 3, r, a), s[1] = mA(c, r, a), s[2] = mA(c - 1 / 3, r, a);
            else if (~e.indexOf("=")) return s = e.match(qI), i && s.length < 4 && (s[3] = 1), s
         } else s = e.match(Nw) || O0.transparent;
         s = s.map(Number)
      }
      return t && !S && (r = s[0] / Si, a = s[1] / Si, l = s[2] / Si, g = Math.max(r, a, l), v = Math.min(r, a, l), m = (g + v) / 2, g === v ? c = h = 0 : (x = g - v, h = m > .5 ? x / (2 - g - v) : x / (g + v), c = g === r ? (a - l) / x + (a < l ? 6 : 0) : g === a ? (l - r) / x + 2 : (r - a) / x + 4, c *= 60), s[0] = ~~(c + .5), s[1] = ~~(h * 100 + .5), s[2] = ~~(m * 100 + .5)), i && s.length < 4 && (s[3] = 1), s
   },
   g4 = function (e) {
      var t = [],
         i = [],
         s = -1;
      return e.split(eh).forEach(function (r) {
         var a = r.match($m) || [];
         t.push.apply(t, a), i.push(s += a.length + 1)
      }), t.c = i, t
   },
   qO = function (e, t, i) {
      var s = "",
         r = (e + s).match(eh),
         a = t ? "hsla(" : "rgba(",
         l = 0,
         c, h, m, g;
      if (!r) return e;
      if (r = r.map(function (v) {
            return (v = m4(v, t, 1)) && a + (t ? v[0] + "," + v[1] + "%," + v[2] + "%," + v[3] : v.join(",")) + ")"
         }), i && (m = g4(e), c = i.c, c.join(s) !== m.c.join(s)))
         for (h = e.replace(eh, "1").split($m), g = h.length - 1; l < g; l++) s += h[l] + (~c.indexOf(l) ? r.shift() || a + "0,0,0,0)" : (m.length ? m : r.length ? r : i).shift());
      if (!h)
         for (h = e.split(eh), g = h.length - 1; l < g; l++) s += h[l] + r[l];
      return s + h[g]
   },
   eh = function () {
      var n = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",
         e;
      for (e in O0) n += "|" + e + "\\b";
      return new RegExp(n + ")", "gi")
   }(),
   NJ = /hsl[a]?\(/,
   v4 = function (e) {
      var t = e.join(" "),
         i;
      if (eh.lastIndex = 0, eh.test(t)) return i = NJ.test(t), e[1] = qO(e[1], i), e[0] = qO(e[0], i, g4(e[1])), !0
   },
   $y, uo = function () {
      var n = Date.now,
         e = 500,
         t = 33,
         i = n(),
         s = i,
         r = 1e3 / 240,
         a = r,
         l = [],
         c, h, m, g, v, x, S = function E(T) {
            var b = n() - s,
               w = T === !0,
               C, N, U, z;
            if ((b > e || b < 0) && (i += b - t), s += b, U = s - i, C = U - a, (C > 0 || w) && (z = ++g.frame, v = U - g.time * 1e3, g.time = U = U / 1e3, a += C + (C >= r ? 4 : r - C), N = 1), w || (c = h(E)), N)
               for (x = 0; x < l.length; x++) l[x](U, v, z, T)
         };
      return g = {
         time: 0,
         frame: 0,
         tick: function () {
            S(!0)
         },
         deltaRatio: function (T) {
            return v / (1e3 / (T || 60))
         },
         wake: function () {
            YI && (!Ow && Y2() && (wu = Ow = window, K2 = wu.document || {}, vo.gsap = ka, (wu.gsapVersions || (wu.gsapVersions = [])).push(ka.version), KI(O1 || wu.GreenSockGlobals || !wu.gsap && wu || {}), d4.forEach(p4)), m = typeof requestAnimationFrame < "u" && requestAnimationFrame, c && g.sleep(), h = m || function (T) {
               return setTimeout(T, a - g.time * 1e3 + 1 | 0)
            }, $y = 1, S(2))
         },
         sleep: function () {
            (m ? cancelAnimationFrame : clearTimeout)(c), $y = 0, h = Qy
         },
         lagSmoothing: function (T, b) {
            e = T || 1 / 0, t = Math.min(b || 33, e)
         },
         fps: function (T) {
            r = 1e3 / (T || 240), a = g.time * 1e3 + r
         },
         add: function (T, b, w) {
            var C = b ? function (N, U, z, B) {
               T(N, U, z, B), g.remove(C)
            } : T;
            return g.remove(T), l[w ? "unshift" : "push"](C), Mg(), C
         },
         remove: function (T, b) {
            ~(b = l.indexOf(T)) && l.splice(b, 1) && x >= b && x--
         },
         _listeners: l
      }, g
   }(),
   Mg = function () {
      return !$y && uo.wake()
   },
   kn = {},
   OJ = /^[\d.\-M][\d.\-,\s]/,
   UJ = /["']/g,
   PJ = function (e) {
      for (var t = {}, i = e.substr(1, e.length - 3).split(":"), s = i[0], r = 1, a = i.length, l, c, h; r < a; r++) c = i[r], l = r !== a - 1 ? c.lastIndexOf(",") : c.length, h = c.substr(0, l), t[s] = isNaN(h) ? h.replace(UJ, "").trim() : +h, s = c.substr(l + 1).trim();
      return t
   },
   LJ = function (e) {
      var t = e.indexOf("(") + 1,
         i = e.indexOf(")"),
         s = e.indexOf("(", t);
      return e.substring(t, ~s && s < i ? e.indexOf(")", i + 1) : i)
   },
   BJ = function (e) {
      var t = (e + "").split("("),
         i = kn[t[0]];
      return i && t.length > 1 && i.config ? i.config.apply(null, ~e.indexOf("{") ? [PJ(t[1])] : LJ(e).split(",").map(e4)) : kn._CE && OJ.test(e) ? kn._CE("", e) : i
   },
   y4 = function (e) {
      return function (t) {
         return 1 - e(1 - t)
      }
   },
   x4 = function n(e, t) {
      for (var i = e._first, s; i;) i instanceof ca ? n(i, t) : i.vars.yoyoEase && (!i._yoyo || !i._repeat) && i._yoyo !== t && (i.timeline ? n(i.timeline, t) : (s = i._ease, i._ease = i._yEase, i._yEase = s, i._yoyo = t)), i = i._next
   },
   Xd = function (e, t) {
      return e && (is(e) ? e : kn[e] || BJ(e)) || t
   },
   dp = function (e, t, i, s) {
      i === void 0 && (i = function (c) {
         return 1 - t(1 - c)
      }), s === void 0 && (s = function (c) {
         return c < .5 ? t(c * 2) / 2 : 1 - t((1 - c) * 2) / 2
      });
      var r = {
            easeIn: t,
            easeOut: i,
            easeInOut: s
         },
         a;
      return Ia(e, function (l) {
         kn[l] = vo[l] = r, kn[a = l.toLowerCase()] = i;
         for (var c in r) kn[a + (c === "easeIn" ? ".in" : c === "easeOut" ? ".out" : ".inOut")] = kn[l + "." + c] = r[c]
      }), r
   },
   _4 = function (e) {
      return function (t) {
         return t < .5 ? (1 - e(1 - t * 2)) / 2 : .5 + e((t - .5) * 2) / 2
      }
   },
   gA = function n(e, t, i) {
      var s = t >= 1 ? t : 1,
         r = (i || (e ? .3 : .45)) / (t < 1 ? t : 1),
         a = r / Dw * (Math.asin(1 / s) || 0),
         l = function (m) {
            return m === 1 ? 1 : s * Math.pow(2, -10 * m) * cJ((m - a) * r) + 1
         },
         c = e === "out" ? l : e === "in" ? function (h) {
            return 1 - l(1 - h)
         } : _4(l);
      return r = Dw / r, c.config = function (h, m) {
         return n(e, h, m)
      }, c
   },
   vA = function n(e, t) {
      t === void 0 && (t = 1.70158);
      var i = function (a) {
            return a ? --a * a * ((t + 1) * a + t) + 1 : 0
         },
         s = e === "out" ? i : e === "in" ? function (r) {
            return 1 - i(1 - r)
         } : _4(i);
      return s.config = function (r) {
         return n(e, r)
      }, s
   };
Ia("Linear,Quad,Cubic,Quart,Quint,Strong", function (n, e) {
   var t = e < 5 ? e + 1 : e;
   dp(n + ",Power" + (t - 1), e ? function (i) {
      return Math.pow(i, t)
   } : function (i) {
      return i
   }, function (i) {
      return 1 - Math.pow(1 - i, t)
   }, function (i) {
      return i < .5 ? Math.pow(i * 2, t) / 2 : 1 - Math.pow((1 - i) * 2, t) / 2
   })
});
kn.Linear.easeNone = kn.none = kn.Linear.easeIn;
dp("Elastic", gA("in"), gA("out"), gA());
(function (n, e) {
   var t = 1 / e,
      i = 2 * t,
      s = 2.5 * t,
      r = function (l) {
         return l < t ? n * l * l : l < i ? n * Math.pow(l - 1.5 / e, 2) + .75 : l < s ? n * (l -= 2.25 / e) * l + .9375 : n * Math.pow(l - 2.625 / e, 2) + .984375
      };
   dp("Bounce", function (a) {
      return 1 - r(1 - a)
   }, r)
})(7.5625, 2.75);
dp("Expo", function (n) {
   return Math.pow(2, 10 * (n - 1)) * n + n * n * n * n * n * n * (1 - n)
});
dp("Circ", function (n) {
   return -(kI(1 - n * n) - 1)
});
dp("Sine", function (n) {
   return n === 1 ? 1 : -uJ(n * oJ) + 1
});
dp("Back", vA("in"), vA("out"), vA());
kn.SteppedEase = kn.steps = vo.SteppedEase = {
   config: function (e, t) {
      e === void 0 && (e = 1);
      var i = 1 / e,
         s = e + (t ? 0 : 1),
         r = t ? 1 : 0,
         a = 1 - bi;
      return function (l) {
         return ((s * Rx(0, a, l) | 0) + r) * i
      }
   }
};
Sg.ease = kn["quad.out"];
Ia("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function (n) {
   return J2 += n + "," + n + "Params,"
});
var S4 = function (e, t) {
      this.id = lJ++, e._gsap = this, this.target = e, this.harness = t, this.get = t ? t.get : JI, this.set = t ? t.getSetter : sC
   },
   ex = function () {
      function n(t) {
         this.vars = t, this._delay = +t.delay || 0, (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase), this._ts = 1, Eg(this, +t.duration, 1, 1), this.data = t.data, zi && (this._ctx = zi, zi.data.push(this)), $y || uo.wake()
      }
      var e = n.prototype;
      return e.delay = function (i) {
         return i || i === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + i - this._delay), this._delay = i, this) : this._delay
      }, e.duration = function (i) {
         return arguments.length ? this.totalDuration(this._repeat > 0 ? i + (i + this._rDelay) * this._repeat : i) : this.totalDuration() && this._dur
      }, e.totalDuration = function (i) {
         return arguments.length ? (this._dirty = 0, Eg(this, this._repeat < 0 ? i : (i - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
      }, e.totalTime = function (i, s) {
         if (Mg(), !arguments.length) return this._tTime;
         var r = this._dp;
         if (r && r.smoothChildTiming && this._ts) {
            for (VT(this, i), !r._dp || r.parent || i4(r, this); r && r.parent;) r.parent._time !== r._start + (r._ts >= 0 ? r._tTime / r._ts : (r.totalDuration() - r._tTime) / -r._ts) && r.totalTime(r._tTime, !0), r = r.parent;
            !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && i < this._tDur || this._ts < 0 && i > 0 || !this._tDur && !i) && Cu(this._dp, this, this._start - this._delay)
         }
         return (this._tTime !== i || !this._dur && !s || this._initted && Math.abs(this._zTime) === bi || !i && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = i), $I(this, i, s)), this
      }, e.time = function (i, s) {
         return arguments.length ? this.totalTime(Math.min(this.totalDuration(), i + GO(this)) % (this._dur + this._rDelay) || (i ? this._dur : 0), s) : this._time
      }, e.totalProgress = function (i, s) {
         return arguments.length ? this.totalTime(this.totalDuration() * i, s) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() >= 0 && this._initted ? 1 : 0
      }, e.progress = function (i, s) {
         return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - i : i) + GO(this), s) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0
      }, e.iteration = function (i, s) {
         var r = this.duration() + this._rDelay;
         return arguments.length ? this.totalTime(this._time + (i - 1) * r, s) : this._repeat ? Tg(this._tTime, r) + 1 : 1
      }, e.timeScale = function (i, s) {
         if (!arguments.length) return this._rts === -bi ? 0 : this._rts;
         if (this._rts === i) return this;
         var r = this.parent && this._ts ? L1(this.parent._time, this) : this._tTime;
         return this._rts = +i || 0, this._ts = this._ps || i === -bi ? 0 : this._rts, this.totalTime(Rx(-Math.abs(this._delay), this.totalDuration(), r), s !== !1), HT(this), vJ(this)
      }, e.paused = function (i) {
         return arguments.length ? (this._ps !== i && (this._ps = i, i ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (Mg(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== bi && (this._tTime -= bi)))), this) : this._ps
      }, e.startTime = function (i) {
         if (arguments.length) {
            this._start = i;
            var s = this.parent || this._dp;
            return s && (s._sort || !this.parent) && Cu(s, this, i - this._delay), this
         }
         return this._start
      }, e.endTime = function (i) {
         return this._start + (za(i) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
      }, e.rawTime = function (i) {
         var s = this.parent || this._dp;
         return s ? i && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? L1(s.rawTime(i), this) : this._tTime : this._tTime
      }, e.revert = function (i) {
         i === void 0 && (i = dJ);
         var s = vr;
         return vr = i, eC(this) && (this.timeline && this.timeline.revert(i), this.totalTime(-.01, i.suppressEvents)), this.data !== "nested" && i.kill !== !1 && this.kill(), vr = s, this
      }, e.globalTime = function (i) {
         for (var s = this, r = arguments.length ? i : s.rawTime(); s;) r = s._start + r / (Math.abs(s._ts) || 1), s = s._dp;
         return !this.parent && this._sat ? this._sat.globalTime(i) : r
      }, e.repeat = function (i) {
         return arguments.length ? (this._repeat = i === 1 / 0 ? -2 : i, kO(this)) : this._repeat === -2 ? 1 / 0 : this._repeat
      }, e.repeatDelay = function (i) {
         if (arguments.length) {
            var s = this._time;
            return this._rDelay = i, kO(this), s ? this.time(s) : this
         }
         return this._rDelay
      }, e.yoyo = function (i) {
         return arguments.length ? (this._yoyo = i, this) : this._yoyo
      }, e.seek = function (i, s) {
         return this.totalTime(Xo(this, i), za(s))
      }, e.restart = function (i, s) {
         return this.play().totalTime(i ? -this._delay : 0, za(s)), this._dur || (this._zTime = -bi), this
      }, e.play = function (i, s) {
         return i != null && this.seek(i, s), this.reversed(!1).paused(!1)
      }, e.reverse = function (i, s) {
         return i != null && this.seek(i || this.totalDuration(), s), this.reversed(!0).paused(!1)
      }, e.pause = function (i, s) {
         return i != null && this.seek(i, s), this.paused(!0)
      }, e.resume = function () {
         return this.paused(!1)
      }, e.reversed = function (i) {
         return arguments.length ? (!!i !== this.reversed() && this.timeScale(-this._rts || (i ? -bi : 0)), this) : this._rts < 0
      }, e.invalidate = function () {
         return this._initted = this._act = 0, this._zTime = -bi, this
      }, e.isActive = function () {
         var i = this.parent || this._dp,
            s = this._start,
            r;
         return !!(!i || this._ts && this._initted && i.isActive() && (r = i.rawTime(!0)) >= s && r < this.endTime(!0) - bi)
      }, e.eventCallback = function (i, s, r) {
         var a = this.vars;
         return arguments.length > 1 ? (s ? (a[i] = s, r && (a[i + "Params"] = r), i === "onUpdate" && (this._onUpdate = s)) : delete a[i], this) : a[i]
      }, e.then = function (i) {
         var s = this;
         return new Promise(function (r) {
            var a = is(i) ? i : t4,
               l = function () {
                  var h = s.then;
                  s.then = null, is(a) && (a = a(s)) && (a.then || a === s) && (s.then = h), r(a), s.then = h
               };
            s._initted && s.totalProgress() === 1 && s._ts >= 0 || !s._tTime && s._ts < 0 ? l() : s._prom = l
         })
      }, e.kill = function () {
         N0(this)
      }, n
   }();
yo(ex.prototype, {
   _time: 0,
   _start: 0,
   _end: 0,
   _tTime: 0,
   _tDur: 0,
   _dirty: 0,
   _repeat: 0,
   _yoyo: !1,
   parent: null,
   _initted: !1,
   _rDelay: 0,
   _ts: 1,
   _dp: 0,
   ratio: 0,
   _zTime: -bi,
   _prom: 0,
   _ps: !1,
   _rts: 1
});
var ca = function (n) {
   GI(e, n);

   function e(i, s) {
      var r;
      return i === void 0 && (i = {}), r = n.call(this, i) || this, r.labels = {}, r.smoothChildTiming = !!i.smoothChildTiming, r.autoRemoveChildren = !!i.autoRemoveChildren, r._sort = za(i.sortChildren), Xi && Cu(i.parent || Xi, bc(r), s), i.reversed && r.reverse(), i.paused && r.paused(!0), i.scrollTrigger && s4(bc(r), i.scrollTrigger), r
   }
   var t = e.prototype;
   return t.to = function (s, r, a) {
      return ty(0, arguments, this), this
   }, t.from = function (s, r, a) {
      return ty(1, arguments, this), this
   }, t.fromTo = function (s, r, a, l) {
      return ty(2, arguments, this), this
   }, t.set = function (s, r, a) {
      return r.duration = 0, r.parent = this, ey(r).repeatDelay || (r.repeat = 0), r.immediateRender = !!r.immediateRender, new ws(s, r, Xo(this, a), 1), this
   }, t.call = function (s, r, a) {
      return Cu(this, ws.delayedCall(0, s, r), a)
   }, t.staggerTo = function (s, r, a, l, c, h, m) {
      return a.duration = r, a.stagger = a.stagger || l, a.onComplete = h, a.onCompleteParams = m, a.parent = this, new ws(s, a, Xo(this, c)), this
   }, t.staggerFrom = function (s, r, a, l, c, h, m) {
      return a.runBackwards = 1, ey(a).immediateRender = za(a.immediateRender), this.staggerTo(s, r, a, l, c, h, m)
   }, t.staggerFromTo = function (s, r, a, l, c, h, m, g) {
      return l.startAt = a, ey(l).immediateRender = za(l.immediateRender), this.staggerTo(s, r, l, c, h, m, g)
   }, t.render = function (s, r, a) {
      var l = this._time,
         c = this._dirty ? this.totalDuration() : this._tDur,
         h = this._dur,
         m = s <= 0 ? 0 : Rs(s),
         g = this._zTime < 0 != s < 0 && (this._initted || !h),
         v, x, S, E, T, b, w, C, N, U, z, B;
      if (this !== Xi && m > c && s >= 0 && (m = c), m !== this._tTime || a || g) {
         if (l !== this._time && h && (m += this._time - l, s += this._time - l), v = m, N = this._start, C = this._ts, b = !C, g && (h || (l = this._zTime), (s || !r) && (this._zTime = s)), this._repeat) {
            if (z = this._yoyo, T = h + this._rDelay, this._repeat < -1 && s < 0) return this.totalTime(T * 100 + s, r, a);
            if (v = Rs(m % T), m === c ? (E = this._repeat, v = h) : (U = Rs(m / T), E = ~~U, E && E === U && (v = h, E--), v > h && (v = h)), U = Tg(this._tTime, T), !l && this._tTime && U !== E && this._tTime - U * T - this._dur <= 0 && (U = E), z && E & 1 && (v = h - v, B = 1), E !== U && !this._lock) {
               var I = z && U & 1,
                  O = I === (z && E & 1);
               if (E < U && (I = !I), l = I ? 0 : m % h ? h : m, this._lock = 1, this.render(l || (B ? 0 : Rs(E * T)), r, !h)._lock = 0, this._tTime = m, !r && this.parent && fo(this, "onRepeat"), this.vars.repeatRefresh && !B && (this.invalidate()._lock = 1), l && l !== this._time || b !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this;
               if (h = this._dur, c = this._tDur, O && (this._lock = 2, l = I ? h : -1e-4, this.render(l, !0), this.vars.repeatRefresh && !B && this.invalidate()), this._lock = 0, !this._ts && !b) return this;
               x4(this, B)
            }
         }
         if (this._hasPause && !this._forcing && this._lock < 2 && (w = SJ(this, Rs(l), Rs(v)), w && (m -= v - (v = w._start))), this._tTime = m, this._time = v, this._act = !C, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = s, l = 0), !l && m && !r && !U && (fo(this, "onStart"), this._tTime !== m)) return this;
         if (v >= l && s >= 0)
            for (x = this._first; x;) {
               if (S = x._next, (x._act || v >= x._start) && x._ts && w !== x) {
                  if (x.parent !== this) return this.render(s, r, a);
                  if (x.render(x._ts > 0 ? (v - x._start) * x._ts : (x._dirty ? x.totalDuration() : x._tDur) + (v - x._start) * x._ts, r, a), v !== this._time || !this._ts && !b) {
                     w = 0, S && (m += this._zTime = -bi);
                     break
                  }
               }
               x = S
            } else {
               x = this._last;
               for (var P = s < 0 ? s : v; x;) {
                  if (S = x._prev, (x._act || P <= x._end) && x._ts && w !== x) {
                     if (x.parent !== this) return this.render(s, r, a);
                     if (x.render(x._ts > 0 ? (P - x._start) * x._ts : (x._dirty ? x.totalDuration() : x._tDur) + (P - x._start) * x._ts, r, a || vr && eC(x)), v !== this._time || !this._ts && !b) {
                        w = 0, S && (m += this._zTime = P ? -bi : bi);
                        break
                     }
                  }
                  x = S
               }
            }
         if (w && !r && (this.pause(), w.render(v >= l ? 0 : -bi)._zTime = v >= l ? 1 : -1, this._ts)) return this._start = N, HT(this), this.render(s, r, a);
         this._onUpdate && !r && fo(this, "onUpdate", !0), (m === c && this._tTime >= this.totalDuration() || !m && l) && (N === this._start || Math.abs(C) !== Math.abs(this._ts)) && (this._lock || ((s || !h) && (m === c && this._ts > 0 || !m && this._ts < 0) && lh(this, 1), !r && !(s < 0 && !l) && (m || l || !c) && (fo(this, m === c && s >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(m < c && this.timeScale() > 0) && this._prom())))
      }
      return this
   }, t.add = function (s, r) {
      var a = this;
      if (zc(r) || (r = Xo(this, r, s)), !(s instanceof ex)) {
         if (Ir(s)) return s.forEach(function (l) {
            return a.add(l, r)
         }), this;
         if (ir(s)) return this.addLabel(s, r);
         if (is(s)) s = ws.delayedCall(0, s);
         else return this
      }
      return this !== s ? Cu(this, s, r) : this
   }, t.getChildren = function (s, r, a, l) {
      s === void 0 && (s = !0), r === void 0 && (r = !0), a === void 0 && (a = !0), l === void 0 && (l = -Zo);
      for (var c = [], h = this._first; h;) h._start >= l && (h instanceof ws ? r && c.push(h) : (a && c.push(h), s && c.push.apply(c, h.getChildren(!0, r, a)))), h = h._next;
      return c
   }, t.getById = function (s) {
      for (var r = this.getChildren(1, 1, 1), a = r.length; a--;)
         if (r[a].vars.id === s) return r[a]
   }, t.remove = function (s) {
      return ir(s) ? this.removeLabel(s) : is(s) ? this.killTweensOf(s) : (s.parent === this && FT(this, s), s === this._recent && (this._recent = this._last), qd(this))
   }, t.totalTime = function (s, r) {
      return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = Rs(uo.time - (this._ts > 0 ? s / this._ts : (this.totalDuration() - s) / -this._ts))), n.prototype.totalTime.call(this, s, r), this._forcing = 0, this) : this._tTime
   }, t.addLabel = function (s, r) {
      return this.labels[s] = Xo(this, r), this
   }, t.removeLabel = function (s) {
      return delete this.labels[s], this
   }, t.addPause = function (s, r, a) {
      var l = ws.delayedCall(0, r || Qy, a);
      return l.data = "isPause", this._hasPause = 1, Cu(this, l, Xo(this, s))
   }, t.removePause = function (s) {
      var r = this._first;
      for (s = Xo(this, s); r;) r._start === s && r.data === "isPause" && lh(r), r = r._next
   }, t.killTweensOf = function (s, r, a) {
      for (var l = this.getTweensOf(s, a), c = l.length; c--;) Yf !== l[c] && l[c].kill(s, r);
      return this
   }, t.getTweensOf = function (s, r) {
      for (var a = [], l = Qo(s), c = this._first, h = zc(r), m; c;) c instanceof ws ? pJ(c._targets, l) && (h ? (!Yf || c._initted && c._ts) && c.globalTime(0) <= r && c.globalTime(c.totalDuration()) > r : !r || c.isActive()) && a.push(c) : (m = c.getTweensOf(l, r)).length && a.push.apply(a, m), c = c._next;
      return a
   }, t.tweenTo = function (s, r) {
      r = r || {};
      var a = this,
         l = Xo(a, s),
         c = r,
         h = c.startAt,
         m = c.onStart,
         g = c.onStartParams,
         v = c.immediateRender,
         x, S = ws.to(a, yo({
            ease: r.ease || "none",
            lazy: !1,
            immediateRender: !1,
            time: l,
            overwrite: "auto",
            duration: r.duration || Math.abs((l - (h && "time" in h ? h.time : a._time)) / a.timeScale()) || bi,
            onStart: function () {
               if (a.pause(), !x) {
                  var T = r.duration || Math.abs((l - (h && "time" in h ? h.time : a._time)) / a.timeScale());
                  S._dur !== T && Eg(S, T, 0, 1).render(S._time, !0, !0), x = 1
               }
               m && m.apply(S, g || [])
            }
         }, r));
      return v ? S.render(0) : S
   }, t.tweenFromTo = function (s, r, a) {
      return this.tweenTo(r, yo({
         startAt: {
            time: Xo(this, s)
         }
      }, a))
   }, t.recent = function () {
      return this._recent
   }, t.nextLabel = function (s) {
      return s === void 0 && (s = this._time), jO(this, Xo(this, s))
   }, t.previousLabel = function (s) {
      return s === void 0 && (s = this._time), jO(this, Xo(this, s), 1)
   }, t.currentLabel = function (s) {
      return arguments.length ? this.seek(s, !0) : this.previousLabel(this._time + bi)
   }, t.shiftChildren = function (s, r, a) {
      a === void 0 && (a = 0);
      for (var l = this._first, c = this.labels, h; l;) l._start >= a && (l._start += s, l._end += s), l = l._next;
      if (r)
         for (h in c) c[h] >= a && (c[h] += s);
      return qd(this)
   }, t.invalidate = function (s) {
      var r = this._first;
      for (this._lock = 0; r;) r.invalidate(s), r = r._next;
      return n.prototype.invalidate.call(this, s)
   }, t.clear = function (s) {
      s === void 0 && (s = !0);
      for (var r = this._first, a; r;) a = r._next, this.remove(r), r = a;
      return this._dp && (this._time = this._tTime = this._pTime = 0), s && (this.labels = {}), qd(this)
   }, t.totalDuration = function (s) {
      var r = 0,
         a = this,
         l = a._last,
         c = Zo,
         h, m, g;
      if (arguments.length) return a.timeScale((a._repeat < 0 ? a.duration() : a.totalDuration()) / (a.reversed() ? -s : s));
      if (a._dirty) {
         for (g = a.parent; l;) h = l._prev, l._dirty && l.totalDuration(), m = l._start, m > c && a._sort && l._ts && !a._lock ? (a._lock = 1, Cu(a, l, m - l._delay, 1)._lock = 0) : c = m, m < 0 && l._ts && (r -= m, (!g && !a._dp || g && g.smoothChildTiming) && (a._start += m / a._ts, a._time -= m, a._tTime -= m), a.shiftChildren(-m, !1, -1 / 0), c = 0), l._end > r && l._ts && (r = l._end), l = h;
         Eg(a, a === Xi && a._time > r ? a._time : r, 1, 1), a._dirty = 0
      }
      return a._tDur
   }, e.updateRoot = function (s) {
      if (Xi._ts && ($I(Xi, L1(s, Xi)), QI = uo.frame), uo.frame >= HO) {
         HO += mo.autoSleep || 120;
         var r = Xi._first;
         if ((!r || !r._ts) && mo.autoSleep && uo._listeners.length < 2) {
            for (; r && !r._ts;) r = r._next;
            r || uo.sleep()
         }
      }
   }, e
}(ex);
yo(ca.prototype, {
   _lock: 0,
   _hasPause: 0,
   _forcing: 0
});
var zJ = function (e, t, i, s, r, a, l) {
      var c = new Fa(this._pt, e, t, 0, 1, w4, null, r),
         h = 0,
         m = 0,
         g, v, x, S, E, T, b, w;
      for (c.b = i, c.e = s, i += "", s += "", (b = ~s.indexOf("random(")) && (s = Jy(s)), a && (w = [i, s], a(w, e, t), i = w[0], s = w[1]), v = i.match(dA) || []; g = dA.exec(s);) S = g[0], E = s.substring(h, g.index), x ? x = (x + 1) % 5 : E.substr(-5) === "rgba(" && (x = 1), S !== v[m++] && (T = parseFloat(v[m - 1]) || 0, c._pt = {
         _next: c._pt,
         p: E || m === 1 ? E : ",",
         s: T,
         c: S.charAt(1) === "=" ? ig(T, S) - T : parseFloat(S) - T,
         m: x && x < 4 ? Math.round : 0
      }, h = dA.lastIndex);
      return c.c = h < s.length ? s.substring(h, s.length) : "", c.fp = l, (XI.test(s) || b) && (c.e = 0), this._pt = c, c
   },
   tC = function (e, t, i, s, r, a, l, c, h, m) {
      is(s) && (s = s(r || 0, e, a));
      var g = e[t],
         v = i !== "get" ? i : is(g) ? h ? e[t.indexOf("set") || !is(e["get" + t.substr(3)]) ? t : "get" + t.substr(3)](h) : e[t]() : g,
         x = is(g) ? h ? GJ : M4 : iC,
         S;
      if (ir(s) && (~s.indexOf("random(") && (s = Jy(s)), s.charAt(1) === "=" && (S = ig(v, s) + (Or(v) || 0), (S || S === 0) && (s = S))), !m || v !== s || Fw) return !isNaN(v * s) && s !== "" ? (S = new Fa(this._pt, e, t, +v || 0, s - (v || 0), typeof g == "boolean" ? jJ : A4, 0, x), h && (S.fp = h), l && S.modifier(l, this, e), this._pt = S) : (!g && !(t in e) && Z2(t, s), zJ.call(this, e, t, v, s, x, c || mo.stringFilter, h))
   },
   IJ = function (e, t, i, s, r) {
      if (is(e) && (e = ny(e, r, t, i, s)), !ku(e) || e.style && e.nodeType || Ir(e) || jI(e)) return ir(e) ? ny(e, r, t, i, s) : e;
      var a = {},
         l;
      for (l in e) a[l] = ny(e[l], r, t, i, s);
      return a
   },
   b4 = function (e, t, i, s, r, a) {
      var l, c, h, m;
      if (oo[e] && (l = new oo[e]).init(r, l.rawVars ? t[e] : IJ(t[e], s, r, a, i), i, s, a) !== !1 && (i._pt = c = new Fa(i._pt, r, e, 0, 1, l.render, l, 0, l.priority), i !== eg))
         for (h = i._ptLookup[i._targets.indexOf(r)], m = l._props.length; m--;) h[l._props[m]] = c;
      return l
   },
   Yf, Fw, nC = function n(e, t, i) {
      var s = e.vars,
         r = s.ease,
         a = s.startAt,
         l = s.immediateRender,
         c = s.lazy,
         h = s.onUpdate,
         m = s.runBackwards,
         g = s.yoyoEase,
         v = s.keyframes,
         x = s.autoRevert,
         S = e._dur,
         E = e._startAt,
         T = e._targets,
         b = e.parent,
         w = b && b.data === "nested" ? b.vars.targets : T,
         C = e._overwrite === "auto" && !X2,
         N = e.timeline,
         U, z, B, I, O, P, q, Q, $, ae, fe, k, Z;
      if (N && (!v || !r) && (r = "none"), e._ease = Xd(r, Sg.ease), e._yEase = g ? y4(Xd(g === !0 ? r : g, Sg.ease)) : 0, g && e._yoyo && !e._repeat && (g = e._yEase, e._yEase = e._ease, e._ease = g), e._from = !N && !!s.runBackwards, !N || v && !s.stagger) {
         if (Q = T[0] ? jd(T[0]).harness : 0, k = Q && s[Q.prop], U = P1(s, Q2), E && (E._zTime < 0 && E.progress(1), t < 0 && m && l && !x ? E.render(-1, !0) : E.revert(m && S ? Nb : hJ), E._lazy = 0), a) {
            if (lh(e._startAt = ws.set(T, yo({
                  data: "isStart",
                  overwrite: !1,
                  parent: b,
                  immediateRender: !0,
                  lazy: !E && za(c),
                  startAt: null,
                  delay: 0,
                  onUpdate: h && function () {
                     return fo(e, "onUpdate")
                  },
                  stagger: 0
               }, a))), e._startAt._dp = 0, e._startAt._sat = e, t < 0 && (vr || !l && !x) && e._startAt.revert(Nb), l && S && t <= 0 && i <= 0) {
               t && (e._zTime = t);
               return
            }
         } else if (m && S && !E) {
            if (t && (l = !1), B = yo({
                  overwrite: !1,
                  data: "isFromStart",
                  lazy: l && !E && za(c),
                  immediateRender: l,
                  stagger: 0,
                  parent: b
               }, U), k && (B[Q.prop] = k), lh(e._startAt = ws.set(T, B)), e._startAt._dp = 0, e._startAt._sat = e, t < 0 && (vr ? e._startAt.revert(Nb) : e._startAt.render(-1, !0)), e._zTime = t, !l) n(e._startAt, bi, bi);
            else if (!t) return
         }
         for (e._pt = e._ptCache = 0, c = S && za(c) || c && !S, z = 0; z < T.length; z++) {
            if (O = T[z], q = O._gsap || $2(T)[z]._gsap, e._ptLookup[z] = ae = {}, Uw[q.id] && $f.length && U1(), fe = w === T ? z : w.indexOf(O), Q && ($ = new Q).init(O, k || U, e, fe, w) !== !1 && (e._pt = I = new Fa(e._pt, O, $.name, 0, 1, $.render, $, 0, $.priority), $._props.forEach(function (J) {
                  ae[J] = I
               }), $.priority && (P = 1)), !Q || k)
               for (B in U) oo[B] && ($ = b4(B, U, e, fe, O, w)) ? $.priority && (P = 1) : ae[B] = I = tC.call(e, O, B, "get", U[B], fe, w, 0, s.stringFilter);
            e._op && e._op[z] && e.kill(O, e._op[z]), C && e._pt && (Yf = e, Xi.killTweensOf(O, ae, e.globalTime(t)), Z = !e.parent, Yf = 0), e._pt && c && (Uw[q.id] = 1)
         }
         P && R4(e), e._onInit && e._onInit(e)
      }
      e._onUpdate = h, e._initted = (!e._op || e._pt) && !Z, v && t <= 0 && N.render(Zo, !0, !0)
   },
   FJ = function (e, t, i, s, r, a, l, c) {
      var h = (e._pt && e._ptCache || (e._ptCache = {}))[t],
         m, g, v, x;
      if (!h)
         for (h = e._ptCache[t] = [], v = e._ptLookup, x = e._targets.length; x--;) {
            if (m = v[x][t], m && m.d && m.d._pt)
               for (m = m.d._pt; m && m.p !== t && m.fp !== t;) m = m._next;
            if (!m) return Fw = 1, e.vars[t] = "+=0", nC(e, l), Fw = 0, c ? Zy(t + " not eligible for reset") : 1;
            h.push(m)
         }
      for (x = h.length; x--;) g = h[x], m = g._pt || g, m.s = (s || s === 0) && !r ? s : m.s + (s || 0) + a * m.c, m.c = i - m.s, g.e && (g.e = hs(i) + Or(g.e)), g.b && (g.b = m.s + Or(g.b))
   },
   HJ = function (e, t) {
      var i = e[0] ? jd(e[0]).harness : 0,
         s = i && i.aliases,
         r, a, l, c;
      if (!s) return t;
      r = bg({}, t);
      for (a in s)
         if (a in r)
            for (c = s[a].split(","), l = c.length; l--;) r[c[l]] = r[a];
      return r
   },
   VJ = function (e, t, i, s) {
      var r = t.ease || s || "power1.inOut",
         a, l;
      if (Ir(t)) l = i[e] || (i[e] = []), t.forEach(function (c, h) {
         return l.push({
            t: h / (t.length - 1) * 100,
            v: c,
            e: r
         })
      });
      else
         for (a in t) l = i[a] || (i[a] = []), a === "ease" || l.push({
            t: parseFloat(e),
            v: t[a],
            e: r
         })
   },
   ny = function (e, t, i, s, r) {
      return is(e) ? e.call(t, i, s, r) : ir(e) && ~e.indexOf("random(") ? Jy(e) : e
   },
   T4 = J2 + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
   E4 = {};
Ia(T4 + ",id,stagger,delay,duration,paused,scrollTrigger", function (n) {
   return E4[n] = 1
});
var ws = function (n) {
   GI(e, n);

   function e(i, s, r, a) {
      var l;
      typeof s == "number" && (r.duration = s, s = r, r = null), l = n.call(this, a ? s : ey(s)) || this;
      var c = l.vars,
         h = c.duration,
         m = c.delay,
         g = c.immediateRender,
         v = c.stagger,
         x = c.overwrite,
         S = c.keyframes,
         E = c.defaults,
         T = c.scrollTrigger,
         b = c.yoyoEase,
         w = s.parent || Xi,
         C = (Ir(i) || jI(i) ? zc(i[0]) : "length" in s) ? [i] : Qo(i),
         N, U, z, B, I, O, P, q;
      if (l._targets = C.length ? $2(C) : Zy("GSAP target " + i + " not found. https://gsap.com", !mo.nullTargetWarn) || [], l._ptLookup = [], l._overwrite = x, S || v || ib(h) || ib(m)) {
         if (s = l.vars, N = l.timeline = new ca({
               data: "nested",
               defaults: E || {},
               targets: w && w.data === "nested" ? w.vars.targets : C
            }), N.kill(), N.parent = N._dp = bc(l), N._start = 0, v || ib(h) || ib(m)) {
            if (B = C.length, P = v && l4(v), ku(v))
               for (I in v) ~T4.indexOf(I) && (q || (q = {}), q[I] = v[I]);
            for (U = 0; U < B; U++) z = P1(s, E4), z.stagger = 0, b && (z.yoyoEase = b), q && bg(z, q), O = C[U], z.duration = +ny(h, bc(l), U, O, C), z.delay = (+ny(m, bc(l), U, O, C) || 0) - l._delay, !v && B === 1 && z.delay && (l._delay = m = z.delay, l._start += m, z.delay = 0), N.to(O, z, P ? P(U, O, C) : 0), N._ease = kn.none;
            N.duration() ? h = m = 0 : l.timeline = 0
         } else if (S) {
            ey(yo(N.vars.defaults, {
               ease: "none"
            })), N._ease = Xd(S.ease || s.ease || "none");
            var Q = 0,
               $, ae, fe;
            if (Ir(S)) S.forEach(function (k) {
               return N.to(C, k, ">")
            }), N.duration();
            else {
               z = {};
               for (I in S) I === "ease" || I === "easeEach" || VJ(I, S[I], z, S.easeEach);
               for (I in z)
                  for ($ = z[I].sort(function (k, Z) {
                        return k.t - Z.t
                     }), Q = 0, U = 0; U < $.length; U++) ae = $[U], fe = {
                     ease: ae.e,
                     duration: (ae.t - (U ? $[U - 1].t : 0)) / 100 * h
                  }, fe[I] = ae.v, N.to(C, fe, Q), Q += fe.duration;
               N.duration() < h && N.to({}, {
                  duration: h - N.duration()
               })
            }
         }
         h || l.duration(h = N.duration())
      } else l.timeline = 0;
      return x === !0 && !X2 && (Yf = bc(l), Xi.killTweensOf(C), Yf = 0), Cu(w, bc(l), r), s.reversed && l.reverse(), s.paused && l.paused(!0), (g || !h && !S && l._start === Rs(w._time) && za(g) && yJ(bc(l)) && w.data !== "nested") && (l._tTime = -bi, l.render(Math.max(0, -m) || 0)), T && s4(bc(l), T), l
   }
   var t = e.prototype;
   return t.render = function (s, r, a) {
      var l = this._time,
         c = this._tDur,
         h = this._dur,
         m = s < 0,
         g = s > c - bi && !m ? c : s < bi ? 0 : s,
         v, x, S, E, T, b, w, C, N;
      if (!h) _J(this, s, r, a);
      else if (g !== this._tTime || !s || a || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== m || this._lazy) {
         if (v = g, C = this.timeline, this._repeat) {
            if (E = h + this._rDelay, this._repeat < -1 && m) return this.totalTime(E * 100 + s, r, a);
            if (v = Rs(g % E), g === c ? (S = this._repeat, v = h) : (T = Rs(g / E), S = ~~T, S && S === T ? (v = h, S--) : v > h && (v = h)), b = this._yoyo && S & 1, b && (N = this._yEase, v = h - v), T = Tg(this._tTime, E), v === l && !a && this._initted && S === T) return this._tTime = g, this;
            S !== T && (C && this._yEase && x4(C, b), this.vars.repeatRefresh && !b && !this._lock && v !== E && this._initted && (this._lock = a = 1, this.render(Rs(E * S), !0).invalidate()._lock = 0))
         }
         if (!this._initted) {
            if (r4(this, m ? s : v, a, r, g)) return this._tTime = 0, this;
            if (l !== this._time && !(a && this.vars.repeatRefresh && S !== T)) return this;
            if (h !== this._dur) return this.render(s, r, a)
         }
         if (this._tTime = g, this._time = v, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = w = (N || this._ease)(v / h), this._from && (this.ratio = w = 1 - w), !l && g && !r && !T && (fo(this, "onStart"), this._tTime !== g)) return this;
         for (x = this._pt; x;) x.r(w, x.d), x = x._next;
         C && C.render(s < 0 ? s : C._dur * C._ease(v / this._dur), r, a) || this._startAt && (this._zTime = s), this._onUpdate && !r && (m && Pw(this, s, r, a), fo(this, "onUpdate")), this._repeat && S !== T && this.vars.onRepeat && !r && this.parent && fo(this, "onRepeat"), (g === this._tDur || !g) && this._tTime === g && (m && !this._onUpdate && Pw(this, s, !0, !0), (s || !h) && (g === this._tDur && this._ts > 0 || !g && this._ts < 0) && lh(this, 1), !r && !(m && !l) && (g || l || b) && (fo(this, g === c ? "onComplete" : "onReverseComplete", !0), this._prom && !(g < c && this.timeScale() > 0) && this._prom()))
      }
      return this
   }, t.targets = function () {
      return this._targets
   }, t.invalidate = function (s) {
      return (!s || !this.vars.runBackwards) && (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(s), n.prototype.invalidate.call(this, s)
   }, t.resetTo = function (s, r, a, l, c) {
      $y || uo.wake(), this._ts || this.play();
      var h = Math.min(this._dur, (this._dp._time - this._start) * this._ts),
         m;
      return this._initted || nC(this, h), m = this._ease(h / this._dur), FJ(this, s, r, a, l, m, h, c) ? this.resetTo(s, r, a, l, 1) : (VT(this, 0), this.parent || n4(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0))
   }, t.kill = function (s, r) {
      if (r === void 0 && (r = "all"), !s && (!r || r === "all")) return this._lazy = this._pt = 0, this.parent ? N0(this) : this.scrollTrigger && this.scrollTrigger.kill(!!vr), this;
      if (this.timeline) {
         var a = this.timeline.totalDuration();
         return this.timeline.killTweensOf(s, r, Yf && Yf.vars.overwrite !== !0)._first || N0(this), this.parent && a !== this.timeline.totalDuration() && Eg(this, this._dur * this.timeline._tDur / a, 0, 1), this
      }
      var l = this._targets,
         c = s ? Qo(s) : l,
         h = this._ptLookup,
         m = this._pt,
         g, v, x, S, E, T, b;
      if ((!r || r === "all") && gJ(l, c)) return r === "all" && (this._pt = 0), N0(this);
      for (g = this._op = this._op || [], r !== "all" && (ir(r) && (E = {}, Ia(r, function (w) {
            return E[w] = 1
         }), r = E), r = HJ(l, r)), b = l.length; b--;)
         if (~c.indexOf(l[b])) {
            v = h[b], r === "all" ? (g[b] = r, S = v, x = {}) : (x = g[b] = g[b] || {}, S = r);
            for (E in S) T = v && v[E], T && ((!("kill" in T.d) || T.d.kill(E) === !0) && FT(this, T, "_pt"), delete v[E]), x !== "all" && (x[E] = 1)
         } return this._initted && !this._pt && m && N0(this), this
   }, e.to = function (s, r) {
      return new e(s, r, arguments[2])
   }, e.from = function (s, r) {
      return ty(1, arguments)
   }, e.delayedCall = function (s, r, a, l) {
      return new e(r, 0, {
         immediateRender: !1,
         lazy: !1,
         overwrite: !1,
         delay: s,
         onComplete: r,
         onReverseComplete: r,
         onCompleteParams: a,
         onReverseCompleteParams: a,
         callbackScope: l
      })
   }, e.fromTo = function (s, r, a) {
      return ty(2, arguments)
   }, e.set = function (s, r) {
      return r.duration = 0, r.repeatDelay || (r.repeat = 0), new e(s, r)
   }, e.killTweensOf = function (s, r, a) {
      return Xi.killTweensOf(s, r, a)
   }, e
}(ex);
yo(ws.prototype, {
   _targets: [],
   _lazy: 0,
   _startAt: 0,
   _op: 0,
   _onInit: 0
});
Ia("staggerTo,staggerFrom,staggerFromTo", function (n) {
   ws[n] = function () {
      var e = new ca,
         t = Bw.call(arguments, 0);
      return t.splice(n === "staggerFromTo" ? 5 : 4, 0, 0), e[n].apply(e, t)
   }
});
var iC = function (e, t, i) {
      return e[t] = i
   },
   M4 = function (e, t, i) {
      return e[t](i)
   },
   GJ = function (e, t, i, s) {
      return e[t](s.fp, i)
   },
   kJ = function (e, t, i) {
      return e.setAttribute(t, i)
   },
   sC = function (e, t) {
      return is(e[t]) ? M4 : W2(e[t]) && e.setAttribute ? kJ : iC
   },
   A4 = function (e, t) {
      return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e6) / 1e6, t)
   },
   jJ = function (e, t) {
      return t.set(t.t, t.p, !!(t.s + t.c * e), t)
   },
   w4 = function (e, t) {
      var i = t._pt,
         s = "";
      if (!e && t.b) s = t.b;
      else if (e === 1 && t.e) s = t.e;
      else {
         for (; i;) s = i.p + (i.m ? i.m(i.s + i.c * e) : Math.round((i.s + i.c * e) * 1e4) / 1e4) + s, i = i._next;
         s += t.c
      }
      t.set(t.t, t.p, s, t)
   },
   rC = function (e, t) {
      for (var i = t._pt; i;) i.r(e, i.d), i = i._next
   },
   qJ = function (e, t, i, s) {
      for (var r = this._pt, a; r;) a = r._next, r.p === s && r.modifier(e, t, i), r = a
   },
   XJ = function (e) {
      for (var t = this._pt, i, s; t;) s = t._next, t.p === e && !t.op || t.op === e ? FT(this, t, "_pt") : t.dep || (i = 1), t = s;
      return !i
   },
   WJ = function (e, t, i, s) {
      s.mSet(e, t, s.m.call(s.tween, i, s.mt), s)
   },
   R4 = function (e) {
      for (var t = e._pt, i, s, r, a; t;) {
         for (i = t._next, s = r; s && s.pr > t.pr;) s = s._next;
         (t._prev = s ? s._prev : a) ? t._prev._next = t: r = t, (t._next = s) ? s._prev = t : a = t, t = i
      }
      e._pt = r
   },
   Fa = function () {
      function n(t, i, s, r, a, l, c, h, m) {
         this.t = i, this.s = r, this.c = a, this.p = s, this.r = l || A4, this.d = c || this, this.set = h || iC, this.pr = m || 0, this._next = t, t && (t._prev = this)
      }
      var e = n.prototype;
      return e.modifier = function (i, s, r) {
         this.mSet = this.mSet || this.set, this.set = WJ, this.m = i, this.mt = r, this.tween = s
      }, n
   }();
Ia(J2 + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function (n) {
   return Q2[n] = 1
});
vo.TweenMax = vo.TweenLite = ws;
vo.TimelineLite = vo.TimelineMax = ca;
Xi = new ca({
   sortChildren: !1,
   defaults: Sg,
   autoRemoveChildren: !0,
   id: "root",
   smoothChildTiming: !0
});
mo.stringFilter = v4;
var Wd = [],
   Ub = {},
   YJ = [],
   XO = 0,
   KJ = 0,
   yA = function (e) {
      return (Ub[e] || YJ).map(function (t) {
         return t()
      })
   },
   Hw = function () {
      var e = Date.now(),
         t = [];
      e - XO > 2 && (yA("matchMediaInit"), Wd.forEach(function (i) {
         var s = i.queries,
            r = i.conditions,
            a, l, c, h;
         for (l in s) a = wu.matchMedia(s[l]).matches, a && (c = 1), a !== r[l] && (r[l] = a, h = 1);
         h && (i.revert(), c && t.push(i))
      }), yA("matchMediaRevert"), t.forEach(function (i) {
         return i.onMatch(i, function (s) {
            return i.add(null, s)
         })
      }), XO = e, yA("matchMedia"))
   },
   C4 = function () {
      function n(t, i) {
         this.selector = i && zw(i), this.data = [], this._r = [], this.isReverted = !1, this.id = KJ++, t && this.add(t)
      }
      var e = n.prototype;
      return e.add = function (i, s, r) {
         is(i) && (r = s, s = i, i = is);
         var a = this,
            l = function () {
               var h = zi,
                  m = a.selector,
                  g;
               return h && h !== a && h.data.push(a), r && (a.selector = zw(r)), zi = a, g = s.apply(a, arguments), is(g) && a._r.push(g), zi = h, a.selector = m, a.isReverted = !1, g
            };
         return a.last = l, i === is ? l(a, function (c) {
            return a.add(null, c)
         }) : i ? a[i] = l : l
      }, e.ignore = function (i) {
         var s = zi;
         zi = null, i(this), zi = s
      }, e.getTweens = function () {
         var i = [];
         return this.data.forEach(function (s) {
            return s instanceof n ? i.push.apply(i, s.getTweens()) : s instanceof ws && !(s.parent && s.parent.data === "nested") && i.push(s)
         }), i
      }, e.clear = function () {
         this._r.length = this.data.length = 0
      }, e.kill = function (i, s) {
         var r = this;
         if (i ? function () {
               for (var l = r.getTweens(), c = r.data.length, h; c--;) h = r.data[c], h.data === "isFlip" && (h.revert(), h.getChildren(!0, !0, !1).forEach(function (m) {
                  return l.splice(l.indexOf(m), 1)
               }));
               for (l.map(function (m) {
                     return {
                        g: m._dur || m._delay || m._sat && !m._sat.vars.immediateRender ? m.globalTime(0) : -1 / 0,
                        t: m
                     }
                  }).sort(function (m, g) {
                     return g.g - m.g || -1 / 0
                  }).forEach(function (m) {
                     return m.t.revert(i)
                  }), c = r.data.length; c--;) h = r.data[c], h instanceof ca ? h.data !== "nested" && (h.scrollTrigger && h.scrollTrigger.revert(), h.kill()) : !(h instanceof ws) && h.revert && h.revert(i);
               r._r.forEach(function (m) {
                  return m(i, r)
               }), r.isReverted = !0
            }() : this.data.forEach(function (l) {
               return l.kill && l.kill()
            }), this.clear(), s)
            for (var a = Wd.length; a--;) Wd[a].id === this.id && Wd.splice(a, 1)
      }, e.revert = function (i) {
         this.kill(i || {})
      }, n
   }(),
   ZJ = function () {
      function n(t) {
         this.contexts = [], this.scope = t, zi && zi.data.push(this)
      }
      var e = n.prototype;
      return e.add = function (i, s, r) {
         ku(i) || (i = {
            matches: i
         });
         var a = new C4(0, r || this.scope),
            l = a.conditions = {},
            c, h, m;
         zi && !a.selector && (a.selector = zi.selector), this.contexts.push(a), s = a.add("onMatch", s), a.queries = i;
         for (h in i) h === "all" ? m = 1 : (c = wu.matchMedia(i[h]), c && (Wd.indexOf(a) < 0 && Wd.push(a), (l[h] = c.matches) && (m = 1), c.addListener ? c.addListener(Hw) : c.addEventListener("change", Hw)));
         return m && s(a, function (g) {
            return a.add(null, g)
         }), this
      }, e.revert = function (i) {
         this.kill(i || {})
      }, e.kill = function (i) {
         this.contexts.forEach(function (s) {
            return s.kill(i, !0)
         })
      }, n
   }(),
   B1 = {
      registerPlugin: function () {
         for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];
         t.forEach(function (s) {
            return p4(s)
         })
      },
      timeline: function (e) {
         return new ca(e)
      },
      getTweensOf: function (e, t) {
         return Xi.getTweensOf(e, t)
      },
      getProperty: function (e, t, i, s) {
         ir(e) && (e = Qo(e)[0]);
         var r = jd(e || {}).get,
            a = i ? t4 : e4;
         return i === "native" && (i = ""), e && (t ? a((oo[t] && oo[t].get || r)(e, t, i, s)) : function (l, c, h) {
            return a((oo[l] && oo[l].get || r)(e, l, c, h))
         })
      },
      quickSetter: function (e, t, i) {
         if (e = Qo(e), e.length > 1) {
            var s = e.map(function (m) {
                  return ka.quickSetter(m, t, i)
               }),
               r = s.length;
            return function (m) {
               for (var g = r; g--;) s[g](m)
            }
         }
         e = e[0] || {};
         var a = oo[t],
            l = jd(e),
            c = l.harness && (l.harness.aliases || {})[t] || t,
            h = a ? function (m) {
               var g = new a;
               eg._pt = 0, g.init(e, i ? m + i : m, eg, 0, [e]), g.render(1, g), eg._pt && rC(1, eg)
            } : l.set(e, c);
         return a ? h : function (m) {
            return h(e, c, i ? m + i : m, l, 1)
         }
      },
      quickTo: function (e, t, i) {
         var s, r = ka.to(e, yo((s = {}, s[t] = "+=0.1", s.paused = !0, s.stagger = 0, s), i || {})),
            a = function (c, h, m) {
               return r.resetTo(t, c, h, m)
            };
         return a.tween = r, a
      },
      isTweening: function (e) {
         return Xi.getTweensOf(e, !0).length > 0
      },
      defaults: function (e) {
         return e && e.ease && (e.ease = Xd(e.ease, Sg.ease)), VO(Sg, e || {})
      },
      config: function (e) {
         return VO(mo, e || {})
      },
      registerEffect: function (e) {
         var t = e.name,
            i = e.effect,
            s = e.plugins,
            r = e.defaults,
            a = e.extendTimeline;
         (s || "").split(",").forEach(function (l) {
            return l && !oo[l] && !vo[l] && Zy(t + " effect requires " + l + " plugin.")
         }), pA[t] = function (l, c, h) {
            return i(Qo(l), yo(c || {}, r), h)
         }, a && (ca.prototype[t] = function (l, c, h) {
            return this.add(pA[t](l, ku(c) ? c : (h = c) && {}, this), h)
         })
      },
      registerEase: function (e, t) {
         kn[e] = Xd(t)
      },
      parseEase: function (e, t) {
         return arguments.length ? Xd(e, t) : kn
      },
      getById: function (e) {
         return Xi.getById(e)
      },
      exportRoot: function (e, t) {
         e === void 0 && (e = {});
         var i = new ca(e),
            s, r;
         for (i.smoothChildTiming = za(e.smoothChildTiming), Xi.remove(i), i._dp = 0, i._time = i._tTime = Xi._time, s = Xi._first; s;) r = s._next, (t || !(!s._dur && s instanceof ws && s.vars.onComplete === s._targets[0])) && Cu(i, s, s._start - s._delay), s = r;
         return Cu(Xi, i, 0), i
      },
      context: function (e, t) {
         return e ? new C4(e, t) : zi
      },
      matchMedia: function (e) {
         return new ZJ(e)
      },
      matchMediaRefresh: function () {
         return Wd.forEach(function (e) {
            var t = e.conditions,
               i, s;
            for (s in t) t[s] && (t[s] = !1, i = 1);
            i && e.revert()
         }) || Hw()
      },
      addEventListener: function (e, t) {
         var i = Ub[e] || (Ub[e] = []);
         ~i.indexOf(t) || i.push(t)
      },
      removeEventListener: function (e, t) {
         var i = Ub[e],
            s = i && i.indexOf(t);
         s >= 0 && i.splice(s, 1)
      },
      utils: {
         wrap: RJ,
         wrapYoyo: CJ,
         distribute: l4,
         random: c4,
         snap: u4,
         normalize: wJ,
         getUnit: Or,
         clamp: TJ,
         splitColor: m4,
         toArray: Qo,
         selector: zw,
         mapRange: h4,
         pipe: MJ,
         unitize: AJ,
         interpolate: DJ,
         shuffle: o4
      },
      install: KI,
      effects: pA,
      ticker: uo,
      updateRoot: ca.updateRoot,
      plugins: oo,
      globalTimeline: Xi,
      core: {
         PropTween: Fa,
         globals: ZI,
         Tween: ws,
         Timeline: ca,
         Animation: ex,
         getCache: jd,
         _removeLinkedListItem: FT,
         reverting: function () {
            return vr
         },
         context: function (e) {
            return e && zi && (zi.data.push(e), e._ctx = zi), zi
         },
         suppressOverwrites: function (e) {
            return X2 = e
         }
      }
   };
Ia("to,from,fromTo,delayedCall,set,killTweensOf", function (n) {
   return B1[n] = ws[n]
});
uo.add(ca.updateRoot);
eg = B1.to({}, {
   duration: 0
});
var QJ = function (e, t) {
      for (var i = e._pt; i && i.p !== t && i.op !== t && i.fp !== t;) i = i._next;
      return i
   },
   JJ = function (e, t) {
      var i = e._targets,
         s, r, a;
      for (s in t)
         for (r = i.length; r--;) a = e._ptLookup[r][s], a && (a = a.d) && (a._pt && (a = QJ(a, s)), a && a.modifier && a.modifier(t[s], e, i[r], s))
   },
   xA = function (e, t) {
      return {
         name: e,
         headless: 1,
         rawVars: 1,
         init: function (s, r, a) {
            a._onInit = function (l) {
               var c, h;
               if (ir(r) && (c = {}, Ia(r, function (m) {
                     return c[m] = 1
                  }), r = c), t) {
                  c = {};
                  for (h in r) c[h] = t(r[h]);
                  r = c
               }
               JJ(l, r)
            }
         }
      }
   },
   ka = B1.registerPlugin({
      name: "attr",
      init: function (e, t, i, s, r) {
         var a, l, c;
         this.tween = i;
         for (a in t) c = e.getAttribute(a) || "", l = this.add(e, "setAttribute", (c || 0) + "", t[a], s, r, 0, 0, a), l.op = a, l.b = c, this._props.push(a)
      },
      render: function (e, t) {
         for (var i = t._pt; i;) vr ? i.set(i.t, i.p, i.b, i) : i.r(e, i.d), i = i._next
      }
   }, {
      name: "endArray",
      headless: 1,
      init: function (e, t) {
         for (var i = t.length; i--;) this.add(e, i, e[i] || 0, t[i], 0, 0, 0, 0, 0, 1)
      }
   }, xA("roundProps", Iw), xA("modifiers"), xA("snap", u4)) || B1;
ws.version = ca.version = ka.version = "3.13.0";
YI = 1;
Y2() && Mg();
kn.Power0;
kn.Power1;
kn.Power2;
kn.Power3;
kn.Power4;
kn.Linear;
kn.Quad;
kn.Cubic;
kn.Quart;
kn.Quint;
kn.Strong;
kn.Elastic;
kn.Back;
kn.SteppedEase;
kn.Bounce;
kn.Sine;
kn.Expo;
kn.Circ;
/*!
 * CSSPlugin 3.13.0
 * https://gsap.com
 *
 * Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license
 * @author: Jack Doyle, jack@greensock.com
 */
var WO, Kf, sg, aC, Bd, YO, oC, $J = function () {
      return typeof window < "u"
   },
   Ic = {},
   Ad = 180 / Math.PI,
   rg = Math.PI / 180,
   Bm = Math.atan2,
   KO = 1e8,
   lC = /([A-Z])/g,
   e$ = /(left|right|width|margin|padding|x)/i,
   t$ = /[\s,\(]\S/,
   Nu = {
      autoAlpha: "opacity,visibility",
      scale: "scaleX,scaleY",
      alpha: "opacity"
   },
   Vw = function (e, t) {
      return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t)
   },
   n$ = function (e, t) {
      return t.set(t.t, t.p, e === 1 ? t.e : Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t)
   },
   i$ = function (e, t) {
      return t.set(t.t, t.p, e ? Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u : t.b, t)
   },
   s$ = function (e, t) {
      var i = t.s + t.c * e;
      t.set(t.t, t.p, ~~(i + (i < 0 ? -.5 : .5)) + t.u, t)
   },
   D4 = function (e, t) {
      return t.set(t.t, t.p, e ? t.e : t.b, t)
   },
   N4 = function (e, t) {
      return t.set(t.t, t.p, e !== 1 ? t.b : t.e, t)
   },
   r$ = function (e, t, i) {
      return e.style[t] = i
   },
   a$ = function (e, t, i) {
      return e.style.setProperty(t, i)
   },
   o$ = function (e, t, i) {
      return e._gsap[t] = i
   },
   l$ = function (e, t, i) {
      return e._gsap.scaleX = e._gsap.scaleY = i
   },
   u$ = function (e, t, i, s, r) {
      var a = e._gsap;
      a.scaleX = a.scaleY = i, a.renderTransform(r, a)
   },
   c$ = function (e, t, i, s, r) {
      var a = e._gsap;
      a[t] = i, a.renderTransform(r, a)
   },
   Ki = "transform",
   Ha = Ki + "Origin",
   f$ = function n(e, t) {
      var i = this,
         s = this.target,
         r = s.style,
         a = s._gsap;
      if (e in Ic && r) {
         if (this.tfm = this.tfm || {}, e !== "transform") e = Nu[e] || e, ~e.indexOf(",") ? e.split(",").forEach(function (l) {
            return i.tfm[l] = Tc(s, l)
         }) : this.tfm[e] = a.x ? a[e] : Tc(s, e), e === Ha && (this.tfm.zOrigin = a.zOrigin);
         else return Nu.transform.split(",").forEach(function (l) {
            return n.call(i, l, t)
         });
         if (this.props.indexOf(Ki) >= 0) return;
         a.svg && (this.svgo = s.getAttribute("data-svg-origin"), this.props.push(Ha, t, "")), e = Ki
      }(r || t) && this.props.push(e, t, r[e])
   },
   O4 = function (e) {
      e.translate && (e.removeProperty("translate"), e.removeProperty("scale"), e.removeProperty("rotate"))
   },
   h$ = function () {
      var e = this.props,
         t = this.target,
         i = t.style,
         s = t._gsap,
         r, a;
      for (r = 0; r < e.length; r += 3) e[r + 1] ? e[r + 1] === 2 ? t[e[r]](e[r + 2]) : t[e[r]] = e[r + 2] : e[r + 2] ? i[e[r]] = e[r + 2] : i.removeProperty(e[r].substr(0, 2) === "--" ? e[r] : e[r].replace(lC, "-$1").toLowerCase());
      if (this.tfm) {
         for (a in this.tfm) s[a] = this.tfm[a];
         s.svg && (s.renderTransform(), t.setAttribute("data-svg-origin", this.svgo || "")), r = oC(), (!r || !r.isStart) && !i[Ki] && (O4(i), s.zOrigin && i[Ha] && (i[Ha] += " " + s.zOrigin + "px", s.zOrigin = 0, s.renderTransform()), s.uncache = 1)
      }
   },
   U4 = function (e, t) {
      var i = {
         target: e,
         props: [],
         revert: h$,
         save: f$
      };
      return e._gsap || ka.core.getCache(e), t && e.style && e.nodeType && t.split(",").forEach(function (s) {
         return i.save(s)
      }), i
   },
   P4, Gw = function (e, t) {
      var i = Kf.createElementNS ? Kf.createElementNS((t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), e) : Kf.createElement(e);
      return i && i.style ? i : Kf.createElement(e)
   },
   Jo = function n(e, t, i) {
      var s = getComputedStyle(e);
      return s[t] || s.getPropertyValue(t.replace(lC, "-$1").toLowerCase()) || s.getPropertyValue(t) || !i && n(e, Ag(t) || t, 1) || ""
   },
   ZO = "O,Moz,ms,Ms,Webkit".split(","),
   Ag = function (e, t, i) {
      var s = t || Bd,
         r = s.style,
         a = 5;
      if (e in r && !i) return e;
      for (e = e.charAt(0).toUpperCase() + e.substr(1); a-- && !(ZO[a] + e in r););
      return a < 0 ? null : (a === 3 ? "ms" : a >= 0 ? ZO[a] : "") + e
   },
   kw = function () {
      $J() && window.document && (WO = window, Kf = WO.document, sg = Kf.documentElement, Bd = Gw("div") || {
         style: {}
      }, Gw("div"), Ki = Ag(Ki), Ha = Ki + "Origin", Bd.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", P4 = !!Ag("perspective"), oC = ka.core.reverting, aC = 1)
   },
   QO = function (e) {
      var t = e.ownerSVGElement,
         i = Gw("svg", t && t.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
         s = e.cloneNode(!0),
         r;
      s.style.display = "block", i.appendChild(s), sg.appendChild(i);
      try {
         r = s.getBBox()
      } catch {}
      return i.removeChild(s), sg.removeChild(i), r
   },
   JO = function (e, t) {
      for (var i = t.length; i--;)
         if (e.hasAttribute(t[i])) return e.getAttribute(t[i])
   },
   L4 = function (e) {
      var t, i;
      try {
         t = e.getBBox()
      } catch {
         t = QO(e), i = 1
      }
      return t && (t.width || t.height) || i || (t = QO(e)), t && !t.width && !t.x && !t.y ? {
         x: +JO(e, ["x", "cx", "x1"]) || 0,
         y: +JO(e, ["y", "cy", "y1"]) || 0,
         width: 0,
         height: 0
      } : t
   },
   B4 = function (e) {
      return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && L4(e))
   },
   ip = function (e, t) {
      if (t) {
         var i = e.style,
            s;
         t in Ic && t !== Ha && (t = Ki), i.removeProperty ? (s = t.substr(0, 2), (s === "ms" || t.substr(0, 6) === "webkit") && (t = "-" + t), i.removeProperty(s === "--" ? t : t.replace(lC, "-$1").toLowerCase())) : i.removeAttribute(t)
      }
   },
   Zf = function (e, t, i, s, r, a) {
      var l = new Fa(e._pt, t, i, 0, 1, a ? N4 : D4);
      return e._pt = l, l.b = s, l.e = r, e._props.push(i), l
   },
   $O = {
      deg: 1,
      rad: 1,
      turn: 1
   },
   d$ = {
      grid: 1,
      flex: 1
   },
   uh = function n(e, t, i, s) {
      var r = parseFloat(i) || 0,
         a = (i + "").trim().substr((r + "").length) || "px",
         l = Bd.style,
         c = e$.test(t),
         h = e.tagName.toLowerCase() === "svg",
         m = (h ? "client" : "offset") + (c ? "Width" : "Height"),
         g = 100,
         v = s === "px",
         x = s === "%",
         S, E, T, b;
      if (s === a || !r || $O[s] || $O[a]) return r;
      if (a !== "px" && !v && (r = n(e, t, i, "px")), b = e.getCTM && B4(e), (x || a === "%") && (Ic[t] || ~t.indexOf("adius"))) return S = b ? e.getBBox()[c ? "width" : "height"] : e[m], hs(x ? r / S * g : r / 100 * S);
      if (l[c ? "width" : "height"] = g + (v ? a : s), E = s !== "rem" && ~t.indexOf("adius") || s === "em" && e.appendChild && !h ? e : e.parentNode, b && (E = (e.ownerSVGElement || {}).parentNode), (!E || E === Kf || !E.appendChild) && (E = Kf.body), T = E._gsap, T && x && T.width && c && T.time === uo.time && !T.uncache) return hs(r / T.width * g);
      if (x && (t === "height" || t === "width")) {
         var w = e.style[t];
         e.style[t] = g + s, S = e[m], w ? e.style[t] = w : ip(e, t)
      } else(x || a === "%") && !d$[Jo(E, "display")] && (l.position = Jo(e, "position")), E === e && (l.position = "static"), E.appendChild(Bd), S = Bd[m], E.removeChild(Bd), l.position = "absolute";
      return c && x && (T = jd(E), T.time = uo.time, T.width = E[m]), hs(v ? S * r / g : S && r ? g / S * r : 0)
   },
   Tc = function (e, t, i, s) {
      var r;
      return aC || kw(), t in Nu && t !== "transform" && (t = Nu[t], ~t.indexOf(",") && (t = t.split(",")[0])), Ic[t] && t !== "transform" ? (r = nx(e, s), r = t !== "transformOrigin" ? r[t] : r.svg ? r.origin : I1(Jo(e, Ha)) + " " + r.zOrigin + "px") : (r = e.style[t], (!r || r === "auto" || s || ~(r + "").indexOf("calc(")) && (r = z1[t] && z1[t](e, t, i) || Jo(e, t) || JI(e, t) || (t === "opacity" ? 1 : 0))), i && !~(r + "").trim().indexOf(" ") ? uh(e, t, r, i) + i : r
   },
   p$ = function (e, t, i, s) {
      if (!i || i === "none") {
         var r = Ag(t, e, 1),
            a = r && Jo(e, r, 1);
         a && a !== i ? (t = r, i = a) : t === "borderColor" && (i = Jo(e, "borderTopColor"))
      }
      var l = new Fa(this._pt, e.style, t, 0, 1, w4),
         c = 0,
         h = 0,
         m, g, v, x, S, E, T, b, w, C, N, U;
      if (l.b = i, l.e = s, i += "", s += "", s.substring(0, 6) === "var(--" && (s = Jo(e, s.substring(4, s.indexOf(")")))), s === "auto" && (E = e.style[t], e.style[t] = s, s = Jo(e, t) || s, E ? e.style[t] = E : ip(e, t)), m = [i, s], v4(m), i = m[0], s = m[1], v = i.match($m) || [], U = s.match($m) || [], U.length) {
         for (; g = $m.exec(s);) T = g[0], w = s.substring(c, g.index), S ? S = (S + 1) % 5 : (w.substr(-5) === "rgba(" || w.substr(-5) === "hsla(") && (S = 1), T !== (E = v[h++] || "") && (x = parseFloat(E) || 0, N = E.substr((x + "").length), T.charAt(1) === "=" && (T = ig(x, T) + N), b = parseFloat(T), C = T.substr((b + "").length), c = $m.lastIndex - C.length, C || (C = C || mo.units[t] || N, c === s.length && (s += C, l.e += C)), N !== C && (x = uh(e, t, E, C) || 0), l._pt = {
            _next: l._pt,
            p: w || h === 1 ? w : ",",
            s: x,
            c: b - x,
            m: S && S < 4 || t === "zIndex" ? Math.round : 0
         });
         l.c = c < s.length ? s.substring(c, s.length) : ""
      } else l.r = t === "display" && s === "none" ? N4 : D4;
      return XI.test(s) && (l.e = 0), this._pt = l, l
   },
   eU = {
      top: "0%",
      bottom: "100%",
      left: "0%",
      right: "100%",
      center: "50%"
   },
   m$ = function (e) {
      var t = e.split(" "),
         i = t[0],
         s = t[1] || "50%";
      return (i === "top" || i === "bottom" || s === "left" || s === "right") && (e = i, i = s, s = e), t[0] = eU[i] || i, t[1] = eU[s] || s, t.join(" ")
   },
   g$ = function (e, t) {
      if (t.tween && t.tween._time === t.tween._dur) {
         var i = t.t,
            s = i.style,
            r = t.u,
            a = i._gsap,
            l, c, h;
         if (r === "all" || r === !0) s.cssText = "", c = 1;
         else
            for (r = r.split(","), h = r.length; --h > -1;) l = r[h], Ic[l] && (c = 1, l = l === "transformOrigin" ? Ha : Ki), ip(i, l);
         c && (ip(i, Ki), a && (a.svg && i.removeAttribute("transform"), s.scale = s.rotate = s.translate = "none", nx(i, 1), a.uncache = 1, O4(s)))
      }
   },
   z1 = {
      clearProps: function (e, t, i, s, r) {
         if (r.data !== "isFromStart") {
            var a = e._pt = new Fa(e._pt, t, i, 0, 0, g$);
            return a.u = s, a.pr = -10, a.tween = r, e._props.push(i), 1
         }
      }
   },
   tx = [1, 0, 0, 1, 0, 0],
   z4 = {},
   I4 = function (e) {
      return e === "matrix(1, 0, 0, 1, 0, 0)" || e === "none" || !e
   },
   tU = function (e) {
      var t = Jo(e, Ki);
      return I4(t) ? tx : t.substr(7).match(qI).map(hs)
   },
   uC = function (e, t) {
      var i = e._gsap || jd(e),
         s = e.style,
         r = tU(e),
         a, l, c, h;
      return i.svg && e.getAttribute("transform") ? (c = e.transform.baseVal.consolidate().matrix, r = [c.a, c.b, c.c, c.d, c.e, c.f], r.join(",") === "1,0,0,1,0,0" ? tx : r) : (r === tx && !e.offsetParent && e !== sg && !i.svg && (c = s.display, s.display = "block", a = e.parentNode, (!a || !e.offsetParent && !e.getBoundingClientRect().width) && (h = 1, l = e.nextElementSibling, sg.appendChild(e)), r = tU(e), c ? s.display = c : ip(e, "display"), h && (l ? a.insertBefore(e, l) : a ? a.appendChild(e) : sg.removeChild(e))), t && r.length > 6 ? [r[0], r[1], r[4], r[5], r[12], r[13]] : r)
   },
   jw = function (e, t, i, s, r, a) {
      var l = e._gsap,
         c = r || uC(e, !0),
         h = l.xOrigin || 0,
         m = l.yOrigin || 0,
         g = l.xOffset || 0,
         v = l.yOffset || 0,
         x = c[0],
         S = c[1],
         E = c[2],
         T = c[3],
         b = c[4],
         w = c[5],
         C = t.split(" "),
         N = parseFloat(C[0]) || 0,
         U = parseFloat(C[1]) || 0,
         z, B, I, O;
      i ? c !== tx && (B = x * T - S * E) && (I = N * (T / B) + U * (-E / B) + (E * w - T * b) / B, O = N * (-S / B) + U * (x / B) - (x * w - S * b) / B, N = I, U = O) : (z = L4(e), N = z.x + (~C[0].indexOf("%") ? N / 100 * z.width : N), U = z.y + (~(C[1] || C[0]).indexOf("%") ? U / 100 * z.height : U)), s || s !== !1 && l.smooth ? (b = N - h, w = U - m, l.xOffset = g + (b * x + w * E) - b, l.yOffset = v + (b * S + w * T) - w) : l.xOffset = l.yOffset = 0, l.xOrigin = N, l.yOrigin = U, l.smooth = !!s, l.origin = t, l.originIsAbsolute = !!i, e.style[Ha] = "0px 0px", a && (Zf(a, l, "xOrigin", h, N), Zf(a, l, "yOrigin", m, U), Zf(a, l, "xOffset", g, l.xOffset), Zf(a, l, "yOffset", v, l.yOffset)), e.setAttribute("data-svg-origin", N + " " + U)
   },
   nx = function (e, t) {
      var i = e._gsap || new S4(e);
      if ("x" in i && !t && !i.uncache) return i;
      var s = e.style,
         r = i.scaleX < 0,
         a = "px",
         l = "deg",
         c = getComputedStyle(e),
         h = Jo(e, Ha) || "0",
         m, g, v, x, S, E, T, b, w, C, N, U, z, B, I, O, P, q, Q, $, ae, fe, k, Z, J, pe, F, ie, ye, we, oe, be;
      return m = g = v = E = T = b = w = C = N = 0, x = S = 1, i.svg = !!(e.getCTM && B4(e)), c.translate && ((c.translate !== "none" || c.scale !== "none" || c.rotate !== "none") && (s[Ki] = (c.translate !== "none" ? "translate3d(" + (c.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (c.rotate !== "none" ? "rotate(" + c.rotate + ") " : "") + (c.scale !== "none" ? "scale(" + c.scale.split(" ").join(",") + ") " : "") + (c[Ki] !== "none" ? c[Ki] : "")), s.scale = s.rotate = s.translate = "none"), B = uC(e, i.svg), i.svg && (i.uncache ? (J = e.getBBox(), h = i.xOrigin - J.x + "px " + (i.yOrigin - J.y) + "px", Z = "") : Z = !t && e.getAttribute("data-svg-origin"), jw(e, Z || h, !!Z || i.originIsAbsolute, i.smooth !== !1, B)), U = i.xOrigin || 0, z = i.yOrigin || 0, B !== tx && (q = B[0], Q = B[1], $ = B[2], ae = B[3], m = fe = B[4], g = k = B[5], B.length === 6 ? (x = Math.sqrt(q * q + Q * Q), S = Math.sqrt(ae * ae + $ * $), E = q || Q ? Bm(Q, q) * Ad : 0, w = $ || ae ? Bm($, ae) * Ad + E : 0, w && (S *= Math.abs(Math.cos(w * rg))), i.svg && (m -= U - (U * q + z * $), g -= z - (U * Q + z * ae))) : (be = B[6], we = B[7], F = B[8], ie = B[9], ye = B[10], oe = B[11], m = B[12], g = B[13], v = B[14], I = Bm(be, ye), T = I * Ad, I && (O = Math.cos(-I), P = Math.sin(-I), Z = fe * O + F * P, J = k * O + ie * P, pe = be * O + ye * P, F = fe * -P + F * O, ie = k * -P + ie * O, ye = be * -P + ye * O, oe = we * -P + oe * O, fe = Z, k = J, be = pe), I = Bm(-$, ye), b = I * Ad, I && (O = Math.cos(-I), P = Math.sin(-I), Z = q * O - F * P, J = Q * O - ie * P, pe = $ * O - ye * P, oe = ae * P + oe * O, q = Z, Q = J, $ = pe), I = Bm(Q, q), E = I * Ad, I && (O = Math.cos(I), P = Math.sin(I), Z = q * O + Q * P, J = fe * O + k * P, Q = Q * O - q * P, k = k * O - fe * P, q = Z, fe = J), T && Math.abs(T) + Math.abs(E) > 359.9 && (T = E = 0, b = 180 - b), x = hs(Math.sqrt(q * q + Q * Q + $ * $)), S = hs(Math.sqrt(k * k + be * be)), I = Bm(fe, k), w = Math.abs(I) > 2e-4 ? I * Ad : 0, N = oe ? 1 / (oe < 0 ? -oe : oe) : 0), i.svg && (Z = e.getAttribute("transform"), i.forceCSS = e.setAttribute("transform", "") || !I4(Jo(e, Ki)), Z && e.setAttribute("transform", Z))), Math.abs(w) > 90 && Math.abs(w) < 270 && (r ? (x *= -1, w += E <= 0 ? 180 : -180, E += E <= 0 ? 180 : -180) : (S *= -1, w += w <= 0 ? 180 : -180)), t = t || i.uncache, i.x = m - ((i.xPercent = m && (!t && i.xPercent || (Math.round(e.offsetWidth / 2) === Math.round(-m) ? -50 : 0))) ? e.offsetWidth * i.xPercent / 100 : 0) + a, i.y = g - ((i.yPercent = g && (!t && i.yPercent || (Math.round(e.offsetHeight / 2) === Math.round(-g) ? -50 : 0))) ? e.offsetHeight * i.yPercent / 100 : 0) + a, i.z = v + a, i.scaleX = hs(x), i.scaleY = hs(S), i.rotation = hs(E) + l, i.rotationX = hs(T) + l, i.rotationY = hs(b) + l, i.skewX = w + l, i.skewY = C + l, i.transformPerspective = N + a, (i.zOrigin = parseFloat(h.split(" ")[2]) || !t && i.zOrigin || 0) && (s[Ha] = I1(h)), i.xOffset = i.yOffset = 0, i.force3D = mo.force3D, i.renderTransform = i.svg ? y$ : P4 ? F4 : v$, i.uncache = 0, i
   },
   I1 = function (e) {
      return (e = e.split(" "))[0] + " " + e[1]
   },
   _A = function (e, t, i) {
      var s = Or(t);
      return hs(parseFloat(t) + parseFloat(uh(e, "x", i + "px", s))) + s
   },
   v$ = function (e, t) {
      t.z = "0px", t.rotationY = t.rotationX = "0deg", t.force3D = 0, F4(e, t)
   },
   Sd = "0deg",
   S0 = "0px",
   bd = ") ",
   F4 = function (e, t) {
      var i = t || this,
         s = i.xPercent,
         r = i.yPercent,
         a = i.x,
         l = i.y,
         c = i.z,
         h = i.rotation,
         m = i.rotationY,
         g = i.rotationX,
         v = i.skewX,
         x = i.skewY,
         S = i.scaleX,
         E = i.scaleY,
         T = i.transformPerspective,
         b = i.force3D,
         w = i.target,
         C = i.zOrigin,
         N = "",
         U = b === "auto" && e && e !== 1 || b === !0;
      if (C && (g !== Sd || m !== Sd)) {
         var z = parseFloat(m) * rg,
            B = Math.sin(z),
            I = Math.cos(z),
            O;
         z = parseFloat(g) * rg, O = Math.cos(z), a = _A(w, a, B * O * -C), l = _A(w, l, -Math.sin(z) * -C), c = _A(w, c, I * O * -C + C)
      }
      T !== S0 && (N += "perspective(" + T + bd), (s || r) && (N += "translate(" + s + "%, " + r + "%) "), (U || a !== S0 || l !== S0 || c !== S0) && (N += c !== S0 || U ? "translate3d(" + a + ", " + l + ", " + c + ") " : "translate(" + a + ", " + l + bd), h !== Sd && (N += "rotate(" + h + bd), m !== Sd && (N += "rotateY(" + m + bd), g !== Sd && (N += "rotateX(" + g + bd), (v !== Sd || x !== Sd) && (N += "skew(" + v + ", " + x + bd), (S !== 1 || E !== 1) && (N += "scale(" + S + ", " + E + bd), w.style[Ki] = N || "translate(0, 0)"
   },
   y$ = function (e, t) {
      var i = t || this,
         s = i.xPercent,
         r = i.yPercent,
         a = i.x,
         l = i.y,
         c = i.rotation,
         h = i.skewX,
         m = i.skewY,
         g = i.scaleX,
         v = i.scaleY,
         x = i.target,
         S = i.xOrigin,
         E = i.yOrigin,
         T = i.xOffset,
         b = i.yOffset,
         w = i.forceCSS,
         C = parseFloat(a),
         N = parseFloat(l),
         U, z, B, I, O;
      c = parseFloat(c), h = parseFloat(h), m = parseFloat(m), m && (m = parseFloat(m), h += m, c += m), c || h ? (c *= rg, h *= rg, U = Math.cos(c) * g, z = Math.sin(c) * g, B = Math.sin(c - h) * -v, I = Math.cos(c - h) * v, h && (m *= rg, O = Math.tan(h - m), O = Math.sqrt(1 + O * O), B *= O, I *= O, m && (O = Math.tan(m), O = Math.sqrt(1 + O * O), U *= O, z *= O)), U = hs(U), z = hs(z), B = hs(B), I = hs(I)) : (U = g, I = v, z = B = 0), (C && !~(a + "").indexOf("px") || N && !~(l + "").indexOf("px")) && (C = uh(x, "x", a, "px"), N = uh(x, "y", l, "px")), (S || E || T || b) && (C = hs(C + S - (S * U + E * B) + T), N = hs(N + E - (S * z + E * I) + b)), (s || r) && (O = x.getBBox(), C = hs(C + s / 100 * O.width), N = hs(N + r / 100 * O.height)), O = "matrix(" + U + "," + z + "," + B + "," + I + "," + C + "," + N + ")", x.setAttribute("transform", O), w && (x.style[Ki] = O)
   },
   x$ = function (e, t, i, s, r) {
      var a = 360,
         l = ir(r),
         c = parseFloat(r) * (l && ~r.indexOf("rad") ? Ad : 1),
         h = c - s,
         m = s + h + "deg",
         g, v;
      return l && (g = r.split("_")[1], g === "short" && (h %= a, h !== h % (a / 2) && (h += h < 0 ? a : -a)), g === "cw" && h < 0 ? h = (h + a * KO) % a - ~~(h / a) * a : g === "ccw" && h > 0 && (h = (h - a * KO) % a - ~~(h / a) * a)), e._pt = v = new Fa(e._pt, t, i, s, h, n$), v.e = m, v.u = "deg", e._props.push(i), v
   },
   nU = function (e, t) {
      for (var i in t) e[i] = t[i];
      return e
   },
   _$ = function (e, t, i) {
      var s = nU({}, i._gsap),
         r = "perspective,force3D,transformOrigin,svgOrigin",
         a = i.style,
         l, c, h, m, g, v, x, S;
      s.svg ? (h = i.getAttribute("transform"), i.setAttribute("transform", ""), a[Ki] = t, l = nx(i, 1), ip(i, Ki), i.setAttribute("transform", h)) : (h = getComputedStyle(i)[Ki], a[Ki] = t, l = nx(i, 1), a[Ki] = h);
      for (c in Ic) h = s[c], m = l[c], h !== m && r.indexOf(c) < 0 && (x = Or(h), S = Or(m), g = x !== S ? uh(i, c, h, S) : parseFloat(h), v = parseFloat(m), e._pt = new Fa(e._pt, l, c, g, v - g, Vw), e._pt.u = S || 0, e._props.push(c));
      nU(l, s)
   };
Ia("padding,margin,Width,Radius", function (n, e) {
   var t = "Top",
      i = "Right",
      s = "Bottom",
      r = "Left",
      a = (e < 3 ? [t, i, s, r] : [t + r, t + i, s + i, s + r]).map(function (l) {
         return e < 2 ? n + l : "border" + l + n
      });
   z1[e > 1 ? "border" + n : n] = function (l, c, h, m, g) {
      var v, x;
      if (arguments.length < 4) return v = a.map(function (S) {
         return Tc(l, S, h)
      }), x = v.join(" "), x.split(v[0]).length === 5 ? v[0] : x;
      v = (m + "").split(" "), x = {}, a.forEach(function (S, E) {
         return x[S] = v[E] = v[E] || v[(E - 1) / 2 | 0]
      }), l.init(c, x, g)
   }
});
var H4 = {
   name: "css",
   register: kw,
   targetTest: function (e) {
      return e.style && e.nodeType
   },
   init: function (e, t, i, s, r) {
      var a = this._props,
         l = e.style,
         c = i.vars.startAt,
         h, m, g, v, x, S, E, T, b, w, C, N, U, z, B, I;
      aC || kw(), this.styles = this.styles || U4(e), I = this.styles.props, this.tween = i;
      for (E in t)
         if (E !== "autoRound" && (m = t[E], !(oo[E] && b4(E, t, i, s, e, r)))) {
            if (x = typeof m, S = z1[E], x === "function" && (m = m.call(i, s, e, r), x = typeof m), x === "string" && ~m.indexOf("random(") && (m = Jy(m)), S) S(this, e, E, m, i) && (B = 1);
            else if (E.substr(0, 2) === "--") h = (getComputedStyle(e).getPropertyValue(E) + "").trim(), m += "", eh.lastIndex = 0, eh.test(h) || (T = Or(h), b = Or(m)), b ? T !== b && (h = uh(e, E, h, b) + b) : T && (m += T), this.add(l, "setProperty", h, m, s, r, 0, 0, E), a.push(E), I.push(E, 0, l[E]);
            else if (x !== "undefined") {
               if (c && E in c ? (h = typeof c[E] == "function" ? c[E].call(i, s, e, r) : c[E], ir(h) && ~h.indexOf("random(") && (h = Jy(h)), Or(h + "") || h === "auto" || (h += mo.units[E] || Or(Tc(e, E)) || ""), (h + "").charAt(1) === "=" && (h = Tc(e, E))) : h = Tc(e, E), v = parseFloat(h), w = x === "string" && m.charAt(1) === "=" && m.substr(0, 2), w && (m = m.substr(2)), g = parseFloat(m), E in Nu && (E === "autoAlpha" && (v === 1 && Tc(e, "visibility") === "hidden" && g && (v = 0), I.push("visibility", 0, l.visibility), Zf(this, l, "visibility", v ? "inherit" : "hidden", g ? "inherit" : "hidden", !g)), E !== "scale" && E !== "transform" && (E = Nu[E], ~E.indexOf(",") && (E = E.split(",")[0]))), C = E in Ic, C) {
                  if (this.styles.save(E), x === "string" && m.substring(0, 6) === "var(--" && (m = Jo(e, m.substring(4, m.indexOf(")"))), g = parseFloat(m)), N || (U = e._gsap, U.renderTransform && !t.parseTransform || nx(e, t.parseTransform), z = t.smoothOrigin !== !1 && U.smooth, N = this._pt = new Fa(this._pt, l, Ki, 0, 1, U.renderTransform, U, 0, -1), N.dep = 1), E === "scale") this._pt = new Fa(this._pt, U, "scaleY", U.scaleY, (w ? ig(U.scaleY, w + g) : g) - U.scaleY || 0, Vw), this._pt.u = 0, a.push("scaleY", E), E += "X";
                  else if (E === "transformOrigin") {
                     I.push(Ha, 0, l[Ha]), m = m$(m), U.svg ? jw(e, m, 0, z, 0, this) : (b = parseFloat(m.split(" ")[2]) || 0, b !== U.zOrigin && Zf(this, U, "zOrigin", U.zOrigin, b), Zf(this, l, E, I1(h), I1(m)));
                     continue
                  } else if (E === "svgOrigin") {
                     jw(e, m, 1, z, 0, this);
                     continue
                  } else if (E in z4) {
                     x$(this, U, E, v, w ? ig(v, w + m) : m);
                     continue
                  } else if (E === "smoothOrigin") {
                     Zf(this, U, "smooth", U.smooth, m);
                     continue
                  } else if (E === "force3D") {
                     U[E] = m;
                     continue
                  } else if (E === "transform") {
                     _$(this, m, e);
                     continue
                  }
               } else E in l || (E = Ag(E) || E);
               if (C || (g || g === 0) && (v || v === 0) && !t$.test(m) && E in l) T = (h + "").substr((v + "").length), g || (g = 0), b = Or(m) || (E in mo.units ? mo.units[E] : T), T !== b && (v = uh(e, E, h, b)), this._pt = new Fa(this._pt, C ? U : l, E, v, (w ? ig(v, w + g) : g) - v, !C && (b === "px" || E === "zIndex") && t.autoRound !== !1 ? s$ : Vw), this._pt.u = b || 0, T !== b && b !== "%" && (this._pt.b = h, this._pt.r = i$);
               else if (E in l) p$.call(this, e, E, h, w ? w + m : m);
               else if (E in e) this.add(e, E, h || e[E], w ? w + m : m, s, r);
               else if (E !== "parseTransform") {
                  Z2(E, m);
                  continue
               }
               C || (E in l ? I.push(E, 0, l[E]) : typeof e[E] == "function" ? I.push(E, 2, e[E]()) : I.push(E, 1, h || e[E])), a.push(E)
            }
         } B && R4(this)
   },
   render: function (e, t) {
      if (t.tween._time || !oC())
         for (var i = t._pt; i;) i.r(e, i.d), i = i._next;
      else t.styles.revert()
   },
   get: Tc,
   aliases: Nu,
   getSetter: function (e, t, i) {
      var s = Nu[t];
      return s && s.indexOf(",") < 0 && (t = s), t in Ic && t !== Ha && (e._gsap.x || Tc(e, "x")) ? i && YO === i ? t === "scale" ? l$ : o$ : (YO = i || {}) && (t === "scale" ? u$ : c$) : e.style && !W2(e.style[t]) ? r$ : ~t.indexOf("-") ? a$ : sC(e, t)
   },
   core: {
      _removeProperty: ip,
      _getMatrix: uC
   }
};
ka.utils.checkPrefix = Ag;
ka.core.getStyleSaver = U4;
(function (n, e, t, i) {
   var s = Ia(n + "," + e + "," + t, function (r) {
      Ic[r] = 1
   });
   Ia(e, function (r) {
      mo.units[r] = "deg", z4[r] = 1
   }), Nu[s[13]] = n + "," + e, Ia(i, function (r) {
      var a = r.split(":");
      Nu[a[1]] = s[a[0]]
   })
})("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
Ia("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function (n) {
   mo.units[n] = "px"
});
ka.registerPlugin(H4);
var iy = ka.registerPlugin(H4) || ka;
iy.core.Tween;
const V4 = l2(n => ({
   isHoveringPlanet: !1,
   setIsHoveringPlanet: e => n({
      isHoveringPlanet: e
   })
}));

function S$(n = 768) {
   const [e, t] = j.useState(window.innerWidth <= n);
   return j.useEffect(() => {
      const i = () => t(window.innerWidth <= n);
      return window.addEventListener("resize", i), () => window.removeEventListener("resize", i)
   }, [n]), e
}

function b$({
   scrollY: n,
   onTargetChange: e,
   onSecondaryTarget1Change: t,
   onSecondaryTarget2Change: i
}) {
   const {
      camera: s
   } = NT(), r = ju(), a = S$(), l = j.useRef({
      x: 0,
      y: 0
   }), c = j.useRef({
      current: 0,
      target: 0
   }), h = j.useRef(!1), m = j.useRef(!1), g = j.useRef(null), v = j.useRef(null), x = j.useRef(null), S = j.useRef(null), E = u2(Q => Q.isPlanetClicked), b = j.useMemo(() => new ee(0, 0, 6), []).length(), w = 40, C = j.useRef(new ee), N = j.useMemo(() => new ee, []), U = j.useMemo(() => new ee, []), z = j.useMemo(() => new ee(0, 1, 0), []), B = j.useMemo(() => new ee, []), I = j.useMemo(() => [{
      id: "section1",
      t: 0
   }, {
      id: "section2",
      t: .25
   }, {
      id: "section3",
      t: .42
   }, {
      id: "section4",
      t: .52
   }, {
      id: "section5",
      t: .6
   }, {
      id: "section6",
      t: .8
   }, {
      id: "section7",
      t: .97
   }], []), O = j.useMemo(() => [{
      id: "sub11",
      t: 0
   }, {
      id: "sub12",
      t: .24
   }, {
      id: "sub13",
      t: .75
   }], []), P = j.useMemo(() => [{
      id: "sub21",
      t: .34
   }, {
      id: "sub22",
      t: .6
   }, {
      id: "sub23",
      t: .9
   }], []);
   j.useEffect(() => {
      if (a) return;
      let Q = null;
      const $ = ae => {
         Q || (Q = requestAnimationFrame(() => {
            l.current.x = ae.clientX / window.innerWidth * 2 - 1, l.current.y = -(ae.clientY / window.innerHeight) * 2 + 1, Q = null
         }))
      };
      return window.addEventListener("mousemove", $), () => {
         window.removeEventListener("mousemove", $), Q && cancelAnimationFrame(Q)
      }
   }, []);
   const q = Q => {
      const $ = Math.PI * 2 * Q,
         ae = b + Q * w,
         fe = Math.sin($) * ae,
         k = Math.cos($) * ae,
         Z = -Q * 34.6;
      return new ee(fe, Z, k)
   };
   return j.useEffect(() => {
      const Q = iy.timeline({
         scrollTrigger: {
            trigger: document.body,
            start: "top top",
            end: "bottom bottom",
            scrub: !0,
            onUpdate: $ => {
               h.current || (c.current.target = $.progress)
            }
         }
      });
      return () => {
         Q.scrollTrigger && Q.scrollTrigger.kill(), Q.kill()
      }
   }, []), a2((Q, $) => {
      const ae = h.current ? 1 : 1 - Math.exp(-4 * $);
      c.current.current += (c.current.target - c.current.current) * ae;
      const fe = c.current.current,
         k = iy.utils.interpolate(0, 1, Math.pow(fe * 2 - 1, 3) * .5 + .5),
         Z = q(k);
      B.copy(Z).normalize(), U.copy(z).cross(B).normalize(), N.copy(B).cross(U).normalize();
      const J = U.clone().multiplyScalar(l.current.x * .2),
         pe = N.clone().multiplyScalar(l.current.y * .2);
      C.current.copy(Z).add(J).add(pe), s.position.lerp(C.current, ae), s.lookAt(0, 0, 0);
      const F = V4.getState().isHoveringPlanet,
         ie = !a && window.innerHeight > window.innerWidth;
      let ye;
      a ? ye = 58 : ie ? ye = 54 : ye = 42;
      let we;
      F ? a ? we = 56 : ie ? we = 52 : we = 40 : we = ye, s.fov = bL.lerp(s.fov, we, 1 - Math.exp(-3 * $)), s.updateProjectionMatrix();
      let oe = null;
      for (const Xe of I) {
         const yt = s.position.distanceTo(q(Xe.t)),
            Mt = Xe.id === "section6" || Xe.id === "section7" ? 29 : 10;
         if (yt < Mt) {
            oe = Xe.id;
            break
         }
      }
      oe !== v.current && (v.current = oe, e && e(oe));
      const be = (Xe, yt) => {
            for (const vt of Xe)
               if (s.position.distanceTo(q(vt.t)) < yt) return vt.id;
            return null
         },
         Pe = be(O, 2),
         Ge = be(P, 10);
      if (Pe !== x.current && (x.current = Pe, t && t(Pe)), Ge !== S.current && (S.current = Ge, i && i(Ge)), E && !m.current) {
         m.current = !0;
         const Xe = document.getElementById("fade-overlay");
         if (!Xe) return;
         g.current = iy.to(Xe, {
            opacity: 1,
            duration: 1.5,
            ease: "power2.out",
            onComplete: () => {
               const yt = window.location.pathname.split("/")[1],
                  Mt = ["ro", "es", "fr", "de", "it"].includes(yt) ? `/${yt}` : "";
               r(`${Mt}/portfolio`), setTimeout(() => window.scrollTo({
                  top: 0
               }), 0)
            }
         })
      }
   }), null
}
/**
 * postprocessing v6.37.6 build Fri Jul 04 2025
 * https://github.com/pmndrs/postprocessing
 * Copyright 2015-2025 Raoul van Rschen
 * @license Zlib
 */
var SA = 1 / 1e3,
   T$ = 1e3,
   E$ = class {
      constructor() {
         this.startTime = performance.now(), this.previousTime = 0, this.currentTime = 0, this._delta = 0, this._elapsed = 0, this._fixedDelta = 1e3 / 60, this.timescale = 1, this.useFixedDelta = !1, this._autoReset = !1
      }
      get autoReset() {
         return this._autoReset
      }
      set autoReset(n) {
         typeof document < "u" && document.hidden !== void 0 && (n ? document.addEventListener("visibilitychange", this) : document.removeEventListener("visibilitychange", this), this._autoReset = n)
      }
      get delta() {
         return this._delta * SA
      }
      get fixedDelta() {
         return this._fixedDelta * SA
      }
      set fixedDelta(n) {
         this._fixedDelta = n * T$
      }
      get elapsed() {
         return this._elapsed * SA
      }
      update(n) {
         this.useFixedDelta ? this._delta = this.fixedDelta : (this.previousTime = this.currentTime, this.currentTime = (n !== void 0 ? n : performance.now()) - this.startTime, this._delta = this.currentTime - this.previousTime), this._delta *= this.timescale, this._elapsed += this._delta
      }
      reset() {
         this._delta = 0, this._elapsed = 0, this.currentTime = performance.now() - this.startTime
      }
      getDelta() {
         return this.delta
      }
      getElapsed() {
         return this.elapsed
      }
      handleEvent(n) {
         document.hidden || (this.currentTime = performance.now() - this.startTime)
      }
      dispose() {
         this.autoReset = !1
      }
   },
   M$ = (() => {
      const n = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]),
         e = new Float32Array([0, 0, 2, 0, 0, 2]),
         t = new pn;
      return t.setAttribute("position", new oi(n, 3)), t.setAttribute("uv", new oi(e, 2)), t
   })(),
   ga = class qw {
      static get fullscreenGeometry() {
         return M$
      }
      constructor(e = "Pass", t = new mg, i = new px) {
         this.name = e, this.renderer = null, this.scene = t, this.camera = i, this.screen = null, this.rtt = !0, this.needsSwap = !0, this.needsDepthTexture = !1, this.enabled = !0
      }
      get renderToScreen() {
         return !this.rtt
      }
      set renderToScreen(e) {
         if (this.rtt === e) {
            const t = this.fullscreenMaterial;
            t !== null && (t.needsUpdate = !0), this.rtt = !e
         }
      }
      set mainScene(e) {}
      set mainCamera(e) {}
      setRenderer(e) {
         this.renderer = e
      }
      isEnabled() {
         return this.enabled
      }
      setEnabled(e) {
         this.enabled = e
      }
      get fullscreenMaterial() {
         return this.screen !== null ? this.screen.material : null
      }
      set fullscreenMaterial(e) {
         let t = this.screen;
         t !== null ? t.material = e : (t = new ds(qw.fullscreenGeometry, e), t.frustumCulled = !1, this.scene === null && (this.scene = new mg), this.scene.add(t), this.screen = t)
      }
      getFullscreenMaterial() {
         return this.fullscreenMaterial
      }
      setFullscreenMaterial(e) {
         this.fullscreenMaterial = e
      }
      getDepthTexture() {
         return null
      }
      setDepthTexture(e, t = Hl) {}
      render(e, t, i, s, r) {
         throw new Error("Render method not implemented!")
      }
      setSize(e, t) {}
      initialize(e, t, i) {}
      dispose() {
         for (const e of Object.keys(this)) {
            const t = this[e];
            (t instanceof ss || t instanceof sr || t instanceof Hi || t instanceof qw) && this[e].dispose()
         }
         this.fullscreenMaterial !== null && this.fullscreenMaterial.dispose()
      }
   },
   A$ = class extends ga {
      constructor() {
         super("ClearMaskPass", null, null), this.needsSwap = !1
      }
      render(n, e, t, i, s) {
         const r = n.state.buffers.stencil;
         r.setLocked(!1), r.setTest(!1)
      }
   },
   w$ = `#include <common>
#include <dithering_pars_fragment>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;
#include <colorspace_fragment>
#include <dithering_fragment>
}`,
   GT = "varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}",
   G4 = class extends gs {
      constructor() {
         super({
            name: "CopyMaterial",
            uniforms: {
               inputBuffer: new nn(null),
               opacity: new nn(1)
            },
            blending: nr,
            toneMapped: !1,
            depthWrite: !1,
            depthTest: !1,
            fragmentShader: w$,
            vertexShader: GT
         })
      }
      set inputBuffer(n) {
         this.uniforms.inputBuffer.value = n
      }
      setInputBuffer(n) {
         this.uniforms.inputBuffer.value = n
      }
      getOpacity(n) {
         return this.uniforms.opacity.value
      }
      setOpacity(n) {
         this.uniforms.opacity.value = n
      }
   },
   R$ = class extends ga {
      constructor(n, e = !0) {
         super("CopyPass"), this.fullscreenMaterial = new G4, this.needsSwap = !1, this.renderTarget = n, n === void 0 && (this.renderTarget = new ss(1, 1, {
            minFilter: Ni,
            magFilter: Ni,
            stencilBuffer: !1,
            depthBuffer: !1
         }), this.renderTarget.texture.name = "CopyPass.Target"), this.autoResize = e
      }
      get resize() {
         return this.autoResize
      }
      set resize(n) {
         this.autoResize = n
      }
      get texture() {
         return this.renderTarget.texture
      }
      getTexture() {
         return this.renderTarget.texture
      }
      setAutoResizeEnabled(n) {
         this.autoResize = n
      }
      render(n, e, t, i, s) {
         this.fullscreenMaterial.inputBuffer = e.texture, n.setRenderTarget(this.renderToScreen ? null : this.renderTarget), n.render(this.scene, this.camera)
      }
      setSize(n, e) {
         this.autoResize && this.renderTarget.setSize(n, e)
      }
      initialize(n, e, t) {
         t !== void 0 && (this.renderTarget.texture.type = t, t !== qs ? this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1" : n !== null && n.outputColorSpace === En && (this.renderTarget.texture.colorSpace = En))
      }
   },
   iU = new dt,
   cC = class extends ga {
      constructor(n = !0, e = !0, t = !1) {
         super("ClearPass", null, null), this.needsSwap = !1, this.color = n, this.depth = e, this.stencil = t, this.overrideClearColor = null, this.overrideClearAlpha = -1
      }
      setClearFlags(n, e, t) {
         this.color = n, this.depth = e, this.stencil = t
      }
      getOverrideClearColor() {
         return this.overrideClearColor
      }
      setOverrideClearColor(n) {
         this.overrideClearColor = n
      }
      getOverrideClearAlpha() {
         return this.overrideClearAlpha
      }
      setOverrideClearAlpha(n) {
         this.overrideClearAlpha = n
      }
      render(n, e, t, i, s) {
         const r = this.overrideClearColor,
            a = this.overrideClearAlpha,
            l = n.getClearAlpha(),
            c = r !== null,
            h = a >= 0;
         c ? (n.getClearColor(iU), n.setClearColor(r, h ? a : l)) : h && n.setClearAlpha(a), n.setRenderTarget(this.renderToScreen ? null : e), n.clear(this.color, this.depth, this.stencil), c ? n.setClearColor(iU, l) : h && n.setClearAlpha(l)
      }
   },
   C$ = class extends ga {
      constructor(n, e) {
         super("MaskPass", n, e), this.needsSwap = !1, this.clearPass = new cC(!1, !1, !0), this.inverse = !1
      }
      set mainScene(n) {
         this.scene = n
      }
      set mainCamera(n) {
         this.camera = n
      }
      get inverted() {
         return this.inverse
      }
      set inverted(n) {
         this.inverse = n
      }
      get clear() {
         return this.clearPass.enabled
      }
      set clear(n) {
         this.clearPass.enabled = n
      }
      getClearPass() {
         return this.clearPass
      }
      isInverted() {
         return this.inverted
      }
      setInverted(n) {
         this.inverted = n
      }
      render(n, e, t, i, s) {
         const r = n.getContext(),
            a = n.state.buffers,
            l = this.scene,
            c = this.camera,
            h = this.clearPass,
            m = this.inverted ? 0 : 1,
            g = 1 - m;
         a.color.setMask(!1), a.depth.setMask(!1), a.color.setLocked(!0), a.depth.setLocked(!0), a.stencil.setTest(!0), a.stencil.setOp(r.REPLACE, r.REPLACE, r.REPLACE), a.stencil.setFunc(r.ALWAYS, m, 4294967295), a.stencil.setClear(g), a.stencil.setLocked(!0), this.clearPass.enabled && (this.renderToScreen ? h.render(n, null) : (h.render(n, e), h.render(n, t))), this.renderToScreen ? (n.setRenderTarget(null), n.render(l, c)) : (n.setRenderTarget(e), n.render(l, c), n.setRenderTarget(t), n.render(l, c)), a.color.setLocked(!1), a.depth.setLocked(!1), a.stencil.setLocked(!1), a.stencil.setFunc(r.EQUAL, 1, 4294967295), a.stencil.setOp(r.KEEP, r.KEEP, r.KEEP), a.stencil.setLocked(!0)
      }
   },
   D$ = class {
      constructor(n = null, {
         depthBuffer: e = !0,
         stencilBuffer: t = !1,
         multisampling: i = 0,
         frameBufferType: s
      } = {}) {
         this.renderer = null, this.inputBuffer = this.createBuffer(e, t, s, i), this.outputBuffer = this.inputBuffer.clone(), this.copyPass = new R$, this.depthTexture = null, this.passes = [], this.timer = new E$, this.autoRenderToScreen = !0, this.setRenderer(n)
      }
      get multisampling() {
         return this.inputBuffer.samples || 0
      }
      set multisampling(n) {
         const e = this.inputBuffer,
            t = this.multisampling;
         t > 0 && n > 0 ? (this.inputBuffer.samples = n, this.outputBuffer.samples = n, this.inputBuffer.dispose(), this.outputBuffer.dispose()) : t !== n && (this.inputBuffer.dispose(), this.outputBuffer.dispose(), this.inputBuffer = this.createBuffer(e.depthBuffer, e.stencilBuffer, e.texture.type, n), this.inputBuffer.depthTexture = this.depthTexture, this.outputBuffer = this.inputBuffer.clone())
      }
      getTimer() {
         return this.timer
      }
      getRenderer() {
         return this.renderer
      }
      setRenderer(n) {
         if (this.renderer = n, n !== null) {
            const e = n.getSize(new Fe),
               t = n.getContext().getContextAttributes().alpha,
               i = this.inputBuffer.texture.type;
            i === qs && n.outputColorSpace === En && (this.inputBuffer.texture.colorSpace = En, this.outputBuffer.texture.colorSpace = En, this.inputBuffer.dispose(), this.outputBuffer.dispose()), n.autoClear = !1, this.setSize(e.width, e.height);
            for (const s of this.passes) s.initialize(n, t, i)
         }
      }
      replaceRenderer(n, e = !0) {
         const t = this.renderer,
            i = t.domElement.parentNode;
         return this.setRenderer(n), e && i !== null && (i.removeChild(t.domElement), i.appendChild(n.domElement)), t
      }
      createDepthTexture() {
         const n = this.depthTexture = new vx;
         return this.inputBuffer.depthTexture = n, this.inputBuffer.dispose(), this.inputBuffer.stencilBuffer ? (n.format = $d, n.type = Jd) : n.type = Vu, n
      }
      deleteDepthTexture() {
         if (this.depthTexture !== null) {
            this.depthTexture.dispose(), this.depthTexture = null, this.inputBuffer.depthTexture = null, this.inputBuffer.dispose();
            for (const n of this.passes) n.setDepthTexture(null)
         }
      }
      createBuffer(n, e, t, i) {
         const s = this.renderer,
            r = s === null ? new Fe : s.getDrawingBufferSize(new Fe),
            a = {
               minFilter: Ni,
               magFilter: Ni,
               stencilBuffer: e,
               depthBuffer: n,
               type: t
            },
            l = new ss(r.width, r.height, a);
         return i > 0 && (l.ignoreDepthForMultisampleCopy = !1, l.samples = i), t === qs && s !== null && s.outputColorSpace === En && (l.texture.colorSpace = En), l.texture.name = "EffectComposer.Buffer", l.texture.generateMipmaps = !1, l
      }
      setMainScene(n) {
         for (const e of this.passes) e.mainScene = n
      }
      setMainCamera(n) {
         for (const e of this.passes) e.mainCamera = n
      }
      addPass(n, e) {
         const t = this.passes,
            i = this.renderer,
            s = i.getDrawingBufferSize(new Fe),
            r = i.getContext().getContextAttributes().alpha,
            a = this.inputBuffer.texture.type;
         if (n.setRenderer(i), n.setSize(s.width, s.height), n.initialize(i, r, a), this.autoRenderToScreen && (t.length > 0 && (t[t.length - 1].renderToScreen = !1), n.renderToScreen && (this.autoRenderToScreen = !1)), e !== void 0 ? t.splice(e, 0, n) : t.push(n), this.autoRenderToScreen && (t[t.length - 1].renderToScreen = !0), n.needsDepthTexture || this.depthTexture !== null)
            if (this.depthTexture === null) {
               const l = this.createDepthTexture();
               for (n of t) n.setDepthTexture(l)
            } else n.setDepthTexture(this.depthTexture)
      }
      removePass(n) {
         const e = this.passes,
            t = e.indexOf(n);
         if (t !== -1 && e.splice(t, 1).length > 0) {
            if (this.depthTexture !== null) {
               const r = (l, c) => l || c.needsDepthTexture;
               e.reduce(r, !1) || (n.getDepthTexture() === this.depthTexture && n.setDepthTexture(null), this.deleteDepthTexture())
            }
            this.autoRenderToScreen && t === e.length && (n.renderToScreen = !1, e.length > 0 && (e[e.length - 1].renderToScreen = !0))
         }
      }
      removeAllPasses() {
         const n = this.passes;
         this.deleteDepthTexture(), n.length > 0 && (this.autoRenderToScreen && (n[n.length - 1].renderToScreen = !1), this.passes = [])
      }
      render(n) {
         const e = this.renderer,
            t = this.copyPass;
         let i = this.inputBuffer,
            s = this.outputBuffer,
            r = !1,
            a, l, c;
         n === void 0 && (this.timer.update(), n = this.timer.getDelta());
         for (const h of this.passes) h.enabled && (h.render(e, i, s, n, r), h.needsSwap && (r && (t.renderToScreen = h.renderToScreen, a = e.getContext(), l = e.state.buffers.stencil, l.setFunc(a.NOTEQUAL, 1, 4294967295), t.render(e, i, s, n, r), l.setFunc(a.EQUAL, 1, 4294967295)), c = i, i = s, s = c), h instanceof C$ ? r = !0 : h instanceof A$ && (r = !1))
      }
      setSize(n, e, t) {
         const i = this.renderer,
            s = i.getSize(new Fe);
         (n === void 0 || e === void 0) && (n = s.width, e = s.height), (s.width !== n || s.height !== e) && i.setSize(n, e, t);
         const r = i.getDrawingBufferSize(new Fe);
         this.inputBuffer.setSize(r.width, r.height), this.outputBuffer.setSize(r.width, r.height);
         for (const a of this.passes) a.setSize(r.width, r.height)
      }
      reset() {
         this.dispose(), this.autoRenderToScreen = !0
      }
      dispose() {
         for (const n of this.passes) n.dispose();
         this.passes = [], this.inputBuffer !== null && this.inputBuffer.dispose(), this.outputBuffer !== null && this.outputBuffer.dispose(), this.deleteDepthTexture(), this.copyPass.dispose(), this.timer.dispose(), ga.fullscreenGeometry.dispose()
      }
   },
   th = {
      NONE: 0,
      DEPTH: 1,
      CONVOLUTION: 2
   },
   $n = {
      FRAGMENT_HEAD: "FRAGMENT_HEAD",
      FRAGMENT_MAIN_UV: "FRAGMENT_MAIN_UV",
      FRAGMENT_MAIN_IMAGE: "FRAGMENT_MAIN_IMAGE",
      VERTEX_HEAD: "VERTEX_HEAD",
      VERTEX_MAIN_SUPPORT: "VERTEX_MAIN_SUPPORT"
   },
   N$ = class {
      constructor() {
         this.shaderParts = new Map([
            [$n.FRAGMENT_HEAD, null],
            [$n.FRAGMENT_MAIN_UV, null],
            [$n.FRAGMENT_MAIN_IMAGE, null],
            [$n.VERTEX_HEAD, null],
            [$n.VERTEX_MAIN_SUPPORT, null]
         ]), this.defines = new Map, this.uniforms = new Map, this.blendModes = new Map, this.extensions = new Set, this.attributes = th.NONE, this.varyings = new Set, this.uvTransformation = !1, this.readDepth = !1, this.colorSpace = Gu
      }
   },
   bA = !1,
   sU = class {
      constructor(n = null) {
         this.originalMaterials = new Map, this.material = null, this.materials = null, this.materialsBackSide = null, this.materialsDoubleSide = null, this.materialsFlatShaded = null, this.materialsFlatShadedBackSide = null, this.materialsFlatShadedDoubleSide = null, this.setMaterial(n), this.meshCount = 0, this.replaceMaterial = e => {
            if (e.isMesh) {
               let t;
               if (e.material.flatShading) switch (e.material.side) {
                  case Ua:
                     t = this.materialsFlatShadedDoubleSide;
                     break;
                  case Ds:
                     t = this.materialsFlatShadedBackSide;
                     break;
                  default:
                     t = this.materialsFlatShaded;
                     break
               } else switch (e.material.side) {
                  case Ua:
                     t = this.materialsDoubleSide;
                     break;
                  case Ds:
                     t = this.materialsBackSide;
                     break;
                  default:
                     t = this.materials;
                     break
               }
               this.originalMaterials.set(e, e.material), e.isSkinnedMesh ? e.material = t[2] : e.isInstancedMesh ? e.material = t[1] : e.material = t[0], ++this.meshCount
            }
         }
      }
      cloneMaterial(n) {
         if (!(n instanceof gs)) return n.clone();
         const e = n.uniforms,
            t = new Map;
         for (const s in e) {
            const r = e[s].value;
            r.isRenderTargetTexture && (e[s].value = null, t.set(s, r))
         }
         const i = n.clone();
         for (const s of t) e[s[0]].value = s[1], i.uniforms[s[0]].value = s[1];
         return i
      }
      setMaterial(n) {
         if (this.disposeMaterials(), this.material = n, n !== null) {
            const e = this.materials = [this.cloneMaterial(n), this.cloneMaterial(n), this.cloneMaterial(n)];
            for (const t of e) t.uniforms = Object.assign({}, n.uniforms), t.side = Hu;
            e[2].skinning = !0, this.materialsBackSide = e.map(t => {
               const i = this.cloneMaterial(t);
               return i.uniforms = Object.assign({}, n.uniforms), i.side = Ds, i
            }), this.materialsDoubleSide = e.map(t => {
               const i = this.cloneMaterial(t);
               return i.uniforms = Object.assign({}, n.uniforms), i.side = Ua, i
            }), this.materialsFlatShaded = e.map(t => {
               const i = this.cloneMaterial(t);
               return i.uniforms = Object.assign({}, n.uniforms), i.flatShading = !0, i
            }), this.materialsFlatShadedBackSide = e.map(t => {
               const i = this.cloneMaterial(t);
               return i.uniforms = Object.assign({}, n.uniforms), i.flatShading = !0, i.side = Ds, i
            }), this.materialsFlatShadedDoubleSide = e.map(t => {
               const i = this.cloneMaterial(t);
               return i.uniforms = Object.assign({}, n.uniforms), i.flatShading = !0, i.side = Ua, i
            })
         }
      }
      render(n, e, t) {
         const i = n.shadowMap.enabled;
         if (n.shadowMap.enabled = !1, bA) {
            const s = this.originalMaterials;
            this.meshCount = 0, e.traverse(this.replaceMaterial), n.render(e, t);
            for (const r of s) r[0].material = r[1];
            this.meshCount !== s.size && s.clear()
         } else {
            const s = e.overrideMaterial;
            e.overrideMaterial = this.material, n.render(e, t), e.overrideMaterial = s
         }
         n.shadowMap.enabled = i
      }
      disposeMaterials() {
         if (this.material !== null) {
            const n = this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide).concat(this.materialsFlatShaded).concat(this.materialsFlatShadedBackSide).concat(this.materialsFlatShadedDoubleSide);
            for (const e of n) e.dispose()
         }
      }
      dispose() {
         this.originalMaterials.clear(), this.disposeMaterials()
      }
      static get workaroundEnabled() {
         return bA
      }
      static set workaroundEnabled(n) {
         bA = n
      }
   },
   Ff = -1,
   js = class extends xo {
      constructor(n, e = Ff, t = Ff, i = 1) {
         super(), this.resizable = n, this.baseSize = new Fe(1, 1), this.preferredSize = new Fe(e, t), this.target = this.preferredSize, this.s = i, this.effectiveSize = new Fe, this.addEventListener("change", () => this.updateEffectiveSize()), this.updateEffectiveSize()
      }
      updateEffectiveSize() {
         const n = this.baseSize,
            e = this.preferredSize,
            t = this.effectiveSize,
            i = this.scale;
         e.width !== Ff ? t.width = e.width : e.height !== Ff ? t.width = Math.round(e.height * (n.width / Math.max(n.height, 1))) : t.width = Math.round(n.width * i), e.height !== Ff ? t.height = e.height : e.width !== Ff ? t.height = Math.round(e.width / Math.max(n.width / Math.max(n.height, 1), 1)) : t.height = Math.round(n.height * i)
      }
      get width() {
         return this.effectiveSize.width
      }
      set width(n) {
         this.preferredWidth = n
      }
      get height() {
         return this.effectiveSize.height
      }
      set height(n) {
         this.preferredHeight = n
      }
      getWidth() {
         return this.width
      }
      getHeight() {
         return this.height
      }
      get scale() {
         return this.s
      }
      set scale(n) {
         this.s !== n && (this.s = n, this.preferredSize.setScalar(Ff), this.dispatchEvent({
            type: "change"
         }), this.resizable.setSize(this.baseSize.width, this.baseSize.height))
      }
      getScale() {
         return this.scale
      }
      setScale(n) {
         this.scale = n
      }
      get baseWidth() {
         return this.baseSize.width
      }
      set baseWidth(n) {
         this.baseSize.width !== n && (this.baseSize.width = n, this.dispatchEvent({
            type: "change"
         }), this.resizable.setSize(this.baseSize.width, this.baseSize.height))
      }
      getBaseWidth() {
         return this.baseWidth
      }
      setBaseWidth(n) {
         this.baseWidth = n
      }
      get baseHeight() {
         return this.baseSize.height
      }
      set baseHeight(n) {
         this.baseSize.height !== n && (this.baseSize.height = n, this.dispatchEvent({
            type: "change"
         }), this.resizable.setSize(this.baseSize.width, this.baseSize.height))
      }
      getBaseHeight() {
         return this.baseHeight
      }
      setBaseHeight(n) {
         this.baseHeight = n
      }
      setBaseSize(n, e) {
         (this.baseSize.width !== n || this.baseSize.height !== e) && (this.baseSize.set(n, e), this.dispatchEvent({
            type: "change"
         }), this.resizable.setSize(this.baseSize.width, this.baseSize.height))
      }
      get preferredWidth() {
         return this.preferredSize.width
      }
      set preferredWidth(n) {
         this.preferredSize.width !== n && (this.preferredSize.width = n, this.dispatchEvent({
            type: "change"
         }), this.resizable.setSize(this.baseSize.width, this.baseSize.height))
      }
      getPreferredWidth() {
         return this.preferredWidth
      }
      setPreferredWidth(n) {
         this.preferredWidth = n
      }
      get preferredHeight() {
         return this.preferredSize.height
      }
      set preferredHeight(n) {
         this.preferredSize.height !== n && (this.preferredSize.height = n, this.dispatchEvent({
            type: "change"
         }), this.resizable.setSize(this.baseSize.width, this.baseSize.height))
      }
      getPreferredHeight() {
         return this.preferredHeight
      }
      setPreferredHeight(n) {
         this.preferredHeight = n
      }
      setPreferredSize(n, e) {
         (this.preferredSize.width !== n || this.preferredSize.height !== e) && (this.preferredSize.set(n, e), this.dispatchEvent({
            type: "change"
         }), this.resizable.setSize(this.baseSize.width, this.baseSize.height))
      }
      copy(n) {
         this.s = n.scale, this.baseSize.set(n.baseWidth, n.baseHeight), this.preferredSize.set(n.preferredWidth, n.preferredHeight), this.dispatchEvent({
            type: "change"
         }), this.resizable.setSize(this.baseSize.width, this.baseSize.height)
      }
      static get AUTO_SIZE() {
         return Ff
      }
   },
   Un = {
      ADD: 0,
      ALPHA: 1,
      AVERAGE: 2,
      COLOR: 3,
      COLOR_BURN: 4,
      COLOR_DODGE: 5,
      DARKEN: 6,
      DIFFERENCE: 7,
      DIVIDE: 8,
      DST: 9,
      EXCLUSION: 10,
      HARD_LIGHT: 11,
      HARD_MIX: 12,
      HUE: 13,
      INVERT: 14,
      INVERT_RGB: 15,
      LIGHTEN: 16,
      LINEAR_BURN: 17,
      LINEAR_DODGE: 18,
      LINEAR_LIGHT: 19,
      LUMINOSITY: 20,
      MULTIPLY: 21,
      NEGATION: 22,
      NORMAL: 23,
      OVERLAY: 24,
      PIN_LIGHT: 25,
      REFLECT: 26,
      SATURATION: 27,
      SCREEN: 28,
      SOFT_LIGHT: 29,
      SRC: 30,
      SUBTRACT: 31,
      VIVID_LIGHT: 32
   },
   O$ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(x.rgb+y.rgb,y.a),opacity);}",
   U$ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,y.a*opacity);}",
   P$ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4((x.rgb+y.rgb)*0.5,y.a),opacity);}",
   L$ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.xy,xHSL.z));return mix(x,vec4(z,y.a),opacity);}",
   B$ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 a=x.rgb,b=y.rgb;vec3 z=mix(step(0.0,b)*(1.0-min(vec3(1.0),(1.0-a)/b)),vec3(1.0),step(1.0,a));return mix(x,vec4(z,y.a),opacity);}",
   z$ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 a=x.rgb,b=y.rgb;vec3 z=step(0.0,a)*mix(min(vec3(1.0),a/max(1.0-b,1e-9)),vec3(1.0),step(1.0,b));return mix(x,vec4(z,y.a),opacity);}",
   I$ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(min(x.rgb,y.rgb),y.a),opacity);}",
   F$ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(abs(x.rgb-y.rgb),y.a),opacity);}",
   H$ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(x.rgb/max(y.rgb,1e-12),y.a),opacity);}",
   V$ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4((x.rgb+y.rgb-2.0*x.rgb*y.rgb),y.a),opacity);}",
   G$ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 a=min(x.rgb,1.0);vec3 b=min(y.rgb,1.0);vec3 z=mix(2.0*a*b,1.0-2.0*(1.0-a)*(1.0-b),step(0.5,b));return mix(x,vec4(z,y.a),opacity);}",
   k$ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(step(1.0,x.rgb+y.rgb),y.a),opacity);}",
   j$ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.x,xHSL.yz));return mix(x,vec4(z,y.a),opacity);}",
   q$ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(1.0-y.rgb,y.a),opacity);}",
   X$ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(y.rgb*(1.0-x.rgb),y.a),opacity);}",
   W$ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(max(x.rgb,y.rgb),y.a),opacity);}",
   Y$ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(clamp(y.rgb+x.rgb-1.0,0.0,1.0),y.a),opacity);}",
   K$ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(min(x.rgb+y.rgb,1.0),y.a),opacity);}",
   Z$ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(clamp(2.0*y.rgb+x.rgb-1.0,0.0,1.0),y.a),opacity);}",
   Q$ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.xy,yHSL.z));return mix(x,vec4(z,y.a),opacity);}",
   J$ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(x.rgb*y.rgb,y.a),opacity);}",
   $$ = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(1.0-abs(1.0-x.rgb-y.rgb),y.a),opacity);}",
   eee = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,opacity);}",
   tee = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 z=mix(2.0*y.rgb*x.rgb,1.0-2.0*(1.0-y.rgb)*(1.0-x.rgb),step(0.5,x.rgb));return mix(x,vec4(z,y.a),opacity);}",
   nee = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 y2=2.0*y.rgb;vec3 z=mix(mix(y2,x.rgb,step(0.5*x.rgb,y.rgb)),max(y2-1.0,vec3(0.0)),step(x.rgb,y2-1.0));return mix(x,vec4(z,y.a),opacity);}",
   iee = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 z=mix(min(x.rgb*x.rgb/max(1.0-y.rgb,1e-12),1.0),y.rgb,step(1.0,y.rgb));return mix(x,vec4(z,y.a),opacity);}",
   see = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.x,yHSL.y,xHSL.z));return mix(x,vec4(z,y.a),opacity);}",
   ree = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(x.rgb+y.rgb-min(x.rgb*y.rgb,1.0),y.a),opacity);}",
   aee = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 a=x.rgb;vec3 b=y.rgb;vec3 y2=2.0*b;vec3 w=step(0.5,b);vec3 c=a-(1.0-y2)*a*(1.0-a);vec3 d=mix(a+(y2-1.0)*(sqrt(a)-a),a+(y2-1.0)*a*((16.0*a-12.0)*a+3.0),w*(1.0-step(0.25,a)));vec3 z=mix(c,d,w);return mix(x,vec4(z,y.a),opacity);}",
   oee = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y;}",
   lee = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,vec4(max(x.rgb+y.rgb-1.0,0.0),y.a),opacity);}",
   uee = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 z=mix(max(1.0-min((1.0-x.rgb)/(2.0*y.rgb),1.0),0.0),min(x.rgb/(2.0*(1.0-y.rgb)),1.0),step(0.5,y.rgb));return mix(x,vec4(z,y.a),opacity);}",
   cee = new Map([
      [Un.ADD, O$],
      [Un.ALPHA, U$],
      [Un.AVERAGE, P$],
      [Un.COLOR, L$],
      [Un.COLOR_BURN, B$],
      [Un.COLOR_DODGE, z$],
      [Un.DARKEN, I$],
      [Un.DIFFERENCE, F$],
      [Un.DIVIDE, H$],
      [Un.DST, null],
      [Un.EXCLUSION, V$],
      [Un.HARD_LIGHT, G$],
      [Un.HARD_MIX, k$],
      [Un.HUE, j$],
      [Un.INVERT, q$],
      [Un.INVERT_RGB, X$],
      [Un.LIGHTEN, W$],
      [Un.LINEAR_BURN, Y$],
      [Un.LINEAR_DODGE, K$],
      [Un.LINEAR_LIGHT, Z$],
      [Un.LUMINOSITY, Q$],
      [Un.MULTIPLY, J$],
      [Un.NEGATION, $$],
      [Un.NORMAL, eee],
      [Un.OVERLAY, tee],
      [Un.PIN_LIGHT, nee],
      [Un.REFLECT, iee],
      [Un.SATURATION, see],
      [Un.SCREEN, ree],
      [Un.SOFT_LIGHT, aee],
      [Un.SRC, oee],
      [Un.SUBTRACT, lee],
      [Un.VIVID_LIGHT, uee]
   ]),
   fee = class extends xo {
      constructor(n, e = 1) {
         super(), this._blendFunction = n, this.opacity = new nn(e)
      }
      getOpacity() {
         return this.opacity.value
      }
      setOpacity(n) {
         this.opacity.value = n
      }
      get blendFunction() {
         return this._blendFunction
      }
      set blendFunction(n) {
         this._blendFunction = n, this.dispatchEvent({
            type: "change"
         })
      }
      getBlendFunction() {
         return this.blendFunction
      }
      setBlendFunction(n) {
         this.blendFunction = n
      }
      getShaderCode() {
         return cee.get(this.blendFunction)
      }
   },
   F1 = class extends xo {
      constructor(n, e, {
         attributes: t = th.NONE,
         blendFunction: i = Un.NORMAL,
         defines: s = new Map,
         uniforms: r = new Map,
         extensions: a = null,
         vertexShader: l = null
      } = {}) {
         super(), this.name = n, this.renderer = null, this.attributes = t, this.fragmentShader = e, this.vertexShader = l, this.defines = s, this.uniforms = r, this.extensions = a, this.blendMode = new fee(i), this.blendMode.addEventListener("change", c => this.setChanged()), this._inputColorSpace = Gu, this._outputColorSpace = Bl
      }
      get inputColorSpace() {
         return this._inputColorSpace
      }
      set inputColorSpace(n) {
         this._inputColorSpace = n, this.setChanged()
      }
      get outputColorSpace() {
         return this._outputColorSpace
      }
      set outputColorSpace(n) {
         this._outputColorSpace = n, this.setChanged()
      }
      set mainScene(n) {}
      set mainCamera(n) {}
      getName() {
         return this.name
      }
      setRenderer(n) {
         this.renderer = n
      }
      getDefines() {
         return this.defines
      }
      getUniforms() {
         return this.uniforms
      }
      getExtensions() {
         return this.extensions
      }
      getBlendMode() {
         return this.blendMode
      }
      getAttributes() {
         return this.attributes
      }
      setAttributes(n) {
         this.attributes = n, this.setChanged()
      }
      getFragmentShader() {
         return this.fragmentShader
      }
      setFragmentShader(n) {
         this.fragmentShader = n, this.setChanged()
      }
      getVertexShader() {
         return this.vertexShader
      }
      setVertexShader(n) {
         this.vertexShader = n, this.setChanged()
      }
      setChanged() {
         this.dispatchEvent({
            type: "change"
         })
      }
      setDepthTexture(n, e = Hl) {}
      update(n, e, t) {}
      setSize(n, e) {}
      initialize(n, e, t) {}
      dispose() {
         for (const n of Object.keys(this)) {
            const e = this[n];
            (e instanceof ss || e instanceof sr || e instanceof Hi || e instanceof ga) && this[n].dispose()
         }
      }
   },
   kT = {
      SMALL: 1,
      MEDIUM: 2,
      LARGE: 3
   },
   hee = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec4 sum=texture2D(inputBuffer,vUv0);sum+=texture2D(inputBuffer,vUv1);sum+=texture2D(inputBuffer,vUv2);sum+=texture2D(inputBuffer,vUv3);gl_FragColor=sum*0.25;
#include <colorspace_fragment>
}`,
   dee = "uniform vec4 texelSize;uniform float kernel;uniform float scale;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vec2 dUv=(texelSize.xy*vec2(kernel)+texelSize.zw)*scale;vUv0=vec2(uv.x-dUv.x,uv.y+dUv.y);vUv1=vec2(uv.x+dUv.x,uv.y+dUv.y);vUv2=vec2(uv.x+dUv.x,uv.y-dUv.y);vUv3=vec2(uv.x-dUv.x,uv.y-dUv.y);gl_Position=vec4(position.xy,1.0,1.0);}",
   pee = [new Float32Array([0, 0]), new Float32Array([0, 1, 1]), new Float32Array([0, 1, 1, 2]), new Float32Array([0, 1, 2, 2, 3]), new Float32Array([0, 1, 2, 3, 4, 4, 5]), new Float32Array([0, 1, 2, 3, 4, 5, 7, 8, 9, 10])],
   mee = class extends gs {
      constructor(n = new Gn) {
         super({
            name: "KawaseBlurMaterial",
            uniforms: {
               inputBuffer: new nn(null),
               texelSize: new nn(new Gn),
               scale: new nn(1),
               kernel: new nn(0)
            },
            blending: nr,
            toneMapped: !1,
            depthWrite: !1,
            depthTest: !1,
            fragmentShader: hee,
            vertexShader: dee
         }), this.setTexelSize(n.x, n.y), this.kernelSize = kT.MEDIUM
      }
      set inputBuffer(n) {
         this.uniforms.inputBuffer.value = n
      }
      setInputBuffer(n) {
         this.inputBuffer = n
      }
      get kernelSequence() {
         return pee[this.kernelSize]
      }
      get scale() {
         return this.uniforms.scale.value
      }
      set scale(n) {
         this.uniforms.scale.value = n
      }
      getScale() {
         return this.uniforms.scale.value
      }
      setScale(n) {
         this.uniforms.scale.value = n
      }
      getKernel() {
         return null
      }
      get kernel() {
         return this.uniforms.kernel.value
      }
      set kernel(n) {
         this.uniforms.kernel.value = n
      }
      setKernel(n) {
         this.kernel = n
      }
      setTexelSize(n, e) {
         this.uniforms.texelSize.value.set(n, e, n * .5, e * .5)
      }
      setSize(n, e) {
         const t = 1 / n,
            i = 1 / e;
         this.uniforms.texelSize.value.set(t, i, t * .5, i * .5)
      }
   },
   k4 = class extends ga {
      constructor({
         kernelSize: n = kT.MEDIUM,
         resolutionScale: e = .5,
         width: t = js.AUTO_SIZE,
         height: i = js.AUTO_SIZE,
         resolutionX: s = t,
         resolutionY: r = i
      } = {}) {
         super("KawaseBlurPass"), this.renderTargetA = new ss(1, 1, {
            depthBuffer: !1
         }), this.renderTargetA.texture.name = "Blur.Target.A", this.renderTargetB = this.renderTargetA.clone(), this.renderTargetB.texture.name = "Blur.Target.B";
         const a = this.resolution = new js(this, s, r, e);
         a.addEventListener("change", l => this.setSize(a.baseWidth, a.baseHeight)), this._blurMaterial = new mee, this._blurMaterial.kernelSize = n, this.copyMaterial = new G4
      }
      getResolution() {
         return this.resolution
      }
      get blurMaterial() {
         return this._blurMaterial
      }
      set blurMaterial(n) {
         this._blurMaterial = n
      }
      get dithering() {
         return this.copyMaterial.dithering
      }
      set dithering(n) {
         this.copyMaterial.dithering = n
      }
      get kernelSize() {
         return this.blurMaterial.kernelSize
      }
      set kernelSize(n) {
         this.blurMaterial.kernelSize = n
      }
      get width() {
         return this.resolution.width
      }
      set width(n) {
         this.resolution.preferredWidth = n
      }
      get height() {
         return this.resolution.height
      }
      set height(n) {
         this.resolution.preferredHeight = n
      }
      get scale() {
         return this.blurMaterial.scale
      }
      set scale(n) {
         this.blurMaterial.scale = n
      }
      getScale() {
         return this.blurMaterial.scale
      }
      setScale(n) {
         this.blurMaterial.scale = n
      }
      getKernelSize() {
         return this.kernelSize
      }
      setKernelSize(n) {
         this.kernelSize = n
      }
      getResolutionScale() {
         return this.resolution.scale
      }
      setResolutionScale(n) {
         this.resolution.scale = n
      }
      render(n, e, t, i, s) {
         const r = this.scene,
            a = this.camera,
            l = this.renderTargetA,
            c = this.renderTargetB,
            h = this.blurMaterial,
            m = h.kernelSequence;
         let g = e;
         this.fullscreenMaterial = h;
         for (let v = 0, x = m.length; v < x; ++v) {
            const S = (v & 1) === 0 ? l : c;
            h.kernel = m[v], h.inputBuffer = g.texture, n.setRenderTarget(S), n.render(r, a), g = S
         }
         this.fullscreenMaterial = this.copyMaterial, this.copyMaterial.inputBuffer = g.texture, n.setRenderTarget(this.renderToScreen ? null : t), n.render(r, a)
      }
      setSize(n, e) {
         const t = this.resolution;
         t.setBaseSize(n, e);
         const i = t.width,
            s = t.height;
         this.renderTargetA.setSize(i, s), this.renderTargetB.setSize(i, s), this.blurMaterial.setSize(n, e)
      }
      initialize(n, e, t) {
         t !== void 0 && (this.renderTargetA.texture.type = t, this.renderTargetB.texture.type = t, t !== qs ? (this.blurMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1", this.copyMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1") : n !== null && n.outputColorSpace === En && (this.renderTargetA.texture.colorSpace = En, this.renderTargetB.texture.colorSpace = En))
      }
      static get AUTO_SIZE() {
         return js.AUTO_SIZE
      }
   },
   gee = `#include <common>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#ifdef RANGE
uniform vec2 range;
#elif defined(THRESHOLD)
uniform float threshold;uniform float smoothing;
#endif
varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);float l=luminance(texel.rgb);
#ifdef RANGE
float low=step(range.x,l);float high=step(l,range.y);l*=low*high;
#elif defined(THRESHOLD)
l=smoothstep(threshold,threshold+smoothing,l)*l;
#endif
#ifdef COLOR
gl_FragColor=vec4(texel.rgb*clamp(l,0.0,1.0),l);
#else
gl_FragColor=vec4(l);
#endif
}`,
   vee = class extends gs {
      constructor(n = !1, e = null) {
         super({
            name: "LuminanceMaterial",
            defines: {
               THREE_REVISION: Og.replace(/\D+/g, "")
            },
            uniforms: {
               inputBuffer: new nn(null),
               threshold: new nn(0),
               smoothing: new nn(1),
               range: new nn(null)
            },
            blending: nr,
            toneMapped: !1,
            depthWrite: !1,
            depthTest: !1,
            fragmentShader: gee,
            vertexShader: GT
         }), this.colorOutput = n, this.luminanceRange = e
      }
      set inputBuffer(n) {
         this.uniforms.inputBuffer.value = n
      }
      setInputBuffer(n) {
         this.uniforms.inputBuffer.value = n
      }
      get threshold() {
         return this.uniforms.threshold.value
      }
      set threshold(n) {
         this.smoothing > 0 || n > 0 ? this.defines.THRESHOLD = "1" : delete this.defines.THRESHOLD, this.uniforms.threshold.value = n
      }
      getThreshold() {
         return this.threshold
      }
      setThreshold(n) {
         this.threshold = n
      }
      get smoothing() {
         return this.uniforms.smoothing.value
      }
      set smoothing(n) {
         this.threshold > 0 || n > 0 ? this.defines.THRESHOLD = "1" : delete this.defines.THRESHOLD, this.uniforms.smoothing.value = n
      }
      getSmoothingFactor() {
         return this.smoothing
      }
      setSmoothingFactor(n) {
         this.smoothing = n
      }
      get useThreshold() {
         return this.threshold > 0 || this.smoothing > 0
      }
      set useThreshold(n) {}
      get colorOutput() {
         return this.defines.COLOR !== void 0
      }
      set colorOutput(n) {
         n ? this.defines.COLOR = "1" : delete this.defines.COLOR, this.needsUpdate = !0
      }
      isColorOutputEnabled(n) {
         return this.colorOutput
      }
      setColorOutputEnabled(n) {
         this.colorOutput = n
      }
      get useRange() {
         return this.luminanceRange !== null
      }
      set useRange(n) {
         this.luminanceRange = null
      }
      get luminanceRange() {
         return this.uniforms.range.value
      }
      set luminanceRange(n) {
         n !== null ? this.defines.RANGE = "1" : delete this.defines.RANGE, this.uniforms.range.value = n, this.needsUpdate = !0
      }
      getLuminanceRange() {
         return this.luminanceRange
      }
      setLuminanceRange(n) {
         this.luminanceRange = n
      }
   },
   yee = class extends ga {
      constructor({
         renderTarget: n,
         luminanceRange: e,
         colorOutput: t,
         resolutionScale: i = 1,
         width: s = js.AUTO_SIZE,
         height: r = js.AUTO_SIZE,
         resolutionX: a = s,
         resolutionY: l = r
      } = {}) {
         super("LuminancePass"), this.fullscreenMaterial = new vee(t, e), this.needsSwap = !1, this.renderTarget = n, this.renderTarget === void 0 && (this.renderTarget = new ss(1, 1, {
            depthBuffer: !1
         }), this.renderTarget.texture.name = "LuminancePass.Target");
         const c = this.resolution = new js(this, a, l, i);
         c.addEventListener("change", h => this.setSize(c.baseWidth, c.baseHeight))
      }
      get texture() {
         return this.renderTarget.texture
      }
      getTexture() {
         return this.renderTarget.texture
      }
      getResolution() {
         return this.resolution
      }
      render(n, e, t, i, s) {
         const r = this.fullscreenMaterial;
         r.inputBuffer = e.texture, n.setRenderTarget(this.renderToScreen ? null : this.renderTarget), n.render(this.scene, this.camera)
      }
      setSize(n, e) {
         const t = this.resolution;
         t.setBaseSize(n, e), this.renderTarget.setSize(t.width, t.height)
      }
      initialize(n, e, t) {
         t !== void 0 && t !== qs && (this.renderTarget.texture.type = t, this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1")
      }
   },
   xee = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#define WEIGHT_INNER 0.125
#define WEIGHT_OUTER 0.0555555
varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;float clampToBorder(const in vec2 uv){return float(uv.s>=0.0&&uv.s<=1.0&&uv.t>=0.0&&uv.t<=1.0);}void main(){vec4 c=vec4(0.0);vec4 w=WEIGHT_INNER*vec4(clampToBorder(vUv00),clampToBorder(vUv01),clampToBorder(vUv02),clampToBorder(vUv03));c+=w.x*texture2D(inputBuffer,vUv00);c+=w.y*texture2D(inputBuffer,vUv01);c+=w.z*texture2D(inputBuffer,vUv02);c+=w.w*texture2D(inputBuffer,vUv03);w=WEIGHT_OUTER*vec4(clampToBorder(vUv04),clampToBorder(vUv05),clampToBorder(vUv06),clampToBorder(vUv07));c+=w.x*texture2D(inputBuffer,vUv04);c+=w.y*texture2D(inputBuffer,vUv05);c+=w.z*texture2D(inputBuffer,vUv06);c+=w.w*texture2D(inputBuffer,vUv07);w=WEIGHT_OUTER*vec4(clampToBorder(vUv08),clampToBorder(vUv09),clampToBorder(vUv10),clampToBorder(vUv11));c+=w.x*texture2D(inputBuffer,vUv08);c+=w.y*texture2D(inputBuffer,vUv09);c+=w.z*texture2D(inputBuffer,vUv10);c+=w.w*texture2D(inputBuffer,vUv11);c+=WEIGHT_OUTER*texture2D(inputBuffer,vUv);gl_FragColor=c;
#include <colorspace_fragment>
}`,
   _ee = "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv00;varying vec2 vUv01;varying vec2 vUv02;varying vec2 vUv03;varying vec2 vUv04;varying vec2 vUv05;varying vec2 vUv06;varying vec2 vUv07;varying vec2 vUv08;varying vec2 vUv09;varying vec2 vUv10;varying vec2 vUv11;void main(){vUv=position.xy*0.5+0.5;vUv00=vUv+texelSize*vec2(-1.0,1.0);vUv01=vUv+texelSize*vec2(1.0,1.0);vUv02=vUv+texelSize*vec2(-1.0,-1.0);vUv03=vUv+texelSize*vec2(1.0,-1.0);vUv04=vUv+texelSize*vec2(-2.0,2.0);vUv05=vUv+texelSize*vec2(0.0,2.0);vUv06=vUv+texelSize*vec2(2.0,2.0);vUv07=vUv+texelSize*vec2(-2.0,0.0);vUv08=vUv+texelSize*vec2(2.0,0.0);vUv09=vUv+texelSize*vec2(-2.0,-2.0);vUv10=vUv+texelSize*vec2(0.0,-2.0);vUv11=vUv+texelSize*vec2(2.0,-2.0);gl_Position=vec4(position.xy,1.0,1.0);}",
   See = class extends gs {
      constructor() {
         super({
            name: "DownsamplingMaterial",
            uniforms: {
               inputBuffer: new nn(null),
               texelSize: new nn(new Fe)
            },
            blending: nr,
            toneMapped: !1,
            depthWrite: !1,
            depthTest: !1,
            fragmentShader: xee,
            vertexShader: _ee
         })
      }
      set inputBuffer(n) {
         this.uniforms.inputBuffer.value = n
      }
      setSize(n, e) {
         this.uniforms.texelSize.value.set(1 / n, 1 / e)
      }
   },
   bee = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;uniform mediump sampler2D supportBuffer;
#else
uniform lowp sampler2D inputBuffer;uniform lowp sampler2D supportBuffer;
#endif
uniform float radius;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vec4 c=vec4(0.0);c+=texture2D(inputBuffer,vUv0)*0.0625;c+=texture2D(inputBuffer,vUv1)*0.125;c+=texture2D(inputBuffer,vUv2)*0.0625;c+=texture2D(inputBuffer,vUv3)*0.125;c+=texture2D(inputBuffer,vUv)*0.25;c+=texture2D(inputBuffer,vUv4)*0.125;c+=texture2D(inputBuffer,vUv5)*0.0625;c+=texture2D(inputBuffer,vUv6)*0.125;c+=texture2D(inputBuffer,vUv7)*0.0625;vec4 baseColor=texture2D(supportBuffer,vUv);gl_FragColor=mix(baseColor,c,radius);
#include <colorspace_fragment>
}`,
   Tee = "uniform vec2 texelSize;varying vec2 vUv;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;varying vec2 vUv4;varying vec2 vUv5;varying vec2 vUv6;varying vec2 vUv7;void main(){vUv=position.xy*0.5+0.5;vUv0=vUv+texelSize*vec2(-1.0,1.0);vUv1=vUv+texelSize*vec2(0.0,1.0);vUv2=vUv+texelSize*vec2(1.0,1.0);vUv3=vUv+texelSize*vec2(-1.0,0.0);vUv4=vUv+texelSize*vec2(1.0,0.0);vUv5=vUv+texelSize*vec2(-1.0,-1.0);vUv6=vUv+texelSize*vec2(0.0,-1.0);vUv7=vUv+texelSize*vec2(1.0,-1.0);gl_Position=vec4(position.xy,1.0,1.0);}",
   Eee = class extends gs {
      constructor() {
         super({
            name: "UpsamplingMaterial",
            uniforms: {
               inputBuffer: new nn(null),
               supportBuffer: new nn(null),
               texelSize: new nn(new Fe),
               radius: new nn(.85)
            },
            blending: nr,
            toneMapped: !1,
            depthWrite: !1,
            depthTest: !1,
            fragmentShader: bee,
            vertexShader: Tee
         })
      }
      set inputBuffer(n) {
         this.uniforms.inputBuffer.value = n
      }
      set supportBuffer(n) {
         this.uniforms.supportBuffer.value = n
      }
      get radius() {
         return this.uniforms.radius.value
      }
      set radius(n) {
         this.uniforms.radius.value = n
      }
      setSize(n, e) {
         this.uniforms.texelSize.value.set(1 / n, 1 / e)
      }
   },
   Mee = class extends ga {
      constructor() {
         super("MipmapBlurPass"), this.needsSwap = !1, this.renderTarget = new ss(1, 1, {
            depthBuffer: !1
         }), this.renderTarget.texture.name = "Upsampling.Mipmap0", this.downsamplingMipmaps = [], this.upsamplingMipmaps = [], this.downsamplingMaterial = new See, this.upsamplingMaterial = new Eee, this.resolution = new Fe
      }
      get texture() {
         return this.renderTarget.texture
      }
      get levels() {
         return this.downsamplingMipmaps.length
      }
      set levels(n) {
         if (this.levels !== n) {
            const e = this.renderTarget;
            this.dispose(), this.downsamplingMipmaps = [], this.upsamplingMipmaps = [];
            for (let t = 0; t < n; ++t) {
               const i = e.clone();
               i.texture.name = "Downsampling.Mipmap" + t, this.downsamplingMipmaps.push(i)
            }
            this.upsamplingMipmaps.push(e);
            for (let t = 1, i = n - 1; t < i; ++t) {
               const s = e.clone();
               s.texture.name = "Upsampling.Mipmap" + t, this.upsamplingMipmaps.push(s)
            }
            this.setSize(this.resolution.x, this.resolution.y)
         }
      }
      get radius() {
         return this.upsamplingMaterial.radius
      }
      set radius(n) {
         this.upsamplingMaterial.radius = n
      }
      render(n, e, t, i, s) {
         const {
            scene: r,
            camera: a
         } = this, {
            downsamplingMaterial: l,
            upsamplingMaterial: c
         } = this, {
            downsamplingMipmaps: h,
            upsamplingMipmaps: m
         } = this;
         let g = e;
         this.fullscreenMaterial = l;
         for (let v = 0, x = h.length; v < x; ++v) {
            const S = h[v];
            l.setSize(g.width, g.height), l.inputBuffer = g.texture, n.setRenderTarget(S), n.render(r, a), g = S
         }
         this.fullscreenMaterial = c;
         for (let v = m.length - 1; v >= 0; --v) {
            const x = m[v];
            c.setSize(g.width, g.height), c.inputBuffer = g.texture, c.supportBuffer = h[v].texture, n.setRenderTarget(x), n.render(r, a), g = x
         }
      }
      setSize(n, e) {
         const t = this.resolution;
         t.set(n, e);
         let i = t.width,
            s = t.height;
         for (let r = 0, a = this.downsamplingMipmaps.length; r < a; ++r) i = Math.round(i * .5), s = Math.round(s * .5), this.downsamplingMipmaps[r].setSize(i, s), r < this.upsamplingMipmaps.length && this.upsamplingMipmaps[r].setSize(i, s)
      }
      initialize(n, e, t) {
         if (t !== void 0) {
            const i = this.downsamplingMipmaps.concat(this.upsamplingMipmaps);
            for (const s of i) s.texture.type = t;
            if (t !== qs) this.downsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1", this.upsamplingMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1";
            else if (n !== null && n.outputColorSpace === En)
               for (const s of i) s.texture.colorSpace = En
         }
      }
      dispose() {
         super.dispose();
         for (const n of this.downsamplingMipmaps.concat(this.upsamplingMipmaps)) n.dispose()
      }
   },
   Aee = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D map;
#else
uniform lowp sampler2D map;
#endif
uniform float intensity;void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){vec4 texel=texture2D(map,uv);outputColor=vec4(texel.rgb*intensity,max(inputColor.a,texel.a));}`,
   wee = class extends F1 {
      constructor({
         blendFunction: n = Un.SCREEN,
         luminanceThreshold: e = 1,
         luminanceSmoothing: t = .03,
         mipmapBlur: i = !0,
         intensity: s = 1,
         radius: r = .85,
         levels: a = 8,
         kernelSize: l = kT.LARGE,
         resolutionScale: c = .5,
         width: h = js.AUTO_SIZE,
         height: m = js.AUTO_SIZE,
         resolutionX: g = h,
         resolutionY: v = m
      } = {}) {
         super("BloomEffect", Aee, {
            blendFunction: n,
            uniforms: new Map([
               ["map", new nn(null)],
               ["intensity", new nn(s)]
            ])
         }), this.renderTarget = new ss(1, 1, {
            depthBuffer: !1
         }), this.renderTarget.texture.name = "Bloom.Target", this.blurPass = new k4({
            kernelSize: l
         }), this.luminancePass = new yee({
            colorOutput: !0
         }), this.luminanceMaterial.threshold = e, this.luminanceMaterial.smoothing = t, this.mipmapBlurPass = new Mee, this.mipmapBlurPass.enabled = i, this.mipmapBlurPass.radius = r, this.mipmapBlurPass.levels = a, this.uniforms.get("map").value = i ? this.mipmapBlurPass.texture : this.renderTarget.texture;
         const x = this.resolution = new js(this, g, v, c);
         x.addEventListener("change", S => this.setSize(x.baseWidth, x.baseHeight))
      }
      get texture() {
         return this.mipmapBlurPass.enabled ? this.mipmapBlurPass.texture : this.renderTarget.texture
      }
      getTexture() {
         return this.texture
      }
      getResolution() {
         return this.resolution
      }
      getBlurPass() {
         return this.blurPass
      }
      getLuminancePass() {
         return this.luminancePass
      }
      get luminanceMaterial() {
         return this.luminancePass.fullscreenMaterial
      }
      getLuminanceMaterial() {
         return this.luminancePass.fullscreenMaterial
      }
      get width() {
         return this.resolution.width
      }
      set width(n) {
         this.resolution.preferredWidth = n
      }
      get height() {
         return this.resolution.height
      }
      set height(n) {
         this.resolution.preferredHeight = n
      }
      get dithering() {
         return this.blurPass.dithering
      }
      set dithering(n) {
         this.blurPass.dithering = n
      }
      get kernelSize() {
         return this.blurPass.kernelSize
      }
      set kernelSize(n) {
         this.blurPass.kernelSize = n
      }
      get distinction() {
         return console.warn(this.name, "distinction was removed"), 1
      }
      set distinction(n) {
         console.warn(this.name, "distinction was removed")
      }
      get intensity() {
         return this.uniforms.get("intensity").value
      }
      set intensity(n) {
         this.uniforms.get("intensity").value = n
      }
      getIntensity() {
         return this.intensity
      }
      setIntensity(n) {
         this.intensity = n
      }
      getResolutionScale() {
         return this.resolution.scale
      }
      setResolutionScale(n) {
         this.resolution.scale = n
      }
      update(n, e, t) {
         const i = this.renderTarget,
            s = this.luminancePass;
         s.enabled ? (s.render(n, e), this.mipmapBlurPass.enabled ? this.mipmapBlurPass.render(n, s.renderTarget) : this.blurPass.render(n, s.renderTarget, i)) : this.mipmapBlurPass.enabled ? this.mipmapBlurPass.render(n, e) : this.blurPass.render(n, e, i)
      }
      setSize(n, e) {
         const t = this.resolution;
         t.setBaseSize(n, e), this.renderTarget.setSize(t.width, t.height), this.blurPass.resolution.copy(t), this.luminancePass.setSize(n, e), this.mipmapBlurPass.setSize(n, e)
      }
      initialize(n, e, t) {
         this.blurPass.initialize(n, e, t), this.luminancePass.initialize(n, e, t), this.mipmapBlurPass.initialize(n, e, t), t !== void 0 && (this.renderTarget.texture.type = t, n !== null && n.outputColorSpace === En && (this.renderTarget.texture.colorSpace = En))
      }
   },
   rU = class extends ga {
      constructor(n, e = "inputBuffer") {
         super("ShaderPass"), this.fullscreenMaterial = n, this.input = e
      }
      setInput(n) {
         this.input = n
      }
      render(n, e, t, i, s) {
         const r = this.fullscreenMaterial.uniforms;
         e !== null && r !== void 0 && r[this.input] !== void 0 && (r[this.input].value = e.texture), n.setRenderTarget(this.renderToScreen ? null : t), n.render(this.scene, this.camera)
      }
      initialize(n, e, t) {
         t !== void 0 && t !== qs && (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1")
      }
   },
   TA = {
      KEEP_MAX_DEPTH: 1,
      DISCARD_MAX_DEPTH: 2
   },
   Ree = `#include <common>
#include <packing>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer0;uniform highp sampler2D depthBuffer1;
#else
uniform mediump sampler2D depthBuffer0;uniform mediump sampler2D depthBuffer1;
#endif
uniform sampler2D inputBuffer;uniform vec2 cameraNearFar;float getViewZ(const in float depth){
#ifdef PERSPECTIVE_CAMERA
return perspectiveDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);
#else
return orthographicDepthToViewZ(depth,cameraNearFar.x,cameraNearFar.y);
#endif
}varying vec2 vUv;void main(){vec2 depth;
#if DEPTH_PACKING_0 == 3201
depth.x=unpackRGBAToDepth(texture2D(depthBuffer0,vUv));
#else
depth.x=texture2D(depthBuffer0,vUv).r;
#ifdef LOG_DEPTH
float d=pow(2.0,depth.x*log2(cameraNearFar.y+1.0))-1.0;float a=cameraNearFar.y/(cameraNearFar.y-cameraNearFar.x);float b=cameraNearFar.y*cameraNearFar.x/(cameraNearFar.x-cameraNearFar.y);depth.x=a+b/d;
#endif
#endif
#if DEPTH_PACKING_1 == 3201
depth.y=unpackRGBAToDepth(texture2D(depthBuffer1,vUv));
#else
depth.y=texture2D(depthBuffer1,vUv).r;
#ifdef LOG_DEPTH
float d=pow(2.0,depth.y*log2(cameraNearFar.y+1.0))-1.0;float a=cameraNearFar.y/(cameraNearFar.y-cameraNearFar.x);float b=cameraNearFar.y*cameraNearFar.x/(cameraNearFar.x-cameraNearFar.y);depth.y=a+b/d;
#endif
#endif
bool isMaxDepth=(depth.x==1.0);
#ifdef PERSPECTIVE_CAMERA
depth.x=viewZToOrthographicDepth(getViewZ(depth.x),cameraNearFar.x,cameraNearFar.y);depth.y=viewZToOrthographicDepth(getViewZ(depth.y),cameraNearFar.x,cameraNearFar.y);
#endif
#if DEPTH_TEST_STRATEGY == 0
bool keep=depthTest(depth.x,depth.y);
#elif DEPTH_TEST_STRATEGY == 1
bool keep=isMaxDepth||depthTest(depth.x,depth.y);
#else
bool keep=!isMaxDepth&&depthTest(depth.x,depth.y);
#endif
if(keep){gl_FragColor=texture2D(inputBuffer,vUv);}else{discard;}}`,
   Cee = class extends gs {
      constructor() {
         super({
            name: "DepthMaskMaterial",
            defines: {
               DEPTH_EPSILON: "0.0001",
               DEPTH_PACKING_0: "0",
               DEPTH_PACKING_1: "0",
               DEPTH_TEST_STRATEGY: TA.KEEP_MAX_DEPTH
            },
            uniforms: {
               inputBuffer: new nn(null),
               depthBuffer0: new nn(null),
               depthBuffer1: new nn(null),
               cameraNearFar: new nn(new Fe(1, 1))
            },
            blending: nr,
            toneMapped: !1,
            depthWrite: !1,
            depthTest: !1,
            fragmentShader: Ree,
            vertexShader: GT
         }), this.depthMode = ug
      }
      set depthBuffer0(n) {
         this.uniforms.depthBuffer0.value = n
      }
      set depthPacking0(n) {
         this.defines.DEPTH_PACKING_0 = n.toFixed(0), this.needsUpdate = !0
      }
      setDepthBuffer0(n, e = Hl) {
         this.depthBuffer0 = n, this.depthPacking0 = e
      }
      set depthBuffer1(n) {
         this.uniforms.depthBuffer1.value = n
      }
      set depthPacking1(n) {
         this.defines.DEPTH_PACKING_1 = n.toFixed(0), this.needsUpdate = !0
      }
      setDepthBuffer1(n, e = Hl) {
         this.depthBuffer1 = n, this.depthPacking1 = e
      }
      get maxDepthStrategy() {
         return Number(this.defines.DEPTH_TEST_STRATEGY)
      }
      set maxDepthStrategy(n) {
         this.defines.DEPTH_TEST_STRATEGY = n.toFixed(0), this.needsUpdate = !0
      }
      get keepFar() {
         return this.maxDepthStrategy
      }
      set keepFar(n) {
         this.maxDepthStrategy = n ? TA.KEEP_MAX_DEPTH : TA.DISCARD_MAX_DEPTH
      }
      getMaxDepthStrategy() {
         return this.maxDepthStrategy
      }
      setMaxDepthStrategy(n) {
         this.maxDepthStrategy = n
      }
      get epsilon() {
         return Number(this.defines.DEPTH_EPSILON)
      }
      set epsilon(n) {
         this.defines.DEPTH_EPSILON = n.toFixed(16), this.needsUpdate = !0
      }
      getEpsilon() {
         return this.epsilon
      }
      setEpsilon(n) {
         this.epsilon = n
      }
      get depthMode() {
         return Number(this.defines.DEPTH_MODE)
      }
      set depthMode(n) {
         let e;
         switch (n) {
            case vy:
               e = "false";
               break;
            case yy:
               e = "true";
               break;
            case xy:
               e = "abs(d1 - d0) <= DEPTH_EPSILON";
               break;
            case by:
               e = "abs(d1 - d0) > DEPTH_EPSILON";
               break;
            case ug:
               e = "d0 > d1";
               break;
            case ih:
               e = "d0 >= d1";
               break;
            case _y:
               e = "d0 <= d1";
               break;
            case Sy:
            default:
               e = "d0 < d1";
               break
         }
         this.defines.DEPTH_MODE = n.toFixed(0), this.defines["depthTest(d0, d1)"] = e, this.needsUpdate = !0
      }
      getDepthMode() {
         return this.depthMode
      }
      setDepthMode(n) {
         this.depthMode = n
      }
      adoptCameraSettings(n) {
         this.copyCameraSettings(n)
      }
      copyCameraSettings(n) {
         n && (this.uniforms.cameraNearFar.value.set(n.near, n.far), n instanceof Cs ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA, this.needsUpdate = !0)
      }
   },
   Dee = `#include <common>
#include <dithering_pars_fragment>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform vec2 lightPosition;uniform float exposure;uniform float decay;uniform float density;uniform float weight;uniform float clampMax;varying vec2 vUv;void main(){vec2 coord=vUv;vec2 delta=lightPosition-coord;delta*=1.0/SAMPLES_FLOAT*density;float illuminationDecay=1.0;vec4 color=vec4(0.0);for(int i=0;i<SAMPLES_INT;++i){coord+=delta;vec4 texel=texture2D(inputBuffer,coord);texel*=illuminationDecay*weight;color+=texel;illuminationDecay*=decay;}gl_FragColor=clamp(color*exposure,0.0,clampMax);
#include <dithering_fragment>
}`,
   Nee = class extends gs {
      constructor(n) {
         super({
            name: "GodRaysMaterial",
            defines: {
               SAMPLES_INT: "60",
               SAMPLES_FLOAT: "60.0"
            },
            uniforms: {
               inputBuffer: new nn(null),
               lightPosition: new nn(n),
               density: new nn(1),
               decay: new nn(1),
               weight: new nn(1),
               exposure: new nn(1),
               clampMax: new nn(1)
            },
            blending: nr,
            toneMapped: !1,
            depthWrite: !1,
            depthTest: !1,
            fragmentShader: Dee,
            vertexShader: GT
         })
      }
      set inputBuffer(n) {
         this.uniforms.inputBuffer.value = n
      }
      setInputBuffer(n) {
         this.uniforms.inputBuffer.value = n
      }
      get lightPosition() {
         return this.uniforms.lightPosition.value
      }
      getLightPosition() {
         return this.uniforms.lightPosition.value
      }
      setLightPosition(n) {
         this.uniforms.lightPosition.value = n
      }
      get density() {
         return this.uniforms.density.value
      }
      set density(n) {
         this.uniforms.density.value = n
      }
      getDensity() {
         return this.uniforms.density.value
      }
      setDensity(n) {
         this.uniforms.density.value = n
      }
      get decay() {
         return this.uniforms.decay.value
      }
      set decay(n) {
         this.uniforms.decay.value = n
      }
      getDecay() {
         return this.uniforms.decay.value
      }
      setDecay(n) {
         this.uniforms.decay.value = n
      }
      get weight() {
         return this.uniforms.weight.value
      }
      set weight(n) {
         this.uniforms.weight.value = n
      }
      getWeight() {
         return this.uniforms.weight.value
      }
      setWeight(n) {
         this.uniforms.weight.value = n
      }
      get exposure() {
         return this.uniforms.exposure.value
      }
      set exposure(n) {
         this.uniforms.exposure.value = n
      }
      getExposure() {
         return this.uniforms.exposure.value
      }
      setExposure(n) {
         this.uniforms.exposure.value = n
      }
      get maxIntensity() {
         return this.uniforms.clampMax.value
      }
      set maxIntensity(n) {
         this.uniforms.clampMax.value = n
      }
      getMaxIntensity() {
         return this.uniforms.clampMax.value
      }
      setMaxIntensity(n) {
         this.uniforms.clampMax.value = n
      }
      get samples() {
         return Number(this.defines.SAMPLES_INT)
      }
      set samples(n) {
         const e = Math.floor(n);
         this.defines.SAMPLES_INT = e.toFixed(0), this.defines.SAMPLES_FLOAT = e.toFixed(1), this.needsUpdate = !0
      }
      getSamples() {
         return this.samples
      }
      setSamples(n) {
         this.samples = n
      }
   },
   fC = class extends ga {
      constructor(n, e, t = null) {
         super("RenderPass", n, e), this.needsSwap = !1, this.clearPass = new cC, this.overrideMaterialManager = t === null ? null : new sU(t), this.ignoreBackground = !1, this.skipShadowMapUpdate = !1, this.selection = null
      }
      set mainScene(n) {
         this.scene = n
      }
      set mainCamera(n) {
         this.camera = n
      }
      get renderToScreen() {
         return super.renderToScreen
      }
      set renderToScreen(n) {
         super.renderToScreen = n, this.clearPass.renderToScreen = n
      }
      get overrideMaterial() {
         const n = this.overrideMaterialManager;
         return n !== null ? n.material : null
      }
      set overrideMaterial(n) {
         const e = this.overrideMaterialManager;
         n !== null ? e !== null ? e.setMaterial(n) : this.overrideMaterialManager = new sU(n) : e !== null && (e.dispose(), this.overrideMaterialManager = null)
      }
      getOverrideMaterial() {
         return this.overrideMaterial
      }
      setOverrideMaterial(n) {
         this.overrideMaterial = n
      }
      get clear() {
         return this.clearPass.enabled
      }
      set clear(n) {
         this.clearPass.enabled = n
      }
      getSelection() {
         return this.selection
      }
      setSelection(n) {
         this.selection = n
      }
      isBackgroundDisabled() {
         return this.ignoreBackground
      }
      setBackgroundDisabled(n) {
         this.ignoreBackground = n
      }
      isShadowMapDisabled() {
         return this.skipShadowMapUpdate
      }
      setShadowMapDisabled(n) {
         this.skipShadowMapUpdate = n
      }
      getClearPass() {
         return this.clearPass
      }
      render(n, e, t, i, s) {
         const r = this.scene,
            a = this.camera,
            l = this.selection,
            c = a.layers.mask,
            h = r.background,
            m = n.shadowMap.autoUpdate,
            g = this.renderToScreen ? null : e;
         l !== null && a.layers.set(l.getLayer()), this.skipShadowMapUpdate && (n.shadowMap.autoUpdate = !1), (this.ignoreBackground || this.clearPass.overrideClearColor !== null) && (r.background = null), this.clearPass.enabled && this.clearPass.render(n, e), n.setRenderTarget(g), this.overrideMaterialManager !== null ? this.overrideMaterialManager.render(n, r, a) : n.render(r, a), a.layers.mask = c, r.background = h, n.shadowMap.autoUpdate = m
      }
   },
   Oee = `#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D map;
#else
uniform lowp sampler2D map;
#endif
void mainImage(const in vec4 inputColor,const in vec2 uv,out vec4 outputColor){outputColor=texture2D(map,uv);}`,
   EA = new ee,
   aU = new Zt,
   Uee = class extends F1 {
      constructor(n, e, {
         blendFunction: t = Un.SCREEN,
         samples: i = 60,
         density: s = .96,
         decay: r = .9,
         weight: a = .4,
         exposure: l = .6,
         clampMax: c = 1,
         blur: h = !0,
         kernelSize: m = kT.SMALL,
         resolutionScale: g = .5,
         width: v = js.AUTO_SIZE,
         height: x = js.AUTO_SIZE,
         resolutionX: S = v,
         resolutionY: E = x
      } = {}) {
         super("GodRaysEffect", Oee, {
            blendFunction: t,
            attributes: th.DEPTH,
            uniforms: new Map([
               ["map", new nn(null)]
            ])
         }), this.camera = n, this._lightSource = e, this.lightSource = e, this.lightScene = new mg, this.screenPosition = new Fe, this.renderTargetA = new ss(1, 1, {
            depthBuffer: !1
         }), this.renderTargetA.texture.name = "GodRays.Target.A", this.renderTargetB = this.renderTargetA.clone(), this.renderTargetB.texture.name = "GodRays.Target.B", this.uniforms.get("map").value = this.renderTargetB.texture, this.renderTargetLight = new ss(1, 1), this.renderTargetLight.texture.name = "GodRays.Light", this.renderTargetLight.depthTexture = new vx, this.renderPassLight = new fC(this.lightScene, n), this.renderPassLight.clearPass.overrideClearColor = new dt(0), this.clearPass = new cC(!0, !1, !1), this.clearPass.overrideClearColor = new dt(0), this.blurPass = new k4({
            kernelSize: m
         }), this.blurPass.enabled = h, this.depthMaskPass = new rU(new Cee);
         const T = this.depthMaskMaterial;
         T.depthBuffer1 = this.renderTargetLight.depthTexture, T.copyCameraSettings(n), this.godRaysPass = new rU(new Nee(this.screenPosition));
         const b = this.godRaysMaterial;
         b.density = s, b.decay = r, b.weight = a, b.exposure = l, b.maxIntensity = c, b.samples = i;
         const w = this.resolution = new js(this, S, E, g);
         w.addEventListener("change", C => this.setSize(w.baseWidth, w.baseHeight))
      }
      set mainCamera(n) {
         this.camera = n, this.renderPassLight.mainCamera = n, this.depthMaskMaterial.copyCameraSettings(n)
      }
      get lightSource() {
         return this._lightSource
      }
      set lightSource(n) {
         this._lightSource = n, n !== null && (n.material.depthWrite = !1, n.material.transparent = !0)
      }
      getBlurPass() {
         return this.blurPass
      }
      get texture() {
         return this.renderTargetB.texture
      }
      getTexture() {
         return this.texture
      }
      get depthMaskMaterial() {
         return this.depthMaskPass.fullscreenMaterial
      }
      get godRaysMaterial() {
         return this.godRaysPass.fullscreenMaterial
      }
      getGodRaysMaterial() {
         return this.godRaysMaterial
      }
      getResolution() {
         return this.resolution
      }
      get width() {
         return this.resolution.width
      }
      set width(n) {
         this.resolution.preferredWidth = n
      }
      get height() {
         return this.resolution.height
      }
      set height(n) {
         this.resolution.preferredHeight = n
      }
      get dithering() {
         return this.godRaysMaterial.dithering
      }
      set dithering(n) {
         const e = this.godRaysMaterial;
         e.dithering = n, e.needsUpdate = !0
      }
      get blur() {
         return this.blurPass.enabled
      }
      set blur(n) {
         this.blurPass.enabled = n
      }
      get kernelSize() {
         return this.blurPass.kernelSize
      }
      set kernelSize(n) {
         this.blurPass.kernelSize = n
      }
      getResolutionScale() {
         return this.resolution.scale
      }
      setResolutionScale(n) {
         this.resolution.scale = n
      }
      get samples() {
         return this.godRaysMaterial.samples
      }
      set samples(n) {
         this.godRaysMaterial.samples = n
      }
      setDepthTexture(n, e = Hl) {
         this.depthMaskPass.fullscreenMaterial.depthBuffer0 = n, this.depthMaskPass.fullscreenMaterial.depthPacking0 = e
      }
      update(n, e, t) {
         const i = this.lightSource,
            s = i.parent,
            r = i.matrixAutoUpdate,
            a = this.renderTargetA,
            l = this.renderTargetLight;
         i.material.depthWrite = !0, i.matrixAutoUpdate = !1, i.updateWorldMatrix(!0, !1), s !== null && (r || aU.copy(i.matrix), i.matrix.copy(i.matrixWorld)), this.lightScene.add(i), this.renderPassLight.render(n, l), this.clearPass.render(n, a), this.depthMaskPass.render(n, l, a), i.material.depthWrite = !1, i.matrixAutoUpdate = r, s !== null && (r || i.matrix.copy(aU), s.add(i)), EA.setFromMatrixPosition(i.matrixWorld).project(this.camera), this.screenPosition.set(Math.min(Math.max((EA.x + 1) * .5, -1), 2), Math.min(Math.max((EA.y + 1) * .5, -1), 2)), this.blurPass.enabled && this.blurPass.render(n, a, a), this.godRaysPass.render(n, a, this.renderTargetB)
      }
      setSize(n, e) {
         const t = this.resolution;
         t.setBaseSize(n, e);
         const i = t.width,
            s = t.height;
         this.renderTargetA.setSize(i, s), this.renderTargetB.setSize(i, s), this.renderTargetLight.setSize(i, s), this.blurPass.resolution.copy(t)
      }
      initialize(n, e, t) {
         this.blurPass.initialize(n, e, t), this.renderPassLight.initialize(n, e, t), this.depthMaskPass.initialize(n, e, t), this.godRaysPass.initialize(n, e, t), t !== void 0 && (this.renderTargetA.texture.type = t, this.renderTargetB.texture.type = t, this.renderTargetLight.texture.type = t, n !== null && n.outputColorSpace === En && (this.renderTargetA.texture.colorSpace = En, this.renderTargetB.texture.colorSpace = En, this.renderTargetLight.texture.colorSpace = En))
      }
   },
   Pee = `#include <packing>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
#ifdef DOWNSAMPLE_NORMALS
uniform lowp sampler2D normalBuffer;
#endif
varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}int findBestDepth(const in float samples[4]){float c=(samples[0]+samples[1]+samples[2]+samples[3])*0.25;float distances[4];distances[0]=abs(c-samples[0]);distances[1]=abs(c-samples[1]);distances[2]=abs(c-samples[2]);distances[3]=abs(c-samples[3]);float maxDistance=max(max(distances[0],distances[1]),max(distances[2],distances[3]));int remaining[3];int rejected[3];int i,j,k;for(i=0,j=0,k=0;i<4;++i){if(distances[i]<maxDistance){remaining[j++]=i;}else{rejected[k++]=i;}}for(;j<3;++j){remaining[j]=rejected[--k];}vec3 s=vec3(samples[remaining[0]],samples[remaining[1]],samples[remaining[2]]);c=(s.x+s.y+s.z)/3.0;distances[0]=abs(c-s.x);distances[1]=abs(c-s.y);distances[2]=abs(c-s.z);float minDistance=min(distances[0],min(distances[1],distances[2]));for(i=0;i<3;++i){if(distances[i]==minDistance){break;}}return remaining[i];}void main(){float d[4];d[0]=readDepth(vUv0);d[1]=readDepth(vUv1);d[2]=readDepth(vUv2);d[3]=readDepth(vUv3);int index=findBestDepth(d);
#ifdef DOWNSAMPLE_NORMALS
vec3 n[4];n[0]=texture2D(normalBuffer,vUv0).rgb;n[1]=texture2D(normalBuffer,vUv1).rgb;n[2]=texture2D(normalBuffer,vUv2).rgb;n[3]=texture2D(normalBuffer,vUv3).rgb;
#else
vec3 n[4];n[0]=vec3(0.0);n[1]=vec3(0.0);n[2]=vec3(0.0);n[3]=vec3(0.0);
#endif
gl_FragColor=vec4(n[index],d[index]);}`,
   Lee = "uniform vec2 texelSize;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vUv0=uv;vUv1=vec2(uv.x,uv.y+texelSize.y);vUv2=vec2(uv.x+texelSize.x,uv.y);vUv3=uv+texelSize;gl_Position=vec4(position.xy,1.0,1.0);}",
   Bee = class extends gs {
      constructor() {
         super({
            name: "DepthDownsamplingMaterial",
            defines: {
               DEPTH_PACKING: "0"
            },
            uniforms: {
               depthBuffer: new nn(null),
               normalBuffer: new nn(null),
               texelSize: new nn(new Fe)
            },
            blending: nr,
            toneMapped: !1,
            depthWrite: !1,
            depthTest: !1,
            fragmentShader: Pee,
            vertexShader: Lee
         })
      }
      set depthBuffer(n) {
         this.uniforms.depthBuffer.value = n
      }
      set depthPacking(n) {
         this.defines.DEPTH_PACKING = n.toFixed(0), this.needsUpdate = !0
      }
      setDepthBuffer(n, e = Hl) {
         this.depthBuffer = n, this.depthPacking = e
      }
      set normalBuffer(n) {
         this.uniforms.normalBuffer.value = n, n !== null ? this.defines.DOWNSAMPLE_NORMALS = "1" : delete this.defines.DOWNSAMPLE_NORMALS, this.needsUpdate = !0
      }
      setNormalBuffer(n) {
         this.normalBuffer = n
      }
      setTexelSize(n, e) {
         this.uniforms.texelSize.value.set(n, e)
      }
      setSize(n, e) {
         this.uniforms.texelSize.value.set(1 / n, 1 / e)
      }
   },
   zee = class extends ga {
      constructor({
         normalBuffer: n = null,
         resolutionScale: e = .5,
         width: t = js.AUTO_SIZE,
         height: i = js.AUTO_SIZE,
         resolutionX: s = t,
         resolutionY: r = i
      } = {}) {
         super("DepthDownsamplingPass");
         const a = new Bee;
         a.normalBuffer = n, this.fullscreenMaterial = a, this.needsDepthTexture = !0, this.needsSwap = !1, this.renderTarget = new ss(1, 1, {
            minFilter: ms,
            magFilter: ms,
            depthBuffer: !1,
            type: ha
         }), this.renderTarget.texture.name = "DepthDownsamplingPass.Target", this.renderTarget.texture.generateMipmaps = !1;
         const l = this.resolution = new js(this, s, r, e);
         l.addEventListener("change", c => this.setSize(l.baseWidth, l.baseHeight))
      }
      get texture() {
         return this.renderTarget.texture
      }
      getTexture() {
         return this.renderTarget.texture
      }
      getResolution() {
         return this.resolution
      }
      setDepthTexture(n, e = Hl) {
         this.fullscreenMaterial.depthBuffer = n, this.fullscreenMaterial.depthPacking = e
      }
      render(n, e, t, i, s) {
         n.setRenderTarget(this.renderToScreen ? null : this.renderTarget), n.render(this.scene, this.camera)
      }
      setSize(n, e) {
         const t = this.resolution;
         t.setBaseSize(n, e), this.renderTarget.setSize(t.width, t.height), this.fullscreenMaterial.setSize(n, e)
      }
      initialize(n, e, t) {
         const i = n.getContext();
         if (!(i.getExtension("EXT_color_buffer_float") || i.getExtension("EXT_color_buffer_half_float"))) throw new Error("Rendering to float texture is not supported.")
      }
   },
   Iee = `#include <common>
#include <packing>
#include <dithering_pars_fragment>
#define packFloatToRGBA(v) packDepthToRGBA(v)
#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#if DEPTH_PACKING == 3201
uniform lowp sampler2D depthBuffer;
#elif defined(GL_FRAGMENT_PRECISION_HIGH)
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;vec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}float getViewZ(const in float depth){
#ifdef PERSPECTIVE_CAMERA
return perspectiveDepthToViewZ(depth,cameraNear,cameraFar);
#else
return orthographicDepthToViewZ(depth,cameraNear,cameraFar);
#endif
}vec3 RGBToHCV(const in vec3 RGB){vec4 P=mix(vec4(RGB.bg,-1.0,2.0/3.0),vec4(RGB.gb,0.0,-1.0/3.0),step(RGB.b,RGB.g));vec4 Q=mix(vec4(P.xyw,RGB.r),vec4(RGB.r,P.yzx),step(P.x,RGB.r));float C=Q.x-min(Q.w,Q.y);float H=abs((Q.w-Q.y)/(6.0*C+EPSILON)+Q.z);return vec3(H,C,Q.x);}vec3 RGBToHSL(const in vec3 RGB){vec3 HCV=RGBToHCV(RGB);float L=HCV.z-HCV.y*0.5;float S=HCV.y/(1.0-abs(L*2.0-1.0)+EPSILON);return vec3(HCV.x,S,L);}vec3 HueToRGB(const in float H){float R=abs(H*6.0-3.0)-1.0;float G=2.0-abs(H*6.0-2.0);float B=2.0-abs(H*6.0-4.0);return clamp(vec3(R,G,B),0.0,1.0);}vec3 HSLToRGB(const in vec3 HSL){vec3 RGB=HueToRGB(HSL.x);float C=(1.0-abs(2.0*HSL.z-1.0))*HSL.y;return(RGB-0.5)*C+HSL.z;}FRAGMENT_HEAD void main(){FRAGMENT_MAIN_UV vec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGE color0.a=clamp(color0.a,0.0,1.0);gl_FragColor=color0;
#ifdef ENCODE_OUTPUT
#include <colorspace_fragment>
#endif
#include <dithering_fragment>
}`,
   Fee = "uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEAD void main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORT gl_Position=vec4(position.xy,1.0,1.0);}",
   Hee = class extends gs {
      constructor(n, e, t, i, s = !1) {
         super({
            name: "EffectMaterial",
            defines: {
               THREE_REVISION: Og.replace(/\D+/g, ""),
               DEPTH_PACKING: "0",
               ENCODE_OUTPUT: "1"
            },
            uniforms: {
               inputBuffer: new nn(null),
               depthBuffer: new nn(null),
               resolution: new nn(new Fe),
               texelSize: new nn(new Fe),
               cameraNear: new nn(.3),
               cameraFar: new nn(1e3),
               aspect: new nn(1),
               time: new nn(0)
            },
            blending: nr,
            toneMapped: !1,
            depthWrite: !1,
            depthTest: !1,
            dithering: s
         }), n && this.setShaderParts(n), e && this.setDefines(e), t && this.setUniforms(t), this.copyCameraSettings(i)
      }
      set inputBuffer(n) {
         this.uniforms.inputBuffer.value = n
      }
      setInputBuffer(n) {
         this.uniforms.inputBuffer.value = n
      }
      get depthBuffer() {
         return this.uniforms.depthBuffer.value
      }
      set depthBuffer(n) {
         this.uniforms.depthBuffer.value = n
      }
      get depthPacking() {
         return Number(this.defines.DEPTH_PACKING)
      }
      set depthPacking(n) {
         this.defines.DEPTH_PACKING = n.toFixed(0), this.needsUpdate = !0
      }
      setDepthBuffer(n, e = Hl) {
         this.depthBuffer = n, this.depthPacking = e
      }
      setShaderData(n) {
         this.setShaderParts(n.shaderParts), this.setDefines(n.defines), this.setUniforms(n.uniforms), this.setExtensions(n.extensions)
      }
      setShaderParts(n) {
         return this.fragmentShader = Iee.replace($n.FRAGMENT_HEAD, n.get($n.FRAGMENT_HEAD) || "").replace($n.FRAGMENT_MAIN_UV, n.get($n.FRAGMENT_MAIN_UV) || "").replace($n.FRAGMENT_MAIN_IMAGE, n.get($n.FRAGMENT_MAIN_IMAGE) || ""), this.vertexShader = Fee.replace($n.VERTEX_HEAD, n.get($n.VERTEX_HEAD) || "").replace($n.VERTEX_MAIN_SUPPORT, n.get($n.VERTEX_MAIN_SUPPORT) || ""), this.needsUpdate = !0, this
      }
      setDefines(n) {
         for (const e of n.entries()) this.defines[e[0]] = e[1];
         return this.needsUpdate = !0, this
      }
      setUniforms(n) {
         for (const e of n.entries()) this.uniforms[e[0]] = e[1];
         return this
      }
      setExtensions(n) {
         this.extensions = {};
         for (const e of n) this.extensions[e] = !0;
         return this
      }
      get encodeOutput() {
         return this.defines.ENCODE_OUTPUT !== void 0
      }
      set encodeOutput(n) {
         this.encodeOutput !== n && (n ? this.defines.ENCODE_OUTPUT = "1" : delete this.defines.ENCODE_OUTPUT, this.needsUpdate = !0)
      }
      isOutputEncodingEnabled(n) {
         return this.encodeOutput
      }
      setOutputEncodingEnabled(n) {
         this.encodeOutput = n
      }
      get time() {
         return this.uniforms.time.value
      }
      set time(n) {
         this.uniforms.time.value = n
      }
      setDeltaTime(n) {
         this.uniforms.time.value += n
      }
      adoptCameraSettings(n) {
         this.copyCameraSettings(n)
      }
      copyCameraSettings(n) {
         n && (this.uniforms.cameraNear.value = n.near, this.uniforms.cameraFar.value = n.far, n instanceof Cs ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA, this.needsUpdate = !0)
      }
      setSize(n, e) {
         const t = this.uniforms;
         t.resolution.value.set(n, e), t.texelSize.value.set(1 / n, 1 / e), t.aspect.value = n / e
      }
      static get Section() {
         return $n
      }
   };

function oU(n, e, t) {
   for (const i of e) {
      const s = "$1" + n + i.charAt(0).toUpperCase() + i.slice(1),
         r = new RegExp("([^\\.])(\\b" + i + "\\b)", "g");
      for (const a of t.entries()) a[1] !== null && t.set(a[0], a[1].replace(r, s))
   }
}

function Vee(n, e, t) {
   let i = e.getFragmentShader(),
      s = e.getVertexShader();
   const r = i !== void 0 && /mainImage/.test(i),
      a = i !== void 0 && /mainUv/.test(i);
   if (t.attributes |= e.getAttributes(), i === void 0) throw new Error(`Missing fragment shader (${e.name})`);
   if (a && (t.attributes & th.CONVOLUTION) !== 0) throw new Error(`Effects that transform UVs are incompatible with convolution effects (${e.name})`);
   if (!r && !a) throw new Error(`Could not find mainImage or mainUv function (${e.name})`); {
      const l = /\w+\s+(\w+)\([\w\s,]*\)\s*{/g,
         c = t.shaderParts;
      let h = c.get($n.FRAGMENT_HEAD) || "",
         m = c.get($n.FRAGMENT_MAIN_UV) || "",
         g = c.get($n.FRAGMENT_MAIN_IMAGE) || "",
         v = c.get($n.VERTEX_HEAD) || "",
         x = c.get($n.VERTEX_MAIN_SUPPORT) || "";
      const S = new Set,
         E = new Set;
      if (a && (m += `	${n}MainUv(UV);
`, t.uvTransformation = !0), s !== null && /mainSupport/.test(s)) {
         const w = /mainSupport *\([\w\s]*?uv\s*?\)/.test(s);
         x += `	${n}MainSupport(`, x += w ? `vUv);
` : `);
`;
         for (const C of s.matchAll(/(?:varying\s+\w+\s+([\S\s]*?);)/g))
            for (const N of C[1].split(/\s*,\s*/)) t.varyings.add(N), S.add(N), E.add(N);
         for (const C of s.matchAll(l)) E.add(C[1])
      }
      for (const w of i.matchAll(l)) E.add(w[1]);
      for (const w of e.defines.keys()) E.add(w.replace(/\([\w\s,]*\)/g, ""));
      for (const w of e.uniforms.keys()) E.add(w);
      E.delete("while"), E.delete("for"), E.delete("if"), e.uniforms.forEach((w, C) => t.uniforms.set(n + C.charAt(0).toUpperCase() + C.slice(1), w)), e.defines.forEach((w, C) => t.defines.set(n + C.charAt(0).toUpperCase() + C.slice(1), w));
      const T = new Map([
         ["fragment", i],
         ["vertex", s]
      ]);
      oU(n, E, t.defines), oU(n, E, T), i = T.get("fragment"), s = T.get("vertex");
      const b = e.blendMode;
      if (t.blendModes.set(b.blendFunction, b), r) {
         e.inputColorSpace !== null && e.inputColorSpace !== t.colorSpace && (g += e.inputColorSpace === En ? `color0 = sRGBTransferOETF(color0);
	` : `color0 = sRGBToLinear(color0);
	`), e.outputColorSpace !== Bl ? t.colorSpace = e.outputColorSpace : e.inputColorSpace !== null && (t.colorSpace = e.inputColorSpace);
         const w = /MainImage *\([\w\s,]*?depth[\w\s,]*?\)/;
         g += `${n}MainImage(color0, UV, `, (t.attributes & th.DEPTH) !== 0 && w.test(i) && (g += "depth, ", t.readDepth = !0), g += `color1);
	`;
         const C = n + "BlendOpacity";
         t.uniforms.set(C, b.opacity), g += `color0 = blend${b.blendFunction}(color0, color1, ${C});

	`, h += `uniform float ${C};

`
      }
      if (h += i + `
`, s !== null && (v += s + `
`), c.set($n.FRAGMENT_HEAD, h), c.set($n.FRAGMENT_MAIN_UV, m), c.set($n.FRAGMENT_MAIN_IMAGE, g), c.set($n.VERTEX_HEAD, v), c.set($n.VERTEX_MAIN_SUPPORT, x), e.extensions !== null)
         for (const w of e.extensions) t.extensions.add(w)
   }
}
var Gee = class extends ga {
      constructor(n, ...e) {
         super("EffectPass"), this.fullscreenMaterial = new Hee(null, null, null, n), this.listener = t => this.handleEvent(t), this.effects = [], this.setEffects(e), this.skipRendering = !1, this.minTime = 1, this.maxTime = Number.POSITIVE_INFINITY, this.timeScale = 1
      }
      set mainScene(n) {
         for (const e of this.effects) e.mainScene = n
      }
      set mainCamera(n) {
         this.fullscreenMaterial.copyCameraSettings(n);
         for (const e of this.effects) e.mainCamera = n
      }
      get encodeOutput() {
         return this.fullscreenMaterial.encodeOutput
      }
      set encodeOutput(n) {
         this.fullscreenMaterial.encodeOutput = n
      }
      get dithering() {
         return this.fullscreenMaterial.dithering
      }
      set dithering(n) {
         const e = this.fullscreenMaterial;
         e.dithering = n, e.needsUpdate = !0
      }
      setEffects(n) {
         for (const e of this.effects) e.removeEventListener("change", this.listener);
         this.effects = n.sort((e, t) => t.attributes - e.attributes);
         for (const e of this.effects) e.addEventListener("change", this.listener)
      }
      updateMaterial() {
         const n = new N$;
         let e = 0;
         for (const a of this.effects)
            if (a.blendMode.blendFunction === Un.DST) n.attributes |= a.getAttributes() & th.DEPTH;
            else {
               if ((n.attributes & a.getAttributes() & th.CONVOLUTION) !== 0) throw new Error(`Convolution effects cannot be merged (${a.name})`);
               Vee("e" + e++, a, n)
            } let t = n.shaderParts.get($n.FRAGMENT_HEAD),
            i = n.shaderParts.get($n.FRAGMENT_MAIN_IMAGE),
            s = n.shaderParts.get($n.FRAGMENT_MAIN_UV);
         const r = /\bblend\b/g;
         for (const a of n.blendModes.values()) t += a.getShaderCode().replace(r, `blend${a.blendFunction}`) + `
`;
         (n.attributes & th.DEPTH) !== 0 ? (n.readDepth && (i = `float depth = readDepth(UV);

	` + i), this.needsDepthTexture = this.getDepthTexture() === null) : this.needsDepthTexture = !1, n.colorSpace === En && (i += `color0 = sRGBToLinear(color0);
	`), n.uvTransformation ? (s = `vec2 transformedUv = vUv;
` + s, n.defines.set("UV", "transformedUv")) : n.defines.set("UV", "vUv"), n.shaderParts.set($n.FRAGMENT_HEAD, t), n.shaderParts.set($n.FRAGMENT_MAIN_IMAGE, i), n.shaderParts.set($n.FRAGMENT_MAIN_UV, s);
         for (const [a, l] of n.shaderParts) l !== null && n.shaderParts.set(a, l.trim().replace(/^#/, `
#`));
         this.skipRendering = e === 0, this.needsSwap = !this.skipRendering, this.fullscreenMaterial.setShaderData(n)
      }
      recompile() {
         this.updateMaterial()
      }
      getDepthTexture() {
         return this.fullscreenMaterial.depthBuffer
      }
      setDepthTexture(n, e = Hl) {
         this.fullscreenMaterial.depthBuffer = n, this.fullscreenMaterial.depthPacking = e;
         for (const t of this.effects) t.setDepthTexture(n, e)
      }
      render(n, e, t, i, s) {
         for (const r of this.effects) r.update(n, e, i);
         if (!this.skipRendering || this.renderToScreen) {
            const r = this.fullscreenMaterial;
            r.inputBuffer = e.texture, r.time += i * this.timeScale, n.setRenderTarget(this.renderToScreen ? null : t), n.render(this.scene, this.camera)
         }
      }
      setSize(n, e) {
         this.fullscreenMaterial.setSize(n, e);
         for (const t of this.effects) t.setSize(n, e)
      }
      initialize(n, e, t) {
         this.renderer = n;
         for (const i of this.effects) i.initialize(n, e, t);
         this.updateMaterial(), t !== void 0 && t !== qs && (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1")
      }
      dispose() {
         super.dispose();
         for (const n of this.effects) n.removeEventListener("change", this.listener), n.dispose()
      }
      handleEvent(n) {
         switch (n.type) {
            case "change":
               this.recompile();
               break
         }
      }
   },
   kee = class extends ga {
      constructor(n, e, {
         renderTarget: t,
         resolutionScale: i = 1,
         width: s = js.AUTO_SIZE,
         height: r = js.AUTO_SIZE,
         resolutionX: a = s,
         resolutionY: l = r
      } = {}) {
         super("NormalPass"), this.needsSwap = !1, this.renderPass = new fC(n, e, new kR);
         const c = this.renderPass;
         c.ignoreBackground = !0, c.skipShadowMapUpdate = !0;
         const h = c.getClearPass();
         h.overrideClearColor = new dt(7829503), h.overrideClearAlpha = 1, this.renderTarget = t, this.renderTarget === void 0 && (this.renderTarget = new ss(1, 1, {
            minFilter: ms,
            magFilter: ms
         }), this.renderTarget.texture.name = "NormalPass.Target");
         const m = this.resolution = new js(this, a, l, i);
         m.addEventListener("change", g => this.setSize(m.baseWidth, m.baseHeight))
      }
      set mainScene(n) {
         this.renderPass.mainScene = n
      }
      set mainCamera(n) {
         this.renderPass.mainCamera = n
      }
      get texture() {
         return this.renderTarget.texture
      }
      getTexture() {
         return this.renderTarget.texture
      }
      getResolution() {
         return this.resolution
      }
      getResolutionScale() {
         return this.resolution.scale
      }
      setResolutionScale(n) {
         this.resolution.scale = n
      }
      render(n, e, t, i, s) {
         const r = this.renderToScreen ? null : this.renderTarget;
         this.renderPass.render(n, r, r)
      }
      setSize(n, e) {
         const t = this.resolution;
         t.setBaseSize(n, e), this.renderTarget.setSize(t.width, t.height)
      }
   };

function sy(n, e, t) {
   return e in n ? Object.defineProperty(n, e, {
      value: t,
      enumerable: !0,
      configurable: !0,
      writable: !0
   }) : n[e] = t, n
}
new Fe;
new Fe;

function j4(n, e) {
   if (!(n instanceof e)) throw new TypeError("Cannot call a class as a function")
}
var ko = function n(e, t, i) {
      var s = this;
      j4(this, n), sy(this, "dot2", function (r, a) {
         return s.x * r + s.y * a
      }), sy(this, "dot3", function (r, a, l) {
         return s.x * r + s.y * a + s.z * l
      }), this.x = e, this.y = t, this.z = i
   },
   jee = [new ko(1, 1, 0), new ko(-1, 1, 0), new ko(1, -1, 0), new ko(-1, -1, 0), new ko(1, 0, 1), new ko(-1, 0, 1), new ko(1, 0, -1), new ko(-1, 0, -1), new ko(0, 1, 1), new ko(0, -1, 1), new ko(0, 1, -1), new ko(0, -1, -1)],
   lU = [151, 160, 137, 91, 90, 15, 131, 13, 201, 95, 96, 53, 194, 233, 7, 225, 140, 36, 103, 30, 69, 142, 8, 99, 37, 240, 21, 10, 23, 190, 6, 148, 247, 120, 234, 75, 0, 26, 197, 62, 94, 252, 219, 203, 117, 35, 11, 32, 57, 177, 33, 88, 237, 149, 56, 87, 174, 20, 125, 136, 171, 168, 68, 175, 74, 165, 71, 134, 139, 48, 27, 166, 77, 146, 158, 231, 83, 111, 229, 122, 60, 211, 133, 230, 220, 105, 92, 41, 55, 46, 245, 40, 244, 102, 143, 54, 65, 25, 63, 161, 1, 216, 80, 73, 209, 76, 132, 187, 208, 89, 18, 169, 200, 196, 135, 130, 116, 188, 159, 86, 164, 100, 109, 198, 173, 186, 3, 64, 52, 217, 226, 250, 124, 123, 5, 202, 38, 147, 118, 126, 255, 82, 85, 212, 207, 206, 59, 227, 47, 16, 58, 17, 182, 189, 28, 42, 223, 183, 170, 213, 119, 248, 152, 2, 44, 154, 163, 70, 221, 153, 101, 155, 167, 43, 172, 9, 129, 22, 39, 253, 19, 98, 108, 110, 79, 113, 224, 232, 178, 185, 112, 104, 218, 246, 97, 228, 251, 34, 242, 193, 238, 210, 144, 12, 191, 179, 162, 241, 81, 51, 145, 235, 249, 14, 239, 107, 49, 192, 214, 31, 181, 199, 106, 157, 184, 84, 204, 176, 115, 121, 50, 45, 127, 4, 150, 254, 138, 236, 205, 93, 222, 114, 67, 29, 24, 72, 243, 141, 128, 195, 78, 66, 215, 61, 156, 180],
   uU = new Array(512),
   cU = new Array(512),
   qee = function (e) {
      e > 0 && e < 1 && (e *= 65536), e = Math.floor(e), e < 256 && (e |= e << 8);
      for (var t = 0; t < 256; t++) {
         var i;
         t & 1 ? i = lU[t] ^ e & 255 : i = lU[t] ^ e >> 8 & 255, uU[t] = uU[t + 256] = i, cU[t] = cU[t + 256] = jee[i % 12]
      }
   };
qee(0);

function Xee(n) {
   if (typeof n == "number") n = Math.abs(n);
   else if (typeof n == "string") {
      var e = n;
      n = 0;
      for (var t = 0; t < e.length; t++) n = (n + (t + 1) * (e.charCodeAt(t) % 96)) % 2147483647
   }
   return n === 0 && (n = 311), n
}

function fU(n) {
   var e = Xee(n);
   return function () {
      var t = e * 48271 % 2147483647;
      return e = t, t / 2147483647
   }
}
var Wee = function n(e) {
   var t = this;
   j4(this, n), sy(this, "seed", 0), sy(this, "init", function (i) {
      t.seed = i, t.value = fU(i)
   }), sy(this, "value", fU(this.seed)), this.init(e)
};
new Wee(Math.random());
const q4 = j.createContext(null),
   hU = n => (n.getAttributes() & 2) === 2,
   Yee = j.memo(j.forwardRef(({
      children: n,
      camera: e,
      scene: t,
      resolutionScale: i,
      enabled: s = !0,
      renderPriority: r = 1,
      autoClear: a = !0,
      depthBuffer: l,
      enableNormalPass: c,
      stencilBuffer: h,
      multisampling: m = 8,
      frameBufferType: g = lp
   }, v) => {
      const {
         gl: x,
         scene: S,
         camera: E,
         size: T
      } = NT(), b = t || S, w = e || E, [C, N, U] = j.useMemo(() => {
         const I = new D$(x, {
            depthBuffer: l,
            stencilBuffer: h,
            multisampling: m,
            frameBufferType: g
         });
         I.addPass(new fC(b, w));
         let O = null,
            P = null;
         return c && (P = new kee(b, w), P.enabled = !1, I.addPass(P), i !== void 0 && (O = new zee({
            normalBuffer: P.texture,
            resolutionScale: i
         }), O.enabled = !1, I.addPass(O))), [I, P, O]
      }, [w, x, l, h, m, g, b, c, i]);
      j.useEffect(() => C == null ? void 0 : C.setSize(T.width, T.height), [C, T]), a2((I, O) => {
         if (s) {
            const P = x.autoClear;
            x.autoClear = a, h && !a && x.clearStencil(), C.render(O), x.autoClear = P
         }
      }, s ? r : 0);
      const z = j.useRef(null);
      j.useLayoutEffect(() => {
         var P;
         const I = [],
            O = z.current.__r3f;
         if (O && C) {
            const q = O.children;
            for (let Q = 0; Q < q.length; Q++) {
               const $ = q[Q].object;
               if ($ instanceof F1) {
                  const ae = [$];
                  if (!hU($)) {
                     let k = null;
                     for (;
                        (k = (P = q[Q + 1]) == null ? void 0 : P.object) instanceof F1 && !hU(k);) ae.push(k), Q++
                  }
                  const fe = new Gee(w, ...ae);
                  I.push(fe)
               } else $ instanceof ga && I.push($)
            }
            for (const Q of I) C == null || C.addPass(Q);
            N && (N.enabled = !0), U && (U.enabled = !0)
         }
         return () => {
            for (const q of I) C == null || C.removePass(q);
            N && (N.enabled = !1), U && (U.enabled = !1)
         }
      }, [C, n, w, N, U]), j.useEffect(() => {
         const I = x.toneMapping;
         return x.toneMapping = ho, () => {
            x.toneMapping = I
         }
      }, [x]);
      const B = j.useMemo(() => ({
         composer: C,
         normalPass: N,
         downSamplingPass: U,
         resolutionScale: i,
         camera: w,
         scene: b
      }), [C, N, U, i, w, b]);
      return j.useImperativeHandle(v, () => C, [C]), H.jsx(q4.Provider, {
         value: B,
         children: H.jsx("group", {
            ref: z,
            children: n
         })
      })
   })),
   dU = n => typeof n == "object" && n != null && "current" in n ? n.current : n;
let Kee = 0;
const pU = new WeakMap,
   Zee = (n, e) => function ({
      blendFunction: t = e == null ? void 0 : e.blendFunction,
      opacity: i = e == null ? void 0 : e.opacity,
      ...s
   }) {
      let r = pU.get(n);
      if (!r) {
         const c = `@react-three/postprocessing/${n.name}-${Kee++}`;
         ZB({
            [c]: n
         }), pU.set(n, r = c)
      }
      const a = NT(c => c.camera),
         l = $o.useMemo(() => [...(e == null ? void 0 : e.args) ?? [], ...s.args ?? [{
            ...e,
            ...s
         }]], [JSON.stringify(s)]);
      return H.jsx(r, {
         camera: a,
         "blendMode-blendFunction": t,
         "blendMode-opacity-value": i,
         ...s,
         args: l
      })
   },
   Qee = Zee(wee, {
      blendFunction: 0
   }),
   Jee = j.forwardRef(function (n, e) {
      const {
         camera: t
      } = j.useContext(q4), i = j.useMemo(() => new Uee(t, dU(n.sun), n), [t, n]);
      return j.useLayoutEffect(() => void(i.lightSource = dU(n.sun)), [i, n.sun]), H.jsx("primitive", {
         ref: e,
         object: i,
         dispose: null
      })
   });

function $ee() {
   const n = j.useRef(),
      [e, t] = j.useState(!1),
      {
         gl: i
      } = NT(),
      s = j.useMemo(() => new cp(12, 32, 32), []),
      r = j.useMemo(() => new Fc({
         color: 16777215
      }), []),
      [a, l] = j.useState(!1);
   return j.useEffect(() => {
      const c = () => {
            console.warn(" WebGL context lost"), l(!0)
         },
         h = () => {
            console.log(" WebGL context restored"), l(!1)
         };
      return i.domElement.addEventListener("webglcontextlost", c), i.domElement.addEventListener("webglcontextrestored", h), () => {
         i.domElement.removeEventListener("webglcontextlost", c), i.domElement.removeEventListener("webglcontextrestored", h)
      }
   }, [i]), j.useEffect(() => {
      n.current && t(!0)
   }, []), H.jsxs(H.Fragment, {
      children: [H.jsx("ambientLight", {
         intensity: .01
      }), H.jsx("directionalLight", {
         position: [0, 100, 150],
         intensity: 5
      }), H.jsx("mesh", {
         ref: n,
         geometry: s,
         material: r,
         position: [0, 100, 150]
      }), !a && H.jsxs(Yee, {
         disableNormalPass: !0,
         multisampling: 4,
         children: [H.jsx(Qee, {
            luminanceThreshold: .8,
            luminanceSmoothing: 1.5,
            intensity: 2
         }), e && n.current && H.jsx(Jee, {
            sun: n,
            samples: 16,
            density: .92,
            decay: .74,
            weight: 1,
            exposure: .5,
            blur: !0,
            kernelSize: 3
         })]
      })]
   })
}

function ete(n) {
   const e = j.useRef(null),
      t = j.useRef(null);
   return j.useEffect(() => (e.current = new Audio("../sounds/planet-hover.mp3"), t.current = new Audio("sounds/planet-click.mp3"), e.current.volume = .4, t.current.volume = .4, () => {
      e.current = null, t.current = null
   }), []), {
      playHover: () => {
         n && e.current && (e.current.currentTime = 0, e.current.play().catch(() => {}))
      },
      playClick: () => {
         n && t.current && (t.current.currentTime = 0, t.current.play().catch(() => {}))
      }
   }
}

function tte({
   setShouldPlay: n,
   shouldPlay: e
}) {
   const t = j.useRef(),
      i = OT(ZR, "textures/planet.jpg"),
      s = u2(m => m.setPlanetClicked),
      r = V4(m => m.setIsHoveringPlanet);
   a2(() => {
      t.current && (t.current.rotation.y += 6e-4)
   }), j.useEffect(() => () => {
      i.dispose()
   }, [i]);
   const a = () => {
         h(), s(!0), c()
      },
      l = m => {
         m.stopPropagation(), document.body.style.cursor = "pointer", r(!0)
      },
      c = () => {
         document.body.style.cursor = "default", r(!1)
      },
      {
         playClick: h
      } = ete(e);
   return H.jsxs("mesh", {
      ref: t,
      onPointerOver: l,
      onPointerOut: c,
      onClick: a,
      children: [H.jsx("sphereGeometry", {
         args: [1.3, 32, 32]
      }), H.jsx("meshStandardMaterial", {
         map: i,
         roughness: .4
      })]
   })
}

function nte() {
   const n = OT(ZR, "textures/background.jpg");
   n.minFilter = Ni, n.magFilter = Ni, n.colorSpace = En;
   const e = j.useMemo(() => new cp(500, 16, 16), []);
   return H.jsxs("mesh", {
      rotation: [0, Math.PI / 2, 0],
      children: [H.jsx("primitive", {
         object: e
      }), H.jsx("meshBasicMaterial", {
         map: n,
         side: Ds,
         transparent: !1
      })]
   })
}

function ite({
   count: n = 500,
   size: e = .05
}) {
   const t = j.useMemo(() => {
      const i = new Float32Array(n * 3);
      for (let s = 0; s < n; s++) i[s * 3] = (Math.random() - .5) * 100, i[s * 3 + 1] = (Math.random() - .5) * 100, i[s * 3 + 2] = (Math.random() - .5) * 100;
      return i
   }, [n]);
   return H.jsxs("points", {
      frustumCulled: !1,
      name: "particles",
      children: [H.jsx("bufferGeometry", {
         children: H.jsx("bufferAttribute", {
            attach: "attributes-position",
            array: t,
            count: t.length / 3,
            itemSize: 3
         })
      }), H.jsx("pointsMaterial", {
         color: "white",
         size: e,
         transparent: !0,
         opacity: .8,
         sizeAttenuation: !0
      })]
   })
}

function ste({
   setShouldPlay: n,
   shouldPlay: e
}) {
   return H.jsxs(H.Fragment, {
      children: [H.jsx(tte, {
         shouldPlay: e,
         setShouldPlay: n
      }), H.jsx(ite, {}), H.jsx(nte, {}), H.jsx($ee, {})]
   })
}
const Il = j.createRef();

function Cx(n) {
   const e = j.useRef(null),
      t = j.useRef(null);
   return j.useEffect(() => (e.current = new Audio("sounds/hover.mp3"), t.current = new Audio("sounds/click.mp3"), e.current.volume = .4, t.current.volume = .4, () => {
      e.current = null, t.current = null
   }), []), {
      playHover: () => {
         n && e.current && (e.current.currentTime = 0, e.current.play().catch(() => {}))
      },
      playClick: () => {
         n && t.current && (t.current.currentTime = 0, t.current.play().catch(() => {}))
      }
   }
}
const Vl = ({
   shouldPlay: n,
   children: e,
   type: t = "button",
   icon: i = null,
   width: s = null,
   height: r = null,
   backgroundColor: a = "transparent",
   textColor: l = "#fff",
   hoverTextColor: c = "#000",
   hoverBackgroundColor: h = "#fff",
   borderColor: m = "#fff",
   hoverBorderColor: g = "#fff",
   onClick: v,
   scrollPercentage: x
}) => {
   const S = j.useRef(null),
      [E, T] = j.useState({
         width: 0,
         height: 0
      });
   j.useEffect(() => {
      if (S.current) {
         const {
            width: N,
            height: U
         } = S.current.getBoundingClientRect();
         T({
            width: N,
            height: U
         })
      }
   }, []);
   const b = N => {
         const U = S.current.getBoundingClientRect(),
            z = N.clientX - U.left,
            B = N.clientY - U.top;
         S.current.style.setProperty("--x", `${z}px`), S.current.style.setProperty("--y", `${B}px`)
      },
      w = N => {
         if (C(), x !== void 0)
            if (Il.current) {
               const U = Il.current.options.content;
               if (U) {
                  const B = (U.scrollHeight - window.innerHeight) * x;
                  Il.current.scrollTo(B)
               }
            } else {
               const z = (document.documentElement.scrollHeight - window.innerHeight) * x;
               window.scrollTo({
                  top: z,
                  behavior: "smooth"
               })
            } v && v(N)
      },
      {
         playClick: C
      } = Cx(n);
   return H.jsx("button", {
      type: t,
      className: "radial-button",
      ref: S,
      onMouseMove: b,
      onClick: w,
      style: {
         width: s,
         height: r,
         "--initial-bg": a,
         "--text-color": l,
         "--hover-bg": h,
         "--hover-text-color": c,
         "--border-color": m,
         "--hover-border-color": g,
         "--button-width": `${E.width}px`,
         "--button-height": `${E.height}px`
      },
      children: H.jsxs("span", {
         className: "button-content",
         children: [i && H.jsx("span", {
            className: "button-icon",
            children: i
         }), e && H.jsx("span", {
            className: "button-label",
            children: e
         })]
      })
   })
};
var X4 = {
      color: void 0,
      size: void 0,
      className: void 0,
      style: void 0,
      attr: void 0
   },
   mU = $o.createContext && $o.createContext(X4),
   rte = ["attr", "size", "title"];

function ate(n, e) {
   if (n == null) return {};
   var t = ote(n, e),
      i, s;
   if (Object.getOwnPropertySymbols) {
      var r = Object.getOwnPropertySymbols(n);
      for (s = 0; s < r.length; s++) i = r[s], !(e.indexOf(i) >= 0) && Object.prototype.propertyIsEnumerable.call(n, i) && (t[i] = n[i])
   }
   return t
}

function ote(n, e) {
   if (n == null) return {};
   var t = {};
   for (var i in n)
      if (Object.prototype.hasOwnProperty.call(n, i)) {
         if (e.indexOf(i) >= 0) continue;
         t[i] = n[i]
      } return t
}

function H1() {
   return H1 = Object.assign ? Object.assign.bind() : function (n) {
      for (var e = 1; e < arguments.length; e++) {
         var t = arguments[e];
         for (var i in t) Object.prototype.hasOwnProperty.call(t, i) && (n[i] = t[i])
      }
      return n
   }, H1.apply(this, arguments)
}

function gU(n, e) {
   var t = Object.keys(n);
   if (Object.getOwnPropertySymbols) {
      var i = Object.getOwnPropertySymbols(n);
      e && (i = i.filter(function (s) {
         return Object.getOwnPropertyDescriptor(n, s).enumerable
      })), t.push.apply(t, i)
   }
   return t
}

function V1(n) {
   for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e] != null ? arguments[e] : {};
      e % 2 ? gU(Object(t), !0).forEach(function (i) {
         lte(n, i, t[i])
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : gU(Object(t)).forEach(function (i) {
         Object.defineProperty(n, i, Object.getOwnPropertyDescriptor(t, i))
      })
   }
   return n
}

function lte(n, e, t) {
   return e = ute(e), e in n ? Object.defineProperty(n, e, {
      value: t,
      enumerable: !0,
      configurable: !0,
      writable: !0
   }) : n[e] = t, n
}

function ute(n) {
   var e = cte(n, "string");
   return typeof e == "symbol" ? e : e + ""
}

function cte(n, e) {
   if (typeof n != "object" || !n) return n;
   var t = n[Symbol.toPrimitive];
   if (t !== void 0) {
      var i = t.call(n, e);
      if (typeof i != "object") return i;
      throw new TypeError("@@toPrimitive must return a primitive value.")
   }
   return (e === "string" ? String : Number)(n)
}

function W4(n) {
   return n && n.map((e, t) => $o.createElement(e.tag, V1({
      key: t
   }, e.attr), W4(e.child)))
}

function jT(n) {
   return e => $o.createElement(fte, H1({
      attr: V1({}, n.attr)
   }, e), W4(n.child))
}

function fte(n) {
   var e = t => {
      var {
         attr: i,
         size: s,
         title: r
      } = n, a = ate(n, rte), l = s || t.size || "1em", c;
      return t.className && (c = t.className), n.className && (c = (c ? c + " " : "") + n.className), $o.createElement("svg", H1({
         stroke: "currentColor",
         fill: "currentColor",
         strokeWidth: "0"
      }, t.attr, i, a, {
         className: c,
         style: V1(V1({
            color: n.color || t.color
         }, t.style), n.style),
         height: l,
         width: l,
         xmlns: "http://www.w3.org/2000/svg"
      }), r && $o.createElement("title", null, r), n.children)
   };
   return mU !== void 0 ? $o.createElement(mU.Consumer, null, t => e(t)) : e(X4)
}

function qT(n) {
   return jT({
      attr: {
         viewBox: "0 0 1024 1024"
      },
      child: [{
         tag: "path",
         attr: {
            d: "M752.145 0c8.685 0 17.572 3.434 24.237 10.099 13.33 13.33 13.33 35.143 0 48.473L320.126 515.03l449.591 449.591c13.33 13.33 13.33 35.144 0 48.474-13.33 13.33-35.142 13.33-48.472 0L247.418 539.268c-13.33-13.33-13.33-35.144 0-48.474L727.91 10.1C734.575 3.435 743.46.002 752.146.002z"
         },
         child: []
      }]
   })(n)
}

function XT(n) {
   return jT({
      attr: {
         viewBox: "0 0 1024 1024"
      },
      child: [{
         tag: "path",
         attr: {
            d: "M271.653 1023.192c-8.685 0-17.573-3.432-24.238-10.097-13.33-13.33-13.33-35.144 0-48.474L703.67 508.163 254.08 58.573c-13.33-13.331-13.33-35.145 0-48.475 13.33-13.33 35.143-13.33 48.473 0L776.38 483.925c13.33 13.33 13.33 35.143 0 48.473l-480.492 480.694c-6.665 6.665-15.551 10.099-24.236 10.099z"
         },
         child: []
      }]
   })(n)
}

function hte(n) {
   return jT({
      attr: {
         viewBox: "0 0 1024 1024"
      },
      child: [{
         tag: "path",
         attr: {
            d: "M8.2 751.4c0 8.6 3.4 17.401 10 24.001 13.2 13.2 34.8 13.2 48 0l451.8-451.8 445.2 445.2c13.2 13.2 34.8 13.2 48 0s13.2-34.8 0-48L542 251.401c-13.2-13.2-34.8-13.2-48 0l-475.8 475.8c-6.8 6.8-10 15.4-10 24.2z"
         },
         child: []
      }]
   })(n)
}

function dte({
   shouldPlay: n
}) {
   const {
      t: e
   } = rs();
   return H.jsxs("section", {
      className: "relative h-[100svh] w-full text-white z-10",
      children: [H.jsxs("div", {
         className: "absolute overflow-hidden top-20 bottom-auto md:top-auto left-5 right-5 md:left-10 md:right-10 w-auto md:w-1/2 md:bottom-8",
         children: [H.jsxs("h3", {
            className: "text-xs md:text-base mb-3 md:mb-7",
            children: [" ", e("services"), " "]
         }), H.jsx("h2", {
            className: "text-2xl md:text-5xl",
            style: {
               whiteSpace: "pre-line"
            },
            children: H.jsx(Mc, {
               i18nKey: "servicesTitle1",
               components: [H.jsx("br", {})]
            })
         })]
      }), H.jsxs("div", {
         className: "absolute bottom-5 md:bottom-9 left-5 right-5 md:left-auto md:right-10 w-auto md:w-1/3 text-white text-xs md:text-sm xl:text-base",
         children: [H.jsxs("div", {
            className: "flex w-23 md:w-30 justify-start gap-2 md:gap-4 arrowRounded",
            children: [H.jsx(Vl, {
               shouldPlay: n,
               scrollPercentage: .12,
               width: "100%",
               icon: H.jsx(qT, {})
            }), H.jsx(Vl, {
               shouldPlay: n,
               scrollPercentage: .5,
               width: "100%",
               icon: H.jsx(XT, {})
            })]
         }), H.jsxs("p", {
            children: [" ", e("servicesText1"), " "]
         })]
      })]
   })
}

function pte({
   shouldPlay: n
}) {
   const {
      t: e
   } = rs();
   return H.jsxs("section", {
      className: "relative h-[100svh] w-full text-white z-10",
      children: [H.jsxs("div", {
         className: "absolute overflow-hidden top-20 bottom-auto md:top-auto left-5 right-5 md:left-10 md:right-10 w-auto md:w-1/2 md:bottom-8",
         children: [H.jsxs("h3", {
            className: "text-xs md:text-base mb-3 md:mb-7",
            children: [" ", e("services"), " "]
         }), H.jsx("h2", {
            className: "text-2xl md:text-5xl",
            style: {
               whiteSpace: "pre-line"
            },
            children: H.jsx(Mc, {
               i18nKey: "servicesTitle2",
               components: [H.jsx("br", {})]
            })
         })]
      }), H.jsxs("div", {
         className: "absolute bottom-5 md:bottom-9 left-5 right-5 md:left-auto md:right-10 w-auto md:w-1/3 text-white text-xs md:text-sm xl:text-base",
         children: [H.jsxs("div", {
            className: "flex w-23 md:w-30 justify-start gap-2 md:gap-4 arrowRounded",
            children: [H.jsx(Vl, {
               shouldPlay: n,
               scrollPercentage: .2,
               width: "100%",
               icon: H.jsx(qT, {})
            }), H.jsx(Vl, {
               shouldPlay: n,
               scrollPercentage: .8,
               width: "100%",
               icon: H.jsx(XT, {})
            })]
         }), H.jsxs("p", {
            children: [" ", e("servicesText2"), " "]
         })]
      })]
   })
}

function mte({
   shouldPlay: n
}) {
   const {
      t: e
   } = rs();
   return H.jsxs("section", {
      className: "relative h-[100svh] w-full text-white z-10",
      children: [H.jsxs("div", {
         className: "absolute overflow-hidden top-20 bottom-auto md:top-auto left-5 right-5 md:left-10 w-auto md:w-1/2 md:right-10 md:bottom-8",
         children: [H.jsxs("h3", {
            className: "text-xs md:text-base mb-3 md:mb-7",
            children: [" ", e("services"), " "]
         }), H.jsx("h2", {
            className: "text-2xl md:text-5xl",
            style: {
               whiteSpace: "pre-line"
            },
            children: H.jsx(Mc, {
               i18nKey: "servicesTitle3",
               components: [H.jsx("br", {})]
            })
         })]
      }), H.jsxs("div", {
         className: "absolute bottom-5 md:bottom-9 left-5 right-5 md:left-auto md:right-10 w-auto md:w-1/3 text-white text-xs md:text-sm xl:text-base",
         children: [H.jsxs("div", {
            className: "flex w-23 md:w-30 justify-start gap-2 md:gap-4 arrowRounded",
            children: [H.jsx(Vl, {
               shouldPlay: n,
               scrollPercentage: .5,
               width: "100%",
               icon: H.jsx(qT, {})
            }), H.jsx(Vl, {
               shouldPlay: n,
               scrollPercentage: 1,
               width: "100%",
               icon: H.jsx(XT, {})
            })]
         }), H.jsxs("p", {
            children: [" ", e("servicesText3"), " "]
         })]
      })]
   })
}

function gte() {
   const {
      t: n
   } = rs();
   return H.jsx("main", {
      className: "relative w-full px-5 md:px-10 py-4 md:py-8 text-white z-10",
      children: H.jsxs("div", {
         className: "flex flex-col overflow-hidden",
         children: [H.jsx("h2", {
            className: "text-xs md:text-base mb-3 md:mb-7",
            children: n("main")
         }), H.jsx("h1", {
            className: "text-3xl md:text-4xl xl:text-5xl",
            children: H.jsx(Mc, {
               i18nKey: "mainTitle",
               components: [H.jsx("br", {})]
            })
         })]
      })
   })
}

function vte({
   shouldPlay: n
}) {
   const {
      t: e
   } = rs();
   return H.jsxs("section", {
      className: "relative h-[100svh] w-full text-white z-10",
      children: [H.jsxs("div", {
         className: "absolute top-20 md:top-33 left-5 right-5 md:left-10 md:right-10",
         children: [H.jsx("h3", {
            className: "text-xs md:text-base mb-3 md:mb-7",
            children: H.jsx(Mc, {
               i18nKey: "aboutUs",
               components: [H.jsx("br", {})]
            })
         }), H.jsx("h2", {
            className: "text-2xl md:text-4xl xl:text-5xl",
            style: {
               whiteSpace: "pre-line"
            },
            children: H.jsx(Mc, {
               i18nKey: "aboutTitle",
               components: [H.jsx("br", {})]
            })
         }), H.jsxs("div", {
            className: "hidden md:flex w-fit justify-start gap-4 arrowRounded",
            children: [H.jsx(Vl, {
               shouldPlay: n,
               scrollPercentage: 0,
               width: "52px",
               icon: H.jsx(qT, {})
            }), H.jsx(Vl, {
               shouldPlay: n,
               scrollPercentage: .2,
               width: "52px",
               icon: H.jsx(XT, {})
            })]
         })]
      }), H.jsx("div", {
         className: "absolute bottom-5 md:bottom-9 left-5 right-0 md:left-auto pr-5 md:pr-10 w-auto md:w-1/2 text-white text-xs md:text-sm xl:text-base",
         children: H.jsx(Mc, {
            i18nKey: "aboutText",
            components: [H.jsx("br", {})]
         })
      }), H.jsx("div", {
         className: "absolute bottom-9 left-10 w-1/3 hidden md:block text-white",
         children: H.jsx("p", {
            className: "text-base",
            children: H.jsx(Mc, {
               i18nKey: "founded",
               components: [H.jsx("br", {})]
            })
         })
      }), H.jsx("div", {
         className: "absolute top-33 right-10 w-1/3 hidden md:block text-white",
         children: H.jsx("p", {
            className: "text-base text-right",
            children: H.jsx(Mc, {
               i18nKey: "aboutClient",
               components: [H.jsx("br", {})]
            })
         })
      })]
   })
}

function Y4() {
   const {
      t: n
   } = rs();
   return H.jsxs("section", {
      className: "text-xs md:text-base relative block md:flex justify-between items-center px-5 md:px-10 h-8 md:h-10 my-5 md:my-5 w-full z-10 gap-5 overflow-hidden",
      children: [H.jsxs("div", {
         className: "flex gap-5 justify-center",
         children: [H.jsx("a", {
            className: "opacity-100 hover:opacity-50 duration-200",
            href: "mailto:info@mysterium.coffee",
            children: "INFO@MYSTERIUM.COFFEE"
         }), H.jsx("a", {
            className: "opacity-100 hover:opacity-50 duration-200",
            href: "https://www.instagram.com/mysterium.coffee/",
            target: "_blank",
            rel: "noopener noreferrer",
            children: "INSTAGRAM"
         }), H.jsx("a", {
            className: "opacity-100 hover:opacity-50 duration-200",
            href: "https://www.linkedin.com/company/orbyte-ar/",
            target: "_blank",
            rel: "noopener noreferrer",
            children: "LINKEDIN"
         })]
      }), H.jsxs("div", {
         className: "flex gap-5 justify-center text-center md:text-right",
         children: [H.jsxs("a", {
            className: "opacity-100 hover:opacity-50 duration-200",
            href: "/privacy",
            target: "_blank",
            children: [" ", n("privacyPolicy"), " "]
         }), H.jsx("p", {
            children: n("rightsReserved")
         })]
      })]
   })
}

function WT({
   shouldPlay: n
}) {
   const e = async i => {
      i.preventDefault();
      const s = new FormData(i.target),
         r = {
            name: s.get("name"),
            email: s.get("email"),
            company: s.get("company"),
            message: s.get("message")
         };
      try {
         const a = await fetch("https://orbyte-1.onrender.com/send-email", {
            method: "POST",
            headers: {
               "Content-Type": "application/json"
            },
            body: JSON.stringify(r)
         });
         if (a.ok) {
            const l = await a.json();
            i.target.reset(), alert("Email sent successfully!", l)
         }
      } catch (a) {
         console.error("Error sending email:", a), alert("Failed to send email. Please try again later.")
      }
   }, {
      t
   } = rs();
   return H.jsxs("footer", {
      className: "relative w-full z-10 ",
      children: [H.jsx("div", {
         className: "relative w-full bg-white shadow-xl z-30",
         style: {
            pointerEvents: "auto"
         },
         children: H.jsxs("div", {
            className: "h-full pb-5 pt-5 px-5 md:px-10 md:pb-10 md:pt-9 overflow-hidden",
            children: [H.jsxs("div", {
               className: "block md:flex items-center justify-center gap-10",
               children: [H.jsxs("div", {
                  className: "flex flex-col w-full md:w-1/2",
                  children: [H.jsxs("h3", {
                     className: "text-xs md:text-base mb-3 md:mb-7 text-black",
                     children: [" ", t("contact"), " "]
                  }), H.jsxs("h2", {
                     className: "text-3xl md:text-4xl xl:text-5xl text-black",
                     children: [" ", t("contactTitle"), " "]
                  })]
               }), H.jsxs("div", {
                  className: "flex flex-col mt-3 md:mt-0 w-full md:w-1/2 text-black text-xs md:text-sm xl:text-base leading-relaxed",
                  children: [H.jsxs("p", {
                     children: [" ", t("contactText1"), " "]
                  }), H.jsxs("p", {
                     className: "hidden md:flex",
                     children: [H.jsx("br", {}), " ", t("contactText2"), " "]
                  })]
               })]
            }), H.jsxs("form", {
               className: "block md:flex items-center justify-center gap-10 mt-5 md:mt-7",
               onSubmit: e,
               children: [H.jsxs("div", {
                  className: "flex flex-col nb text-xs md:text-base w-full md:w-1/2 gap-2 md:gap-5",
                  children: [H.jsx("input", {
                     type: "text",
                     name: "name",
                     placeholder: "Full Name",
                     required: !0,
                     className: "inputData px-3 md:px-5 h-8 md:h-13",
                     autoComplete: "name"
                  }), H.jsx("input", {
                     type: "email",
                     name: "email",
                     placeholder: "Email Address",
                     required: !0,
                     className: "inputData px-3 md:px-5 h-8 md:h-13",
                     autoComplete: "email"
                  }), H.jsx("input", {
                     type: "text",
                     name: "company",
                     placeholder: "Company Name",
                     className: "inputData px-3 md:px-5 h-8 md:h-13",
                     autoComplete: "organization"
                  })]
               }), H.jsxs("div", {
                  className: "flex flex-col nb text-xs md:text-base w-full md:w-1/2 pt-2 md:pt-0 gap-5",
                  children: [H.jsx("textarea", {
                     name: "message",
                     placeholder: "Message",
                     required: !0,
                     className: "inputText px-3 py-2 md:px-5 md:py-4 h-20 rounded-2xl md:rounded-4xl br md:h-31"
                  }), H.jsxs("div", {
                     className: "flex items-center justify-between",
                     children: [H.jsx(Vl, {
                        shouldPlay: n,
                        type: "submit",
                        width: "100%",
                        backgroundColor: "#000",
                        textColor: "#fff",
                        hoverTextColor: "#000",
                        hoverBackgroundColor: "#fff",
                        borderColor: "#000",
                        hoverBorderColor: "#000",
                        children: t("submit")
                     }), H.jsx("p", {
                        className: "text-black w-full text-right px-2 md:px-5",
                        children: t("backTop")
                     }), H.jsx("div", {
                        className: "w-11 md:w-13",
                        children: H.jsx(Vl, {
                           shouldPlay: n,
                           scrollPercentage: 0,
                           borderColor: "black",
                           hoverBorderColor: "black",
                           textColor: "black",
                           hoverTextColor: "white",
                           hoverBackgroundColor: "black",
                           width: "100%",
                           icon: H.jsx(hte, {})
                        })
                     })]
                  })]
               })]
            })]
         })
      }), H.jsx("div", {
         className: "relative w-full z-10",
         children: H.jsx(Y4, {})
      })]
   })
}

function yte() {
   const {
      t: n
   } = rs();
   return H.jsx("section", {
      className: "relative h-[100svh] w-full hidden 2xl:block text-white z-10",
      children: H.jsxs("div", {
         className: "absolute bottom-9 left-1/2 -translate-x-1/2 transform text-center flex flex-col items-center",
         children: [H.jsx("div", {
            className: "arrow",
            children: H.jsx("img", {
               src: "icons/arrow.svg",
               alt: "ArrowDown"
            })
         }), H.jsx("p", {
            className: "text-base opacity-80",
            children: n("step1")
         })]
      })
   })
}

function xte() {
   const {
      t: n
   } = rs();
   return H.jsxs("section", {
      className: "relative h-[100svh] w-full text-white z-10",
      children: [H.jsxs("div", {
         className: "absolute bottom-[56%] md:bottom-[60%] left-1/2 -translate-x-1/2 transform text-center flex flex-col items-center",
         children: [H.jsx("p", {
            className: "text-xs md:text-base opacity-80 block md:hidden 2xl:block",
            children: n("step2")
         }), H.jsx("div", {
            className: "arrow",
            children: H.jsx("img", {
               src: "icons/arrow.svg",
               alt: "ArrowD",
               className: "w-8 md:w-auto"
            })
         })]
      }), H.jsx("div", {
         className: "absolute top-[56%] md:top-[60%] left-1/2 transform -translate-x-1/2 text-center place-items-center",
         children: H.jsx("div", {
            className: "arrow rotate-180",
            children: H.jsx("img", {
               src: "icons/arrow.svg",
               alt: "ArrowUp",
               className: "w-8 md:w-auto"
            })
         })
      })]
   })
}

function _te() {
   const {
      t: n
   } = rs();
   return H.jsx("section", {
      className: "h-[100svh] w-full flex items-center justify-center text-white z-10",
      children: H.jsx("div", {
         className: "px-10 text-center",
         children: H.jsx("h2", {
            className: "footerText",
            children: n("footerText")
         })
      })
   })
}
var Ste = "1.3.4";

function K4(n, e, t) {
   return Math.max(n, Math.min(e, t))
}

function bte(n, e, t) {
   return (1 - t) * n + t * e
}

function Tte(n, e, t, i) {
   return bte(n, e, 1 - Math.exp(-t * i))
}

function Ete(n, e) {
   return (n % e + e) % e
}
var Mte = class {
   constructor() {
      Ut(this, "isRunning", !1);
      Ut(this, "value", 0);
      Ut(this, "from", 0);
      Ut(this, "to", 0);
      Ut(this, "currentTime", 0);
      Ut(this, "lerp");
      Ut(this, "duration");
      Ut(this, "easing");
      Ut(this, "onUpdate")
   }
   advance(n) {
      var t;
      if (!this.isRunning) return;
      let e = !1;
      if (this.duration && this.easing) {
         this.currentTime += n;
         const i = K4(0, this.currentTime / this.duration, 1);
         e = i >= 1;
         const s = e ? 1 : this.easing(i);
         this.value = this.from + (this.to - this.from) * s
      } else this.lerp ? (this.value = Tte(this.value, this.to, this.lerp * 60, n), Math.round(this.value) === this.to && (this.value = this.to, e = !0)) : (this.value = this.to, e = !0);
      e && this.stop(), (t = this.onUpdate) == null || t.call(this, this.value, e)
   }
   stop() {
      this.isRunning = !1
   }
   fromTo(n, e, {
      lerp: t,
      duration: i,
      easing: s,
      onStart: r,
      onUpdate: a
   }) {
      this.from = this.value = n, this.to = e, this.lerp = t, this.duration = i, this.easing = s, this.currentTime = 0, this.isRunning = !0, r == null || r(), this.onUpdate = a
   }
};

function Ate(n, e) {
   let t;
   return function (...i) {
      let s = this;
      clearTimeout(t), t = setTimeout(() => {
         t = void 0, n.apply(s, i)
      }, e)
   }
}
var wte = class {
      constructor(n, e, {
         autoResize: t = !0,
         debounce: i = 250
      } = {}) {
         Ut(this, "width", 0);
         Ut(this, "height", 0);
         Ut(this, "scrollHeight", 0);
         Ut(this, "scrollWidth", 0);
         Ut(this, "debouncedResize");
         Ut(this, "wrapperResizeObserver");
         Ut(this, "contentResizeObserver");
         Ut(this, "resize", () => {
            this.onWrapperResize(), this.onContentResize()
         });
         Ut(this, "onWrapperResize", () => {
            this.wrapper instanceof Window ? (this.width = window.innerWidth, this.height = window.innerHeight) : (this.width = this.wrapper.clientWidth, this.height = this.wrapper.clientHeight)
         });
         Ut(this, "onContentResize", () => {
            this.wrapper instanceof Window ? (this.scrollHeight = this.content.scrollHeight, this.scrollWidth = this.content.scrollWidth) : (this.scrollHeight = this.wrapper.scrollHeight, this.scrollWidth = this.wrapper.scrollWidth)
         });
         this.wrapper = n, this.content = e, t && (this.debouncedResize = Ate(this.resize, i), this.wrapper instanceof Window ? window.addEventListener("resize", this.debouncedResize, !1) : (this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize), this.wrapperResizeObserver.observe(this.wrapper)), this.contentResizeObserver = new ResizeObserver(this.debouncedResize), this.contentResizeObserver.observe(this.content)), this.resize()
      }
      destroy() {
         var n, e;
         (n = this.wrapperResizeObserver) == null || n.disconnect(), (e = this.contentResizeObserver) == null || e.disconnect(), this.wrapper === window && this.debouncedResize && window.removeEventListener("resize", this.debouncedResize, !1)
      }
      get limit() {
         return {
            x: this.scrollWidth - this.width,
            y: this.scrollHeight - this.height
         }
      }
   },
   Z4 = class {
      constructor() {
         Ut(this, "events", {})
      }
      emit(n, ...e) {
         var i;
         let t = this.events[n] || [];
         for (let s = 0, r = t.length; s < r; s++)(i = t[s]) == null || i.call(t, ...e)
      }
      on(n, e) {
         var t;
         return (t = this.events[n]) != null && t.push(e) || (this.events[n] = [e]), () => {
            var i;
            this.events[n] = (i = this.events[n]) == null ? void 0 : i.filter(s => e !== s)
         }
      }
      off(n, e) {
         var t;
         this.events[n] = (t = this.events[n]) == null ? void 0 : t.filter(i => e !== i)
      }
      destroy() {
         this.events = {}
      }
   },
   vU = 100 / 6,
   Hf = {
      passive: !1
   },
   Rte = class {
      constructor(n, e = {
         wheelMultiplier: 1,
         touchMultiplier: 1
      }) {
         Ut(this, "touchStart", {
            x: 0,
            y: 0
         });
         Ut(this, "lastDelta", {
            x: 0,
            y: 0
         });
         Ut(this, "window", {
            width: 0,
            height: 0
         });
         Ut(this, "emitter", new Z4);
         Ut(this, "onTouchStart", n => {
            const {
               clientX: e,
               clientY: t
            } = n.targetTouches ? n.targetTouches[0] : n;
            this.touchStart.x = e, this.touchStart.y = t, this.lastDelta = {
               x: 0,
               y: 0
            }, this.emitter.emit("scroll", {
               deltaX: 0,
               deltaY: 0,
               event: n
            })
         });
         Ut(this, "onTouchMove", n => {
            const {
               clientX: e,
               clientY: t
            } = n.targetTouches ? n.targetTouches[0] : n, i = -(e - this.touchStart.x) * this.options.touchMultiplier, s = -(t - this.touchStart.y) * this.options.touchMultiplier;
            this.touchStart.x = e, this.touchStart.y = t, this.lastDelta = {
               x: i,
               y: s
            }, this.emitter.emit("scroll", {
               deltaX: i,
               deltaY: s,
               event: n
            })
         });
         Ut(this, "onTouchEnd", n => {
            this.emitter.emit("scroll", {
               deltaX: this.lastDelta.x,
               deltaY: this.lastDelta.y,
               event: n
            })
         });
         Ut(this, "onWheel", n => {
            let {
               deltaX: e,
               deltaY: t,
               deltaMode: i
            } = n;
            const s = i === 1 ? vU : i === 2 ? this.window.width : 1,
               r = i === 1 ? vU : i === 2 ? this.window.height : 1;
            e *= s, t *= r, e *= this.options.wheelMultiplier, t *= this.options.wheelMultiplier, this.emitter.emit("scroll", {
               deltaX: e,
               deltaY: t,
               event: n
            })
         });
         Ut(this, "onWindowResize", () => {
            this.window = {
               width: window.innerWidth,
               height: window.innerHeight
            }
         });
         this.element = n, this.options = e, window.addEventListener("resize", this.onWindowResize, !1), this.onWindowResize(), this.element.addEventListener("wheel", this.onWheel, Hf), this.element.addEventListener("touchstart", this.onTouchStart, Hf), this.element.addEventListener("touchmove", this.onTouchMove, Hf), this.element.addEventListener("touchend", this.onTouchEnd, Hf)
      }
      on(n, e) {
         return this.emitter.on(n, e)
      }
      destroy() {
         this.emitter.destroy(), window.removeEventListener("resize", this.onWindowResize, !1), this.element.removeEventListener("wheel", this.onWheel, Hf), this.element.removeEventListener("touchstart", this.onTouchStart, Hf), this.element.removeEventListener("touchmove", this.onTouchMove, Hf), this.element.removeEventListener("touchend", this.onTouchEnd, Hf)
      }
   },
   yU = n => Math.min(1, 1.001 - Math.pow(2, -10 * n)),
   Cte = class {
      constructor({
         wrapper: n = window,
         content: e = document.documentElement,
         eventsTarget: t = n,
         smoothWheel: i = !0,
         syncTouch: s = !1,
         syncTouchLerp: r = .075,
         touchInertiaMultiplier: a = 35,
         duration: l,
         easing: c,
         lerp: h = .1,
         infinite: m = !1,
         orientation: g = "vertical",
         gestureOrientation: v = "vertical",
         touchMultiplier: x = 1,
         wheelMultiplier: S = 1,
         autoResize: E = !0,
         prevent: T,
         virtualScroll: b,
         overscroll: w = !0,
         autoRaf: C = !1,
         anchors: N = !1,
         autoToggle: U = !1,
         allowNestedScroll: z = !1,
         __experimental__naiveDimensions: B = !1
      } = {}) {
         Ut(this, "_isScrolling", !1);
         Ut(this, "_isStopped", !1);
         Ut(this, "_isLocked", !1);
         Ut(this, "_preventNextNativeScrollEvent", !1);
         Ut(this, "_resetVelocityTimeout", null);
         Ut(this, "__rafID", null);
         Ut(this, "isTouching");
         Ut(this, "time", 0);
         Ut(this, "userData", {});
         Ut(this, "lastVelocity", 0);
         Ut(this, "velocity", 0);
         Ut(this, "direction", 0);
         Ut(this, "options");
         Ut(this, "targetScroll");
         Ut(this, "animatedScroll");
         Ut(this, "animate", new Mte);
         Ut(this, "emitter", new Z4);
         Ut(this, "dimensions");
         Ut(this, "virtualScroll");
         Ut(this, "onScrollEnd", n => {
            n instanceof CustomEvent || (this.isScrolling === "smooth" || this.isScrolling === !1) && n.stopPropagation()
         });
         Ut(this, "dispatchScrollendEvent", () => {
            this.options.wrapper.dispatchEvent(new CustomEvent("scrollend", {
               bubbles: this.options.wrapper === window,
               detail: {
                  lenisScrollEnd: !0
               }
            }))
         });
         Ut(this, "onTransitionEnd", n => {
            if (n.propertyName.includes("overflow")) {
               const e = this.isHorizontal ? "overflow-x" : "overflow-y",
                  t = getComputedStyle(this.rootElement)[e];
               ["hidden", "clip"].includes(t) ? this.stop() : this.start()
            }
         });
         Ut(this, "onClick", n => {
            const t = n.composedPath().find(i => {
               var s, r, a;
               return i instanceof HTMLAnchorElement && (((s = i.getAttribute("href")) == null ? void 0 : s.startsWith("#")) || ((r = i.getAttribute("href")) == null ? void 0 : r.startsWith("/#")) || ((a = i.getAttribute("href")) == null ? void 0 : a.startsWith("./#")))
            });
            if (t) {
               const i = t.getAttribute("href");
               if (i) {
                  const s = typeof this.options.anchors == "object" && this.options.anchors ? this.options.anchors : void 0;
                  let r = `#${i.split("#")[1]}`;
                  ["#", "/#", "./#", "#top", "/#top", "./#top"].includes(i) && (r = 0), this.scrollTo(r, s)
               }
            }
         });
         Ut(this, "onPointerDown", n => {
            n.button === 1 && this.reset()
         });
         Ut(this, "onVirtualScroll", n => {
            if (typeof this.options.virtualScroll == "function" && this.options.virtualScroll(n) === !1) return;
            const {
               deltaX: e,
               deltaY: t,
               event: i
            } = n;
            if (this.emitter.emit("virtual-scroll", {
                  deltaX: e,
                  deltaY: t,
                  event: i
               }), i.ctrlKey || i.lenisStopPropagation) return;
            const s = i.type.includes("touch"),
               r = i.type.includes("wheel");
            this.isTouching = i.type === "touchstart" || i.type === "touchmove";
            const a = e === 0 && t === 0;
            if (this.options.syncTouch && s && i.type === "touchstart" && a && !this.isStopped && !this.isLocked) {
               this.reset();
               return
            }
            const c = this.options.gestureOrientation === "vertical" && t === 0 || this.options.gestureOrientation === "horizontal" && e === 0;
            if (a || c) return;
            let h = i.composedPath();
            h = h.slice(0, h.indexOf(this.rootElement));
            const m = this.options.prevent;
            if (h.find(T => {
                  var b, w, C;
                  return T instanceof HTMLElement && (typeof m == "function" && (m == null ? void 0 : m(T)) || ((b = T.hasAttribute) == null ? void 0 : b.call(T, "data-lenis-prevent")) || s && ((w = T.hasAttribute) == null ? void 0 : w.call(T, "data-lenis-prevent-touch")) || r && ((C = T.hasAttribute) == null ? void 0 : C.call(T, "data-lenis-prevent-wheel")) || this.options.allowNestedScroll && this.checkNestedScroll(T, {
                     deltaX: e,
                     deltaY: t
                  }))
               })) return;
            if (this.isStopped || this.isLocked) {
               i.preventDefault();
               return
            }
            if (!(this.options.syncTouch && s || this.options.smoothWheel && r)) {
               this.isScrolling = "native", this.animate.stop(), i.lenisStopPropagation = !0;
               return
            }
            let v = t;
            this.options.gestureOrientation === "both" ? v = Math.abs(t) > Math.abs(e) ? t : e : this.options.gestureOrientation === "horizontal" && (v = e), (!this.options.overscroll || this.options.infinite || this.options.wrapper !== window && (this.animatedScroll > 0 && this.animatedScroll < this.limit || this.animatedScroll === 0 && t > 0 || this.animatedScroll === this.limit && t < 0)) && (i.lenisStopPropagation = !0), i.preventDefault();
            const x = s && this.options.syncTouch,
               E = s && i.type === "touchend" && Math.abs(v) > 5;
            E && (v = this.velocity * this.options.touchInertiaMultiplier), this.scrollTo(this.targetScroll + v, {
               programmatic: !1,
               ...x ? {
                  lerp: E ? this.options.syncTouchLerp : 1
               } : {
                  lerp: this.options.lerp,
                  duration: this.options.duration,
                  easing: this.options.easing
               }
            })
         });
         Ut(this, "onNativeScroll", () => {
            if (this._resetVelocityTimeout !== null && (clearTimeout(this._resetVelocityTimeout), this._resetVelocityTimeout = null), this._preventNextNativeScrollEvent) {
               this._preventNextNativeScrollEvent = !1;
               return
            }
            if (this.isScrolling === !1 || this.isScrolling === "native") {
               const n = this.animatedScroll;
               this.animatedScroll = this.targetScroll = this.actualScroll, this.lastVelocity = this.velocity, this.velocity = this.animatedScroll - n, this.direction = Math.sign(this.animatedScroll - n), this.isStopped || (this.isScrolling = "native"), this.emit(), this.velocity !== 0 && (this._resetVelocityTimeout = setTimeout(() => {
                  this.lastVelocity = this.velocity, this.velocity = 0, this.isScrolling = !1, this.emit()
               }, 400))
            }
         });
         Ut(this, "raf", n => {
            const e = n - (this.time || n);
            this.time = n, this.animate.advance(e * .001), this.options.autoRaf && (this.__rafID = requestAnimationFrame(this.raf))
         });
         window.lenisVersion = Ste, (!n || n === document.documentElement) && (n = window), typeof l == "number" && typeof c != "function" ? c = yU : typeof c == "function" && typeof l != "number" && (l = 1), this.options = {
            wrapper: n,
            content: e,
            eventsTarget: t,
            smoothWheel: i,
            syncTouch: s,
            syncTouchLerp: r,
            touchInertiaMultiplier: a,
            duration: l,
            easing: c,
            lerp: h,
            infinite: m,
            gestureOrientation: v,
            orientation: g,
            touchMultiplier: x,
            wheelMultiplier: S,
            autoResize: E,
            prevent: T,
            virtualScroll: b,
            overscroll: w,
            autoRaf: C,
            anchors: N,
            autoToggle: U,
            allowNestedScroll: z,
            __experimental__naiveDimensions: B
         }, this.dimensions = new wte(n, e, {
            autoResize: E
         }), this.updateClassName(), this.targetScroll = this.animatedScroll = this.actualScroll, this.options.wrapper.addEventListener("scroll", this.onNativeScroll, !1), this.options.wrapper.addEventListener("scrollend", this.onScrollEnd, {
            capture: !0
         }), this.options.anchors && this.options.wrapper === window && this.options.wrapper.addEventListener("click", this.onClick, !1), this.options.wrapper.addEventListener("pointerdown", this.onPointerDown, !1), this.virtualScroll = new Rte(t, {
            touchMultiplier: x,
            wheelMultiplier: S
         }), this.virtualScroll.on("scroll", this.onVirtualScroll), this.options.autoToggle && this.rootElement.addEventListener("transitionend", this.onTransitionEnd, {
            passive: !0
         }), this.options.autoRaf && (this.__rafID = requestAnimationFrame(this.raf))
      }
      destroy() {
         this.emitter.destroy(), this.options.wrapper.removeEventListener("scroll", this.onNativeScroll, !1), this.options.wrapper.removeEventListener("scrollend", this.onScrollEnd, {
            capture: !0
         }), this.options.wrapper.removeEventListener("pointerdown", this.onPointerDown, !1), this.options.anchors && this.options.wrapper === window && this.options.wrapper.removeEventListener("click", this.onClick, !1), this.virtualScroll.destroy(), this.dimensions.destroy(), this.cleanUpClassName(), this.__rafID && cancelAnimationFrame(this.__rafID)
      }
      on(n, e) {
         return this.emitter.on(n, e)
      }
      off(n, e) {
         return this.emitter.off(n, e)
      }
      setScroll(n) {
         this.isHorizontal ? this.options.wrapper.scrollTo({
            left: n,
            behavior: "instant"
         }) : this.options.wrapper.scrollTo({
            top: n,
            behavior: "instant"
         })
      }
      resize() {
         this.dimensions.resize(), this.animatedScroll = this.targetScroll = this.actualScroll, this.emit()
      }
      emit() {
         this.emitter.emit("scroll", this)
      }
      reset() {
         this.isLocked = !1, this.isScrolling = !1, this.animatedScroll = this.targetScroll = this.actualScroll, this.lastVelocity = this.velocity = 0, this.animate.stop()
      }
      start() {
         this.isStopped && (this.reset(), this.isStopped = !1, this.emit())
      }
      stop() {
         this.isStopped || (this.reset(), this.isStopped = !0, this.emit())
      }
      scrollTo(n, {
         offset: e = 0,
         immediate: t = !1,
         lock: i = !1,
         duration: s = this.options.duration,
         easing: r = this.options.easing,
         lerp: a = this.options.lerp,
         onStart: l,
         onComplete: c,
         force: h = !1,
         programmatic: m = !0,
         userData: g
      } = {}) {
         if (!((this.isStopped || this.isLocked) && !h)) {
            if (typeof n == "string" && ["top", "left", "start"].includes(n)) n = 0;
            else if (typeof n == "string" && ["bottom", "right", "end"].includes(n)) n = this.limit;
            else {
               let v;
               if (typeof n == "string" ? v = document.querySelector(n) : n instanceof HTMLElement && (n != null && n.nodeType) && (v = n), v) {
                  if (this.options.wrapper !== window) {
                     const S = this.rootElement.getBoundingClientRect();
                     e -= this.isHorizontal ? S.left : S.top
                  }
                  const x = v.getBoundingClientRect();
                  n = (this.isHorizontal ? x.left : x.top) + this.animatedScroll
               }
            }
            if (typeof n == "number") {
               if (n += e, n = Math.round(n), this.options.infinite) {
                  if (m) {
                     this.targetScroll = this.animatedScroll = this.scroll;
                     const v = n - this.animatedScroll;
                     v > this.limit / 2 ? n = n - this.limit : v < -this.limit / 2 && (n = n + this.limit)
                  }
               } else n = K4(0, n, this.limit);
               if (n === this.targetScroll) {
                  l == null || l(this), c == null || c(this);
                  return
               }
               if (this.userData = g ?? {}, t) {
                  this.animatedScroll = this.targetScroll = n, this.setScroll(this.scroll), this.reset(), this.preventNextNativeScrollEvent(), this.emit(), c == null || c(this), this.userData = {}, requestAnimationFrame(() => {
                     this.dispatchScrollendEvent()
                  });
                  return
               }
               m || (this.targetScroll = n), typeof s == "number" && typeof r != "function" ? r = yU : typeof r == "function" && typeof s != "number" && (s = 1), this.animate.fromTo(this.animatedScroll, n, {
                  duration: s,
                  easing: r,
                  lerp: a,
                  onStart: () => {
                     i && (this.isLocked = !0), this.isScrolling = "smooth", l == null || l(this)
                  },
                  onUpdate: (v, x) => {
                     this.isScrolling = "smooth", this.lastVelocity = this.velocity, this.velocity = v - this.animatedScroll, this.direction = Math.sign(this.velocity), this.animatedScroll = v, this.setScroll(this.scroll), m && (this.targetScroll = v), x || this.emit(), x && (this.reset(), this.emit(), c == null || c(this), this.userData = {}, requestAnimationFrame(() => {
                        this.dispatchScrollendEvent()
                     }), this.preventNextNativeScrollEvent())
                  }
               })
            }
         }
      }
      preventNextNativeScrollEvent() {
         this._preventNextNativeScrollEvent = !0, requestAnimationFrame(() => {
            this._preventNextNativeScrollEvent = !1
         })
      }
      checkNestedScroll(n, {
         deltaX: e,
         deltaY: t
      }) {
         const i = Date.now(),
            s = n._lenis ?? (n._lenis = {});
         let r, a, l, c, h, m, g, v;
         const x = this.options.gestureOrientation;
         if (i - (s.time ?? 0) > 2e3) {
            s.time = Date.now();
            const U = window.getComputedStyle(n);
            s.computedStyle = U;
            const z = U.overflowX,
               B = U.overflowY;
            if (r = ["auto", "overlay", "scroll"].includes(z), a = ["auto", "overlay", "scroll"].includes(B), s.hasOverflowX = r, s.hasOverflowY = a, !r && !a || x === "vertical" && !a || x === "horizontal" && !r) return !1;
            h = n.scrollWidth, m = n.scrollHeight, g = n.clientWidth, v = n.clientHeight, l = h > g, c = m > v, s.isScrollableX = l, s.isScrollableY = c, s.scrollWidth = h, s.scrollHeight = m, s.clientWidth = g, s.clientHeight = v
         } else l = s.isScrollableX, c = s.isScrollableY, r = s.hasOverflowX, a = s.hasOverflowY, h = s.scrollWidth, m = s.scrollHeight, g = s.clientWidth, v = s.clientHeight;
         if (!r && !a || !l && !c || x === "vertical" && (!a || !c) || x === "horizontal" && (!r || !l)) return !1;
         let S;
         if (x === "horizontal") S = "x";
         else if (x === "vertical") S = "y";
         else {
            const U = e !== 0,
               z = t !== 0;
            U && r && l && (S = "x"), z && a && c && (S = "y")
         }
         if (!S) return !1;
         let E, T, b, w, C;
         if (S === "x") E = n.scrollLeft, T = h - g, b = e, w = r, C = l;
         else if (S === "y") E = n.scrollTop, T = m - v, b = t, w = a, C = c;
         else return !1;
         return (b > 0 ? E < T : E > 0) && w && C
      }
      get rootElement() {
         return this.options.wrapper === window ? document.documentElement : this.options.wrapper
      }
      get limit() {
         return this.options.__experimental__naiveDimensions ? this.isHorizontal ? this.rootElement.scrollWidth - this.rootElement.clientWidth : this.rootElement.scrollHeight - this.rootElement.clientHeight : this.dimensions.limit[this.isHorizontal ? "x" : "y"]
      }
      get isHorizontal() {
         return this.options.orientation === "horizontal"
      }
      get actualScroll() {
         const n = this.options.wrapper;
         return this.isHorizontal ? n.scrollX ?? n.scrollLeft : n.scrollY ?? n.scrollTop
      }
      get scroll() {
         return this.options.infinite ? Ete(this.animatedScroll, this.limit) : this.animatedScroll
      }
      get progress() {
         return this.limit === 0 ? 1 : this.scroll / this.limit
      }
      get isScrolling() {
         return this._isScrolling
      }
      set isScrolling(n) {
         this._isScrolling !== n && (this._isScrolling = n, this.updateClassName())
      }
      get isStopped() {
         return this._isStopped
      }
      set isStopped(n) {
         this._isStopped !== n && (this._isStopped = n, this.updateClassName())
      }
      get isLocked() {
         return this._isLocked
      }
      set isLocked(n) {
         this._isLocked !== n && (this._isLocked = n, this.updateClassName())
      }
      get isSmooth() {
         return this.isScrolling === "smooth"
      }
      get className() {
         let n = "lenis";
         return this.options.autoToggle && (n += " lenis-autoToggle"), this.isStopped && (n += " lenis-stopped"), this.isLocked && (n += " lenis-locked"), this.isScrolling && (n += " lenis-scrolling"), this.isScrolling === "smooth" && (n += " lenis-smooth"), n
      }
      updateClassName() {
         this.cleanUpClassName(), this.rootElement.className = `${this.rootElement.className} ${this.className}`.trim()
      }
      cleanUpClassName() {
         this.rootElement.className = this.rootElement.className.replace(/lenis(-\w+)?/g, "").trim()
      }
   };

function Dte(n) {
   j.useEffect(() => {
      if (!n.current) return;
      Il.current = new Cte({
         wrapper: window,
         content: n.current,
         duration: 1.2,
         smooth: !0,
         syncTouch: !0
      });
      const e = t => {
         var i;
         (i = Il.current) == null || i.raf(t), requestAnimationFrame(e)
      };
      return requestAnimationFrame(e), () => {
         var t;
         (t = Il.current) == null || t.destroy(), Il.current = null
      }
   }, [n])
}
let Xw = null,
   Pb = null;

function Nte(n) {
   Xw = n
}

function Ote() {
   const n = Xw;
   return Xw = null, n
}

function Ute(n) {
   Pb = n
}

function Pte() {
   Pb && (Pb(), Pb = null)
}

function Lte({
   shouldPlay: n,
   activeTarget: e,
   activeSecondaryTarget1: t,
   activeSecondaryTarget2: i
}) {
   const s = j.useRef();
   Dte(s);
   const [r, a] = j.useState({
      section1: !1,
      section2: !1,
      section3: !1,
      section4: !1,
      section5: !1,
      section6: !1,
      section7: !1
   }), [l, c] = j.useState({
      sub11: !1,
      sub12: !1,
      sub13: !1
   }), [h, m] = j.useState({
      sub21: !1,
      sub22: !1,
      sub23: !1
   }), [g, v] = j.useState(null);
   return j.useEffect(() => {
      if (e && r.hasOwnProperty(e)) {
         const x = Object.keys(r).find(S => r[S]);
         e === "section7" && v(x), a({
            section1: !1,
            section2: !1,
            section3: !1,
            section4: !1,
            section5: !1,
            section6: !1,
            section7: !1,
            [e]: !0
         })
      }
   }, [e]), j.useEffect(() => {
      c({
         sub11: !1,
         sub12: !1,
         sub13: !1
      }), t && l.hasOwnProperty(t) && c(x => ({
         ...x,
         [t]: !0
      }))
   }, [t]), j.useEffect(() => {
      m({
         sub21: !1,
         sub22: !1,
         sub23: !1
      }), i && h.hasOwnProperty(i) && m(x => ({
         ...x,
         [i]: !0
      }))
   }, [i]), j.useEffect(() => {
      const x = setInterval(() => {
         var b;
         const S = Ote(),
            E = Il.current,
            T = (b = E == null ? void 0 : E.options) == null ? void 0 : b.content;
         if (S !== null && T && T.scrollHeight > 0) {
            const C = (T.scrollHeight - window.innerHeight) * S;
            E.scrollTo(C), clearInterval(x)
         }
      }, 50);
      return Pte(), () => clearInterval(x)
   }, []), H.jsx(H.Fragment, {
      children: H.jsxs("div", {
         className: "scroll-container",
         ref: s,
         children: [H.jsx("div", {
            className: `animated-main ${r.section1?"visible":""}`,
            children: H.jsx(gte, {})
         }), H.jsx("div", {
            className: `animated-step ${l.sub11?"visible":""}`,
            children: H.jsx(yte, {})
         }), H.jsx("div", {
            className: `animated-text about ${r.section2?"visible":""}`,
            children: H.jsx(vte, {
               shouldPlay: n
            })
         }), H.jsx("div", {
            className: `animated-step ${h.sub21?"visible":""}`,
            children: H.jsx(xte, {})
         }), H.jsx("div", {
            className: `animated-text ${r.section3?"visible":""}`,
            children: H.jsx(dte, {
               shouldPlay: n
            })
         }), H.jsx("div", {
            className: `animated-text ${r.section4?"visible":""}`,
            children: H.jsx(pte, {
               shouldPlay: n
            })
         }), H.jsx("div", {
            className: `animated-text ${r.section5?"visible":""}`,
            children: H.jsx(mte, {
               shouldPlay: n
            })
         }), H.jsx("div", {
            className: `animated-text ${r.section6?"visible":""}`,
            children: H.jsx(_te, {})
         }), H.jsx("div", {
            className: `animated-main ${r.section6?"visible":""}`,
            children: H.jsx(Y4, {
               shouldPlay: n
            })
         }), H.jsx("div", {
            className: `animated-form ${r.section7?"visible":""}`,
            children: H.jsx(WT, {
               shouldPlay: n
            })
         })]
      })
   })
}

function xU({
   setShouldPlay: n,
   shouldPlay: e
}) {
   const [t, i] = j.useState(null), [s, r] = j.useState(null), [a, l] = j.useState(null), c = u2(x => x.setPlanetClicked), h = il(), {
      progress: m
   } = EW(), [g, v] = j.useState(!1);
   return j.useEffect(() => {
      if (m === 100) {
         const x = setTimeout(() => v(!0), 300);
         return () => clearTimeout(x)
      }
   }, [m]), j.useEffect(() => {
      const x = () => {
         n(!0), window.removeEventListener("click", x)
      };
      return window.addEventListener("click", x), () => window.removeEventListener("click", x)
   }, []), j.useEffect(() => {
      c(!1)
   }, [h.pathname]), H.jsxs(H.Fragment, {
      children: [H.jsx(aJ, {
         componentProgress: m,
         isThreeLoaded: g
      }), H.jsx(PT, {
         pageKey: "home"
      }), H.jsx(YX, {
         dpr: [1, 1.5],
         camera: {
            position: [0, 0, 6]
         },
         gl: {
            powerPreference: "high-performance",
            preserveDrawingBuffer: !1,
            toneMapping: ho,
            outputColorSpace: En,
            antialias: !0
         },
         onCreated: ({
            gl: x
         }) => {
            console.log(" WebGL context created"), x.setClearColor(new dt("#000000")), x.outputColorSpace = En, x.toneMapping = ho
         },
         style: {
            width: "100vw",
            height: "100svh",
            position: "fixed",
            zIndex: 1
         },
         children: H.jsxs(j.Suspense, {
            fallback: null,
            children: [H.jsx(b$, {
               onTargetChange: i,
               onSecondaryTarget1Change: r,
               onSecondaryTarget2Change: l
            }), H.jsx(ste, {
               shouldPlay: e,
               setShouldPlay: n
            })]
         })
      }), H.jsx(Lte, {
         activeTarget: t,
         activeSecondaryTarget1: s,
         activeSecondaryTarget2: a,
         shouldPlay: e
      }), H.jsx("div", {
         id: "fade-overlay",
         style: {
            position: "fixed",
            top: 0,
            left: 0,
            width: "100vw",
            height: "100vh",
            backgroundColor: "#090909",
            opacity: 0,
            pointerEvents: "none",
            zIndex: 9999
         }
      })]
   })
}

function Q4(n, e) {
   return function () {
      return n.apply(e, arguments)
   }
}
const {
   toString: Bte
} = Object.prototype, {
   getPrototypeOf: hC
} = Object, {
   iterator: YT,
   toStringTag: J4
} = Symbol, KT = (n => e => {
   const t = Bte.call(e);
   return n[t] || (n[t] = t.slice(8, -1).toLowerCase())
})(Object.create(null)), ql = n => (n = n.toLowerCase(), e => KT(e) === n), ZT = n => e => typeof e === n, {
   isArray: Gg
} = Array, ix = ZT("undefined");

function zte(n) {
   return n !== null && !ix(n) && n.constructor !== null && !ix(n.constructor) && Va(n.constructor.isBuffer) && n.constructor.isBuffer(n)
}
const $4 = ql("ArrayBuffer");

function Ite(n) {
   let e;
   return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? e = ArrayBuffer.isView(n) : e = n && n.buffer && $4(n.buffer), e
}
const Fte = ZT("string"),
   Va = ZT("function"),
   eF = ZT("number"),
   QT = n => n !== null && typeof n == "object",
   Hte = n => n === !0 || n === !1,
   Lb = n => {
      if (KT(n) !== "object") return !1;
      const e = hC(n);
      return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(J4 in n) && !(YT in n)
   },
   Vte = ql("Date"),
   Gte = ql("File"),
   kte = ql("Blob"),
   jte = ql("FileList"),
   qte = n => QT(n) && Va(n.pipe),
   Xte = n => {
      let e;
      return n && (typeof FormData == "function" && n instanceof FormData || Va(n.append) && ((e = KT(n)) === "formdata" || e === "object" && Va(n.toString) && n.toString() === "[object FormData]"))
   },
   Wte = ql("URLSearchParams"),
   [Yte, Kte, Zte, Qte] = ["ReadableStream", "Request", "Response", "Headers"].map(ql),
   Jte = n => n.trim ? n.trim() : n.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");

function Dx(n, e, {
   allOwnKeys: t = !1
} = {}) {
   if (n === null || typeof n > "u") return;
   let i, s;
   if (typeof n != "object" && (n = [n]), Gg(n))
      for (i = 0, s = n.length; i < s; i++) e.call(null, n[i], i, n);
   else {
      const r = t ? Object.getOwnPropertyNames(n) : Object.keys(n),
         a = r.length;
      let l;
      for (i = 0; i < a; i++) l = r[i], e.call(null, n[l], l, n)
   }
}

function tF(n, e) {
   e = e.toLowerCase();
   const t = Object.keys(n);
   let i = t.length,
      s;
   for (; i-- > 0;)
      if (s = t[i], e === s.toLowerCase()) return s;
   return null
}
const zd = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global,
   nF = n => !ix(n) && n !== zd;

function Ww() {
   const {
      caseless: n
   } = nF(this) && this || {}, e = {}, t = (i, s) => {
      const r = n && tF(e, s) || s;
      Lb(e[r]) && Lb(i) ? e[r] = Ww(e[r], i) : Lb(i) ? e[r] = Ww({}, i) : Gg(i) ? e[r] = i.slice() : e[r] = i
   };
   for (let i = 0, s = arguments.length; i < s; i++) arguments[i] && Dx(arguments[i], t);
   return e
}
const $te = (n, e, t, {
      allOwnKeys: i
   } = {}) => (Dx(e, (s, r) => {
      t && Va(s) ? n[r] = Q4(s, t) : n[r] = s
   }, {
      allOwnKeys: i
   }), n),
   ene = n => (n.charCodeAt(0) === 65279 && (n = n.slice(1)), n),
   tne = (n, e, t, i) => {
      n.prototype = Object.create(e.prototype, i), n.prototype.constructor = n, Object.defineProperty(n, "super", {
         value: e.prototype
      }), t && Object.assign(n.prototype, t)
   },
   nne = (n, e, t, i) => {
      let s, r, a;
      const l = {};
      if (e = e || {}, n == null) return e;
      do {
         for (s = Object.getOwnPropertyNames(n), r = s.length; r-- > 0;) a = s[r], (!i || i(a, n, e)) && !l[a] && (e[a] = n[a], l[a] = !0);
         n = t !== !1 && hC(n)
      } while (n && (!t || t(n, e)) && n !== Object.prototype);
      return e
   },
   ine = (n, e, t) => {
      n = String(n), (t === void 0 || t > n.length) && (t = n.length), t -= e.length;
      const i = n.indexOf(e, t);
      return i !== -1 && i === t
   },
   sne = n => {
      if (!n) return null;
      if (Gg(n)) return n;
      let e = n.length;
      if (!eF(e)) return null;
      const t = new Array(e);
      for (; e-- > 0;) t[e] = n[e];
      return t
   },
   rne = (n => e => n && e instanceof n)(typeof Uint8Array < "u" && hC(Uint8Array)),
   ane = (n, e) => {
      const i = (n && n[YT]).call(n);
      let s;
      for (;
         (s = i.next()) && !s.done;) {
         const r = s.value;
         e.call(n, r[0], r[1])
      }
   },
   one = (n, e) => {
      let t;
      const i = [];
      for (;
         (t = n.exec(e)) !== null;) i.push(t);
      return i
   },
   lne = ql("HTMLFormElement"),
   une = n => n.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function (t, i, s) {
      return i.toUpperCase() + s
   }),
   _U = (({
      hasOwnProperty: n
   }) => (e, t) => n.call(e, t))(Object.prototype),
   cne = ql("RegExp"),
   iF = (n, e) => {
      const t = Object.getOwnPropertyDescriptors(n),
         i = {};
      Dx(t, (s, r) => {
         let a;
         (a = e(s, r, n)) !== !1 && (i[r] = a || s)
      }), Object.defineProperties(n, i)
   },
   fne = n => {
      iF(n, (e, t) => {
         if (Va(n) && ["arguments", "caller", "callee"].indexOf(t) !== -1) return !1;
         const i = n[t];
         if (Va(i)) {
            if (e.enumerable = !1, "writable" in e) {
               e.writable = !1;
               return
            }
            e.set || (e.set = () => {
               throw Error("Can not rewrite read-only method '" + t + "'")
            })
         }
      })
   },
   hne = (n, e) => {
      const t = {},
         i = s => {
            s.forEach(r => {
               t[r] = !0
            })
         };
      return Gg(n) ? i(n) : i(String(n).split(e)), t
   },
   dne = () => {},
   pne = (n, e) => n != null && Number.isFinite(n = +n) ? n : e;

function mne(n) {
   return !!(n && Va(n.append) && n[J4] === "FormData" && n[YT])
}
const gne = n => {
      const e = new Array(10),
         t = (i, s) => {
            if (QT(i)) {
               if (e.indexOf(i) >= 0) return;
               if (!("toJSON" in i)) {
                  e[s] = i;
                  const r = Gg(i) ? [] : {};
                  return Dx(i, (a, l) => {
                     const c = t(a, s + 1);
                     !ix(c) && (r[l] = c)
                  }), e[s] = void 0, r
               }
            }
            return i
         };
      return t(n, 0)
   },
   vne = ql("AsyncFunction"),
   yne = n => n && (QT(n) || Va(n)) && Va(n.then) && Va(n.catch),
   sF = ((n, e) => n ? setImmediate : e ? ((t, i) => (zd.addEventListener("message", ({
      source: s,
      data: r
   }) => {
      s === zd && r === t && i.length && i.shift()()
   }, !1), s => {
      i.push(s), zd.postMessage(t, "*")
   }))(`axios@${Math.random()}`, []) : t => setTimeout(t))(typeof setImmediate == "function", Va(zd.postMessage)),
   xne = typeof queueMicrotask < "u" ? queueMicrotask.bind(zd) : typeof process < "u" && process.nextTick || sF,
   _ne = n => n != null && Va(n[YT]),
   Le = {
      isArray: Gg,
      isArrayBuffer: $4,
      isBuffer: zte,
      isFormData: Xte,
      isArrayBufferView: Ite,
      isString: Fte,
      isNumber: eF,
      isBoolean: Hte,
      isObject: QT,
      isPlainObject: Lb,
      isReadableStream: Yte,
      isRequest: Kte,
      isResponse: Zte,
      isHeaders: Qte,
      isUndefined: ix,
      isDate: Vte,
      isFile: Gte,
      isBlob: kte,
      isRegExp: cne,
      isFunction: Va,
      isStream: qte,
      isURLSearchParams: Wte,
      isTypedArray: rne,
      isFileList: jte,
      forEach: Dx,
      merge: Ww,
      extend: $te,
      trim: Jte,
      stripBOM: ene,
      inherits: tne,
      toFlatObject: nne,
      kindOf: KT,
      kindOfTest: ql,
      endsWith: ine,
      toArray: sne,
      forEachEntry: ane,
      matchAll: one,
      isHTMLForm: lne,
      hasOwnProperty: _U,
      hasOwnProp: _U,
      reduceDescriptors: iF,
      freezeMethods: fne,
      toObjectSet: hne,
      toCamelCase: une,
      noop: dne,
      toFiniteNumber: pne,
      findKey: tF,
      global: zd,
      isContextDefined: nF,
      isSpecCompliantForm: mne,
      toJSONObject: gne,
      isAsyncFn: vne,
      isThenable: yne,
      setImmediate: sF,
      asap: xne,
      isIterable: _ne
   };

function dn(n, e, t, i, s) {
   Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = n, this.name = "AxiosError", e && (this.code = e), t && (this.config = t), i && (this.request = i), s && (this.response = s, this.status = s.status ? s.status : null)
}
Le.inherits(dn, Error, {
   toJSON: function () {
      return {
         message: this.message,
         name: this.name,
         description: this.description,
         number: this.number,
         fileName: this.fileName,
         lineNumber: this.lineNumber,
         columnNumber: this.columnNumber,
         stack: this.stack,
         config: Le.toJSONObject(this.config),
         code: this.code,
         status: this.status
      }
   }
});
const rF = dn.prototype,
   aF = {};
["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach(n => {
   aF[n] = {
      value: n
   }
});
Object.defineProperties(dn, aF);
Object.defineProperty(rF, "isAxiosError", {
   value: !0
});
dn.from = (n, e, t, i, s, r) => {
   const a = Object.create(rF);
   return Le.toFlatObject(n, a, function (c) {
      return c !== Error.prototype
   }, l => l !== "isAxiosError"), dn.call(a, n.message, e, t, i, s), a.cause = n, a.name = n.name, r && Object.assign(a, r), a
};
const Sne = null;

function Yw(n) {
   return Le.isPlainObject(n) || Le.isArray(n)
}

function oF(n) {
   return Le.endsWith(n, "[]") ? n.slice(0, -2) : n
}

function SU(n, e, t) {
   return n ? n.concat(e).map(function (s, r) {
      return s = oF(s), !t && r ? "[" + s + "]" : s
   }).join(t ? "." : "") : e
}

function bne(n) {
   return Le.isArray(n) && !n.some(Yw)
}
const Tne = Le.toFlatObject(Le, {}, null, function (e) {
   return /^is[A-Z]/.test(e)
});

function JT(n, e, t) {
   if (!Le.isObject(n)) throw new TypeError("target must be an object");
   e = e || new FormData, t = Le.toFlatObject(t, {
      metaTokens: !0,
      dots: !1,
      indexes: !1
   }, !1, function (E, T) {
      return !Le.isUndefined(T[E])
   });
   const i = t.metaTokens,
      s = t.visitor || m,
      r = t.dots,
      a = t.indexes,
      c = (t.Blob || typeof Blob < "u" && Blob) && Le.isSpecCompliantForm(e);
   if (!Le.isFunction(s)) throw new TypeError("visitor must be a function");

   function h(S) {
      if (S === null) return "";
      if (Le.isDate(S)) return S.toISOString();
      if (Le.isBoolean(S)) return S.toString();
      if (!c && Le.isBlob(S)) throw new dn("Blob is not supported. Use a Buffer instead.");
      return Le.isArrayBuffer(S) || Le.isTypedArray(S) ? c && typeof Blob == "function" ? new Blob([S]) : Buffer.from(S) : S
   }

   function m(S, E, T) {
      let b = S;
      if (S && !T && typeof S == "object") {
         if (Le.endsWith(E, "{}")) E = i ? E : E.slice(0, -2), S = JSON.stringify(S);
         else if (Le.isArray(S) && bne(S) || (Le.isFileList(S) || Le.endsWith(E, "[]")) && (b = Le.toArray(S))) return E = oF(E), b.forEach(function (C, N) {
            !(Le.isUndefined(C) || C === null) && e.append(a === !0 ? SU([E], N, r) : a === null ? E : E + "[]", h(C))
         }), !1
      }
      return Yw(S) ? !0 : (e.append(SU(T, E, r), h(S)), !1)
   }
   const g = [],
      v = Object.assign(Tne, {
         defaultVisitor: m,
         convertValue: h,
         isVisitable: Yw
      });

   function x(S, E) {
      if (!Le.isUndefined(S)) {
         if (g.indexOf(S) !== -1) throw Error("Circular reference detected in " + E.join("."));
         g.push(S), Le.forEach(S, function (b, w) {
            (!(Le.isUndefined(b) || b === null) && s.call(e, b, Le.isString(w) ? w.trim() : w, E, v)) === !0 && x(b, E ? E.concat(w) : [w])
         }), g.pop()
      }
   }
   if (!Le.isObject(n)) throw new TypeError("data must be an object");
   return x(n), e
}

function bU(n) {
   const e = {
      "!": "%21",
      "'": "%27",
      "(": "%28",
      ")": "%29",
      "~": "%7E",
      "%20": "+",
      "%00": "\0"
   };
   return encodeURIComponent(n).replace(/[!'()~]|%20|%00/g, function (i) {
      return e[i]
   })
}

function dC(n, e) {
   this._pairs = [], n && JT(n, this, e)
}
const lF = dC.prototype;
lF.append = function (e, t) {
   this._pairs.push([e, t])
};
lF.toString = function (e) {
   const t = e ? function (i) {
      return e.call(this, i, bU)
   } : bU;
   return this._pairs.map(function (s) {
      return t(s[0]) + "=" + t(s[1])
   }, "").join("&")
};

function Ene(n) {
   return encodeURIComponent(n).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]")
}

function uF(n, e, t) {
   if (!e) return n;
   const i = t && t.encode || Ene;
   Le.isFunction(t) && (t = {
      serialize: t
   });
   const s = t && t.serialize;
   let r;
   if (s ? r = s(e, t) : r = Le.isURLSearchParams(e) ? e.toString() : new dC(e, t).toString(i), r) {
      const a = n.indexOf("#");
      a !== -1 && (n = n.slice(0, a)), n += (n.indexOf("?") === -1 ? "?" : "&") + r
   }
   return n
}
class TU {
   constructor() {
      this.handlers = []
   }
   use(e, t, i) {
      return this.handlers.push({
         fulfilled: e,
         rejected: t,
         synchronous: i ? i.synchronous : !1,
         runWhen: i ? i.runWhen : null
      }), this.handlers.length - 1
   }
   eject(e) {
      this.handlers[e] && (this.handlers[e] = null)
   }
   clear() {
      this.handlers && (this.handlers = [])
   }
   forEach(e) {
      Le.forEach(this.handlers, function (i) {
         i !== null && e(i)
      })
   }
}
const cF = {
      silentJSONParsing: !0,
      forcedJSONParsing: !0,
      clarifyTimeoutError: !1
   },
   Mne = typeof URLSearchParams < "u" ? URLSearchParams : dC,
   Ane = typeof FormData < "u" ? FormData : null,
   wne = typeof Blob < "u" ? Blob : null,
   Rne = {
      isBrowser: !0,
      classes: {
         URLSearchParams: Mne,
         FormData: Ane,
         Blob: wne
      },
      protocols: ["http", "https", "file", "blob", "url", "data"]
   },
   pC = typeof window < "u" && typeof document < "u",
   Kw = typeof navigator == "object" && navigator || void 0,
   Cne = pC && (!Kw || ["ReactNative", "NativeScript", "NS"].indexOf(Kw.product) < 0),
   Dne = typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && typeof self.importScripts == "function",
   Nne = pC && window.location.href || "http://localhost",
   One = Object.freeze(Object.defineProperty({
      __proto__: null,
      hasBrowserEnv: pC,
      hasStandardBrowserEnv: Cne,
      hasStandardBrowserWebWorkerEnv: Dne,
      navigator: Kw,
      origin: Nne
   }, Symbol.toStringTag, {
      value: "Module"
   })),
   Ur = {
      ...One,
      ...Rne
   };

function Une(n, e) {
   return JT(n, new Ur.classes.URLSearchParams, Object.assign({
      visitor: function (t, i, s, r) {
         return Ur.isNode && Le.isBuffer(t) ? (this.append(i, t.toString("base64")), !1) : r.defaultVisitor.apply(this, arguments)
      }
   }, e))
}

function Pne(n) {
   return Le.matchAll(/\w+|\[(\w*)]/g, n).map(e => e[0] === "[]" ? "" : e[1] || e[0])
}

function Lne(n) {
   const e = {},
      t = Object.keys(n);
   let i;
   const s = t.length;
   let r;
   for (i = 0; i < s; i++) r = t[i], e[r] = n[r];
   return e
}

function fF(n) {
   function e(t, i, s, r) {
      let a = t[r++];
      if (a === "__proto__") return !0;
      const l = Number.isFinite(+a),
         c = r >= t.length;
      return a = !a && Le.isArray(s) ? s.length : a, c ? (Le.hasOwnProp(s, a) ? s[a] = [s[a], i] : s[a] = i, !l) : ((!s[a] || !Le.isObject(s[a])) && (s[a] = []), e(t, i, s[a], r) && Le.isArray(s[a]) && (s[a] = Lne(s[a])), !l)
   }
   if (Le.isFormData(n) && Le.isFunction(n.entries)) {
      const t = {};
      return Le.forEachEntry(n, (i, s) => {
         e(Pne(i), s, t, 0)
      }), t
   }
   return null
}

function Bne(n, e, t) {
   if (Le.isString(n)) try {
      return (e || JSON.parse)(n), Le.trim(n)
   } catch (i) {
      if (i.name !== "SyntaxError") throw i
   }
   return (t || JSON.stringify)(n)
}
const Nx = {
   transitional: cF,
   adapter: ["xhr", "http", "fetch"],
   transformRequest: [function (e, t) {
      const i = t.getContentType() || "",
         s = i.indexOf("application/json") > -1,
         r = Le.isObject(e);
      if (r && Le.isHTMLForm(e) && (e = new FormData(e)), Le.isFormData(e)) return s ? JSON.stringify(fF(e)) : e;
      if (Le.isArrayBuffer(e) || Le.isBuffer(e) || Le.isStream(e) || Le.isFile(e) || Le.isBlob(e) || Le.isReadableStream(e)) return e;
      if (Le.isArrayBufferView(e)) return e.buffer;
      if (Le.isURLSearchParams(e)) return t.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString();
      let l;
      if (r) {
         if (i.indexOf("application/x-www-form-urlencoded") > -1) return Une(e, this.formSerializer).toString();
         if ((l = Le.isFileList(e)) || i.indexOf("multipart/form-data") > -1) {
            const c = this.env && this.env.FormData;
            return JT(l ? {
               "files[]": e
            } : e, c && new c, this.formSerializer)
         }
      }
      return r || s ? (t.setContentType("application/json", !1), Bne(e)) : e
   }],
   transformResponse: [function (e) {
      const t = this.transitional || Nx.transitional,
         i = t && t.forcedJSONParsing,
         s = this.responseType === "json";
      if (Le.isResponse(e) || Le.isReadableStream(e)) return e;
      if (e && Le.isString(e) && (i && !this.responseType || s)) {
         const a = !(t && t.silentJSONParsing) && s;
         try {
            return JSON.parse(e)
         } catch (l) {
            if (a) throw l.name === "SyntaxError" ? dn.from(l, dn.ERR_BAD_RESPONSE, this, null, this.response) : l
         }
      }
      return e
   }],
   timeout: 0,
   xsrfCookieName: "XSRF-TOKEN",
   xsrfHeaderName: "X-XSRF-TOKEN",
   maxContentLength: -1,
   maxBodyLength: -1,
   env: {
      FormData: Ur.classes.FormData,
      Blob: Ur.classes.Blob
   },
   validateStatus: function (e) {
      return e >= 200 && e < 300
   },
   headers: {
      common: {
         Accept: "application/json, text/plain, */*",
         "Content-Type": void 0
      }
   }
};
Le.forEach(["delete", "get", "head", "post", "put", "patch"], n => {
   Nx.headers[n] = {}
});
const zne = Le.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]),
   Ine = n => {
      const e = {};
      let t, i, s;
      return n && n.split(`
`).forEach(function (a) {
         s = a.indexOf(":"), t = a.substring(0, s).trim().toLowerCase(), i = a.substring(s + 1).trim(), !(!t || e[t] && zne[t]) && (t === "set-cookie" ? e[t] ? e[t].push(i) : e[t] = [i] : e[t] = e[t] ? e[t] + ", " + i : i)
      }), e
   },
   EU = Symbol("internals");

function b0(n) {
   return n && String(n).trim().toLowerCase()
}

function Bb(n) {
   return n === !1 || n == null ? n : Le.isArray(n) ? n.map(Bb) : String(n)
}

function Fne(n) {
   const e = Object.create(null),
      t = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
   let i;
   for (; i = t.exec(n);) e[i[1]] = i[2];
   return e
}
const Hne = n => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(n.trim());

function MA(n, e, t, i, s) {
   if (Le.isFunction(i)) return i.call(this, e, t);
   if (s && (e = t), !!Le.isString(e)) {
      if (Le.isString(i)) return e.indexOf(i) !== -1;
      if (Le.isRegExp(i)) return i.test(e)
   }
}

function Vne(n) {
   return n.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, t, i) => t.toUpperCase() + i)
}

function Gne(n, e) {
   const t = Le.toCamelCase(" " + e);
   ["get", "set", "has"].forEach(i => {
      Object.defineProperty(n, i + t, {
         value: function (s, r, a) {
            return this[i].call(this, e, s, r, a)
         },
         configurable: !0
      })
   })
}
let Ga = class {
   constructor(e) {
      e && this.set(e)
   }
   set(e, t, i) {
      const s = this;

      function r(l, c, h) {
         const m = b0(c);
         if (!m) throw new Error("header name must be a non-empty string");
         const g = Le.findKey(s, m);
         (!g || s[g] === void 0 || h === !0 || h === void 0 && s[g] !== !1) && (s[g || c] = Bb(l))
      }
      const a = (l, c) => Le.forEach(l, (h, m) => r(h, m, c));
      if (Le.isPlainObject(e) || e instanceof this.constructor) a(e, t);
      else if (Le.isString(e) && (e = e.trim()) && !Hne(e)) a(Ine(e), t);
      else if (Le.isObject(e) && Le.isIterable(e)) {
         let l = {},
            c, h;
         for (const m of e) {
            if (!Le.isArray(m)) throw TypeError("Object iterator must return a key-value pair");
            l[h = m[0]] = (c = l[h]) ? Le.isArray(c) ? [...c, m[1]] : [c, m[1]] : m[1]
         }
         a(l, t)
      } else e != null && r(t, e, i);
      return this
   }
   get(e, t) {
      if (e = b0(e), e) {
         const i = Le.findKey(this, e);
         if (i) {
            const s = this[i];
            if (!t) return s;
            if (t === !0) return Fne(s);
            if (Le.isFunction(t)) return t.call(this, s, i);
            if (Le.isRegExp(t)) return t.exec(s);
            throw new TypeError("parser must be boolean|regexp|function")
         }
      }
   }
   has(e, t) {
      if (e = b0(e), e) {
         const i = Le.findKey(this, e);
         return !!(i && this[i] !== void 0 && (!t || MA(this, this[i], i, t)))
      }
      return !1
   }
   delete(e, t) {
      const i = this;
      let s = !1;

      function r(a) {
         if (a = b0(a), a) {
            const l = Le.findKey(i, a);
            l && (!t || MA(i, i[l], l, t)) && (delete i[l], s = !0)
         }
      }
      return Le.isArray(e) ? e.forEach(r) : r(e), s
   }
   clear(e) {
      const t = Object.keys(this);
      let i = t.length,
         s = !1;
      for (; i--;) {
         const r = t[i];
         (!e || MA(this, this[r], r, e, !0)) && (delete this[r], s = !0)
      }
      return s
   }
   normalize(e) {
      const t = this,
         i = {};
      return Le.forEach(this, (s, r) => {
         const a = Le.findKey(i, r);
         if (a) {
            t[a] = Bb(s), delete t[r];
            return
         }
         const l = e ? Vne(r) : String(r).trim();
         l !== r && delete t[r], t[l] = Bb(s), i[l] = !0
      }), this
   }
   concat(...e) {
      return this.constructor.concat(this, ...e)
   }
   toJSON(e) {
      const t = Object.create(null);
      return Le.forEach(this, (i, s) => {
         i != null && i !== !1 && (t[s] = e && Le.isArray(i) ? i.join(", ") : i)
      }), t
   } [Symbol.iterator]() {
      return Object.entries(this.toJSON())[Symbol.iterator]()
   }
   toString() {
      return Object.entries(this.toJSON()).map(([e, t]) => e + ": " + t).join(`
`)
   }
   getSetCookie() {
      return this.get("set-cookie") || []
   }
   get[Symbol.toStringTag]() {
      return "AxiosHeaders"
   }
   static from(e) {
      return e instanceof this ? e : new this(e)
   }
   static concat(e, ...t) {
      const i = new this(e);
      return t.forEach(s => i.set(s)), i
   }
   static accessor(e) {
      const i = (this[EU] = this[EU] = {
            accessors: {}
         }).accessors,
         s = this.prototype;

      function r(a) {
         const l = b0(a);
         i[l] || (Gne(s, a), i[l] = !0)
      }
      return Le.isArray(e) ? e.forEach(r) : r(e), this
   }
};
Ga.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
Le.reduceDescriptors(Ga.prototype, ({
   value: n
}, e) => {
   let t = e[0].toUpperCase() + e.slice(1);
   return {
      get: () => n,
      set(i) {
         this[t] = i
      }
   }
});
Le.freezeMethods(Ga);

function AA(n, e) {
   const t = this || Nx,
      i = e || t,
      s = Ga.from(i.headers);
   let r = i.data;
   return Le.forEach(n, function (l) {
      r = l.call(t, r, s.normalize(), e ? e.status : void 0)
   }), s.normalize(), r
}

function hF(n) {
   return !!(n && n.__CANCEL__)
}

function kg(n, e, t) {
   dn.call(this, n ?? "canceled", dn.ERR_CANCELED, e, t), this.name = "CanceledError"
}
Le.inherits(kg, dn, {
   __CANCEL__: !0
});

function dF(n, e, t) {
   const i = t.config.validateStatus;
   !t.status || !i || i(t.status) ? n(t) : e(new dn("Request failed with status code " + t.status, [dn.ERR_BAD_REQUEST, dn.ERR_BAD_RESPONSE][Math.floor(t.status / 100) - 4], t.config, t.request, t))
}

function kne(n) {
   const e = /^([-+\w]{1,25})(:?\/\/|:)/.exec(n);
   return e && e[1] || ""
}

function jne(n, e) {
   n = n || 10;
   const t = new Array(n),
      i = new Array(n);
   let s = 0,
      r = 0,
      a;
   return e = e !== void 0 ? e : 1e3,
      function (c) {
         const h = Date.now(),
            m = i[r];
         a || (a = h), t[s] = c, i[s] = h;
         let g = r,
            v = 0;
         for (; g !== s;) v += t[g++], g = g % n;
         if (s = (s + 1) % n, s === r && (r = (r + 1) % n), h - a < e) return;
         const x = m && h - m;
         return x ? Math.round(v * 1e3 / x) : void 0
      }
}

function qne(n, e) {
   let t = 0,
      i = 1e3 / e,
      s, r;
   const a = (h, m = Date.now()) => {
      t = m, s = null, r && (clearTimeout(r), r = null), n.apply(null, h)
   };
   return [(...h) => {
      const m = Date.now(),
         g = m - t;
      g >= i ? a(h, m) : (s = h, r || (r = setTimeout(() => {
         r = null, a(s)
      }, i - g)))
   }, () => s && a(s)]
}
const G1 = (n, e, t = 3) => {
      let i = 0;
      const s = jne(50, 250);
      return qne(r => {
         const a = r.loaded,
            l = r.lengthComputable ? r.total : void 0,
            c = a - i,
            h = s(c),
            m = a <= l;
         i = a;
         const g = {
            loaded: a,
            total: l,
            progress: l ? a / l : void 0,
            bytes: c,
            rate: h || void 0,
            estimated: h && l && m ? (l - a) / h : void 0,
            event: r,
            lengthComputable: l != null,
            [e ? "download" : "upload"]: !0
         };
         n(g)
      }, t)
   },
   MU = (n, e) => {
      const t = n != null;
      return [i => e[0]({
         lengthComputable: t,
         total: n,
         loaded: i
      }), e[1]]
   },
   AU = n => (...e) => Le.asap(() => n(...e)),
   Xne = Ur.hasStandardBrowserEnv ? ((n, e) => t => (t = new URL(t, Ur.origin), n.protocol === t.protocol && n.host === t.host && (e || n.port === t.port)))(new URL(Ur.origin), Ur.navigator && /(msie|trident)/i.test(Ur.navigator.userAgent)) : () => !0,
   Wne = Ur.hasStandardBrowserEnv ? {
      write(n, e, t, i, s, r) {
         const a = [n + "=" + encodeURIComponent(e)];
         Le.isNumber(t) && a.push("expires=" + new Date(t).toGMTString()), Le.isString(i) && a.push("path=" + i), Le.isString(s) && a.push("domain=" + s), r === !0 && a.push("secure"), document.cookie = a.join("; ")
      },
      read(n) {
         const e = document.cookie.match(new RegExp("(^|;\\s*)(" + n + ")=([^;]*)"));
         return e ? decodeURIComponent(e[3]) : null
      },
      remove(n) {
         this.write(n, "", Date.now() - 864e5)
      }
   } : {
      write() {},
      read() {
         return null
      },
      remove() {}
   };

function Yne(n) {
   return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(n)
}

function Kne(n, e) {
   return e ? n.replace(/\/?\/$/, "") + "/" + e.replace(/^\/+/, "") : n
}

function pF(n, e, t) {
   let i = !Yne(e);
   return n && (i || t == !1) ? Kne(n, e) : e
}
const wU = n => n instanceof Ga ? {
   ...n
} : n;

function sp(n, e) {
   e = e || {};
   const t = {};

   function i(h, m, g, v) {
      return Le.isPlainObject(h) && Le.isPlainObject(m) ? Le.merge.call({
         caseless: v
      }, h, m) : Le.isPlainObject(m) ? Le.merge({}, m) : Le.isArray(m) ? m.slice() : m
   }

   function s(h, m, g, v) {
      if (Le.isUndefined(m)) {
         if (!Le.isUndefined(h)) return i(void 0, h, g, v)
      } else return i(h, m, g, v)
   }

   function r(h, m) {
      if (!Le.isUndefined(m)) return i(void 0, m)
   }

   function a(h, m) {
      if (Le.isUndefined(m)) {
         if (!Le.isUndefined(h)) return i(void 0, h)
      } else return i(void 0, m)
   }

   function l(h, m, g) {
      if (g in e) return i(h, m);
      if (g in n) return i(void 0, h)
   }
   const c = {
      url: r,
      method: r,
      data: r,
      baseURL: a,
      transformRequest: a,
      transformResponse: a,
      paramsSerializer: a,
      timeout: a,
      timeoutMessage: a,
      withCredentials: a,
      withXSRFToken: a,
      adapter: a,
      responseType: a,
      xsrfCookieName: a,
      xsrfHeaderName: a,
      onUploadProgress: a,
      onDownloadProgress: a,
      decompress: a,
      maxContentLength: a,
      maxBodyLength: a,
      beforeRedirect: a,
      transport: a,
      httpAgent: a,
      httpsAgent: a,
      cancelToken: a,
      socketPath: a,
      responseEncoding: a,
      validateStatus: l,
      headers: (h, m, g) => s(wU(h), wU(m), g, !0)
   };
   return Le.forEach(Object.keys(Object.assign({}, n, e)), function (m) {
      const g = c[m] || s,
         v = g(n[m], e[m], m);
      Le.isUndefined(v) && g !== l || (t[m] = v)
   }), t
}
const mF = n => {
      const e = sp({}, n);
      let {
         data: t,
         withXSRFToken: i,
         xsrfHeaderName: s,
         xsrfCookieName: r,
         headers: a,
         auth: l
      } = e;
      e.headers = a = Ga.from(a), e.url = uF(pF(e.baseURL, e.url, e.allowAbsoluteUrls), n.params, n.paramsSerializer), l && a.set("Authorization", "Basic " + btoa((l.username || "") + ":" + (l.password ? unescape(encodeURIComponent(l.password)) : "")));
      let c;
      if (Le.isFormData(t)) {
         if (Ur.hasStandardBrowserEnv || Ur.hasStandardBrowserWebWorkerEnv) a.setContentType(void 0);
         else if ((c = a.getContentType()) !== !1) {
            const [h, ...m] = c ? c.split(";").map(g => g.trim()).filter(Boolean) : [];
            a.setContentType([h || "multipart/form-data", ...m].join("; "))
         }
      }
      if (Ur.hasStandardBrowserEnv && (i && Le.isFunction(i) && (i = i(e)), i || i !== !1 && Xne(e.url))) {
         const h = s && r && Wne.read(r);
         h && a.set(s, h)
      }
      return e
   },
   Zne = typeof XMLHttpRequest < "u",
   Qne = Zne && function (n) {
      return new Promise(function (t, i) {
         const s = mF(n);
         let r = s.data;
         const a = Ga.from(s.headers).normalize();
         let {
            responseType: l,
            onUploadProgress: c,
            onDownloadProgress: h
         } = s, m, g, v, x, S;

         function E() {
            x && x(), S && S(), s.cancelToken && s.cancelToken.unsubscribe(m), s.signal && s.signal.removeEventListener("abort", m)
         }
         let T = new XMLHttpRequest;
         T.open(s.method.toUpperCase(), s.url, !0), T.timeout = s.timeout;

         function b() {
            if (!T) return;
            const C = Ga.from("getAllResponseHeaders" in T && T.getAllResponseHeaders()),
               U = {
                  data: !l || l === "text" || l === "json" ? T.responseText : T.response,
                  status: T.status,
                  statusText: T.statusText,
                  headers: C,
                  config: n,
                  request: T
               };
            dF(function (B) {
               t(B), E()
            }, function (B) {
               i(B), E()
            }, U), T = null
         }
         "onloadend" in T ? T.onloadend = b : T.onreadystatechange = function () {
            !T || T.readyState !== 4 || T.status === 0 && !(T.responseURL && T.responseURL.indexOf("file:") === 0) || setTimeout(b)
         }, T.onabort = function () {
            T && (i(new dn("Request aborted", dn.ECONNABORTED, n, T)), T = null)
         }, T.onerror = function () {
            i(new dn("Network Error", dn.ERR_NETWORK, n, T)), T = null
         }, T.ontimeout = function () {
            let N = s.timeout ? "timeout of " + s.timeout + "ms exceeded" : "timeout exceeded";
            const U = s.transitional || cF;
            s.timeoutErrorMessage && (N = s.timeoutErrorMessage), i(new dn(N, U.clarifyTimeoutError ? dn.ETIMEDOUT : dn.ECONNABORTED, n, T)), T = null
         }, r === void 0 && a.setContentType(null), "setRequestHeader" in T && Le.forEach(a.toJSON(), function (N, U) {
            T.setRequestHeader(U, N)
         }), Le.isUndefined(s.withCredentials) || (T.withCredentials = !!s.withCredentials), l && l !== "json" && (T.responseType = s.responseType), h && ([v, S] = G1(h, !0), T.addEventListener("progress", v)), c && T.upload && ([g, x] = G1(c), T.upload.addEventListener("progress", g), T.upload.addEventListener("loadend", x)), (s.cancelToken || s.signal) && (m = C => {
            T && (i(!C || C.type ? new kg(null, n, T) : C), T.abort(), T = null)
         }, s.cancelToken && s.cancelToken.subscribe(m), s.signal && (s.signal.aborted ? m() : s.signal.addEventListener("abort", m)));
         const w = kne(s.url);
         if (w && Ur.protocols.indexOf(w) === -1) {
            i(new dn("Unsupported protocol " + w + ":", dn.ERR_BAD_REQUEST, n));
            return
         }
         T.send(r || null)
      })
   },
   Jne = (n, e) => {
      const {
         length: t
      } = n = n ? n.filter(Boolean) : [];
      if (e || t) {
         let i = new AbortController,
            s;
         const r = function (h) {
            if (!s) {
               s = !0, l();
               const m = h instanceof Error ? h : this.reason;
               i.abort(m instanceof dn ? m : new kg(m instanceof Error ? m.message : m))
            }
         };
         let a = e && setTimeout(() => {
            a = null, r(new dn(`timeout ${e} of ms exceeded`, dn.ETIMEDOUT))
         }, e);
         const l = () => {
            n && (a && clearTimeout(a), a = null, n.forEach(h => {
               h.unsubscribe ? h.unsubscribe(r) : h.removeEventListener("abort", r)
            }), n = null)
         };
         n.forEach(h => h.addEventListener("abort", r));
         const {
            signal: c
         } = i;
         return c.unsubscribe = () => Le.asap(l), c
      }
   },
   $ne = function* (n, e) {
      let t = n.byteLength;
      if (t < e) {
         yield n;
         return
      }
      let i = 0,
         s;
      for (; i < t;) s = i + e, yield n.slice(i, s), i = s
   },
   eie = async function* (n, e) {
      for await (const t of tie(n)) yield* $ne(t, e)
   }, tie = async function* (n) {
      if (n[Symbol.asyncIterator]) {
         yield* n;
         return
      }
      const e = n.getReader();
      try {
         for (;;) {
            const {
               done: t,
               value: i
            } = await e.read();
            if (t) break;
            yield i
         }
      } finally {
         await e.cancel()
      }
   }, RU = (n, e, t, i) => {
      const s = eie(n, e);
      let r = 0,
         a, l = c => {
            a || (a = !0, i && i(c))
         };
      return new ReadableStream({
         async pull(c) {
            try {
               const {
                  done: h,
                  value: m
               } = await s.next();
               if (h) {
                  l(), c.close();
                  return
               }
               let g = m.byteLength;
               if (t) {
                  let v = r += g;
                  t(v)
               }
               c.enqueue(new Uint8Array(m))
            } catch (h) {
               throw l(h), h
            }
         },
         cancel(c) {
            return l(c), s.return()
         }
      }, {
         highWaterMark: 2
      })
   }, $T = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", gF = $T && typeof ReadableStream == "function", nie = $T && (typeof TextEncoder == "function" ? (n => e => n.encode(e))(new TextEncoder) : async n => new Uint8Array(await new Response(n).arrayBuffer())), vF = (n, ...e) => {
      try {
         return !!n(...e)
      } catch {
         return !1
      }
   }, iie = gF && vF(() => {
      let n = !1;
      const e = new Request(Ur.origin, {
         body: new ReadableStream,
         method: "POST",
         get duplex() {
            return n = !0, "half"
         }
      }).headers.has("Content-Type");
      return n && !e
   }), CU = 64 * 1024, Zw = gF && vF(() => Le.isReadableStream(new Response("").body)), k1 = {
      stream: Zw && (n => n.body)
   };
$T && (n => {
   ["text", "arrayBuffer", "blob", "formData", "stream"].forEach(e => {
      !k1[e] && (k1[e] = Le.isFunction(n[e]) ? t => t[e]() : (t, i) => {
         throw new dn(`Response type '${e}' is not supported`, dn.ERR_NOT_SUPPORT, i)
      })
   })
})(new Response);
const sie = async n => {
   if (n == null) return 0;
   if (Le.isBlob(n)) return n.size;
   if (Le.isSpecCompliantForm(n)) return (await new Request(Ur.origin, {
      method: "POST",
      body: n
   }).arrayBuffer()).byteLength;
   if (Le.isArrayBufferView(n) || Le.isArrayBuffer(n)) return n.byteLength;
   if (Le.isURLSearchParams(n) && (n = n + ""), Le.isString(n)) return (await nie(n)).byteLength
}, rie = async (n, e) => {
   const t = Le.toFiniteNumber(n.getContentLength());
   return t ?? sie(e)
}, aie = $T && (async n => {
   let {
      url: e,
      method: t,
      data: i,
      signal: s,
      cancelToken: r,
      timeout: a,
      onDownloadProgress: l,
      onUploadProgress: c,
      responseType: h,
      headers: m,
      withCredentials: g = "same-origin",
      fetchOptions: v
   } = mF(n);
   h = h ? (h + "").toLowerCase() : "text";
   let x = Jne([s, r && r.toAbortSignal()], a),
      S;
   const E = x && x.unsubscribe && (() => {
      x.unsubscribe()
   });
   let T;
   try {
      if (c && iie && t !== "get" && t !== "head" && (T = await rie(m, i)) !== 0) {
         let U = new Request(e, {
               method: "POST",
               body: i,
               duplex: "half"
            }),
            z;
         if (Le.isFormData(i) && (z = U.headers.get("content-type")) && m.setContentType(z), U.body) {
            const [B, I] = MU(T, G1(AU(c)));
            i = RU(U.body, CU, B, I)
         }
      }
      Le.isString(g) || (g = g ? "include" : "omit");
      const b = "credentials" in Request.prototype;
      S = new Request(e, {
         ...v,
         signal: x,
         method: t.toUpperCase(),
         headers: m.normalize().toJSON(),
         body: i,
         duplex: "half",
         credentials: b ? g : void 0
      });
      let w = await fetch(S, v);
      const C = Zw && (h === "stream" || h === "response");
      if (Zw && (l || C && E)) {
         const U = {};
         ["status", "statusText", "headers"].forEach(O => {
            U[O] = w[O]
         });
         const z = Le.toFiniteNumber(w.headers.get("content-length")),
            [B, I] = l && MU(z, G1(AU(l), !0)) || [];
         w = new Response(RU(w.body, CU, B, () => {
            I && I(), E && E()
         }), U)
      }
      h = h || "text";
      let N = await k1[Le.findKey(k1, h) || "text"](w, n);
      return !C && E && E(), await new Promise((U, z) => {
         dF(U, z, {
            data: N,
            headers: Ga.from(w.headers),
            status: w.status,
            statusText: w.statusText,
            config: n,
            request: S
         })
      })
   } catch (b) {
      throw E && E(), b && b.name === "TypeError" && /Load failed|fetch/i.test(b.message) ? Object.assign(new dn("Network Error", dn.ERR_NETWORK, n, S), {
         cause: b.cause || b
      }) : dn.from(b, b && b.code, n, S)
   }
}), Qw = {
   http: Sne,
   xhr: Qne,
   fetch: aie
};
Le.forEach(Qw, (n, e) => {
   if (n) {
      try {
         Object.defineProperty(n, "name", {
            value: e
         })
      } catch {}
      Object.defineProperty(n, "adapterName", {
         value: e
      })
   }
});
const DU = n => `- ${n}`,
   oie = n => Le.isFunction(n) || n === null || n === !1,
   yF = {
      getAdapter: n => {
         n = Le.isArray(n) ? n : [n];
         const {
            length: e
         } = n;
         let t, i;
         const s = {};
         for (let r = 0; r < e; r++) {
            t = n[r];
            let a;
            if (i = t, !oie(t) && (i = Qw[(a = String(t)).toLowerCase()], i === void 0)) throw new dn(`Unknown adapter '${a}'`);
            if (i) break;
            s[a || "#" + r] = i
         }
         if (!i) {
            const r = Object.entries(s).map(([l, c]) => `adapter ${l} ` + (c === !1 ? "is not supported by the environment" : "is not available in the build"));
            let a = e ? r.length > 1 ? `since :
` + r.map(DU).join(`
`) : " " + DU(r[0]) : "as no adapter specified";
            throw new dn("There is no suitable adapter to dispatch the request " + a, "ERR_NOT_SUPPORT")
         }
         return i
      },
      adapters: Qw
   };

function wA(n) {
   if (n.cancelToken && n.cancelToken.throwIfRequested(), n.signal && n.signal.aborted) throw new kg(null, n)
}

function NU(n) {
   return wA(n), n.headers = Ga.from(n.headers), n.data = AA.call(n, n.transformRequest), ["post", "put", "patch"].indexOf(n.method) !== -1 && n.headers.setContentType("application/x-www-form-urlencoded", !1), yF.getAdapter(n.adapter || Nx.adapter)(n).then(function (i) {
      return wA(n), i.data = AA.call(n, n.transformResponse, i), i.headers = Ga.from(i.headers), i
   }, function (i) {
      return hF(i) || (wA(n), i && i.response && (i.response.data = AA.call(n, n.transformResponse, i.response), i.response.headers = Ga.from(i.response.headers))), Promise.reject(i)
   })
}
const xF = "1.10.0",
   eE = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((n, e) => {
   eE[n] = function (i) {
      return typeof i === n || "a" + (e < 1 ? "n " : " ") + n
   }
});
const OU = {};
eE.transitional = function (e, t, i) {
   function s(r, a) {
      return "[Axios v" + xF + "] Transitional option '" + r + "'" + a + (i ? ". " + i : "")
   }
   return (r, a, l) => {
      if (e === !1) throw new dn(s(a, " has been removed" + (t ? " in " + t : "")), dn.ERR_DEPRECATED);
      return t && !OU[a] && (OU[a] = !0, console.warn(s(a, " has been deprecated since v" + t + " and will be removed in the near future"))), e ? e(r, a, l) : !0
   }
};
eE.spelling = function (e) {
   return (t, i) => (console.warn(`${i} is likely a misspelling of ${e}`), !0)
};

function lie(n, e, t) {
   if (typeof n != "object") throw new dn("options must be an object", dn.ERR_BAD_OPTION_VALUE);
   const i = Object.keys(n);
   let s = i.length;
   for (; s-- > 0;) {
      const r = i[s],
         a = e[r];
      if (a) {
         const l = n[r],
            c = l === void 0 || a(l, r, n);
         if (c !== !0) throw new dn("option " + r + " must be " + c, dn.ERR_BAD_OPTION_VALUE);
         continue
      }
      if (t !== !0) throw new dn("Unknown option " + r, dn.ERR_BAD_OPTION)
   }
}
const zb = {
      assertOptions: lie,
      validators: eE
   },
   Au = zb.validators;
let Yd = class {
   constructor(e) {
      this.defaults = e || {}, this.interceptors = {
         request: new TU,
         response: new TU
      }
   }
   async request(e, t) {
      try {
         return await this._request(e, t)
      } catch (i) {
         if (i instanceof Error) {
            let s = {};
            Error.captureStackTrace ? Error.captureStackTrace(s) : s = new Error;
            const r = s.stack ? s.stack.replace(/^.+\n/, "") : "";
            try {
               i.stack ? r && !String(i.stack).endsWith(r.replace(/^.+\n.+\n/, "")) && (i.stack += `
` + r) : i.stack = r
            } catch {}
         }
         throw i
      }
   }
   _request(e, t) {
      typeof e == "string" ? (t = t || {}, t.url = e) : t = e || {}, t = sp(this.defaults, t);
      const {
         transitional: i,
         paramsSerializer: s,
         headers: r
      } = t;
      i !== void 0 && zb.assertOptions(i, {
         silentJSONParsing: Au.transitional(Au.boolean),
         forcedJSONParsing: Au.transitional(Au.boolean),
         clarifyTimeoutError: Au.transitional(Au.boolean)
      }, !1), s != null && (Le.isFunction(s) ? t.paramsSerializer = {
         serialize: s
      } : zb.assertOptions(s, {
         encode: Au.function,
         serialize: Au.function
      }, !0)), t.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? t.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : t.allowAbsoluteUrls = !0), zb.assertOptions(t, {
         baseUrl: Au.spelling("baseURL"),
         withXsrfToken: Au.spelling("withXSRFToken")
      }, !0), t.method = (t.method || this.defaults.method || "get").toLowerCase();
      let a = r && Le.merge(r.common, r[t.method]);
      r && Le.forEach(["delete", "get", "head", "post", "put", "patch", "common"], S => {
         delete r[S]
      }), t.headers = Ga.concat(a, r);
      const l = [];
      let c = !0;
      this.interceptors.request.forEach(function (E) {
         typeof E.runWhen == "function" && E.runWhen(t) === !1 || (c = c && E.synchronous, l.unshift(E.fulfilled, E.rejected))
      });
      const h = [];
      this.interceptors.response.forEach(function (E) {
         h.push(E.fulfilled, E.rejected)
      });
      let m, g = 0,
         v;
      if (!c) {
         const S = [NU.bind(this), void 0];
         for (S.unshift.apply(S, l), S.push.apply(S, h), v = S.length, m = Promise.resolve(t); g < v;) m = m.then(S[g++], S[g++]);
         return m
      }
      v = l.length;
      let x = t;
      for (g = 0; g < v;) {
         const S = l[g++],
            E = l[g++];
         try {
            x = S(x)
         } catch (T) {
            E.call(this, T);
            break
         }
      }
      try {
         m = NU.call(this, x)
      } catch (S) {
         return Promise.reject(S)
      }
      for (g = 0, v = h.length; g < v;) m = m.then(h[g++], h[g++]);
      return m
   }
   getUri(e) {
      e = sp(this.defaults, e);
      const t = pF(e.baseURL, e.url, e.allowAbsoluteUrls);
      return uF(t, e.params, e.paramsSerializer)
   }
};
Le.forEach(["delete", "get", "head", "options"], function (e) {
   Yd.prototype[e] = function (t, i) {
      return this.request(sp(i || {}, {
         method: e,
         url: t,
         data: (i || {}).data
      }))
   }
});
Le.forEach(["post", "put", "patch"], function (e) {
   function t(i) {
      return function (r, a, l) {
         return this.request(sp(l || {}, {
            method: e,
            headers: i ? {
               "Content-Type": "multipart/form-data"
            } : {},
            url: r,
            data: a
         }))
      }
   }
   Yd.prototype[e] = t(), Yd.prototype[e + "Form"] = t(!0)
});
let uie = class _F {
   constructor(e) {
      if (typeof e != "function") throw new TypeError("executor must be a function.");
      let t;
      this.promise = new Promise(function (r) {
         t = r
      });
      const i = this;
      this.promise.then(s => {
         if (!i._listeners) return;
         let r = i._listeners.length;
         for (; r-- > 0;) i._listeners[r](s);
         i._listeners = null
      }), this.promise.then = s => {
         let r;
         const a = new Promise(l => {
            i.subscribe(l), r = l
         }).then(s);
         return a.cancel = function () {
            i.unsubscribe(r)
         }, a
      }, e(function (r, a, l) {
         i.reason || (i.reason = new kg(r, a, l), t(i.reason))
      })
   }
   throwIfRequested() {
      if (this.reason) throw this.reason
   }
   subscribe(e) {
      if (this.reason) {
         e(this.reason);
         return
      }
      this._listeners ? this._listeners.push(e) : this._listeners = [e]
   }
   unsubscribe(e) {
      if (!this._listeners) return;
      const t = this._listeners.indexOf(e);
      t !== -1 && this._listeners.splice(t, 1)
   }
   toAbortSignal() {
      const e = new AbortController,
         t = i => {
            e.abort(i)
         };
      return this.subscribe(t), e.signal.unsubscribe = () => this.unsubscribe(t), e.signal
   }
   static source() {
      let e;
      return {
         token: new _F(function (s) {
            e = s
         }),
         cancel: e
      }
   }
};

function cie(n) {
   return function (t) {
      return n.apply(null, t)
   }
}

function fie(n) {
   return Le.isObject(n) && n.isAxiosError === !0
}
const Jw = {
   Continue: 100,
   SwitchingProtocols: 101,
   Processing: 102,
   EarlyHints: 103,
   Ok: 200,
   Created: 201,
   Accepted: 202,
   NonAuthoritativeInformation: 203,
   NoContent: 204,
   ResetContent: 205,
   PartialContent: 206,
   MultiStatus: 207,
   AlreadyReported: 208,
   ImUsed: 226,
   MultipleChoices: 300,
   MovedPermanently: 301,
   Found: 302,
   SeeOther: 303,
   NotModified: 304,
   UseProxy: 305,
   Unused: 306,
   TemporaryRedirect: 307,
   PermanentRedirect: 308,
   BadRequest: 400,
   Unauthorized: 401,
   PaymentRequired: 402,
   Forbidden: 403,
   NotFound: 404,
   MethodNotAllowed: 405,
   NotAcceptable: 406,
   ProxyAuthenticationRequired: 407,
   RequestTimeout: 408,
   Conflict: 409,
   Gone: 410,
   LengthRequired: 411,
   PreconditionFailed: 412,
   PayloadTooLarge: 413,
   UriTooLong: 414,
   UnsupportedMediaType: 415,
   RangeNotSatisfiable: 416,
   ExpectationFailed: 417,
   ImATeapot: 418,
   MisdirectedRequest: 421,
   UnprocessableEntity: 422,
   Locked: 423,
   FailedDependency: 424,
   TooEarly: 425,
   UpgradeRequired: 426,
   PreconditionRequired: 428,
   TooManyRequests: 429,
   RequestHeaderFieldsTooLarge: 431,
   UnavailableForLegalReasons: 451,
   InternalServerError: 500,
   NotImplemented: 501,
   BadGateway: 502,
   ServiceUnavailable: 503,
   GatewayTimeout: 504,
   HttpVersionNotSupported: 505,
   VariantAlsoNegotiates: 506,
   InsufficientStorage: 507,
   LoopDetected: 508,
   NotExtended: 510,
   NetworkAuthenticationRequired: 511
};
Object.entries(Jw).forEach(([n, e]) => {
   Jw[e] = n
});

function SF(n) {
   const e = new Yd(n),
      t = Q4(Yd.prototype.request, e);
   return Le.extend(t, Yd.prototype, e, {
      allOwnKeys: !0
   }), Le.extend(t, e, null, {
      allOwnKeys: !0
   }), t.create = function (s) {
      return SF(sp(n, s))
   }, t
}
const ni = SF(Nx);
ni.Axios = Yd;
ni.CanceledError = kg;
ni.CancelToken = uie;
ni.isCancel = hF;
ni.VERSION = xF;
ni.toFormData = JT;
ni.AxiosError = dn;
ni.Cancel = ni.CanceledError;
ni.all = function (e) {
   return Promise.all(e)
};
ni.spread = cie;
ni.isAxiosError = fie;
ni.mergeConfig = sp;
ni.AxiosHeaders = Ga;
ni.formToJSON = n => fF(Le.isHTMLForm(n) ? new FormData(n) : n);
ni.getAdapter = yF.getAdapter;
ni.HttpStatusCode = Jw;
ni.default = ni;
const {
   Axios: pue,
   AxiosError: mue,
   CanceledError: gue,
   isCancel: vue,
   CancelToken: yue,
   VERSION: xue,
   all: _ue,
   Cancel: Sue,
   isAxiosError: bue,
   spread: Tue,
   toFormData: Eue,
   AxiosHeaders: Mue,
   HttpStatusCode: Aue,
   formToJSON: wue,
   getAdapter: Rue,
   mergeConfig: Cue
} = ni;

function hie() {
   const [n, e] = j.useState([]), {
      i18n: t
   } = rs();
   return j.useEffect(() => {
      ni.get("https://ong.mysterium-ai.com/projects.json").then(i => e(i.data)).catch(i => console.error("Error al cargar proyectos", i))
   }, [t.language]), n
}

function die(n) {
   const [e, t] = j.useState([]), i = a => {
      t(l => l.includes(a) ? l.filter(c => c !== a) : [...l, a])
   }, s = j.useMemo(() => e.length ? n.filter(a => e.includes(a.type)) : n, [n, e]), r = j.useMemo(() => [...new Set(n.map(a => a.type))], [n]);
   return {
      filtered: s,
      filteredTypes: e,
      uniqueTypes: r,
      toggleType: i
   }
}

function pie(n, e) {
   for (var t = 0; t < e.length; t++) {
      var i = e[t];
      i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(n, i.key, i)
   }
}

function mie(n, e, t) {
   return e && pie(n.prototype, e), n
}
/*!
 * Observer 3.13.0
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license
 * @author: Jack Doyle, jack@greensock.com
 */
var gr, Ib, co, Qf, Jf, ag, bF, wd, ry, TF, Rc, Ol, EF, MF = function () {
      return gr || typeof window < "u" && (gr = window.gsap) && gr.registerPlugin && gr
   },
   AF = 1,
   tg = [],
   Dn = [],
   Fu = [],
   ay = Date.now,
   $w = function (e, t) {
      return t
   },
   gie = function () {
      var e = ry.core,
         t = e.bridge || {},
         i = e._scrollers,
         s = e._proxies;
      i.push.apply(i, Dn), s.push.apply(s, Fu), Dn = i, Fu = s, $w = function (a, l) {
         return t[a](l)
      }
   },
   nh = function (e, t) {
      return ~Fu.indexOf(e) && Fu[Fu.indexOf(e) + 1][t]
   },
   oy = function (e) {
      return !!~TF.indexOf(e)
   },
   ia = function (e, t, i, s, r) {
      return e.addEventListener(t, i, {
         passive: s !== !1,
         capture: !!r
      })
   },
   na = function (e, t, i, s) {
      return e.removeEventListener(t, i, !!s)
   },
   sb = "scrollLeft",
   rb = "scrollTop",
   eR = function () {
      return Rc && Rc.isPressed || Dn.cache++
   },
   j1 = function (e, t) {
      var i = function s(r) {
         if (r || r === 0) {
            AF && (co.history.scrollRestoration = "manual");
            var a = Rc && Rc.isPressed;
            r = s.v = Math.round(r) || (Rc && Rc.iOS ? 1 : 0), e(r), s.cacheID = Dn.cache, a && $w("ss", r)
         } else(t || Dn.cache !== s.cacheID || $w("ref")) && (s.cacheID = Dn.cache, s.v = e());
         return s.v + s.offset
      };
      return i.offset = 0, e && i
   },
   fa = {
      s: sb,
      p: "left",
      p2: "Left",
      os: "right",
      os2: "Right",
      d: "width",
      d2: "Width",
      a: "x",
      sc: j1(function (n) {
         return arguments.length ? co.scrollTo(n, ks.sc()) : co.pageXOffset || Qf[sb] || Jf[sb] || ag[sb] || 0
      })
   },
   ks = {
      s: rb,
      p: "top",
      p2: "Top",
      os: "bottom",
      os2: "Bottom",
      d: "height",
      d2: "Height",
      a: "y",
      op: fa,
      sc: j1(function (n) {
         return arguments.length ? co.scrollTo(fa.sc(), n) : co.pageYOffset || Qf[rb] || Jf[rb] || ag[rb] || 0
      })
   },
   Oa = function (e, t) {
      return (t && t._ctx && t._ctx.selector || gr.utils.toArray)(e)[0] || (typeof e == "string" && gr.config().nullTargetWarn !== !1 ? console.warn("Element not found:", e) : null)
   },
   vie = function (e, t) {
      for (var i = t.length; i--;)
         if (t[i] === e || t[i].contains(e)) return !0;
      return !1
   },
   ch = function (e, t) {
      var i = t.s,
         s = t.sc;
      oy(e) && (e = Qf.scrollingElement || Jf);
      var r = Dn.indexOf(e),
         a = s === ks.sc ? 1 : 2;
      !~r && (r = Dn.push(e) - 1), Dn[r + a] || ia(e, "scroll", eR);
      var l = Dn[r + a],
         c = l || (Dn[r + a] = j1(nh(e, i), !0) || (oy(e) ? s : j1(function (h) {
            return arguments.length ? e[i] = h : e[i]
         })));
      return c.target = e, l || (c.smooth = gr.getProperty(e, "scrollBehavior") === "smooth"), c
   },
   tR = function (e, t, i) {
      var s = e,
         r = e,
         a = ay(),
         l = a,
         c = t || 50,
         h = Math.max(500, c * 3),
         m = function (S, E) {
            var T = ay();
            E || T - a > c ? (r = s, s = S, l = a, a = T) : i ? s += S : s = r + (S - r) / (T - l) * (a - l)
         },
         g = function () {
            r = s = i ? 0 : s, l = a = 0
         },
         v = function (S) {
            var E = l,
               T = r,
               b = ay();
            return (S || S === 0) && S !== s && m(S), a === l || b - l > h ? 0 : (s + (i ? T : -T)) / ((i ? b : a) - E) * 1e3
         };
      return {
         update: m,
         reset: g,
         getVelocity: v
      }
   },
   T0 = function (e, t) {
      return t && !e._gsapAllow && e.preventDefault(), e.changedTouches ? e.changedTouches[0] : e
   },
   UU = function (e) {
      var t = Math.max.apply(Math, e),
         i = Math.min.apply(Math, e);
      return Math.abs(t) >= Math.abs(i) ? t : i
   },
   wF = function () {
      ry = gr.core.globals().ScrollTrigger, ry && ry.core && gie()
   },
   RF = function (e) {
      return gr = e || MF(), !Ib && gr && typeof document < "u" && document.body && (co = window, Qf = document, Jf = Qf.documentElement, ag = Qf.body, TF = [co, Qf, Jf, ag], gr.utils.clamp, EF = gr.core.context || function () {}, wd = "onpointerenter" in ag ? "pointer" : "mouse", bF = ps.isTouch = co.matchMedia && co.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in co || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0, Ol = ps.eventTypes = ("ontouchstart" in Jf ? "touchstart,touchmove,touchcancel,touchend" : "onpointerdown" in Jf ? "pointerdown,pointermove,pointercancel,pointerup" : "mousedown,mousemove,mouseup,mouseup").split(","), setTimeout(function () {
         return AF = 0
      }, 500), wF(), Ib = 1), Ib
   };
fa.op = ks;
Dn.cache = 0;
var ps = function () {
   function n(t) {
      this.init(t)
   }
   var e = n.prototype;
   return e.init = function (i) {
      Ib || RF(gr) || console.warn("Please gsap.registerPlugin(Observer)"), ry || wF();
      var s = i.tolerance,
         r = i.dragMinimum,
         a = i.type,
         l = i.target,
         c = i.lineHeight,
         h = i.debounce,
         m = i.preventDefault,
         g = i.onStop,
         v = i.onStopDelay,
         x = i.ignore,
         S = i.wheelSpeed,
         E = i.event,
         T = i.onDragStart,
         b = i.onDragEnd,
         w = i.onDrag,
         C = i.onPress,
         N = i.onRelease,
         U = i.onRight,
         z = i.onLeft,
         B = i.onUp,
         I = i.onDown,
         O = i.onChangeX,
         P = i.onChangeY,
         q = i.onChange,
         Q = i.onToggleX,
         $ = i.onToggleY,
         ae = i.onHover,
         fe = i.onHoverEnd,
         k = i.onMove,
         Z = i.ignoreCheck,
         J = i.isNormalizer,
         pe = i.onGestureStart,
         F = i.onGestureEnd,
         ie = i.onWheel,
         ye = i.onEnable,
         we = i.onDisable,
         oe = i.onClick,
         be = i.scrollSpeed,
         Pe = i.capture,
         Ge = i.allowClicks,
         Xe = i.lockAxis,
         yt = i.onLockAxis;
      this.target = l = Oa(l) || Jf, this.vars = i, x && (x = gr.utils.toArray(x)), s = s || 1e-9, r = r || 0, S = S || 1, be = be || 1, a = a || "wheel,touch,pointer", h = h !== !1, c || (c = parseFloat(co.getComputedStyle(ag).lineHeight) || 22);
      var vt, Mt, zt, lt, ne, sn, ze, te = this,
         Be = 0,
         Je = 0,
         Ue = i.passive || !m && i.passive !== !1,
         K = ch(l, fa),
         G = ch(l, ks),
         me = K(),
         Ne = G(),
         Oe = ~a.indexOf("touch") && !~a.indexOf("pointer") && Ol[0] === "pointerdown",
         De = oy(l),
         Ye = l.ownerDocument || Qf,
         We = [0, 0, 0],
         Ze = [0, 0, 0],
         kt = 0,
         Ke = function () {
            return kt = ay()
         },
         et = function (_t, It) {
            return (te.event = _t) && x && vie(_t.target, x) || It && Oe && _t.pointerType !== "touch" || Z && Z(_t, It)
         },
         xt = function () {
            te._vx.reset(), te._vy.reset(), Mt.pause(), g && g(te)
         },
         mt = function () {
            var _t = te.deltaX = UU(We),
               It = te.deltaY = UU(Ze),
               Qe = Math.abs(_t) >= s,
               St = Math.abs(It) >= s;
            q && (Qe || St) && q(te, _t, It, We, Ze), Qe && (U && te.deltaX > 0 && U(te), z && te.deltaX < 0 && z(te), O && O(te), Q && te.deltaX < 0 != Be < 0 && Q(te), Be = te.deltaX, We[0] = We[1] = We[2] = 0), St && (I && te.deltaY > 0 && I(te), B && te.deltaY < 0 && B(te), P && P(te), $ && te.deltaY < 0 != Je < 0 && $(te), Je = te.deltaY, Ze[0] = Ze[1] = Ze[2] = 0), (lt || zt) && (k && k(te), zt && (T && zt === 1 && T(te), w && w(te), zt = 0), lt = !1), sn && !(sn = !1) && yt && yt(te), ne && (ie(te), ne = !1), vt = 0
         },
         it = function (_t, It, Qe) {
            We[Qe] += _t, Ze[Qe] += It, te._vx.update(_t), te._vy.update(It), h ? vt || (vt = requestAnimationFrame(mt)) : mt()
         },
         jt = function (_t, It) {
            Xe && !ze && (te.axis = ze = Math.abs(_t) > Math.abs(It) ? "x" : "y", sn = !0), ze !== "y" && (We[2] += _t, te._vx.update(_t, !0)), ze !== "x" && (Ze[2] += It, te._vy.update(It, !0)), h ? vt || (vt = requestAnimationFrame(mt)) : mt()
         },
         Rt = function (_t) {
            if (!et(_t, 1)) {
               _t = T0(_t, m);
               var It = _t.clientX,
                  Qe = _t.clientY,
                  St = It - te.x,
                  gt = Qe - te.y,
                  Dt = te.isDragging;
               te.x = It, te.y = Qe, (Dt || (St || gt) && (Math.abs(te.startX - It) >= r || Math.abs(te.startY - Qe) >= r)) && (zt = Dt ? 2 : 1, Dt || (te.isDragging = !0), jt(St, gt))
            }
         },
         cn = te.onPress = function (ut) {
            et(ut, 1) || ut && ut.button || (te.axis = ze = null, Mt.pause(), te.isPressed = !0, ut = T0(ut), Be = Je = 0, te.startX = te.x = ut.clientX, te.startY = te.y = ut.clientY, te._vx.reset(), te._vy.reset(), ia(J ? l : Ye, Ol[1], Rt, Ue, !0), te.deltaX = te.deltaY = 0, C && C(te))
         },
         le = te.onRelease = function (ut) {
            if (!et(ut, 1)) {
               na(J ? l : Ye, Ol[1], Rt, !0);
               var _t = !isNaN(te.y - te.startY),
                  It = te.isDragging,
                  Qe = It && (Math.abs(te.x - te.startX) > 3 || Math.abs(te.y - te.startY) > 3),
                  St = T0(ut);
               !Qe && _t && (te._vx.reset(), te._vy.reset(), m && Ge && gr.delayedCall(.08, function () {
                  if (ay() - kt > 300 && !ut.defaultPrevented) {
                     if (ut.target.click) ut.target.click();
                     else if (Ye.createEvent) {
                        var gt = Ye.createEvent("MouseEvents");
                        gt.initMouseEvent("click", !0, !0, co, 1, St.screenX, St.screenY, St.clientX, St.clientY, !1, !1, !1, !1, 0, null), ut.target.dispatchEvent(gt)
                     }
                  }
               })), te.isDragging = te.isGesturing = te.isPressed = !1, g && It && !J && Mt.restart(!0), zt && mt(), b && It && b(te), N && N(te, Qe)
            }
         },
         rt = function (_t) {
            return _t.touches && _t.touches.length > 1 && (te.isGesturing = !0) && pe(_t, te.isDragging)
         },
         Re = function () {
            return (te.isGesturing = !1) || F(te)
         },
         Ie = function (_t) {
            if (!et(_t)) {
               var It = K(),
                  Qe = G();
               it((It - me) * be, (Qe - Ne) * be, 1), me = It, Ne = Qe, g && Mt.restart(!0)
            }
         },
         nt = function (_t) {
            if (!et(_t)) {
               _t = T0(_t, m), ie && (ne = !0);
               var It = (_t.deltaMode === 1 ? c : _t.deltaMode === 2 ? co.innerHeight : 1) * S;
               it(_t.deltaX * It, _t.deltaY * It, 0), g && !J && Mt.restart(!0)
            }
         },
         at = function (_t) {
            if (!et(_t)) {
               var It = _t.clientX,
                  Qe = _t.clientY,
                  St = It - te.x,
                  gt = Qe - te.y;
               te.x = It, te.y = Qe, lt = !0, g && Mt.restart(!0), (St || gt) && jt(St, gt)
            }
         },
         Bt = function (_t) {
            te.event = _t, ae(te)
         },
         mn = function (_t) {
            te.event = _t, fe(te)
         },
         Yn = function (_t) {
            return et(_t) || T0(_t, m) && oe(te)
         };
      Mt = te._dc = gr.delayedCall(v || .25, xt).pause(), te.deltaX = te.deltaY = 0, te._vx = tR(0, 50, !0), te._vy = tR(0, 50, !0), te.scrollX = K, te.scrollY = G, te.isDragging = te.isGesturing = te.isPressed = !1, EF(this), te.enable = function (ut) {
         return te.isEnabled || (ia(De ? Ye : l, "scroll", eR), a.indexOf("scroll") >= 0 && ia(De ? Ye : l, "scroll", Ie, Ue, Pe), a.indexOf("wheel") >= 0 && ia(l, "wheel", nt, Ue, Pe), (a.indexOf("touch") >= 0 && bF || a.indexOf("pointer") >= 0) && (ia(l, Ol[0], cn, Ue, Pe), ia(Ye, Ol[2], le), ia(Ye, Ol[3], le), Ge && ia(l, "click", Ke, !0, !0), oe && ia(l, "click", Yn), pe && ia(Ye, "gesturestart", rt), F && ia(Ye, "gestureend", Re), ae && ia(l, wd + "enter", Bt), fe && ia(l, wd + "leave", mn), k && ia(l, wd + "move", at)), te.isEnabled = !0, te.isDragging = te.isGesturing = te.isPressed = lt = zt = !1, te._vx.reset(), te._vy.reset(), me = K(), Ne = G(), ut && ut.type && cn(ut), ye && ye(te)), te
      }, te.disable = function () {
         te.isEnabled && (tg.filter(function (ut) {
            return ut !== te && oy(ut.target)
         }).length || na(De ? Ye : l, "scroll", eR), te.isPressed && (te._vx.reset(), te._vy.reset(), na(J ? l : Ye, Ol[1], Rt, !0)), na(De ? Ye : l, "scroll", Ie, Pe), na(l, "wheel", nt, Pe), na(l, Ol[0], cn, Pe), na(Ye, Ol[2], le), na(Ye, Ol[3], le), na(l, "click", Ke, !0), na(l, "click", Yn), na(Ye, "gesturestart", rt), na(Ye, "gestureend", Re), na(l, wd + "enter", Bt), na(l, wd + "leave", mn), na(l, wd + "move", at), te.isEnabled = te.isPressed = te.isDragging = !1, we && we(te))
      }, te.kill = te.revert = function () {
         te.disable();
         var ut = tg.indexOf(te);
         ut >= 0 && tg.splice(ut, 1), Rc === te && (Rc = 0)
      }, tg.push(te), J && oy(l) && (Rc = te), te.enable(E)
   }, mie(n, [{
      key: "velocityX",
      get: function () {
         return this._vx.getVelocity()
      }
   }, {
      key: "velocityY",
      get: function () {
         return this._vy.getVelocity()
      }
   }]), n
}();
ps.version = "3.13.0";
ps.create = function (n) {
   return new ps(n)
};
ps.register = RF;
ps.getAll = function () {
   return tg.slice()
};
ps.getById = function (n) {
   return tg.filter(function (e) {
      return e.vars.id === n
   })[0]
};
MF() && gr.registerPlugin(ps);
/*!
 * ScrollTrigger 3.13.0
 * https://gsap.com
 *
 * @license Copyright 2008-2025, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license
 * @author: Jack Doyle, jack@greensock.com
 */
var bt, Hm, Cn, wi, lo, ai, mC, q1, sx, ly, U0, ab, Dr, tE, nR, aa, PU, LU, Vm, CF, RA, DF, ra, iR, NF, OF, Gf, sR, gC, og, vC, X1, rR, CA, ob = 1,
   Nr = Date.now,
   DA = Nr(),
   nl = 0,
   P0 = 0,
   BU = function (e, t, i) {
      var s = ao(e) && (e.substr(0, 6) === "clamp(" || e.indexOf("max") > -1);
      return i["_" + t + "Clamp"] = s, s ? e.substr(6, e.length - 7) : e
   },
   zU = function (e, t) {
      return t && (!ao(e) || e.substr(0, 6) !== "clamp(") ? "clamp(" + e + ")" : e
   },
   yie = function n() {
      return P0 && requestAnimationFrame(n)
   },
   IU = function () {
      return tE = 1
   },
   FU = function () {
      return tE = 0
   },
   Ru = function (e) {
      return e
   },
   L0 = function (e) {
      return Math.round(e * 1e5) / 1e5 || 0
   },
   UF = function () {
      return typeof window < "u"
   },
   PF = function () {
      return bt || UF() && (bt = window.gsap) && bt.registerPlugin && bt
   },
   rp = function (e) {
      return !!~mC.indexOf(e)
   },
   LF = function (e) {
      return (e === "Height" ? vC : Cn["inner" + e]) || lo["client" + e] || ai["client" + e]
   },
   BF = function (e) {
      return nh(e, "getBoundingClientRect") || (rp(e) ? function () {
         return kb.width = Cn.innerWidth, kb.height = vC, kb
      } : function () {
         return Ac(e)
      })
   },
   xie = function (e, t, i) {
      var s = i.d,
         r = i.d2,
         a = i.a;
      return (a = nh(e, "getBoundingClientRect")) ? function () {
         return a()[s]
      } : function () {
         return (t ? LF(r) : e["client" + r]) || 0
      }
   },
   _ie = function (e, t) {
      return !t || ~Fu.indexOf(e) ? BF(e) : function () {
         return kb
      }
   },
   Ou = function (e, t) {
      var i = t.s,
         s = t.d2,
         r = t.d,
         a = t.a;
      return Math.max(0, (i = "scroll" + s) && (a = nh(e, i)) ? a() - BF(e)()[r] : rp(e) ? (lo[i] || ai[i]) - LF(s) : e[i] - e["offset" + s])
   },
   lb = function (e, t) {
      for (var i = 0; i < Vm.length; i += 3)(!t || ~t.indexOf(Vm[i + 1])) && e(Vm[i], Vm[i + 1], Vm[i + 2])
   },
   ao = function (e) {
      return typeof e == "string"
   },
   Pr = function (e) {
      return typeof e == "function"
   },
   B0 = function (e) {
      return typeof e == "number"
   },
   Rd = function (e) {
      return typeof e == "object"
   },
   E0 = function (e, t, i) {
      return e && e.progress(t ? 0 : 1) && i && e.pause()
   },
   NA = function (e, t) {
      if (e.enabled) {
         var i = e._ctx ? e._ctx.add(function () {
            return t(e)
         }) : t(e);
         i && i.totalTime && (e.callbackAnimation = i)
      }
   },
   zm = Math.abs,
   zF = "left",
   IF = "top",
   yC = "right",
   xC = "bottom",
   Kd = "width",
   Zd = "height",
   uy = "Right",
   cy = "Left",
   fy = "Top",
   hy = "Bottom",
   Ms = "padding",
   Wo = "margin",
   wg = "Width",
   _C = "Height",
   Gs = "px",
   Yo = function (e) {
      return Cn.getComputedStyle(e)
   },
   Sie = function (e) {
      var t = Yo(e).position;
      e.style.position = t === "absolute" || t === "fixed" ? t : "relative"
   },
   HU = function (e, t) {
      for (var i in t) i in e || (e[i] = t[i]);
      return e
   },
   Ac = function (e, t) {
      var i = t && Yo(e)[nR] !== "matrix(1, 0, 0, 1, 0, 0)" && bt.to(e, {
            x: 0,
            y: 0,
            xPercent: 0,
            yPercent: 0,
            rotation: 0,
            rotationX: 0,
            rotationY: 0,
            scale: 1,
            skewX: 0,
            skewY: 0
         }).progress(1),
         s = e.getBoundingClientRect();
      return i && i.progress(0).kill(), s
   },
   W1 = function (e, t) {
      var i = t.d2;
      return e["offset" + i] || e["client" + i] || 0
   },
   FF = function (e) {
      var t = [],
         i = e.labels,
         s = e.duration(),
         r;
      for (r in i) t.push(i[r] / s);
      return t
   },
   bie = function (e) {
      return function (t) {
         return bt.utils.snap(FF(e), t)
      }
   },
   SC = function (e) {
      var t = bt.utils.snap(e),
         i = Array.isArray(e) && e.slice(0).sort(function (s, r) {
            return s - r
         });
      return i ? function (s, r, a) {
         a === void 0 && (a = .001);
         var l;
         if (!r) return t(s);
         if (r > 0) {
            for (s -= a, l = 0; l < i.length; l++)
               if (i[l] >= s) return i[l];
            return i[l - 1]
         } else
            for (l = i.length, s += a; l--;)
               if (i[l] <= s) return i[l];
         return i[0]
      } : function (s, r, a) {
         a === void 0 && (a = .001);
         var l = t(s);
         return !r || Math.abs(l - s) < a || l - s < 0 == r < 0 ? l : t(r < 0 ? s - e : s + e)
      }
   },
   Tie = function (e) {
      return function (t, i) {
         return SC(FF(e))(t, i.direction)
      }
   },
   ub = function (e, t, i, s) {
      return i.split(",").forEach(function (r) {
         return e(t, r, s)
      })
   },
   tr = function (e, t, i, s, r) {
      return e.addEventListener(t, i, {
         passive: !s,
         capture: !!r
      })
   },
   er = function (e, t, i, s) {
      return e.removeEventListener(t, i, !!s)
   },
   cb = function (e, t, i) {
      i = i && i.wheelHandler, i && (e(t, "wheel", i), e(t, "touchmove", i))
   },
   VU = {
      startColor: "green",
      endColor: "red",
      indent: 0,
      fontSize: "16px",
      fontWeight: "normal"
   },
   fb = {
      toggleActions: "play",
      anticipatePin: 0
   },
   Y1 = {
      top: 0,
      left: 0,
      center: .5,
      bottom: 1,
      right: 1
   },
   Fb = function (e, t) {
      if (ao(e)) {
         var i = e.indexOf("="),
            s = ~i ? +(e.charAt(i - 1) + 1) * parseFloat(e.substr(i + 1)) : 0;
         ~i && (e.indexOf("%") > i && (s *= t / 100), e = e.substr(0, i - 1)), e = s + (e in Y1 ? Y1[e] * t : ~e.indexOf("%") ? parseFloat(e) * t / 100 : parseFloat(e) || 0)
      }
      return e
   },
   hb = function (e, t, i, s, r, a, l, c) {
      var h = r.startColor,
         m = r.endColor,
         g = r.fontSize,
         v = r.indent,
         x = r.fontWeight,
         S = wi.createElement("div"),
         E = rp(i) || nh(i, "pinType") === "fixed",
         T = e.indexOf("scroller") !== -1,
         b = E ? ai : i,
         w = e.indexOf("start") !== -1,
         C = w ? h : m,
         N = "border-color:" + C + ";font-size:" + g + ";color:" + C + ";font-weight:" + x + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
      return N += "position:" + ((T || c) && E ? "fixed;" : "absolute;"), (T || c || !E) && (N += (s === ks ? yC : xC) + ":" + (a + parseFloat(v)) + "px;"), l && (N += "box-sizing:border-box;text-align:left;width:" + l.offsetWidth + "px;"), S._isStart = w, S.setAttribute("class", "gsap-marker-" + e + (t ? " marker-" + t : "")), S.style.cssText = N, S.innerText = t || t === 0 ? e + "-" + t : e, b.children[0] ? b.insertBefore(S, b.children[0]) : b.appendChild(S), S._offset = S["offset" + s.op.d2], Hb(S, 0, s, w), S
   },
   Hb = function (e, t, i, s) {
      var r = {
            display: "block"
         },
         a = i[s ? "os2" : "p2"],
         l = i[s ? "p2" : "os2"];
      e._isFlipped = s, r[i.a + "Percent"] = s ? -100 : 0, r[i.a] = s ? "1px" : 0, r["border" + a + wg] = 1, r["border" + l + wg] = 0, r[i.p] = t + "px", bt.set(e, r)
   },
   Tn = [],
   aR = {},
   rx, GU = function () {
      return Nr() - nl > 34 && (rx || (rx = requestAnimationFrame(Nc)))
   },
   Im = function () {
      (!ra || !ra.isPressed || ra.startX > ai.clientWidth) && (Dn.cache++, ra ? rx || (rx = requestAnimationFrame(Nc)) : Nc(), nl || op("scrollStart"), nl = Nr())
   },
   OA = function () {
      OF = Cn.innerWidth, NF = Cn.innerHeight
   },
   z0 = function (e) {
      Dn.cache++, (e === !0 || !Dr && !DF && !wi.fullscreenElement && !wi.webkitFullscreenElement && (!iR || OF !== Cn.innerWidth || Math.abs(Cn.innerHeight - NF) > Cn.innerHeight * .25)) && q1.restart(!0)
   },
   ap = {},
   Eie = [],
   HF = function n() {
      return er(Nn, "scrollEnd", n) || Id(!0)
   },
   op = function (e) {
      return ap[e] && ap[e].map(function (t) {
         return t()
      }) || Eie
   },
   ro = [],
   VF = function (e) {
      for (var t = 0; t < ro.length; t += 5)(!e || ro[t + 4] && ro[t + 4].query === e) && (ro[t].style.cssText = ro[t + 1], ro[t].getBBox && ro[t].setAttribute("transform", ro[t + 2] || ""), ro[t + 3].uncache = 1)
   },
   bC = function (e, t) {
      var i;
      for (aa = 0; aa < Tn.length; aa++) i = Tn[aa], i && (!t || i._ctx === t) && (e ? i.kill(1) : i.revert(!0, !0));
      X1 = !0, t && VF(t), t || op("revert")
   },
   GF = function (e, t) {
      Dn.cache++, (t || !oa) && Dn.forEach(function (i) {
         return Pr(i) && i.cacheID++ && (i.rec = 0)
      }), ao(e) && (Cn.history.scrollRestoration = gC = e)
   },
   oa, Qd = 0,
   kU, Mie = function () {
      if (kU !== Qd) {
         var e = kU = Qd;
         requestAnimationFrame(function () {
            return e === Qd && Id(!0)
         })
      }
   },
   kF = function () {
      ai.appendChild(og), vC = !ra && og.offsetHeight || Cn.innerHeight, ai.removeChild(og)
   },
   jU = function (e) {
      return sx(".gsap-marker-start, .gsap-marker-end, .gsap-marker-scroller-start, .gsap-marker-scroller-end").forEach(function (t) {
         return t.style.display = e ? "none" : "block"
      })
   },
   Id = function (e, t) {
      if (lo = wi.documentElement, ai = wi.body, mC = [Cn, wi, lo, ai], nl && !e && !X1) {
         tr(Nn, "scrollEnd", HF);
         return
      }
      kF(), oa = Nn.isRefreshing = !0, Dn.forEach(function (s) {
         return Pr(s) && ++s.cacheID && (s.rec = s())
      });
      var i = op("refreshInit");
      CF && Nn.sort(), t || bC(), Dn.forEach(function (s) {
         Pr(s) && (s.smooth && (s.target.style.scrollBehavior = "auto"), s(0))
      }), Tn.slice(0).forEach(function (s) {
         return s.refresh()
      }), X1 = !1, Tn.forEach(function (s) {
         if (s._subPinOffset && s.pin) {
            var r = s.vars.horizontal ? "offsetWidth" : "offsetHeight",
               a = s.pin[r];
            s.revert(!0, 1), s.adjustPinSpacing(s.pin[r] - a), s.refresh()
         }
      }), rR = 1, jU(!0), Tn.forEach(function (s) {
         var r = Ou(s.scroller, s._dir),
            a = s.vars.end === "max" || s._endClamp && s.end > r,
            l = s._startClamp && s.start >= r;
         (a || l) && s.setPositions(l ? r - 1 : s.start, a ? Math.max(l ? r : s.start + 1, r) : s.end, !0)
      }), jU(!1), rR = 0, i.forEach(function (s) {
         return s && s.render && s.render(-1)
      }), Dn.forEach(function (s) {
         Pr(s) && (s.smooth && requestAnimationFrame(function () {
            return s.target.style.scrollBehavior = "smooth"
         }), s.rec && s(s.rec))
      }), GF(gC, 1), q1.pause(), Qd++, oa = 2, Nc(2), Tn.forEach(function (s) {
         return Pr(s.vars.onRefresh) && s.vars.onRefresh(s)
      }), oa = Nn.isRefreshing = !1, op("refresh")
   },
   oR = 0,
   Vb = 1,
   dy, Nc = function (e) {
      if (e === 2 || !oa && !X1) {
         Nn.isUpdating = !0, dy && dy.update(0);
         var t = Tn.length,
            i = Nr(),
            s = i - DA >= 50,
            r = t && Tn[0].scroll();
         if (Vb = oR > r ? -1 : 1, oa || (oR = r), s && (nl && !tE && i - nl > 200 && (nl = 0, op("scrollEnd")), U0 = DA, DA = i), Vb < 0) {
            for (aa = t; aa-- > 0;) Tn[aa] && Tn[aa].update(0, s);
            Vb = 1
         } else
            for (aa = 0; aa < t; aa++) Tn[aa] && Tn[aa].update(0, s);
         Nn.isUpdating = !1
      }
      rx = 0
   },
   lR = [zF, IF, xC, yC, Wo + hy, Wo + uy, Wo + fy, Wo + cy, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"],
   Gb = lR.concat([Kd, Zd, "boxSizing", "max" + wg, "max" + _C, "position", Wo, Ms, Ms + fy, Ms + uy, Ms + hy, Ms + cy]),
   Aie = function (e, t, i) {
      lg(i);
      var s = e._gsap;
      if (s.spacerIsNative) lg(s.spacerState);
      else if (e._gsap.swappedIn) {
         var r = t.parentNode;
         r && (r.insertBefore(e, t), r.removeChild(t))
      }
      e._gsap.swappedIn = !1
   },
   UA = function (e, t, i, s) {
      if (!e._gsap.swappedIn) {
         for (var r = lR.length, a = t.style, l = e.style, c; r--;) c = lR[r], a[c] = i[c];
         a.position = i.position === "absolute" ? "absolute" : "relative", i.display === "inline" && (a.display = "inline-block"), l[xC] = l[yC] = "auto", a.flexBasis = i.flexBasis || "auto", a.overflow = "visible", a.boxSizing = "border-box", a[Kd] = W1(e, fa) + Gs, a[Zd] = W1(e, ks) + Gs, a[Ms] = l[Wo] = l[IF] = l[zF] = "0", lg(s), l[Kd] = l["max" + wg] = i[Kd], l[Zd] = l["max" + _C] = i[Zd], l[Ms] = i[Ms], e.parentNode !== t && (e.parentNode.insertBefore(t, e), t.appendChild(e)), e._gsap.swappedIn = !0
      }
   },
   wie = /([A-Z])/g,
   lg = function (e) {
      if (e) {
         var t = e.t.style,
            i = e.length,
            s = 0,
            r, a;
         for ((e.t._gsap || bt.core.getCache(e.t)).uncache = 1; s < i; s += 2) a = e[s + 1], r = e[s], a ? t[r] = a : t[r] && t.removeProperty(r.replace(wie, "-$1").toLowerCase())
      }
   },
   db = function (e) {
      for (var t = Gb.length, i = e.style, s = [], r = 0; r < t; r++) s.push(Gb[r], i[Gb[r]]);
      return s.t = e, s
   },
   Rie = function (e, t, i) {
      for (var s = [], r = e.length, a = i ? 8 : 0, l; a < r; a += 2) l = e[a], s.push(l, l in t ? t[l] : e[a + 1]);
      return s.t = e.t, s
   },
   kb = {
      left: 0,
      top: 0
   },
   qU = function (e, t, i, s, r, a, l, c, h, m, g, v, x, S) {
      Pr(e) && (e = e(c)), ao(e) && e.substr(0, 3) === "max" && (e = v + (e.charAt(4) === "=" ? Fb("0" + e.substr(3), i) : 0));
      var E = x ? x.time() : 0,
         T, b, w;
      if (x && x.seek(0), isNaN(e) || (e = +e), B0(e)) x && (e = bt.utils.mapRange(x.scrollTrigger.start, x.scrollTrigger.end, 0, v, e)), l && Hb(l, i, s, !0);
      else {
         Pr(t) && (t = t(c));
         var C = (e || "0").split(" "),
            N, U, z, B;
         w = Oa(t, c) || ai, N = Ac(w) || {}, (!N || !N.left && !N.top) && Yo(w).display === "none" && (B = w.style.display, w.style.display = "block", N = Ac(w), B ? w.style.display = B : w.style.removeProperty("display")), U = Fb(C[0], N[s.d]), z = Fb(C[1] || "0", i), e = N[s.p] - h[s.p] - m + U + r - z, l && Hb(l, z, s, i - z < 20 || l._isStart && z > 20), i -= i - z
      }
      if (S && (c[S] = e || -.001, e < 0 && (e = 0)), a) {
         var I = e + i,
            O = a._isStart;
         T = "scroll" + s.d2, Hb(a, I, s, O && I > 20 || !O && (g ? Math.max(ai[T], lo[T]) : a.parentNode[T]) <= I + 1), g && (h = Ac(l), g && (a.style[s.op.p] = h[s.op.p] - s.op.m - a._offset + Gs))
      }
      return x && w && (T = Ac(w), x.seek(v), b = Ac(w), x._caScrollDist = T[s.p] - b[s.p], e = e / x._caScrollDist * v), x && x.seek(E), x ? e : Math.round(e)
   },
   Cie = /(webkit|moz|length|cssText|inset)/i,
   XU = function (e, t, i, s) {
      if (e.parentNode !== t) {
         var r = e.style,
            a, l;
         if (t === ai) {
            e._stOrig = r.cssText, l = Yo(e);
            for (a in l) !+a && !Cie.test(a) && l[a] && typeof r[a] == "string" && a !== "0" && (r[a] = l[a]);
            r.top = i, r.left = s
         } else r.cssText = e._stOrig;
         bt.core.getCache(e).uncache = 1, t.appendChild(e)
      }
   },
   jF = function (e, t, i) {
      var s = t,
         r = s;
      return function (a) {
         var l = Math.round(e());
         return l !== s && l !== r && Math.abs(l - s) > 3 && Math.abs(l - r) > 3 && (a = l, i && i()), r = s, s = Math.round(a), s
      }
   },
   pb = function (e, t, i) {
      var s = {};
      s[t.p] = "+=" + i, bt.set(e, s)
   },
   WU = function (e, t) {
      var i = ch(e, t),
         s = "_scroll" + t.p2,
         r = function a(l, c, h, m, g) {
            var v = a.tween,
               x = c.onComplete,
               S = {};
            h = h || i();
            var E = jF(i, h, function () {
               v.kill(), a.tween = 0
            });
            return g = m && g || 0, m = m || l - h, v && v.kill(), c[s] = l, c.inherit = !1, c.modifiers = S, S[s] = function () {
               return E(h + m * v.ratio + g * v.ratio * v.ratio)
            }, c.onUpdate = function () {
               Dn.cache++, a.tween && Nc()
            }, c.onComplete = function () {
               a.tween = 0, x && x.call(v)
            }, v = a.tween = bt.to(e, c), v
         };
      return e[s] = i, i.wheelHandler = function () {
         return r.tween && r.tween.kill() && (r.tween = 0)
      }, tr(e, "wheel", i.wheelHandler), Nn.isTouch && tr(e, "touchmove", i.wheelHandler), r
   },
   Nn = function () {
      function n(t, i) {
         Hm || n.register(bt) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"), sR(this), this.init(t, i)
      }
      var e = n.prototype;
      return e.init = function (i, s) {
         if (this.progress = this.start = 0, this.vars && this.kill(!0, !0), !P0) {
            this.update = this.refresh = this.kill = Ru;
            return
         }
         i = HU(ao(i) || B0(i) || i.nodeType ? {
            trigger: i
         } : i, fb);
         var r = i,
            a = r.onUpdate,
            l = r.toggleClass,
            c = r.id,
            h = r.onToggle,
            m = r.onRefresh,
            g = r.scrub,
            v = r.trigger,
            x = r.pin,
            S = r.pinSpacing,
            E = r.invalidateOnRefresh,
            T = r.anticipatePin,
            b = r.onScrubComplete,
            w = r.onSnapComplete,
            C = r.once,
            N = r.snap,
            U = r.pinReparent,
            z = r.pinSpacer,
            B = r.containerAnimation,
            I = r.fastScrollEnd,
            O = r.preventOverlaps,
            P = i.horizontal || i.containerAnimation && i.horizontal !== !1 ? fa : ks,
            q = !g && g !== 0,
            Q = Oa(i.scroller || Cn),
            $ = bt.core.getCache(Q),
            ae = rp(Q),
            fe = ("pinType" in i ? i.pinType : nh(Q, "pinType") || ae && "fixed") === "fixed",
            k = [i.onEnter, i.onLeave, i.onEnterBack, i.onLeaveBack],
            Z = q && i.toggleActions.split(" "),
            J = "markers" in i ? i.markers : fb.markers,
            pe = ae ? 0 : parseFloat(Yo(Q)["border" + P.p2 + wg]) || 0,
            F = this,
            ie = i.onRefreshInit && function () {
               return i.onRefreshInit(F)
            },
            ye = xie(Q, ae, P),
            we = _ie(Q, ae),
            oe = 0,
            be = 0,
            Pe = 0,
            Ge = ch(Q, P),
            Xe, yt, vt, Mt, zt, lt, ne, sn, ze, te, Be, Je, Ue, K, G, me, Ne, Oe, De, Ye, We, Ze, kt, Ke, et, xt, mt, it, jt, Rt, cn, le, rt, Re, Ie, nt, at, Bt, mn;
         if (F._startClamp = F._endClamp = !1, F._dir = P, T *= 45, F.scroller = Q, F.scroll = B ? B.time.bind(B) : Ge, Mt = Ge(), F.vars = i, s = s || i.animation, "refreshPriority" in i && (CF = 1, i.refreshPriority === -9999 && (dy = F)), $.tweenScroll = $.tweenScroll || {
               top: WU(Q, ks),
               left: WU(Q, fa)
            }, F.tweenTo = Xe = $.tweenScroll[P.p], F.scrubDuration = function (Qe) {
               rt = B0(Qe) && Qe, rt ? le ? le.duration(Qe) : le = bt.to(s, {
                  ease: "expo",
                  totalProgress: "+=0",
                  inherit: !1,
                  duration: rt,
                  paused: !0,
                  onComplete: function () {
                     return b && b(F)
                  }
               }) : (le && le.progress(1).kill(), le = 0)
            }, s && (s.vars.lazy = !1, s._initted && !F.isReverted || s.vars.immediateRender !== !1 && i.immediateRender !== !1 && s.duration() && s.render(0, !0, !0), F.animation = s.pause(), s.scrollTrigger = F, F.scrubDuration(g), Rt = 0, c || (c = s.vars.id)), N && ((!Rd(N) || N.push) && (N = {
               snapTo: N
            }), "scrollBehavior" in ai.style && bt.set(ae ? [ai, lo] : Q, {
               scrollBehavior: "auto"
            }), Dn.forEach(function (Qe) {
               return Pr(Qe) && Qe.target === (ae ? wi.scrollingElement || lo : Q) && (Qe.smooth = !1)
            }), vt = Pr(N.snapTo) ? N.snapTo : N.snapTo === "labels" ? bie(s) : N.snapTo === "labelsDirectional" ? Tie(s) : N.directional !== !1 ? function (Qe, St) {
               return SC(N.snapTo)(Qe, Nr() - be < 500 ? 0 : St.direction)
            } : bt.utils.snap(N.snapTo), Re = N.duration || {
               min: .1,
               max: 2
            }, Re = Rd(Re) ? ly(Re.min, Re.max) : ly(Re, Re), Ie = bt.delayedCall(N.delay || rt / 2 || .1, function () {
               var Qe = Ge(),
                  St = Nr() - be < 500,
                  gt = Xe.tween;
               if ((St || Math.abs(F.getVelocity()) < 10) && !gt && !tE && oe !== Qe) {
                  var Dt = (Qe - lt) / K,
                     Ti = s && !q ? s.totalProgress() : Dt,
                     Xt = St ? 0 : (Ti - cn) / (Nr() - U0) * 1e3 || 0,
                     _n = bt.utils.clamp(-Dt, 1 - Dt, zm(Xt / 2) * Xt / .185),
                     ii = Dt + (N.inertia === !1 ? 0 : _n),
                     Ft, Mn, gn = N,
                     Zi = gn.onStart,
                     zn = gn.onInterrupt,
                     Pn = gn.onComplete;
                  if (Ft = vt(ii, F), B0(Ft) || (Ft = ii), Mn = Math.max(0, Math.round(lt + Ft * K)), Qe <= ne && Qe >= lt && Mn !== Qe) {
                     if (gt && !gt._initted && gt.data <= zm(Mn - Qe)) return;
                     N.inertia === !1 && (_n = Ft - Dt), Xe(Mn, {
                        duration: Re(zm(Math.max(zm(ii - Ti), zm(Ft - Ti)) * .185 / Xt / .05 || 0)),
                        ease: N.ease || "power3",
                        data: zm(Mn - Qe),
                        onInterrupt: function () {
                           return Ie.restart(!0) && zn && zn(F)
                        },
                        onComplete: function () {
                           F.update(), oe = Ge(), s && !q && (le ? le.resetTo("totalProgress", Ft, s._tTime / s._tDur) : s.progress(Ft)), Rt = cn = s && !q ? s.totalProgress() : F.progress, w && w(F), Pn && Pn(F)
                        }
                     }, Qe, _n * K, Mn - Qe - _n * K), Zi && Zi(F, Xe.tween)
                  }
               } else F.isActive && oe !== Qe && Ie.restart(!0)
            }).pause()), c && (aR[c] = F), v = F.trigger = Oa(v || x !== !0 && x), mn = v && v._gsap && v._gsap.stRevert, mn && (mn = mn(F)), x = x === !0 ? v : Oa(x), ao(l) && (l = {
               targets: v,
               className: l
            }), x && (S === !1 || S === Wo || (S = !S && x.parentNode && x.parentNode.style && Yo(x.parentNode).display === "flex" ? !1 : Ms), F.pin = x, yt = bt.core.getCache(x), yt.spacer ? G = yt.pinState : (z && (z = Oa(z), z && !z.nodeType && (z = z.current || z.nativeElement), yt.spacerIsNative = !!z, z && (yt.spacerState = db(z))), yt.spacer = Oe = z || wi.createElement("div"), Oe.classList.add("pin-spacer"), c && Oe.classList.add("pin-spacer-" + c), yt.pinState = G = db(x)), i.force3D !== !1 && bt.set(x, {
               force3D: !0
            }), F.spacer = Oe = yt.spacer, jt = Yo(x), Ke = jt[S + P.os2], Ye = bt.getProperty(x), We = bt.quickSetter(x, P.a, Gs), UA(x, Oe, jt), Ne = db(x)), J) {
            Je = Rd(J) ? HU(J, VU) : VU, te = hb("scroller-start", c, Q, P, Je, 0), Be = hb("scroller-end", c, Q, P, Je, 0, te), De = te["offset" + P.op.d2];
            var Yn = Oa(nh(Q, "content") || Q);
            sn = this.markerStart = hb("start", c, Yn, P, Je, De, 0, B), ze = this.markerEnd = hb("end", c, Yn, P, Je, De, 0, B), B && (Bt = bt.quickSetter([sn, ze], P.a, Gs)), !fe && !(Fu.length && nh(Q, "fixedMarkers") === !0) && (Sie(ae ? ai : Q), bt.set([te, Be], {
               force3D: !0
            }), xt = bt.quickSetter(te, P.a, Gs), it = bt.quickSetter(Be, P.a, Gs))
         }
         if (B) {
            var ut = B.vars.onUpdate,
               _t = B.vars.onUpdateParams;
            B.eventCallback("onUpdate", function () {
               F.update(0, 0, 1), ut && ut.apply(B, _t || [])
            })
         }
         if (F.previous = function () {
               return Tn[Tn.indexOf(F) - 1]
            }, F.next = function () {
               return Tn[Tn.indexOf(F) + 1]
            }, F.revert = function (Qe, St) {
               if (!St) return F.kill(!0);
               var gt = Qe !== !1 || !F.enabled,
                  Dt = Dr;
               gt !== F.isReverted && (gt && (nt = Math.max(Ge(), F.scroll.rec || 0), Pe = F.progress, at = s && s.progress()), sn && [sn, ze, te, Be].forEach(function (Ti) {
                  return Ti.style.display = gt ? "none" : "block"
               }), gt && (Dr = F, F.update(gt)), x && (!U || !F.isActive) && (gt ? Aie(x, Oe, G) : UA(x, Oe, Yo(x), et)), gt || F.update(gt), Dr = Dt, F.isReverted = gt)
            }, F.refresh = function (Qe, St, gt, Dt) {
               if (!((Dr || !F.enabled) && !St)) {
                  if (x && Qe && nl) {
                     tr(n, "scrollEnd", HF);
                     return
                  }!oa && ie && ie(F), Dr = F, Xe.tween && !gt && (Xe.tween.kill(), Xe.tween = 0), le && le.pause(), E && s && (s.revert({
                     kill: !1
                  }).invalidate(), s.getChildren && s.getChildren(!0, !0, !1).forEach(function (Wt) {
                     return Wt.vars.immediateRender && Wt.render(0, !0, !0)
                  })), F.isReverted || F.revert(!0, !0), F._subPinOffset = !1;
                  var Ti = ye(),
                     Xt = we(),
                     _n = B ? B.duration() : Ou(Q, P),
                     ii = K <= .01 || !K,
                     Ft = 0,
                     Mn = Dt || 0,
                     gn = Rd(gt) ? gt.end : i.end,
                     Zi = i.endTrigger || v,
                     zn = Rd(gt) ? gt.start : i.start || (i.start === 0 || !v ? 0 : x ? "0 0" : "0 100%"),
                     Pn = F.pinnedContainer = i.pinnedContainer && Oa(i.pinnedContainer, F),
                     Ns = v && Math.max(0, Tn.indexOf(F)) || 0,
                     Ei = Ns,
                     ei, X, ue, Te, xe, de, je, st, ot, ct, At, wt, Tt;
                  for (J && Rd(gt) && (wt = bt.getProperty(te, P.p), Tt = bt.getProperty(Be, P.p)); Ei-- > 0;) de = Tn[Ei], de.end || de.refresh(0, 1) || (Dr = F), je = de.pin, je && (je === v || je === x || je === Pn) && !de.isReverted && (ct || (ct = []), ct.unshift(de), de.revert(!0, !0)), de !== Tn[Ei] && (Ns--, Ei--);
                  for (Pr(zn) && (zn = zn(F)), zn = BU(zn, "start", F), lt = qU(zn, v, Ti, P, Ge(), sn, te, F, Xt, pe, fe, _n, B, F._startClamp && "_startClamp") || (x ? -.001 : 0), Pr(gn) && (gn = gn(F)), ao(gn) && !gn.indexOf("+=") && (~gn.indexOf(" ") ? gn = (ao(zn) ? zn.split(" ")[0] : "") + gn : (Ft = Fb(gn.substr(2), Ti), gn = ao(zn) ? zn : (B ? bt.utils.mapRange(0, B.duration(), B.scrollTrigger.start, B.scrollTrigger.end, lt) : lt) + Ft, Zi = v)), gn = BU(gn, "end", F), ne = Math.max(lt, qU(gn || (Zi ? "100% 0" : _n), Zi, Ti, P, Ge() + Ft, ze, Be, F, Xt, pe, fe, _n, B, F._endClamp && "_endClamp")) || -.001, Ft = 0, Ei = Ns; Ei--;) de = Tn[Ei], je = de.pin, je && de.start - de._pinPush <= lt && !B && de.end > 0 && (ei = de.end - (F._startClamp ? Math.max(0, de.start) : de.start), (je === v && de.start - de._pinPush < lt || je === Pn) && isNaN(zn) && (Ft += ei * (1 - de.progress)), je === x && (Mn += ei));
                  if (lt += Ft, ne += Ft, F._startClamp && (F._startClamp += Ft), F._endClamp && !oa && (F._endClamp = ne || -.001, ne = Math.min(ne, Ou(Q, P))), K = ne - lt || (lt -= .01) && .001, ii && (Pe = bt.utils.clamp(0, 1, bt.utils.normalize(lt, ne, nt))), F._pinPush = Mn, sn && Ft && (ei = {}, ei[P.a] = "+=" + Ft, Pn && (ei[P.p] = "-=" + Ge()), bt.set([sn, ze], ei)), x && !(rR && F.end >= Ou(Q, P))) ei = Yo(x), Te = P === ks, ue = Ge(), Ze = parseFloat(Ye(P.a)) + Mn, !_n && ne > 1 && (At = (ae ? wi.scrollingElement || lo : Q).style, At = {
                     style: At,
                     value: At["overflow" + P.a.toUpperCase()]
                  }, ae && Yo(ai)["overflow" + P.a.toUpperCase()] !== "scroll" && (At.style["overflow" + P.a.toUpperCase()] = "scroll")), UA(x, Oe, ei), Ne = db(x), X = Ac(x, !0), st = fe && ch(Q, Te ? fa : ks)(), S ? (et = [S + P.os2, K + Mn + Gs], et.t = Oe, Ei = S === Ms ? W1(x, P) + K + Mn : 0, Ei && (et.push(P.d, Ei + Gs), Oe.style.flexBasis !== "auto" && (Oe.style.flexBasis = Ei + Gs)), lg(et), Pn && Tn.forEach(function (Wt) {
                     Wt.pin === Pn && Wt.vars.pinSpacing !== !1 && (Wt._subPinOffset = !0)
                  }), fe && Ge(nt)) : (Ei = W1(x, P), Ei && Oe.style.flexBasis !== "auto" && (Oe.style.flexBasis = Ei + Gs)), fe && (xe = {
                     top: X.top + (Te ? ue - lt : st) + Gs,
                     left: X.left + (Te ? st : ue - lt) + Gs,
                     boxSizing: "border-box",
                     position: "fixed"
                  }, xe[Kd] = xe["max" + wg] = Math.ceil(X.width) + Gs, xe[Zd] = xe["max" + _C] = Math.ceil(X.height) + Gs, xe[Wo] = xe[Wo + fy] = xe[Wo + uy] = xe[Wo + hy] = xe[Wo + cy] = "0", xe[Ms] = ei[Ms], xe[Ms + fy] = ei[Ms + fy], xe[Ms + uy] = ei[Ms + uy], xe[Ms + hy] = ei[Ms + hy], xe[Ms + cy] = ei[Ms + cy], me = Rie(G, xe, U), oa && Ge(0)), s ? (ot = s._initted, RA(1), s.render(s.duration(), !0, !0), kt = Ye(P.a) - Ze + K + Mn, mt = Math.abs(K - kt) > 1, fe && mt && me.splice(me.length - 2, 2), s.render(0, !0, !0), ot || s.invalidate(!0), s.parent || s.totalTime(s.totalTime()), RA(0)) : kt = K, At && (At.value ? At.style["overflow" + P.a.toUpperCase()] = At.value : At.style.removeProperty("overflow-" + P.a));
                  else if (v && Ge() && !B)
                     for (X = v.parentNode; X && X !== ai;) X._pinOffset && (lt -= X._pinOffset, ne -= X._pinOffset), X = X.parentNode;
                  ct && ct.forEach(function (Wt) {
                     return Wt.revert(!1, !0)
                  }), F.start = lt, F.end = ne, Mt = zt = oa ? nt : Ge(), !B && !oa && (Mt < nt && Ge(nt), F.scroll.rec = 0), F.revert(!1, !0), be = Nr(), Ie && (oe = -1, Ie.restart(!0)), Dr = 0, s && q && (s._initted || at) && s.progress() !== at && s.progress(at || 0, !0).render(s.time(), !0, !0), (ii || Pe !== F.progress || B || E || s && !s._initted) && (s && !q && (s._initted || Pe || s.vars.immediateRender !== !1) && s.totalProgress(B && lt < -.001 && !Pe ? bt.utils.normalize(lt, ne, 0) : Pe, !0), F.progress = ii || (Mt - lt) / K === Pe ? 0 : Pe), x && S && (Oe._pinOffset = Math.round(F.progress * kt)), le && le.invalidate(), isNaN(wt) || (wt -= bt.getProperty(te, P.p), Tt -= bt.getProperty(Be, P.p), pb(te, P, wt), pb(sn, P, wt - (Dt || 0)), pb(Be, P, Tt), pb(ze, P, Tt - (Dt || 0))), ii && !oa && F.update(), m && !oa && !Ue && (Ue = !0, m(F), Ue = !1)
               }
            }, F.getVelocity = function () {
               return (Ge() - zt) / (Nr() - U0) * 1e3 || 0
            }, F.endAnimation = function () {
               E0(F.callbackAnimation), s && (le ? le.progress(1) : s.paused() ? q || E0(s, F.direction < 0, 1) : E0(s, s.reversed()))
            }, F.labelToScroll = function (Qe) {
               return s && s.labels && (lt || F.refresh() || lt) + s.labels[Qe] / s.duration() * K || 0
            }, F.getTrailing = function (Qe) {
               var St = Tn.indexOf(F),
                  gt = F.direction > 0 ? Tn.slice(0, St).reverse() : Tn.slice(St + 1);
               return (ao(Qe) ? gt.filter(function (Dt) {
                  return Dt.vars.preventOverlaps === Qe
               }) : gt).filter(function (Dt) {
                  return F.direction > 0 ? Dt.end <= lt : Dt.start >= ne
               })
            }, F.update = function (Qe, St, gt) {
               if (!(B && !gt && !Qe)) {
                  var Dt = oa === !0 ? nt : F.scroll(),
                     Ti = Qe ? 0 : (Dt - lt) / K,
                     Xt = Ti < 0 ? 0 : Ti > 1 ? 1 : Ti || 0,
                     _n = F.progress,
                     ii, Ft, Mn, gn, Zi, zn, Pn, Ns;
                  if (St && (zt = Mt, Mt = B ? Ge() : Dt, N && (cn = Rt, Rt = s && !q ? s.totalProgress() : Xt)), T && x && !Dr && !ob && nl && (!Xt && lt < Dt + (Dt - zt) / (Nr() - U0) * T ? Xt = 1e-4 : Xt === 1 && ne > Dt + (Dt - zt) / (Nr() - U0) * T && (Xt = .9999)), Xt !== _n && F.enabled) {
                     if (ii = F.isActive = !!Xt && Xt < 1, Ft = !!_n && _n < 1, zn = ii !== Ft, Zi = zn || !!Xt != !!_n, F.direction = Xt > _n ? 1 : -1, F.progress = Xt, Zi && !Dr && (Mn = Xt && !_n ? 0 : Xt === 1 ? 1 : _n === 1 ? 2 : 3, q && (gn = !zn && Z[Mn + 1] !== "none" && Z[Mn + 1] || Z[Mn], Ns = s && (gn === "complete" || gn === "reset" || gn in s))), O && (zn || Ns) && (Ns || g || !s) && (Pr(O) ? O(F) : F.getTrailing(O).forEach(function (ue) {
                           return ue.endAnimation()
                        })), q || (le && !Dr && !ob ? (le._dp._time - le._start !== le._time && le.render(le._dp._time - le._start), le.resetTo ? le.resetTo("totalProgress", Xt, s._tTime / s._tDur) : (le.vars.totalProgress = Xt, le.invalidate().restart())) : s && s.totalProgress(Xt, !!(Dr && (be || Qe)))), x) {
                        if (Qe && S && (Oe.style[S + P.os2] = Ke), !fe) We(L0(Ze + kt * Xt));
                        else if (Zi) {
                           if (Pn = !Qe && Xt > _n && ne + 1 > Dt && Dt + 1 >= Ou(Q, P), U)
                              if (!Qe && (ii || Pn)) {
                                 var Ei = Ac(x, !0),
                                    ei = Dt - lt;
                                 XU(x, ai, Ei.top + (P === ks ? ei : 0) + Gs, Ei.left + (P === ks ? 0 : ei) + Gs)
                              } else XU(x, Oe);
                           lg(ii || Pn ? me : Ne), mt && Xt < 1 && ii || We(Ze + (Xt === 1 && !Pn ? kt : 0))
                        }
                     }
                     N && !Xe.tween && !Dr && !ob && Ie.restart(!0), l && (zn || C && Xt && (Xt < 1 || !CA)) && sx(l.targets).forEach(function (ue) {
                        return ue.classList[ii || C ? "add" : "remove"](l.className)
                     }), a && !q && !Qe && a(F), Zi && !Dr ? (q && (Ns && (gn === "complete" ? s.pause().totalProgress(1) : gn === "reset" ? s.restart(!0).pause() : gn === "restart" ? s.restart(!0) : s[gn]()), a && a(F)), (zn || !CA) && (h && zn && NA(F, h), k[Mn] && NA(F, k[Mn]), C && (Xt === 1 ? F.kill(!1, 1) : k[Mn] = 0), zn || (Mn = Xt === 1 ? 1 : 3, k[Mn] && NA(F, k[Mn]))), I && !ii && Math.abs(F.getVelocity()) > (B0(I) ? I : 2500) && (E0(F.callbackAnimation), le ? le.progress(1) : E0(s, gn === "reverse" ? 1 : !Xt, 1))) : q && a && !Dr && a(F)
                  }
                  if (it) {
                     var X = B ? Dt / B.duration() * (B._caScrollDist || 0) : Dt;
                     xt(X + (te._isFlipped ? 1 : 0)), it(X)
                  }
                  Bt && Bt(-Dt / B.duration() * (B._caScrollDist || 0))
               }
            }, F.enable = function (Qe, St) {
               F.enabled || (F.enabled = !0, tr(Q, "resize", z0), ae || tr(Q, "scroll", Im), ie && tr(n, "refreshInit", ie), Qe !== !1 && (F.progress = Pe = 0, Mt = zt = oe = Ge()), St !== !1 && F.refresh())
            }, F.getTween = function (Qe) {
               return Qe && Xe ? Xe.tween : le
            }, F.setPositions = function (Qe, St, gt, Dt) {
               if (B) {
                  var Ti = B.scrollTrigger,
                     Xt = B.duration(),
                     _n = Ti.end - Ti.start;
                  Qe = Ti.start + _n * Qe / Xt, St = Ti.start + _n * St / Xt
               }
               F.refresh(!1, !1, {
                  start: zU(Qe, gt && !!F._startClamp),
                  end: zU(St, gt && !!F._endClamp)
               }, Dt), F.update()
            }, F.adjustPinSpacing = function (Qe) {
               if (et && Qe) {
                  var St = et.indexOf(P.d) + 1;
                  et[St] = parseFloat(et[St]) + Qe + Gs, et[1] = parseFloat(et[1]) + Qe + Gs, lg(et)
               }
            }, F.disable = function (Qe, St) {
               if (F.enabled && (Qe !== !1 && F.revert(!0, !0), F.enabled = F.isActive = !1, St || le && le.pause(), nt = 0, yt && (yt.uncache = 1), ie && er(n, "refreshInit", ie), Ie && (Ie.pause(), Xe.tween && Xe.tween.kill() && (Xe.tween = 0)), !ae)) {
                  for (var gt = Tn.length; gt--;)
                     if (Tn[gt].scroller === Q && Tn[gt] !== F) return;
                  er(Q, "resize", z0), ae || er(Q, "scroll", Im)
               }
            }, F.kill = function (Qe, St) {
               F.disable(Qe, St), le && !St && le.kill(), c && delete aR[c];
               var gt = Tn.indexOf(F);
               gt >= 0 && Tn.splice(gt, 1), gt === aa && Vb > 0 && aa--, gt = 0, Tn.forEach(function (Dt) {
                  return Dt.scroller === F.scroller && (gt = 1)
               }), gt || oa || (F.scroll.rec = 0), s && (s.scrollTrigger = null, Qe && s.revert({
                  kill: !1
               }), St || s.kill()), sn && [sn, ze, te, Be].forEach(function (Dt) {
                  return Dt.parentNode && Dt.parentNode.removeChild(Dt)
               }), dy === F && (dy = 0), x && (yt && (yt.uncache = 1), gt = 0, Tn.forEach(function (Dt) {
                  return Dt.pin === x && gt++
               }), gt || (yt.spacer = 0)), i.onKill && i.onKill(F)
            }, Tn.push(F), F.enable(!1, !1), mn && mn(F), s && s.add && !K) {
            var It = F.update;
            F.update = function () {
               F.update = It, Dn.cache++, lt || ne || F.refresh()
            }, bt.delayedCall(.01, F.update), K = .01, lt = ne = 0
         } else F.refresh();
         x && Mie()
      }, n.register = function (i) {
         return Hm || (bt = i || PF(), UF() && window.document && n.enable(), Hm = P0), Hm
      }, n.defaults = function (i) {
         if (i)
            for (var s in i) fb[s] = i[s];
         return fb
      }, n.disable = function (i, s) {
         P0 = 0, Tn.forEach(function (a) {
            return a[s ? "kill" : "disable"](i)
         }), er(Cn, "wheel", Im), er(wi, "scroll", Im), clearInterval(ab), er(wi, "touchcancel", Ru), er(ai, "touchstart", Ru), ub(er, wi, "pointerdown,touchstart,mousedown", IU), ub(er, wi, "pointerup,touchend,mouseup", FU), q1.kill(), lb(er);
         for (var r = 0; r < Dn.length; r += 3) cb(er, Dn[r], Dn[r + 1]), cb(er, Dn[r], Dn[r + 2])
      }, n.enable = function () {
         if (Cn = window, wi = document, lo = wi.documentElement, ai = wi.body, bt && (sx = bt.utils.toArray, ly = bt.utils.clamp, sR = bt.core.context || Ru, RA = bt.core.suppressOverwrites || Ru, gC = Cn.history.scrollRestoration || "auto", oR = Cn.pageYOffset || 0, bt.core.globals("ScrollTrigger", n), ai)) {
            P0 = 1, og = document.createElement("div"), og.style.height = "100vh", og.style.position = "absolute", kF(), yie(), ps.register(bt), n.isTouch = ps.isTouch, Gf = ps.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent), iR = ps.isTouch === 1, tr(Cn, "wheel", Im), mC = [Cn, wi, lo, ai], bt.matchMedia ? (n.matchMedia = function (h) {
               var m = bt.matchMedia(),
                  g;
               for (g in h) m.add(g, h[g]);
               return m
            }, bt.addEventListener("matchMediaInit", function () {
               return bC()
            }), bt.addEventListener("matchMediaRevert", function () {
               return VF()
            }), bt.addEventListener("matchMedia", function () {
               Id(0, 1), op("matchMedia")
            }), bt.matchMedia().add("(orientation: portrait)", function () {
               return OA(), OA
            })) : console.warn("Requires GSAP 3.11.0 or later"), OA(), tr(wi, "scroll", Im);
            var i = ai.hasAttribute("style"),
               s = ai.style,
               r = s.borderTopStyle,
               a = bt.core.Animation.prototype,
               l, c;
            for (a.revert || Object.defineProperty(a, "revert", {
                  value: function () {
                     return this.time(-.01, !0)
                  }
               }), s.borderTopStyle = "solid", l = Ac(ai), ks.m = Math.round(l.top + ks.sc()) || 0, fa.m = Math.round(l.left + fa.sc()) || 0, r ? s.borderTopStyle = r : s.removeProperty("border-top-style"), i || (ai.setAttribute("style", ""), ai.removeAttribute("style")), ab = setInterval(GU, 250), bt.delayedCall(.5, function () {
                  return ob = 0
               }), tr(wi, "touchcancel", Ru), tr(ai, "touchstart", Ru), ub(tr, wi, "pointerdown,touchstart,mousedown", IU), ub(tr, wi, "pointerup,touchend,mouseup", FU), nR = bt.utils.checkPrefix("transform"), Gb.push(nR), Hm = Nr(), q1 = bt.delayedCall(.2, Id).pause(), Vm = [wi, "visibilitychange", function () {
                  var h = Cn.innerWidth,
                     m = Cn.innerHeight;
                  wi.hidden ? (PU = h, LU = m) : (PU !== h || LU !== m) && z0()
               }, wi, "DOMContentLoaded", Id, Cn, "load", Id, Cn, "resize", z0], lb(tr), Tn.forEach(function (h) {
                  return h.enable(0, 1)
               }), c = 0; c < Dn.length; c += 3) cb(er, Dn[c], Dn[c + 1]), cb(er, Dn[c], Dn[c + 2])
         }
      }, n.config = function (i) {
         "limitCallbacks" in i && (CA = !!i.limitCallbacks);
         var s = i.syncInterval;
         s && clearInterval(ab) || (ab = s) && setInterval(GU, s), "ignoreMobileResize" in i && (iR = n.isTouch === 1 && i.ignoreMobileResize), "autoRefreshEvents" in i && (lb(er) || lb(tr, i.autoRefreshEvents || "none"), DF = (i.autoRefreshEvents + "").indexOf("resize") === -1)
      }, n.scrollerProxy = function (i, s) {
         var r = Oa(i),
            a = Dn.indexOf(r),
            l = rp(r);
         ~a && Dn.splice(a, l ? 6 : 2), s && (l ? Fu.unshift(Cn, s, ai, s, lo, s) : Fu.unshift(r, s))
      }, n.clearMatchMedia = function (i) {
         Tn.forEach(function (s) {
            return s._ctx && s._ctx.query === i && s._ctx.kill(!0, !0)
         })
      }, n.isInViewport = function (i, s, r) {
         var a = (ao(i) ? Oa(i) : i).getBoundingClientRect(),
            l = a[r ? Kd : Zd] * s || 0;
         return r ? a.right - l > 0 && a.left + l < Cn.innerWidth : a.bottom - l > 0 && a.top + l < Cn.innerHeight
      }, n.positionInViewport = function (i, s, r) {
         ao(i) && (i = Oa(i));
         var a = i.getBoundingClientRect(),
            l = a[r ? Kd : Zd],
            c = s == null ? l / 2 : s in Y1 ? Y1[s] * l : ~s.indexOf("%") ? parseFloat(s) * l / 100 : parseFloat(s) || 0;
         return r ? (a.left + c) / Cn.innerWidth : (a.top + c) / Cn.innerHeight
      }, n.killAll = function (i) {
         if (Tn.slice(0).forEach(function (r) {
               return r.vars.id !== "ScrollSmoother" && r.kill()
            }), i !== !0) {
            var s = ap.killAll || [];
            ap = {}, s.forEach(function (r) {
               return r()
            })
         }
      }, n
   }();
Nn.version = "3.13.0";
Nn.saveStyles = function (n) {
   return n ? sx(n).forEach(function (e) {
      if (e && e.style) {
         var t = ro.indexOf(e);
         t >= 0 && ro.splice(t, 5), ro.push(e, e.style.cssText, e.getBBox && e.getAttribute("transform"), bt.core.getCache(e), sR())
      }
   }) : ro
};
Nn.revert = function (n, e) {
   return bC(!n, e)
};
Nn.create = function (n, e) {
   return new Nn(n, e)
};
Nn.refresh = function (n) {
   return n ? z0(!0) : (Hm || Nn.register()) && Id(!0)
};
Nn.update = function (n) {
   return ++Dn.cache && Nc(n === !0 ? 2 : 0)
};
Nn.clearScrollMemory = GF;
Nn.maxScroll = function (n, e) {
   return Ou(n, e ? fa : ks)
};
Nn.getScrollFunc = function (n, e) {
   return ch(Oa(n), e ? fa : ks)
};
Nn.getById = function (n) {
   return aR[n]
};
Nn.getAll = function () {
   return Tn.filter(function (n) {
      return n.vars.id !== "ScrollSmoother"
   })
};
Nn.isScrolling = function () {
   return !!nl
};
Nn.snapDirectional = SC;
Nn.addEventListener = function (n, e) {
   var t = ap[n] || (ap[n] = []);
   ~t.indexOf(e) || t.push(e)
};
Nn.removeEventListener = function (n, e) {
   var t = ap[n],
      i = t && t.indexOf(e);
   i >= 0 && t.splice(i, 1)
};
Nn.batch = function (n, e) {
   var t = [],
      i = {},
      s = e.interval || .016,
      r = e.batchMax || 1e9,
      a = function (h, m) {
         var g = [],
            v = [],
            x = bt.delayedCall(s, function () {
               m(g, v), g = [], v = []
            }).pause();
         return function (S) {
            g.length || x.restart(!0), g.push(S.trigger), v.push(S), r <= g.length && x.progress(1)
         }
      },
      l;
   for (l in e) i[l] = l.substr(0, 2) === "on" && Pr(e[l]) && l !== "onRefreshInit" ? a(l, e[l]) : e[l];
   return Pr(r) && (r = r(), tr(Nn, "refresh", function () {
      return r = e.batchMax()
   })), sx(n).forEach(function (c) {
      var h = {};
      for (l in i) h[l] = i[l];
      h.trigger = c, t.push(Nn.create(h))
   }), t
};
var YU = function (e, t, i, s) {
      return t > s ? e(s) : t < 0 && e(0), i > s ? (s - t) / (i - t) : i < 0 ? t / (t - i) : 1
   },
   PA = function n(e, t) {
      t === !0 ? e.style.removeProperty("touch-action") : e.style.touchAction = t === !0 ? "auto" : t ? "pan-" + t + (ps.isTouch ? " pinch-zoom" : "") : "none", e === lo && n(ai, t)
   },
   mb = {
      auto: 1,
      scroll: 1
   },
   Die = function (e) {
      var t = e.event,
         i = e.target,
         s = e.axis,
         r = (t.changedTouches ? t.changedTouches[0] : t).target,
         a = r._gsap || bt.core.getCache(r),
         l = Nr(),
         c;
      if (!a._isScrollT || l - a._isScrollT > 2e3) {
         for (; r && r !== ai && (r.scrollHeight <= r.clientHeight && r.scrollWidth <= r.clientWidth || !(mb[(c = Yo(r)).overflowY] || mb[c.overflowX]));) r = r.parentNode;
         a._isScroll = r && r !== i && !rp(r) && (mb[(c = Yo(r)).overflowY] || mb[c.overflowX]), a._isScrollT = l
      }(a._isScroll || s === "x") && (t.stopPropagation(), t._gsapAllow = !0)
   },
   qF = function (e, t, i, s) {
      return ps.create({
         target: e,
         capture: !0,
         debounce: !1,
         lockAxis: !0,
         type: t,
         onWheel: s = s && Die,
         onPress: s,
         onDrag: s,
         onScroll: s,
         onEnable: function () {
            return i && tr(wi, ps.eventTypes[0], ZU, !1, !0)
         },
         onDisable: function () {
            return er(wi, ps.eventTypes[0], ZU, !0)
         }
      })
   },
   Nie = /(input|label|select|textarea)/i,
   KU, ZU = function (e) {
      var t = Nie.test(e.target.tagName);
      (t || KU) && (e._gsapAllow = !0, KU = t)
   },
   Oie = function (e) {
      Rd(e) || (e = {}), e.preventDefault = e.isNormalizer = e.allowClicks = !0, e.type || (e.type = "wheel,touch"), e.debounce = !!e.debounce, e.id = e.id || "normalizer";
      var t = e,
         i = t.normalizeScrollX,
         s = t.momentum,
         r = t.allowNestedScroll,
         a = t.onRelease,
         l, c, h = Oa(e.target) || lo,
         m = bt.core.globals().ScrollSmoother,
         g = m && m.get(),
         v = Gf && (e.content && Oa(e.content) || g && e.content !== !1 && !g.smooth() && g.content()),
         x = ch(h, ks),
         S = ch(h, fa),
         E = 1,
         T = (ps.isTouch && Cn.visualViewport ? Cn.visualViewport.scale * Cn.visualViewport.width : Cn.outerWidth) / Cn.innerWidth,
         b = 0,
         w = Pr(s) ? function () {
            return s(l)
         } : function () {
            return s || 2.8
         },
         C, N, U = qF(h, e.type, !0, r),
         z = function () {
            return N = !1
         },
         B = Ru,
         I = Ru,
         O = function () {
            c = Ou(h, ks), I = ly(Gf ? 1 : 0, c), i && (B = ly(0, Ou(h, fa))), C = Qd
         },
         P = function () {
            v._gsap.y = L0(parseFloat(v._gsap.y) + x.offset) + "px", v.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(v._gsap.y) + ", 0, 1)", x.offset = x.cacheID = 0
         },
         q = function () {
            if (N) {
               requestAnimationFrame(z);
               var J = L0(l.deltaY / 2),
                  pe = I(x.v - J);
               if (v && pe !== x.v + x.offset) {
                  x.offset = pe - x.v;
                  var F = L0((parseFloat(v && v._gsap.y) || 0) - x.offset);
                  v.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + F + ", 0, 1)", v._gsap.y = F + "px", x.cacheID = Dn.cache, Nc()
               }
               return !0
            }
            x.offset && P(), N = !0
         },
         Q, $, ae, fe, k = function () {
            O(), Q.isActive() && Q.vars.scrollY > c && (x() > c ? Q.progress(1) && x(c) : Q.resetTo("scrollY", c))
         };
      return v && bt.set(v, {
         y: "+=0"
      }), e.ignoreCheck = function (Z) {
         return Gf && Z.type === "touchmove" && q() || E > 1.05 && Z.type !== "touchstart" || l.isGesturing || Z.touches && Z.touches.length > 1
      }, e.onPress = function () {
         N = !1;
         var Z = E;
         E = L0((Cn.visualViewport && Cn.visualViewport.scale || 1) / T), Q.pause(), Z !== E && PA(h, E > 1.01 ? !0 : i ? !1 : "x"), $ = S(), ae = x(), O(), C = Qd
      }, e.onRelease = e.onGestureStart = function (Z, J) {
         if (x.offset && P(), !J) fe.restart(!0);
         else {
            Dn.cache++;
            var pe = w(),
               F, ie;
            i && (F = S(), ie = F + pe * .05 * -Z.velocityX / .227, pe *= YU(S, F, ie, Ou(h, fa)), Q.vars.scrollX = B(ie)), F = x(), ie = F + pe * .05 * -Z.velocityY / .227, pe *= YU(x, F, ie, Ou(h, ks)), Q.vars.scrollY = I(ie), Q.invalidate().duration(pe).play(.01), (Gf && Q.vars.scrollY >= c || F >= c - 1) && bt.to({}, {
               onUpdate: k,
               duration: pe
            })
         }
         a && a(Z)
      }, e.onWheel = function () {
         Q._ts && Q.pause(), Nr() - b > 1e3 && (C = 0, b = Nr())
      }, e.onChange = function (Z, J, pe, F, ie) {
         if (Qd !== C && O(), J && i && S(B(F[2] === J ? $ + (Z.startX - Z.x) : S() + J - F[1])), pe) {
            x.offset && P();
            var ye = ie[2] === pe,
               we = ye ? ae + Z.startY - Z.y : x() + pe - ie[1],
               oe = I(we);
            ye && we !== oe && (ae += oe - we), x(oe)
         }(pe || J) && Nc()
      }, e.onEnable = function () {
         PA(h, i ? !1 : "x"), Nn.addEventListener("refresh", k), tr(Cn, "resize", k), x.smooth && (x.target.style.scrollBehavior = "auto", x.smooth = S.smooth = !1), U.enable()
      }, e.onDisable = function () {
         PA(h, !0), er(Cn, "resize", k), Nn.removeEventListener("refresh", k), U.kill()
      }, e.lockAxis = e.lockAxis !== !1, l = new ps(e), l.iOS = Gf, Gf && !x() && x(1), Gf && bt.ticker.add(Ru), fe = l._dc, Q = bt.to(l, {
         ease: "power4",
         paused: !0,
         inherit: !1,
         scrollX: i ? "+=0.1" : "+=0",
         scrollY: "+=0.1",
         modifiers: {
            scrollY: jF(x, x(), function () {
               return Q.pause()
            })
         },
         onUpdate: Nc,
         onComplete: fe.vars.onComplete
      }), l
   };
Nn.sort = function (n) {
   if (Pr(n)) return Tn.sort(n);
   var e = Cn.pageYOffset || 0;
   return Nn.getAll().forEach(function (t) {
      return t._sortY = t.trigger ? e + t.trigger.getBoundingClientRect().top : t.start + Cn.innerHeight
   }), Tn.sort(n || function (t, i) {
      return (t.vars.refreshPriority || 0) * -1e6 + (t.vars.containerAnimation ? 1e6 : t._sortY) - ((i.vars.containerAnimation ? 1e6 : i._sortY) + (i.vars.refreshPriority || 0) * -1e6)
   })
};
Nn.observe = function (n) {
   return new ps(n)
};
Nn.normalizeScroll = function (n) {
   if (typeof n > "u") return ra;
   if (n === !0 && ra) return ra.enable();
   if (n === !1) {
      ra && ra.kill(), ra = n;
      return
   }
   var e = n instanceof ps ? n : Oie(n);
   return ra && ra.target === e.target && ra.kill(), rp(e.target) && (ra = e), e
};
Nn.core = {
   _getVelocityProp: tR,
   _inputObserver: qF,
   _scrollers: Dn,
   _proxies: Fu,
   bridge: {
      ss: function () {
         nl || op("scrollStart"), nl = Nr()
      },
      ref: function () {
         return Dr
      }
   }
};
PF() && bt.registerPlugin(Nn);
iy.registerPlugin(Nn);

function Uie({
   projects: n = [],
   shouldPlay: e
}) {
   const t = j.useRef(null),
      i = ju(),
      {
         i18n: s
      } = rs(),
      r = s.language,
      a = ["md:col-span-2", "md:col-span-4", "md:col-span-3", "md:col-span-3", "md:col-span-4", "md:col-span-2"];
   return j.useEffect(() => () => {
      Nn.getAll().forEach(l => l.kill())
   }, [n]), H.jsx("section", {
      ref: t,
      className: `
        grid grid-cols-1 md:grid-cols-6
        gap-x-1 md:gap-x-5
        gap-y-3 md:gap-y-5
        px-5 md:px-10
        pt-4 md:pt-8
        pb-5 md:pb-10
      `,
      children: n.map((l, c) => {
         var g, v, x;
         const h = `col-span-1 ${a[c%a.length]}`,
            m = (g = l.media) == null ? void 0 : g.find(S => S.type === "image");
         return H.jsxs("article", {
            onClick: () => i(`/portfolio/${l._id}`),
            className: `
              grid-item flex flex-col overflow-hidden rounded-2xl md:rounded-4xl
              ${h}
              h-[40vh] xl:h-[80vh]   /* altura responsive */
            `,
            children: [H.jsxs("div", {
               className: `
              flex justify-between items-center
              text-white text-xs md:text-base
              px-2 md:px-3 py-1 md:py-2
              z-10
            `,
               children: [H.jsx("span", {
                  className: "overflow-hidden text-ellipsis whitespace-nowrap",
                  children: ((v = l.title) == null ? void 0 : v[r]) || "[Sin ttulo]"
               }), H.jsxs("span", {
                  className: `
                uppercase hidden md:flex
                overflow-hidden text-ellipsis whitespace-nowrap
              `,
                  children: ["#", l.type]
               })]
            }), m != null && m.url ? H.jsx("img", {
               src: m.url,
               alt: (x = l.title) == null ? void 0 : x[r],
               className: `
                  w-full h-full object-cover
                  rounded-2xl md:rounded-4xl
                  cursor-pointer
                `
            }) : H.jsx("div", {
               className: `
                bg-gray-800 w-full h-full
                flex items-center justify-center
                text-white rounded-2xl
              `,
               children: "Sin imagen"
            })]
         }, l._id)
      })
   })
}

function Pie({
   projects: n = [],
   shouldPlay: e
}) {
   const [t, i] = j.useState(null), {
      i18n: s
   } = rs(), r = s.language, a = ju();
   return H.jsx("div", {
      className: "relative",
      children: H.jsx("div", {
         className: "flex flex-col pb-5 md:pb-10",
         children: n.map(l => {
            var m, g;
            const c = (t == null ? void 0 : t._id) === l._id,
               h = (m = l.media) == null ? void 0 : m.find(v => v.type === "image");
            return H.jsxs("div", {
               onClick: () => a(`/portfolio/${l._id}`),
               onMouseEnter: () => i(l),
               onMouseLeave: () => i(null),
               className: `relative flex justify-between items-center px-5 md:px-10 py-5 md:py-8 text-xs md:text-base cursor-pointer transition-colors duration-300 ${c?"bg-neutral-800":""}`,
               children: [H.jsxs("div", {
                  className: "flex gap-4 items-baseline text-left",
                  children: [H.jsx("h3", {
                     className: "text-xs md:text-4xl uppercase",
                     children: l.title[r]
                  }), H.jsx("p", {
                     className: "text-xs md:text-base uppercase",
                     children: l.clientName
                  })]
               }), H.jsxs("div", {
                  className: "flex gap-4 items-baseline text-right",
                  children: [H.jsxs("p", {
                     className: "text-white uppercase",
                     children: ["#", l.type]
                  }), H.jsx("p", {
                     className: "text-white text-xs md:text-4xl uppercase",
                     children: new Date(l.date).getFullYear()
                  })]
               }), H.jsx("div", {
                  className: "absolute inset-0 inset-x-5 md:inset-x-10 border-b"
               }), (h == null ? void 0 : h.url) && H.jsx("div", {
                  className: "absolute h-[5vh] md:h-[15vh] object-contain inset-0 flex items-center justify-center pointer-events-none z-20",
                  children: H.jsx("img", {
                     src: h.url.replace(/"/g, ""),
                     alt: (g = l.title) == null ? void 0 : g[r],
                     className: `project-image ${c?"show":""}`
                  })
               })]
            }, l._id)
         })
      })
   })
}

function Lie({
   project: n,
   onClose: e
}) {
   const {
      t
   } = rs(), {
      i18n: i
   } = rs(), s = i.language;
   return H.jsxs("section", {
      className: "relative pt-18 md:pt-32 px-5 md:px-10",
      children: [H.jsxs("div", {
         className: "flex justify-between place-items-start pb-3 md:pb-5",
         children: [H.jsx("div", {
            onClick: e,
            className: "uppercase text-sm md:text-base cursor-pointer opacity-50 hover:opacity-100 transition-opacity",
            children: t("portfolio")
         }), H.jsx("div", {
            className: "hidden md:flex space-x-4 uppercase text-sm md:text-3xl",
            children: H.jsx("p", {
               children: n.clientName
            })
         })]
      }), H.jsxs("div", {
         className: "block md:flex justify-between uppercase items-baseline border-b pb-2 md:pb-8",
         children: [H.jsx("h1", {
            id: "project-title",
            className: "text-2xl md:text-5xl",
            children: n.title[s]
         }), H.jsxs("p", {
            className: "text-xs md:text-base pl-0 md:pl-2 py-2 md:py-0",
            children: ["#", n.type]
         })]
      })]
   })
}

function Bie({
   types: n = [],
   selected: e = [],
   toggle: t = () => {},
   shouldPlay: i
}) {
   const s = a => {
         r(), t(a)
      },
      {
         playClick: r
      } = Cx(i);
   return H.jsx("div", {
      className: "flex gap-2",
      children: n.map(a => H.jsxs("button", {
         onClick: () => s(a),
         className: `pl-0 md:pl-2 py-2 md:py-0 text-xs md:text-base uppercase transition ${e.includes(a)?"text-white opacity-100 cursor-pointer":"text-white opacity-50 hover:opacity-100 cursor-pointer"}`,
         children: ["#", a]
      }, a))
   })
}

function zie({
   viewMode: n,
   setViewMode: e,
   types: t,
   selected: i,
   toggle: s,
   shouldPlay: r
}) {
   const {
      t: a
   } = rs(), l = h => {
      c(), e(`${h}`)
   }, {
      playClick: c
   } = Cx(r);
   return H.jsx(H.Fragment, {
      children: H.jsxs("section", {
         className: "px-5 md:px-10",
         children: [H.jsxs("div", {
            className: "flex justify-between place-items-start pb-3 md:pb-5",
            children: [H.jsx("div", {
               className: "uppercase text-sm md:text-base",
               children: a("portfolio")
            }), H.jsxs("div", {
               className: "hidden md:flex space-x-4 text-sm md:text-3xl",
               children: [H.jsx("button", {
                  className: n === "list" ? "" : "opacity-50 hover:opacity-100 transition-opacity cursor-pointer",
                  onClick: () => l("list"),
                  children: "LIST"
               }), H.jsx("button", {
                  className: n === "img" ? "" : "opacity-50 hover:opacity-100 transition-opacity cursor-pointer",
                  onClick: () => l("img"),
                  children: "IMG"
               })]
            })]
         }), H.jsxs("div", {
            className: "block md:flex justify-between items-baseline border-b pb-2 md:pb-8",
            children: [H.jsxs("h1", {
               className: "text-4xl md:text-5xl",
               children: [a("selectedWork"), "."]
            }), H.jsx(Bie, {
               shouldPlay: r,
               types: t,
               selected: i,
               toggle: s
            })]
         })]
      })
   })
}

function Iie({
   shouldPlay: n
}) {
   const [e, t] = j.useState("img"), i = hie(), {
      filtered: s,
      filteredTypes: r,
      uniqueTypes: a,
      toggleType: l
   } = die(i);
   return H.jsxs(H.Fragment, {
      children: [H.jsx(zie, {
         shouldPlay: n,
         viewMode: e,
         setViewMode: t,
         types: a,
         selected: r,
         toggle: l
      }), e === "img" ? H.jsx(Uie, {
         projects: s,
         shouldPlay: n
      }) : H.jsx(Pie, {
         projects: s,
         shouldPlay: n
      })]
   })
}

function QU({
   shouldPlay: n
}) {
   return H.jsxs(H.Fragment, {
      children: [H.jsx(PT, {
         pageKey: "projects"
      }), H.jsx("main", {
         className: "relative min-h-screen pt-18 md:pt-32",
         children: H.jsx(Iie, {
            shouldPlay: n
         })
      }), H.jsx(WT, {
         shouldPlay: n
      })]
   })
}

function Fie() {
   const [n, e] = j.useState(""), [t, i] = j.useState(""), [s, r] = j.useState(null), a = ju(), l = async c => {
      c.preventDefault(), r(null);
      try {
         await ni.post("https://orbyte-1.onrender.com/api/auth/login", {
            email: n,
            password: t
         }, {
            withCredentials: !0
         }), a("/admin/projects")
      } catch {
         r("Credenciales incorrectas o error del servidor.")
      }
   };
   return H.jsx("div", {
      className: "min-h-screen flex items-center justify-center bg-black text-white px-6",
      children: H.jsxs("form", {
         onSubmit: l,
         className: "bg-white/5 p-8 rounded-lg shadow-md w-full max-w-md space-y-6",
         children: [H.jsx("h1", {
            className: "text-2xl font-bold",
            children: "Iniciar sesin"
         }), s && H.jsx("p", {
            className: "text-red-400 text-sm",
            children: s
         }), H.jsxs("div", {
            children: [H.jsx("label", {
               className: "block mb-1 text-sm",
               children: "Email"
            }), H.jsx("input", {
               type: "email",
               value: n,
               onChange: c => e(c.target.value),
               className: "w-full px-3 py-2 rounded bg-gray-800 text-white border border-gray-600",
               required: !0
            })]
         }), H.jsxs("div", {
            children: [H.jsx("label", {
               className: "block mb-1 text-sm",
               children: "Contrasea"
            }), H.jsx("input", {
               type: "password",
               value: t,
               onChange: c => i(c.target.value),
               className: "w-full px-3 py-2 rounded bg-gray-800 text-white border border-gray-600",
               required: !0
            })]
         }), H.jsx("button", {
            type: "submit",
            className: "w-full bg-blue-600 hover:bg-blue-700 text-white py-2 px-4 rounded",
            children: "Iniciar sesin"
         })]
      })
   })
}

function Hie() {
   const [n, e] = j.useState(!1), [t, i] = j.useState(!0), [s, r] = j.useState(null), [a, l] = j.useState([]), [c, h] = j.useState(!1), [m, g] = j.useState(!1), [v, x] = j.useState(null), [S, E] = j.useState({
      title: {
         es: "",
         en: "",
         fr: "",
         de: ""
      },
      description: {
         es: "",
         en: "",
         fr: "",
         de: ""
      },
      clientName: "",
      type: "",
      date: "",
      visible: !1,
      media: []
   }), [T, b] = j.useState([]);
   j.useEffect(() => {
      ni.get("https://orbyte-1.onrender.com/api/admin/projects", {
         withCredentials: !0,
         headers: {
            "Cache-Control": "no-cache"
         }
      }).then(() => e(!0)).catch(() => r("No tens permisos para ver esta seccin.")).finally(() => i(!1))
   }, []), j.useEffect(() => {
      n && ni.get("https://ong.mysterium-ai.com/projects.json", {
         withCredentials: !0
      }).then(O => l(O.data)).catch(() => r("No se pudieron obtener los proyectos."))
   }, [n]);
   const w = async O => {
      if (window.confirm("Confirms eliminar este proyecto?")) try {
         await ni.delete(`https://orbyte-1.onrender.com/api/projects/${O}`, {
            withCredentials: !0
         }), l(a.filter(P => P._id !== O))
      } catch (P) {
         console.error("Error al eliminar:", P)
      }
   }, C = async (O, P) => {
      try {
         const q = await ni.put(`https://orbyte-1.onrender.com/api/projects/${O}`, {
            visible: !P
         }, {
            withCredentials: !0
         });
         l(a.map(Q => Q._id === O ? q.data : Q))
      } catch (q) {
         console.error("Error al actualizar visibilidad:", q)
      }
   }, N = O => {
      const {
         name: P,
         value: q
      } = O.target, [Q, $] = P.split(".");
      E(ae => ({
         ...ae,
         [Q]: {
            ...ae[Q],
            [$]: q
         }
      }))
   }, U = O => {
      const {
         name: P,
         value: q,
         type: Q,
         checked: $
      } = O.target;
      E({
         ...S,
         [P]: Q === "checkbox" ? $ : q
      })
   }, z = O => {
      var P;
      g(!0), h(!0), x(O._id), E({
         title: O.title || {
            es: "",
            en: "",
            fr: "",
            de: ""
         },
         description: O.description || {
            es: "",
            en: "",
            fr: "",
            de: ""
         },
         clientName: O.clientName || "",
         type: O.type || "",
         date: ((P = O.date) == null ? void 0 : P.split("T")[0]) || "",
         visible: O.visible || !1,
         media: O.media || []
      }), b([])
   }, B = () => {
      g(!1), x(null), h(!1), E({
         title: "",
         description: "",
         clientName: "",
         type: "",
         date: "",
         visible: !1,
         media: []
      }), b([])
   }, I = async O => {
      O.preventDefault(), r(null);
      try {
         let P = [];
         if (T.length > 0) {
            const Q = new FormData;
            Array.from(T).forEach(ae => {
               Q.append("media", ae)
            }), P = (await ni.post("https://orbyte-1.onrender.com/api/upload", Q, {
               withCredentials: !0,
               headers: {
                  "Content-Type": "multipart/form-data"
               }
            })).data
         }
         const q = {
            ...S,
            media: P
         };
         if (m) {
            const Q = await ni.put(`https://orbyte-1.onrender.com/api/projects/${v}`, q, {
               withCredentials: !0
            });
            l(a.map($ => $._id === v ? Q.data : $))
         } else {
            const Q = await ni.post("https://orbyte-1.onrender.com/api/projects", q, {
               withCredentials: !0
            });
            l([Q.data, ...a])
         }
         B()
      } catch (P) {
         console.error(P), r("Error al guardar el proyecto.")
      }
   };
   return t ? H.jsx("p", {
      className: "text-white",
      children: "Cargando..."
   }) : s ? H.jsx("p", {
      className: "text-red-500 text-center mt-10",
      children: s
   }) : n ? H.jsxs("div", {
      className: "px-5 md:px-10 pt-18 md:pt-32 space-y-6 text-white",
      children: [H.jsx("h1", {
         className: "text-3xl font-bold border-b border-white pb-2",
         children: "Panel de Administracin"
      }), H.jsx("button", {
         onClick: () => {
            B(), h(!c)
         },
         className: "bg-green-600 hover:bg-green-700 text-white py-2 px-4 rounded",
         children: c ? "Cancelar" : "Crear nuevo proyecto"
      }), c && H.jsxs("form", {
         onSubmit: I,
         className: "space-y-4 max-w-xl mt-6",
         children: [s && H.jsx("p", {
            className: "text-red-500",
            children: s
         }), H.jsx("label", {
            className: "block text-sm",
            children: "Ttulo (ES)"
         }), H.jsx("input", {
            name: "title.es",
            placeholder: "Ttulo en espaol",
            value: S.title.es,
            onChange: N,
            className: "w-full p-2 bg-gray-800 border border-gray-600 rounded"
         }), H.jsx("label", {
            className: "block text-sm",
            children: "Ttulo (EN)"
         }), H.jsx("input", {
            name: "title.en",
            placeholder: "Title in English",
            value: S.title.en,
            onChange: N,
            className: "w-full p-2 bg-gray-800 border border-gray-600 rounded"
         }), H.jsx("label", {
            className: "block text-sm",
            children: "Ttulo (FR)"
         }), H.jsx("input", {
            name: "title.fr",
            placeholder: "Titre en franais",
            value: S.title.fr,
            onChange: N,
            className: "w-full p-2 bg-gray-800 border border-gray-600 rounded"
         }), H.jsx("label", {
            className: "block text-sm",
            children: "Ttulo (DE)"
         }), H.jsx("input", {
            name: "title.de",
            placeholder: "Titel auf Deutsch",
            value: S.title.de,
            onChange: N,
            className: "w-full p-2 bg-gray-800 border border-gray-600 rounded"
         }), H.jsx("label", {
            className: "block text-sm",
            children: "Descripcin (ES)"
         }), H.jsx("textarea", {
            name: "description.es",
            placeholder: "Descripcin en espaol",
            value: S.description.es,
            onChange: N,
            className: "w-full p-2 bg-gray-800 border border-gray-600 rounded"
         }), H.jsx("label", {
            className: "block text-sm",
            children: "Descripcin (EN)"
         }), H.jsx("textarea", {
            name: "description.en",
            placeholder: "Description in English",
            value: S.description.en,
            onChange: N,
            className: "w-full p-2 bg-gray-800 border border-gray-600 rounded"
         }), H.jsx("label", {
            className: "block text-sm",
            children: "Descripcin (FR)"
         }), H.jsx("textarea", {
            name: "description.fr",
            placeholder: "Description en franais",
            value: S.description.fr,
            onChange: N,
            className: "w-full p-2 bg-gray-800 border border-gray-600 rounded"
         }), H.jsx("label", {
            className: "block text-sm",
            children: "Descripcin (DE)"
         }), H.jsx("textarea", {
            name: "description.de",
            placeholder: "Beschreibung auf Deutsch",
            value: S.description.de,
            onChange: N,
            className: "w-full p-2 bg-gray-800 border border-gray-600 rounded"
         }), H.jsx("input", {
            name: "clientName",
            placeholder: "Cliente",
            value: S.clientName,
            onChange: U,
            required: !0,
            className: "w-full p-2 bg-gray-800 border border-gray-600 rounded"
         }), H.jsx("input", {
            name: "type",
            placeholder: "Tipo",
            value: S.type,
            onChange: U,
            required: !0,
            className: "w-full p-2 bg-gray-800 border border-gray-600 rounded"
         }), H.jsx("input", {
            name: "date",
            type: "date",
            value: S.date,
            onChange: U,
            required: !0,
            className: "w-full p-2 bg-gray-800 border border-gray-600 rounded"
         }), H.jsx("input", {
            type: "file",
            name: "media",
            multiple: !0,
            accept: "image/*,video/*",
            onChange: O => b(O.target.files),
            className: "..."
         }), H.jsxs("label", {
            className: "flex items-center",
            children: [H.jsx("input", {
               type: "checkbox",
               name: "visible",
               checked: S.visible,
               onChange: U,
               className: "mr-2"
            }), "Hacer visible"]
         }), H.jsx("button", {
            type: "submit",
            className: "bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded",
            children: m ? "Guardar cambios" : "Crear proyecto"
         })]
      }), a.length === 0 ? H.jsx("p", {
         className: "text-gray-400",
         children: "No hay proyectos an."
      }) : H.jsx("ul", {
         className: "space-y-4",
         children: a.map(O => {
            var P;
            return H.jsxs("li", {
               className: "border border-white/20 rounded-lg p-4 flex justify-between items-center",
               children: [H.jsxs("div", {
                  children: [H.jsx("p", {
                     className: "font-semibold",
                     children: (P = O.title) == null ? void 0 : P.es
                  }), H.jsxs("p", {
                     className: "text-sm text-gray-400",
                     children: [O.clientName, "  ", O.type]
                  })]
               }), H.jsxs("div", {
                  className: "flex gap-4 items-center",
                  children: [H.jsx("span", {
                     className: "text-xs text-gray-400",
                     children: O.date ? new Date(O.date).getFullYear() : "Sin fecha"
                  }), H.jsx("button", {
                     onClick: () => C(O._id, O.visible),
                     className: "text-sm text-yellow-400 hover:underline",
                     children: O.visible ? "Ocultar" : "Publicar"
                  }), H.jsx("button", {
                     onClick: () => z(O),
                     className: "text-sm text-blue-400 hover:underline",
                     children: "Editar"
                  }), H.jsx("button", {
                     onClick: () => w(O._id),
                     className: "text-sm text-red-400 hover:underline",
                     children: "Borrar"
                  })]
               })]
            }, O._id)
         })
      })]
   }) : null
}

function JU() {
   const {
      t: n
   } = rs();
   return H.jsxs(H.Fragment, {
      children: [H.jsx(PT, {
         pageKey: "privacy"
      }), H.jsx("section", {
         className: "flex flex-col items-center justify-between",
         children: H.jsxs("div", {
            className: "relative min-h-screen w-auto md:w-2/3 px-5 md:px-10 pt-18 md:pt-32 pb-10 md:pb-20",
            children: [H.jsx("h2", {
               className: "uppercase text-4xl md:text-5xl",
               children: n("privacyPolicy")
            }), H.jsx("h3", {
               className: "uppercase text-sm md:text-base py-2 md:py-5",
               children: n("lastUpdated")
            }), H.jsx("p", {
               className: "py-4",
               children: n("introParagraph")
            }), H.jsx("h4", {
               className: "font-bold text-xl pt-6 pb-2",
               children: n("section1Title")
            }), H.jsx("p", {
               children: n("section1Paragraph1")
            }), H.jsxs("ul", {
               className: "list-disc pl-5 pt-2",
               children: [H.jsx("li", {
                  children: n("section1Bullet1")
               }), H.jsx("li", {
                  children: n("section1Bullet2")
               }), H.jsx("li", {
                  children: n("section1Bullet3")
               }), H.jsx("li", {
                  children: n("section1Bullet4")
               })]
            }), H.jsx("p", {
               className: "pt-4",
               children: n("section1Paragraph2")
            }), H.jsx("h4", {
               className: "font-bold text-xl pt-6 pb-2",
               children: n("section2Title")
            }), H.jsx("p", {
               children: n("section2Paragraph1")
            }), H.jsxs("ul", {
               className: "list-disc pl-5 pt-2",
               children: [H.jsx("li", {
                  children: n("section2Bullet1")
               }), H.jsx("li", {
                  children: n("section2Bullet2")
               })]
            }), H.jsx("p", {
               className: "pt-4",
               children: n("section2Paragraph2")
            }), H.jsx("h4", {
               className: "font-bold text-xl pt-6 pb-2",
               children: n("section3Title")
            }), H.jsx("p", {
               children: n("section3Paragraph1")
            }), H.jsx("p", {
               className: "pt-4",
               children: n("section3Paragraph2")
            }), H.jsx("h4", {
               className: "font-bold text-xl pt-6 pb-2",
               children: n("section4Title")
            }), H.jsx("p", {
               children: n("section4Paragraph1")
            }), H.jsxs("ul", {
               className: "list-disc pl-5 pt-2",
               children: [H.jsx("li", {
                  children: n("section4Bullet1")
               }), H.jsx("li", {
                  children: n("section4Bullet2")
               }), H.jsx("li", {
                  children: n("section4Bullet3")
               })]
            }), H.jsx("p", {
               className: "pt-4",
               children: n("section4Paragraph2")
            }), H.jsx("h4", {
               className: "font-bold text-xl pt-6 pb-2",
               children: n("section5Title")
            }), H.jsx("p", {
               children: n("section5Paragraph1")
            }), H.jsx("h4", {
               className: "font-bold text-xl pt-6 pb-2",
               children: n("section6Title")
            }), H.jsx("p", {
               children: n("section6Paragraph1")
            }), H.jsx("h4", {
               className: "font-bold text-xl pt-6 pb-2",
               children: n("section7Title")
            }), H.jsx("p", {
               children: n("section7Paragraph1")
            }), H.jsx("h4", {
               className: "font-bold text-xl pt-6 pb-2",
               children: n("section8Title")
            }), H.jsx("p", {
               children: n("section8Paragraph1")
            })]
         })
      }), H.jsx(WT, {})]
   })
}

function Vie({
   shouldPlay: n
}) {
   const e = j.useRef(null),
      t = 1e3,
      i = 500,
      s = .4,
      r = c => Math.max(0, Math.min(c, 1)),
      a = () => {
         const c = e.current;
         if (!c) return;
         const h = performance.now();
         c.volume = 0, c.loop = !0, c.play().catch(g => console.warn("Audio play prevented:", g));
         const m = g => {
            const v = g - h,
               x = Math.min(v / i, 1),
               S = r(x * s);
            c.volume = S, x < 1 && !document.hidden ? requestAnimationFrame(m) : c.volume = r(s)
         };
         if (!document.hidden) requestAnimationFrame(m);
         else {
            let g = 0;
            const v = 50,
               x = Math.ceil(i / v),
               S = setInterval(() => {
                  g++;
                  const E = g / x;
                  c.volume = r(E * s), g >= x && (clearInterval(S), c.volume = r(s))
               }, v)
         }
      },
      l = (c = !1) => {
         const h = e.current;
         if (!h) return;
         if (c) {
            h.pause(), h.currentTime = 0, h.volume = r(s);
            return
         }
         const m = r(h.volume),
            g = performance.now(),
            v = x => {
               const S = x - g,
                  E = Math.min(S / t, 1),
                  T = r(m * (1 - E));
               h.volume = T, E < 1 && !document.hidden ? requestAnimationFrame(v) : (h.pause(), h.currentTime = 0, h.volume = r(s))
            };
         if (!document.hidden) requestAnimationFrame(v);
         else {
            let x = 0;
            const S = 50,
               E = Math.ceil(t / S),
               T = setInterval(() => {
                  x++;
                  const b = x / E,
                     w = r(m * (1 - b));
                  h.volume = w, x >= E && (clearInterval(T), h.pause(), h.currentTime = 0, h.volume = r(s))
               }, S)
         }
      };
   return j.useEffect(() => {
      e.current && (n && !document.hidden ? a() : l())
   }, [n]), j.useEffect(() => {
      const c = () => {
         e.current && (document.hidden ? l() : n && a())
      };
      return document.addEventListener("visibilitychange", c), () => {
         document.removeEventListener("visibilitychange", c)
      }
   }, [n]), H.jsx("audio", {
      ref: e,
      src: "sounds/ambient.mp3",
      preload: "auto"
   })
}

function Gie(n) {
   return jT({
      attr: {
         viewBox: "0 0 512 512"
      },
      child: [{
         tag: "path",
         attr: {
            d: "M128 320l128-128 128 128z"
         },
         child: []
      }]
   })(n)
}
const kie = ({
   shouldPlay: n
}) => {
   const {
      i18n: e
   } = rs(), t = ju(), i = il(), [s, r] = j.useState(!1), [a, l] = j.useState(() => e.language.slice(0, 2).toUpperCase() || "EN");
   j.useEffect(() => {
      l(e.language.slice(0, 2).toUpperCase())
   }, [e.language]);
   const c = j.useRef(null),
      h = {
         EN: "en",
         RO: "ro",
         ES: "es",
         FR: "fr",
         DE: "de",
         IT: "it"
      },
      m = () => {
         v(), r(!s)
      },
      g = x => {
         v();
         const S = h[x];
         e.changeLanguage(S), l(x), r(!1);
         const T = i.pathname.split("/").filter(Boolean),
            b = T.length > 0 && ["ro", "es", "fr", "de", "it"].includes(T[0]) ? T.slice(1).join("/") : T.join("/"),
            w = S === "en" ? `/${b}` : `/${S}${b?"/"+b:""}`;
         t(w || "/")
      };
   j.useEffect(() => {
      const x = S => {
         c.current && !c.current.contains(S.target) && r(!1)
      };
      return document.addEventListener("mousedown", x), () => document.removeEventListener("mousedown", x)
   }, []);
   const {
      playClick: v
   } = Cx(n);
   return H.jsx("div", {
      className: "text-xs md:text-base nb",
      children: H.jsxs("div", {
         ref: c,
         className: "relative inline-block text-left",
         children: [H.jsxs("button", {
            onClick: m,
            className: "cursor-pointer h-8 md:h-auto flex items-center language",
            children: [a, H.jsx(Gie, {
               className: `transition-transform duration-200 ${s?"rotate-0":"rotate-180"}`
            })]
         }), s && H.jsx("ul", {
            className: "absolute mt-1 z-10 rounded shadow-md",
            children: Object.keys(h).filter(x => x !== a).map(x => H.jsx("li", {
               onClick: () => g(x),
               className: "language cursor-pointer px-2 py-1",
               children: x
            }, x))
         })]
      })
   })
};

function jie({
   shouldPlay: n,
   setShouldPlay: e
}) {
   const t = ju(),
      i = il(),
      {
         i18n: s,
         t: r
      } = rs(),
      [a, l] = j.useState(0),
      [c, h] = j.useState(!1),
      m = T => T.replace(/\/+$/, ""),
      g = i.pathname.split("/").filter(Boolean),
      v = ["ro", "es", "fr", "de", "it"].includes(g[0]) ? g[0] : null,
      x = !v && m(i.pathname) === "" || v && m(i.pathname) === `/${v}`;
   x ? (document.documentElement.style.overflow = "hidden", document.body.style.overflow = "hidden") : (document.documentElement.style.overflow = "", document.body.style.overflow = ""), j.useEffect(() => {
      l(T => T + 1)
   }, [s.language]), j.useEffect(() => {
      if (x) {
         h(!1);
         return
      }
      const T = () => {
         h(window.scrollY > 20)
      };
      return window.addEventListener("scroll", T), () => window.removeEventListener("scroll", T)
   }, [x]);
   const S = T => {
         E();
         const b = v ? `/${v}` : "/",
            w = () => {
               var N, U;
               const C = (U = (N = Il.current) == null ? void 0 : N.options) == null ? void 0 : U.content;
               if (C) {
                  const B = (C.scrollHeight - window.innerHeight) * T;
                  Il.current.scrollTo(B)
               }
            };
         x && Il.current ? w() : (Nte(T), Ute(w), t(b))
      },
      {
         playClick: E
      } = Cx(n);
   return H.jsxs("header", {
      className: `
        fixed top-0 z-50 w-full h-8 md:h-13 my-5 gap-5 md:my-10 px-5 md:px-10
        flex justify-between transition-opacity duration-500
        ${c?"opacity-0 pointer-events-none":"opacity-100"}
      `,
      children: [H.jsxs("div", {
         className: "flex items-center text-xs md:text-base gap-4 md:gap-10",
         children: [H.jsx("img", {
            src: "logo/iso.svg",
            alt: "Logo",
            className: "h-full cursor-pointer opacity-100 hover:opacity-50 duration-200",
            id: "logo",
            onClick: () => S(0)
         }), H.jsx(kie, {
            shouldPlay: n
         }), H.jsx("button", {
            className: `text-xs md:text-base hidden h-full md:h-auto items-center -translate-x-1 nb sm:flex sound ${n?"sound-on":"sound-off"}`,
            onClick: () => e(T => !T),
            children: r(n ? "soundOn" : "soundOff")
         })]
      }), H.jsx("nav", {
         children: H.jsxs("ul", {
            className: "flex items-center justify-end gap-4 md:gap-10 ",
            children: [H.jsx("li", {
               className: "text-xs md:text-base h-8 md:h-13 flex items-center",
               children: H.jsx("a", {
                  className: "cursor-pointer opacity-100 h-full md:h-auto hover:opacity-50 nb duration-200 flex items-center",
                  href: "./about",
                  children: r("aboutUs")
               })
            }), H.jsx("li", {
               className: "text-xs md:text-base h-8 md:h-13 flex items-center",
               children: H.jsx("a", {
                  className: "cursor-pointer opacity-100 h-full md:h-auto hover:opacity-50 nb duration-200 flex items-center",
                  href: "./video/",
                  children: r("videoBtn")
               })
            }), H.jsx("li", {
               className: "text-xs md:text-base h-8 md:h-13 flex items-center",
               children: H.jsx("button", {
                  className: "cursor-pointer opacity-100 h-full md:h-auto hover:opacity-50 nb duration-200",
                  onClick: () => S(.5),
                  children: r("services")
               })
            }), H.jsx("div", {
               className: "h-8 md:h-13 w-[35%] md:w-auto text-xs md:text-base",
               children: H.jsx(Vl, {
                  shouldPlay: n,
                  scrollPercentage: 1,
                  width: "100%",
                  height: "100%",
                  children: r("contact")
               })
            })]
         })
      })]
   }, a)
}
const qie = ["en", "es", "fr", "de"],
   Xie = () => {
      const {
         i18n: n
      } = rs(), e = il(), t = ju();
      return j.useEffect(() => {
         const i = e.pathname.split("/").filter(Boolean),
            s = i[0];
         if (qie.includes(s))
            if (s === "en") {
               if (e.pathname.startsWith("/en")) {
                  const r = "/" + i.slice(1).join("/");
                  t(r || "/", {
                     replace: !0
                  });
                  return
               }
               n.language !== "ro" && n.changeLanguage("ro")
            } else n.language !== s && n.changeLanguage(s);
         else n.language !== "ro" && n.changeLanguage("ro");
         document.documentElement.lang = n.language || "ro"
      }, [e.pathname, n, t]), null
   };

function $U({
   shouldPlay: n
}) {
   var C, N, U;
   const {
      id: e
   } = bP(), t = ju(), {
      t: i,
      i18n: s
   } = rs(), r = s.language, [a, l] = j.useState(null), [c, h] = j.useState(!0), [m, g] = j.useState({}), [v, x] = j.useState([]);
   j.useEffect(() => {
      async function z() {
         try {
            const B = await ni.get(`https://ong.mysterium-ai.com/projects.json`);
            const projectData = B.data.find(p => p._id === e);
            const I = {data: B.data.filter(p => p._id !== e).slice(0, 2)};
            l(projectData), x(I.data)
         } catch (B) {
            console.error("Error al traer los datos", B)
         } finally {
            h(!1)
         }
      }
      z()
   }, [e]);

   function S(z) {
      return new Promise(B => {
         const I = new Image;
         I.src = z.url, I.onload = () => {
            B({
               id: z._id,
               aspectRatio: I.naturalWidth / I.naturalHeight
            })
         }, I.onerror = () => B({
            id: z._id,
            aspectRatio: 1
         })
      })
   }
   if (j.useEffect(() => {
         if (!a) return;
         const z = a.media || [];
         Promise.all(z.filter(B => B.type === "image").map(S)).then(B => {
            const I = {};
            B.forEach(({
               id: O,
               aspectRatio: P
            }) => {
               I[O] = P
            }), g(I)
         })
      }, [a]), c) return H.jsx("div", {
      className: "absolute left-1/2 -translate-x-1/2 top-1/2 text-center",
      children: "Loading..."
   });
   if (!a) return H.jsx("div", {
      className: "absolute left-1/2 -translate-x-1/2 top-1/2 text-center text-red-500",
      children: "Project not found"
   });
   const E = ((C = a.media) == null ? void 0 : C.filter(z => z.type === "image")) || [],
      T = ((N = a.media) == null ? void 0 : N.filter(z => z.type === "video")) || [],
      b = v;

   function w(z) {
      var P;
      const B = z === 0,
         I = z === 1,
         O = m[(P = E[0]) == null ? void 0 : P._id] ?? 1;
      return B ? O >= 1 ? "md:col-span-6" : "md:col-span-2" : I && O < 1 ? "md:col-span-4" : "md:col-span-3"
   }
   return H.jsxs(H.Fragment, {
      children: [H.jsx(PT, {
         pageKey: "projects"
      }), H.jsx("main", {
         children: H.jsxs("article", {
            "aria-labelledby": "project-title",
            children: [H.jsx(Lie, {
               project: a,
               onClose: () => t("/portfolio")
            }), H.jsxs("div", {
               className: "flex justify-between p-5 md:p-10",
               children: [H.jsxs("div", {
                  className: "flex w-1/2 justify-between text-gray-400 pr-0 md:pr-5 text-xs md:text-base",
                  children: [H.jsx("p", {
                     children: new Date(a.date).toLocaleDateString()
                  }), H.jsx("p", {
                     className: "uppercase",
                     children: i("projectDetails")
                  })]
               }), H.jsx("div", {
                  className: "w-1/2 flex flex-col items-start pl-5",
                  children: H.jsx("p", {
                     className: "text-xs md:text-base",
                     children: (U = a.description) == null ? void 0 : U[r]
                  })
               })]
            }), H.jsx(nI, {
               mode: "wait",
               children: H.jsxs(Db.div, {
                  initial: {
                     opacity: 0,
                     y: 20
                  },
                  animate: {
                     opacity: 1,
                     y: 0
                  },
                  exit: {
                     opacity: 0,
                     y: -20
                  },
                  transition: {
                     duration: .4
                  },
                  className: "px-5 md:px-10 space-y-5 md:space-y-10",
                  children: [H.jsxs("div", {
                     className: "grid grid-cols-1 md:grid-cols-6 gap-x-1 md:gap-x-5 gap-y-3 md:gap-y-5",
                     children: [E.map((z, B) => {
                        const I = w(B);
                        return H.jsx("div", {
                           className: `${I} h-[40vh] xl:h-[80vh]`,
                           children: H.jsx(Db.img, {
                              src: z.url,
                              alt: `img-${B}`,
                              className: "w-full h-full object-cover rounded-2xl md:rounded-4xl",
                              initial: {
                                 opacity: 0
                              },
                              animate: {
                                 opacity: 1
                              },
                              transition: {
                                 delay: .1 * B
                              }
                           })
                        }, z._id || z.url || B)
                     }), T.map((z, B) => H.jsx(Db.video, {
                        controls: !0,
                        className: "md:col-span-4 h-[40vh] xl:h-[80vh] rounded-2xl md:rounded-4xl w-full object-cover",
                        initial: {
                           opacity: 0
                        },
                        animate: {
                           opacity: 1
                        },
                        transition: {
                           delay: .1 * B
                        },
                        children: H.jsx("source", {
                           src: z.url,
                           type: "video/mp4"
                        })
                     }, z._id || z.url || B))]
                  }), H.jsx("h3", {
                     className: "text-base border-b pb-2 md:pb-5",
                     children: i("nextProject")
                  }), H.jsx("div", {
                     className: "flex gap-x-1 md:gap-x-5 pb-5 md:pb-10",
                     children: b.map(z => {
                        var B, I, O, P;
                        return H.jsx("div", {
                           onClick: () => {
                              t(`/portfolio/${z._id}`), window.scrollTo({
                                 top: 0,
                                 behavior: "smooth"
                              })
                           },
                           className: "w-1/2 overflow-hidden cursor-pointer group",
                           children: H.jsxs("div", {
                              children: [H.jsxs("div", {
                                 className: "flex justify-between text-xs md:text-base pb-2 md:pb-5 overflow-hidden text-ellipsis whitespace-nowrap",
                                 children: [H.jsx("span", {
                                    className: "overflow-hidden text-ellipsis whitespace-nowrap",
                                    children: (B = z.title) == null ? void 0 : B[r]
                                 }), H.jsxs("span", {
                                    className: "overflow-hidden text-ellipsis whitespace-nowrap uppercase hidden md:flex",
                                    children: ["#", z.type]
                                 })]
                              }), H.jsx("div", {
                                 className: "h-[20vh] md:h-[40vh] overflow-hidden rounded-2xl md:rounded-4xl",
                                 children: H.jsx("img", {
                                    src: (O = (I = z.media) == null ? void 0 : I.find(q => q.type === "image")) == null ? void 0 : O.url,
                                    alt: (P = z.title) == null ? void 0 : P[r],
                                    className: "w-full h-full object-cover"
                                 })
                              })]
                           })
                        }, z._id)
                     })
                  })]
               }, a._id)
            })]
         })
      }), H.jsx(WT, {
         shouldPlay: n
      })]
   })
}
const M0 = ({
      children: n
   }) => {
      const {
         lang: e
      } = bP(), t = ["ro", "es", "fr", "de", "it"];
      return e ? e === "en" ? H.jsx(zA, {
         to: "/",
         replace: !0
      }) : t.includes(e) ? n : H.jsx(zA, {
         to: "/",
         replace: !0
      }) : n
   },
   $t = n => typeof n == "string",
   A0 = () => {
      let n, e;
      const t = new Promise((i, s) => {
         n = i, e = s
      });
      return t.resolve = n, t.reject = e, t
   },
   eP = n => n == null ? "" : "" + n,
   Wie = (n, e, t) => {
      n.forEach(i => {
         e[i] && (t[i] = e[i])
      })
   },
   Yie = /###/g,
   tP = n => n && n.indexOf("###") > -1 ? n.replace(Yie, ".") : n,
   nP = n => !n || $t(n),
   py = (n, e, t) => {
      const i = $t(e) ? e.split(".") : e;
      let s = 0;
      for (; s < i.length - 1;) {
         if (nP(n)) return {};
         const r = tP(i[s]);
         !n[r] && t && (n[r] = new t), Object.prototype.hasOwnProperty.call(n, r) ? n = n[r] : n = {}, ++s
      }
      return nP(n) ? {} : {
         obj: n,
         k: tP(i[s])
      }
   },
   iP = (n, e, t) => {
      const {
         obj: i,
         k: s
      } = py(n, e, Object);
      if (i !== void 0 || e.length === 1) {
         i[s] = t;
         return
      }
      let r = e[e.length - 1],
         a = e.slice(0, e.length - 1),
         l = py(n, a, Object);
      for (; l.obj === void 0 && a.length;) r = `${a[a.length-1]}.${r}`, a = a.slice(0, a.length - 1), l = py(n, a, Object), l != null && l.obj && typeof l.obj[`${l.k}.${r}`] < "u" && (l.obj = void 0);
      l.obj[`${l.k}.${r}`] = t
   },
   Kie = (n, e, t, i) => {
      const {
         obj: s,
         k: r
      } = py(n, e, Object);
      s[r] = s[r] || [], s[r].push(t)
   },
   K1 = (n, e) => {
      const {
         obj: t,
         k: i
      } = py(n, e);
      if (t && Object.prototype.hasOwnProperty.call(t, i)) return t[i]
   },
   Zie = (n, e, t) => {
      const i = K1(n, t);
      return i !== void 0 ? i : K1(e, t)
   },
   XF = (n, e, t) => {
      for (const i in e) i !== "__proto__" && i !== "constructor" && (i in n ? $t(n[i]) || n[i] instanceof String || $t(e[i]) || e[i] instanceof String ? t && (n[i] = e[i]) : XF(n[i], e[i], t) : n[i] = e[i]);
      return n
   },
   Fm = n => n.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
var Qie = {
   "&": "&amp;",
   "<": "&lt;",
   ">": "&gt;",
   '"': "&quot;",
   "'": "&#39;",
   "/": "&#x2F;"
};
const Jie = n => $t(n) ? n.replace(/[&<>"'\/]/g, e => Qie[e]) : n;
class $ie {
   constructor(e) {
      this.capacity = e, this.regExpMap = new Map, this.regExpQueue = []
   }
   getRegExp(e) {
      const t = this.regExpMap.get(e);
      if (t !== void 0) return t;
      const i = new RegExp(e);
      return this.regExpQueue.length === this.capacity && this.regExpMap.delete(this.regExpQueue.shift()), this.regExpMap.set(e, i), this.regExpQueue.push(e), i
   }
}
const ese = [" ", ",", "?", "!", ";"],
   tse = new $ie(20),
   nse = (n, e, t) => {
      e = e || "", t = t || "";
      const i = ese.filter(a => e.indexOf(a) < 0 && t.indexOf(a) < 0);
      if (i.length === 0) return !0;
      const s = tse.getRegExp(`(${i.map(a=>a==="?"?"\\?":a).join("|")})`);
      let r = !s.test(n);
      if (!r) {
         const a = n.indexOf(t);
         a > 0 && !s.test(n.substring(0, a)) && (r = !0)
      }
      return r
   },
   uR = (n, e, t = ".") => {
      if (!n) return;
      if (n[e]) return Object.prototype.hasOwnProperty.call(n, e) ? n[e] : void 0;
      const i = e.split(t);
      let s = n;
      for (let r = 0; r < i.length;) {
         if (!s || typeof s != "object") return;
         let a, l = "";
         for (let c = r; c < i.length; ++c)
            if (c !== r && (l += t), l += i[c], a = s[l], a !== void 0) {
               if (["string", "number", "boolean"].indexOf(typeof a) > -1 && c < i.length - 1) continue;
               r += c - r + 1;
               break
            } s = a
      }
      return s
   },
   ax = n => n == null ? void 0 : n.replace("_", "-"),
   ise = {
      type: "logger",
      log(n) {
         this.output("log", n)
      },
      warn(n) {
         this.output("warn", n)
      },
      error(n) {
         this.output("error", n)
      },
      output(n, e) {
         var t, i;
         (i = (t = console == null ? void 0 : console[n]) == null ? void 0 : t.apply) == null || i.call(t, console, e)
      }
   };
class Z1 {
   constructor(e, t = {}) {
      this.init(e, t)
   }
   init(e, t = {}) {
      this.prefix = t.prefix || "i18next:", this.logger = e || ise, this.options = t, this.debug = t.debug
   }
   log(...e) {
      return this.forward(e, "log", "", !0)
   }
   warn(...e) {
      return this.forward(e, "warn", "", !0)
   }
   error(...e) {
      return this.forward(e, "error", "")
   }
   deprecate(...e) {
      return this.forward(e, "warn", "WARNING DEPRECATED: ", !0)
   }
   forward(e, t, i, s) {
      return s && !this.debug ? null : ($t(e[0]) && (e[0] = `${i}${this.prefix} ${e[0]}`), this.logger[t](e))
   }
   create(e) {
      return new Z1(this.logger, {
         prefix: `${this.prefix}:${e}:`,
         ...this.options
      })
   }
   clone(e) {
      return e = e || this.options, e.prefix = e.prefix || this.prefix, new Z1(this.logger, e)
   }
}
var Uu = new Z1;
class nE {
   constructor() {
      this.observers = {}
   }
   on(e, t) {
      return e.split(" ").forEach(i => {
         this.observers[i] || (this.observers[i] = new Map);
         const s = this.observers[i].get(t) || 0;
         this.observers[i].set(t, s + 1)
      }), this
   }
   off(e, t) {
      if (this.observers[e]) {
         if (!t) {
            delete this.observers[e];
            return
         }
         this.observers[e].delete(t)
      }
   }
   emit(e, ...t) {
      this.observers[e] && Array.from(this.observers[e].entries()).forEach(([s, r]) => {
         for (let a = 0; a < r; a++) s(...t)
      }), this.observers["*"] && Array.from(this.observers["*"].entries()).forEach(([s, r]) => {
         for (let a = 0; a < r; a++) s.apply(s, [e, ...t])
      })
   }
}
class sP extends nE {
   constructor(e, t = {
      ns: ["translation"],
      defaultNS: "translation"
   }) {
      super(), this.data = e || {}, this.options = t, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.options.ignoreJSONStructure === void 0 && (this.options.ignoreJSONStructure = !0)
   }
   addNamespaces(e) {
      this.options.ns.indexOf(e) < 0 && this.options.ns.push(e)
   }
   removeNamespaces(e) {
      const t = this.options.ns.indexOf(e);
      t > -1 && this.options.ns.splice(t, 1)
   }
   getResource(e, t, i, s = {}) {
      var h, m;
      const r = s.keySeparator !== void 0 ? s.keySeparator : this.options.keySeparator,
         a = s.ignoreJSONStructure !== void 0 ? s.ignoreJSONStructure : this.options.ignoreJSONStructure;
      let l;
      e.indexOf(".") > -1 ? l = e.split(".") : (l = [e, t], i && (Array.isArray(i) ? l.push(...i) : $t(i) && r ? l.push(...i.split(r)) : l.push(i)));
      const c = K1(this.data, l);
      return !c && !t && !i && e.indexOf(".") > -1 && (e = l[0], t = l[1], i = l.slice(2).join(".")), c || !a || !$t(i) ? c : uR((m = (h = this.data) == null ? void 0 : h[e]) == null ? void 0 : m[t], i, r)
   }
   addResource(e, t, i, s, r = {
      silent: !1
   }) {
      const a = r.keySeparator !== void 0 ? r.keySeparator : this.options.keySeparator;
      let l = [e, t];
      i && (l = l.concat(a ? i.split(a) : i)), e.indexOf(".") > -1 && (l = e.split("."), s = t, t = l[1]), this.addNamespaces(t), iP(this.data, l, s), r.silent || this.emit("added", e, t, i, s)
   }
   addResources(e, t, i, s = {
      silent: !1
   }) {
      for (const r in i)($t(i[r]) || Array.isArray(i[r])) && this.addResource(e, t, r, i[r], {
         silent: !0
      });
      s.silent || this.emit("added", e, t, i)
   }
   addResourceBundle(e, t, i, s, r, a = {
      silent: !1,
      skipCopy: !1
   }) {
      let l = [e, t];
      e.indexOf(".") > -1 && (l = e.split("."), s = i, i = t, t = l[1]), this.addNamespaces(t);
      let c = K1(this.data, l) || {};
      a.skipCopy || (i = JSON.parse(JSON.stringify(i))), s ? XF(c, i, r) : c = {
         ...c,
         ...i
      }, iP(this.data, l, c), a.silent || this.emit("added", e, t, i)
   }
   removeResourceBundle(e, t) {
      this.hasResourceBundle(e, t) && delete this.data[e][t], this.removeNamespaces(t), this.emit("removed", e, t)
   }
   hasResourceBundle(e, t) {
      return this.getResource(e, t) !== void 0
   }
   getResourceBundle(e, t) {
      return t || (t = this.options.defaultNS), this.getResource(e, t)
   }
   getDataByLanguage(e) {
      return this.data[e]
   }
   hasLanguageSomeTranslations(e) {
      const t = this.getDataByLanguage(e);
      return !!(t && Object.keys(t) || []).find(s => t[s] && Object.keys(t[s]).length > 0)
   }
   toJSON() {
      return this.data
   }
}
var WF = {
   processors: {},
   addPostProcessor(n) {
      this.processors[n.name] = n
   },
   handle(n, e, t, i, s) {
      return n.forEach(r => {
         var a;
         e = ((a = this.processors[r]) == null ? void 0 : a.process(e, t, i, s)) ?? e
      }), e
   }
};
const rP = {},
   aP = n => !$t(n) && typeof n != "boolean" && typeof n != "number";
class Q1 extends nE {
   constructor(e, t = {}) {
      super(), Wie(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], e, this), this.options = t, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.logger = Uu.create("translator")
   }
   changeLanguage(e) {
      e && (this.language = e)
   }
   exists(e, t = {
      interpolation: {}
   }) {
      const i = {
         ...t
      };
      if (e == null) return !1;
      const s = this.resolve(e, i);
      return (s == null ? void 0 : s.res) !== void 0
   }
   extractFromKey(e, t) {
      let i = t.nsSeparator !== void 0 ? t.nsSeparator : this.options.nsSeparator;
      i === void 0 && (i = ":");
      const s = t.keySeparator !== void 0 ? t.keySeparator : this.options.keySeparator;
      let r = t.ns || this.options.defaultNS || [];
      const a = i && e.indexOf(i) > -1,
         l = !this.options.userDefinedKeySeparator && !t.keySeparator && !this.options.userDefinedNsSeparator && !t.nsSeparator && !nse(e, i, s);
      if (a && !l) {
         const c = e.match(this.interpolator.nestingRegexp);
         if (c && c.length > 0) return {
            key: e,
            namespaces: $t(r) ? [r] : r
         };
         const h = e.split(i);
         (i !== s || i === s && this.options.ns.indexOf(h[0]) > -1) && (r = h.shift()), e = h.join(s)
      }
      return {
         key: e,
         namespaces: $t(r) ? [r] : r
      }
   }
   translate(e, t, i) {
      let s = typeof t == "object" ? {
         ...t
      } : t;
      if (typeof s != "object" && this.options.overloadTranslationOptionHandler && (s = this.options.overloadTranslationOptionHandler(arguments)), typeof options == "object" && (s = {
            ...s
         }), s || (s = {}), e == null) return "";
      Array.isArray(e) || (e = [String(e)]);
      const r = s.returnDetails !== void 0 ? s.returnDetails : this.options.returnDetails,
         a = s.keySeparator !== void 0 ? s.keySeparator : this.options.keySeparator,
         {
            key: l,
            namespaces: c
         } = this.extractFromKey(e[e.length - 1], s),
         h = c[c.length - 1];
      let m = s.nsSeparator !== void 0 ? s.nsSeparator : this.options.nsSeparator;
      m === void 0 && (m = ":");
      const g = s.lng || this.language,
         v = s.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
      if ((g == null ? void 0 : g.toLowerCase()) === "cimode") return v ? r ? {
         res: `${h}${m}${l}`,
         usedKey: l,
         exactUsedKey: l,
         usedLng: g,
         usedNS: h,
         usedParams: this.getUsedParamsDetails(s)
      } : `${h}${m}${l}` : r ? {
         res: l,
         usedKey: l,
         exactUsedKey: l,
         usedLng: g,
         usedNS: h,
         usedParams: this.getUsedParamsDetails(s)
      } : l;
      const x = this.resolve(e, s);
      let S = x == null ? void 0 : x.res;
      const E = (x == null ? void 0 : x.usedKey) || l,
         T = (x == null ? void 0 : x.exactUsedKey) || l,
         b = ["[object Number]", "[object Function]", "[object RegExp]"],
         w = s.joinArrays !== void 0 ? s.joinArrays : this.options.joinArrays,
         C = !this.i18nFormat || this.i18nFormat.handleAsObject,
         N = s.count !== void 0 && !$t(s.count),
         U = Q1.hasDefaultValue(s),
         z = N ? this.pluralResolver.getSuffix(g, s.count, s) : "",
         B = s.ordinal && N ? this.pluralResolver.getSuffix(g, s.count, {
            ordinal: !1
         }) : "",
         I = N && !s.ordinal && s.count === 0,
         O = I && s[`defaultValue${this.options.pluralSeparator}zero`] || s[`defaultValue${z}`] || s[`defaultValue${B}`] || s.defaultValue;
      let P = S;
      C && !S && U && (P = O);
      const q = aP(P),
         Q = Object.prototype.toString.apply(P);
      if (C && P && q && b.indexOf(Q) < 0 && !($t(w) && Array.isArray(P))) {
         if (!s.returnObjects && !this.options.returnObjects) {
            this.options.returnedObjectHandler || this.logger.warn("accessing an object - but returnObjects options is not enabled!");
            const $ = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(E, P, {
               ...s,
               ns: c
            }) : `key '${l} (${this.language})' returned an object instead of string.`;
            return r ? (x.res = $, x.usedParams = this.getUsedParamsDetails(s), x) : $
         }
         if (a) {
            const $ = Array.isArray(P),
               ae = $ ? [] : {},
               fe = $ ? T : E;
            for (const k in P)
               if (Object.prototype.hasOwnProperty.call(P, k)) {
                  const Z = `${fe}${a}${k}`;
                  U && !S ? ae[k] = this.translate(Z, {
                     ...s,
                     defaultValue: aP(O) ? O[k] : void 0,
                     joinArrays: !1,
                     ns: c
                  }) : ae[k] = this.translate(Z, {
                     ...s,
                     joinArrays: !1,
                     ns: c
                  }), ae[k] === Z && (ae[k] = P[k])
               } S = ae
         }
      } else if (C && $t(w) && Array.isArray(S)) S = S.join(w), S && (S = this.extendTranslation(S, e, s, i));
      else {
         let $ = !1,
            ae = !1;
         !this.isValidLookup(S) && U && ($ = !0, S = O), this.isValidLookup(S) || (ae = !0, S = l);
         const k = (s.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey) && ae ? void 0 : S,
            Z = U && O !== S && this.options.updateMissing;
         if (ae || $ || Z) {
            if (this.logger.log(Z ? "updateKey" : "missingKey", g, h, l, Z ? O : S), a) {
               const ie = this.resolve(l, {
                  ...s,
                  keySeparator: !1
               });
               ie && ie.res && this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.")
            }
            let J = [];
            const pe = this.languageUtils.getFallbackCodes(this.options.fallbackLng, s.lng || this.language);
            if (this.options.saveMissingTo === "fallback" && pe && pe[0])
               for (let ie = 0; ie < pe.length; ie++) J.push(pe[ie]);
            else this.options.saveMissingTo === "all" ? J = this.languageUtils.toResolveHierarchy(s.lng || this.language) : J.push(s.lng || this.language);
            const F = (ie, ye, we) => {
               var be;
               const oe = U && we !== S ? we : k;
               this.options.missingKeyHandler ? this.options.missingKeyHandler(ie, h, ye, oe, Z, s) : (be = this.backendConnector) != null && be.saveMissing && this.backendConnector.saveMissing(ie, h, ye, oe, Z, s), this.emit("missingKey", ie, h, ye, S)
            };
            this.options.saveMissing && (this.options.saveMissingPlurals && N ? J.forEach(ie => {
               const ye = this.pluralResolver.getSuffixes(ie, s);
               I && s[`defaultValue${this.options.pluralSeparator}zero`] && ye.indexOf(`${this.options.pluralSeparator}zero`) < 0 && ye.push(`${this.options.pluralSeparator}zero`), ye.forEach(we => {
                  F([ie], l + we, s[`defaultValue${we}`] || O)
               })
            }) : F(J, l, O))
         }
         S = this.extendTranslation(S, e, s, x, i), ae && S === l && this.options.appendNamespaceToMissingKey && (S = `${h}${m}${l}`), (ae || $) && this.options.parseMissingKeyHandler && (S = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${h}${m}${l}` : l, $ ? S : void 0, s))
      }
      return r ? (x.res = S, x.usedParams = this.getUsedParamsDetails(s), x) : S
   }
   extendTranslation(e, t, i, s, r) {
      var c, h;
      if ((c = this.i18nFormat) != null && c.parse) e = this.i18nFormat.parse(e, {
         ...this.options.interpolation.defaultVariables,
         ...i
      }, i.lng || this.language || s.usedLng, s.usedNS, s.usedKey, {
         resolved: s
      });
      else if (!i.skipInterpolation) {
         i.interpolation && this.interpolator.init({
            ...i,
            interpolation: {
               ...this.options.interpolation,
               ...i.interpolation
            }
         });
         const m = $t(e) && (((h = i == null ? void 0 : i.interpolation) == null ? void 0 : h.skipOnVariables) !== void 0 ? i.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
         let g;
         if (m) {
            const x = e.match(this.interpolator.nestingRegexp);
            g = x && x.length
         }
         let v = i.replace && !$t(i.replace) ? i.replace : i;
         if (this.options.interpolation.defaultVariables && (v = {
               ...this.options.interpolation.defaultVariables,
               ...v
            }), e = this.interpolator.interpolate(e, v, i.lng || this.language || s.usedLng, i), m) {
            const x = e.match(this.interpolator.nestingRegexp),
               S = x && x.length;
            g < S && (i.nest = !1)
         }!i.lng && s && s.res && (i.lng = this.language || s.usedLng), i.nest !== !1 && (e = this.interpolator.nest(e, (...x) => (r == null ? void 0 : r[0]) === x[0] && !i.context ? (this.logger.warn(`It seems you are nesting recursively key: ${x[0]} in key: ${t[0]}`), null) : this.translate(...x, t), i)), i.interpolation && this.interpolator.reset()
      }
      const a = i.postProcess || this.options.postProcess,
         l = $t(a) ? [a] : a;
      return e != null && (l != null && l.length) && i.applyPostProcessor !== !1 && (e = WF.handle(l, e, t, this.options && this.options.postProcessPassResolved ? {
         i18nResolved: {
            ...s,
            usedParams: this.getUsedParamsDetails(i)
         },
         ...i
      } : i, this)), e
   }
   resolve(e, t = {}) {
      let i, s, r, a, l;
      return $t(e) && (e = [e]), e.forEach(c => {
         if (this.isValidLookup(i)) return;
         const h = this.extractFromKey(c, t),
            m = h.key;
         s = m;
         let g = h.namespaces;
         this.options.fallbackNS && (g = g.concat(this.options.fallbackNS));
         const v = t.count !== void 0 && !$t(t.count),
            x = v && !t.ordinal && t.count === 0,
            S = t.context !== void 0 && ($t(t.context) || typeof t.context == "number") && t.context !== "",
            E = t.lngs ? t.lngs : this.languageUtils.toResolveHierarchy(t.lng || this.language, t.fallbackLng);
         g.forEach(T => {
            var b, w;
            this.isValidLookup(i) || (l = T, !rP[`${E[0]}-${T}`] && ((b = this.utils) != null && b.hasLoadedNamespace) && !((w = this.utils) != null && w.hasLoadedNamespace(l)) && (rP[`${E[0]}-${T}`] = !0, this.logger.warn(`key "${s}" for languages "${E.join(", ")}" won't get resolved as namespace "${l}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")), E.forEach(C => {
               var z;
               if (this.isValidLookup(i)) return;
               a = C;
               const N = [m];
               if ((z = this.i18nFormat) != null && z.addLookupKeys) this.i18nFormat.addLookupKeys(N, m, C, T, t);
               else {
                  let B;
                  v && (B = this.pluralResolver.getSuffix(C, t.count, t));
                  const I = `${this.options.pluralSeparator}zero`,
                     O = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
                  if (v && (N.push(m + B), t.ordinal && B.indexOf(O) === 0 && N.push(m + B.replace(O, this.options.pluralSeparator)), x && N.push(m + I)), S) {
                     const P = `${m}${this.options.contextSeparator}${t.context}`;
                     N.push(P), v && (N.push(P + B), t.ordinal && B.indexOf(O) === 0 && N.push(P + B.replace(O, this.options.pluralSeparator)), x && N.push(P + I))
                  }
               }
               let U;
               for (; U = N.pop();) this.isValidLookup(i) || (r = U, i = this.getResource(C, T, U, t))
            }))
         })
      }), {
         res: i,
         usedKey: s,
         exactUsedKey: r,
         usedLng: a,
         usedNS: l
      }
   }
   isValidLookup(e) {
      return e !== void 0 && !(!this.options.returnNull && e === null) && !(!this.options.returnEmptyString && e === "")
   }
   getResource(e, t, i, s = {}) {
      var r;
      return (r = this.i18nFormat) != null && r.getResource ? this.i18nFormat.getResource(e, t, i, s) : this.resourceStore.getResource(e, t, i, s)
   }
   getUsedParamsDetails(e = {}) {
      const t = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"],
         i = e.replace && !$t(e.replace);
      let s = i ? e.replace : e;
      if (i && typeof e.count < "u" && (s.count = e.count), this.options.interpolation.defaultVariables && (s = {
            ...this.options.interpolation.defaultVariables,
            ...s
         }), !i) {
         s = {
            ...s
         };
         for (const r of t) delete s[r]
      }
      return s
   }
   static hasDefaultValue(e) {
      const t = "defaultValue";
      for (const i in e)
         if (Object.prototype.hasOwnProperty.call(e, i) && t === i.substring(0, t.length) && e[i] !== void 0) return !0;
      return !1
   }
}
class oP {
   constructor(e) {
      this.options = e, this.supportedLngs = this.options.supportedLngs || !1, this.logger = Uu.create("languageUtils")
   }
   getScriptPartFromCode(e) {
      if (e = ax(e), !e || e.indexOf("-") < 0) return null;
      const t = e.split("-");
      return t.length === 2 || (t.pop(), t[t.length - 1].toLowerCase() === "x") ? null : this.formatLanguageCode(t.join("-"))
   }
   getLanguagePartFromCode(e) {
      if (e = ax(e), !e || e.indexOf("-") < 0) return e;
      const t = e.split("-");
      return this.formatLanguageCode(t[0])
   }
   formatLanguageCode(e) {
      if ($t(e) && e.indexOf("-") > -1) {
         let t;
         try {
            t = Intl.getCanonicalLocales(e)[0]
         } catch {}
         return t && this.options.lowerCaseLng && (t = t.toLowerCase()), t || (this.options.lowerCaseLng ? e.toLowerCase() : e)
      }
      return this.options.cleanCode || this.options.lowerCaseLng ? e.toLowerCase() : e
   }
   isSupportedCode(e) {
      return (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) && (e = this.getLanguagePartFromCode(e)), !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(e) > -1
   }
   getBestMatchFromCodes(e) {
      if (!e) return null;
      let t;
      return e.forEach(i => {
         if (t) return;
         const s = this.formatLanguageCode(i);
         (!this.options.supportedLngs || this.isSupportedCode(s)) && (t = s)
      }), !t && this.options.supportedLngs && e.forEach(i => {
         if (t) return;
         const s = this.getScriptPartFromCode(i);
         if (this.isSupportedCode(s)) return t = s;
         const r = this.getLanguagePartFromCode(i);
         if (this.isSupportedCode(r)) return t = r;
         t = this.options.supportedLngs.find(a => {
            if (a === r) return a;
            if (!(a.indexOf("-") < 0 && r.indexOf("-") < 0) && (a.indexOf("-") > 0 && r.indexOf("-") < 0 && a.substring(0, a.indexOf("-")) === r || a.indexOf(r) === 0 && r.length > 1)) return a
         })
      }), t || (t = this.getFallbackCodes(this.options.fallbackLng)[0]), t
   }
   getFallbackCodes(e, t) {
      if (!e) return [];
      if (typeof e == "function" && (e = e(t)), $t(e) && (e = [e]), Array.isArray(e)) return e;
      if (!t) return e.default || [];
      let i = e[t];
      return i || (i = e[this.getScriptPartFromCode(t)]), i || (i = e[this.formatLanguageCode(t)]), i || (i = e[this.getLanguagePartFromCode(t)]), i || (i = e.default), i || []
   }
   toResolveHierarchy(e, t) {
      const i = this.getFallbackCodes((t === !1 ? [] : t) || this.options.fallbackLng || [], e),
         s = [],
         r = a => {
            a && (this.isSupportedCode(a) ? s.push(a) : this.logger.warn(`rejecting language code not found in supportedLngs: ${a}`))
         };
      return $t(e) && (e.indexOf("-") > -1 || e.indexOf("_") > -1) ? (this.options.load !== "languageOnly" && r(this.formatLanguageCode(e)), this.options.load !== "languageOnly" && this.options.load !== "currentOnly" && r(this.getScriptPartFromCode(e)), this.options.load !== "currentOnly" && r(this.getLanguagePartFromCode(e))) : $t(e) && r(this.formatLanguageCode(e)), i.forEach(a => {
         s.indexOf(a) < 0 && r(this.formatLanguageCode(a))
      }), s
   }
}
const lP = {
      zero: 0,
      one: 1,
      two: 2,
      few: 3,
      many: 4,
      other: 5
   },
   uP = {
      select: n => n === 1 ? "one" : "other",
      resolvedOptions: () => ({
         pluralCategories: ["one", "other"]
      })
   };
class sse {
   constructor(e, t = {}) {
      this.languageUtils = e, this.options = t, this.logger = Uu.create("pluralResolver"), this.pluralRulesCache = {}
   }
   addRule(e, t) {
      this.rules[e] = t
   }
   clearCache() {
      this.pluralRulesCache = {}
   }
   getRule(e, t = {}) {
      const i = ax(e === "dev" ? "en" : e),
         s = t.ordinal ? "ordinal" : "cardinal",
         r = JSON.stringify({
            cleanedCode: i,
            type: s
         });
      if (r in this.pluralRulesCache) return this.pluralRulesCache[r];
      let a;
      try {
         a = new Intl.PluralRules(i, {
            type: s
         })
      } catch {
         if (!Intl) return this.logger.error("No Intl support, please use an Intl polyfill!"), uP;
         if (!e.match(/-|_/)) return uP;
         const c = this.languageUtils.getLanguagePartFromCode(e);
         a = this.getRule(c, t)
      }
      return this.pluralRulesCache[r] = a, a
   }
   needsPlural(e, t = {}) {
      let i = this.getRule(e, t);
      return i || (i = this.getRule("dev", t)), (i == null ? void 0 : i.resolvedOptions().pluralCategories.length) > 1
   }
   getPluralFormsOfKey(e, t, i = {}) {
      return this.getSuffixes(e, i).map(s => `${t}${s}`)
   }
   getSuffixes(e, t = {}) {
      let i = this.getRule(e, t);
      return i || (i = this.getRule("dev", t)), i ? i.resolvedOptions().pluralCategories.sort((s, r) => lP[s] - lP[r]).map(s => `${this.options.prepend}${t.ordinal?`ordinal${this.options.prepend}`:""}${s}`) : []
   }
   getSuffix(e, t, i = {}) {
      const s = this.getRule(e, i);
      return s ? `${this.options.prepend}${i.ordinal?`ordinal${this.options.prepend}`:""}${s.select(t)}` : (this.logger.warn(`no plural rule found for: ${e}`), this.getSuffix("dev", t, i))
   }
}
const cP = (n, e, t, i = ".", s = !0) => {
      let r = Zie(n, e, t);
      return !r && s && $t(t) && (r = uR(n, t, i), r === void 0 && (r = uR(e, t, i))), r
   },
   LA = n => n.replace(/\$/g, "$$$$");
class rse {
   constructor(e = {}) {
      var t;
      this.logger = Uu.create("interpolator"), this.options = e, this.format = ((t = e == null ? void 0 : e.interpolation) == null ? void 0 : t.format) || (i => i), this.init(e)
   }
   init(e = {}) {
      e.interpolation || (e.interpolation = {
         escapeValue: !0
      });
      const {
         escape: t,
         escapeValue: i,
         useRawValueToEscape: s,
         prefix: r,
         prefixEscaped: a,
         suffix: l,
         suffixEscaped: c,
         formatSeparator: h,
         unescapeSuffix: m,
         unescapePrefix: g,
         nestingPrefix: v,
         nestingPrefixEscaped: x,
         nestingSuffix: S,
         nestingSuffixEscaped: E,
         nestingOptionsSeparator: T,
         maxReplaces: b,
         alwaysFormat: w
      } = e.interpolation;
      this.escape = t !== void 0 ? t : Jie, this.escapeValue = i !== void 0 ? i : !0, this.useRawValueToEscape = s !== void 0 ? s : !1, this.prefix = r ? Fm(r) : a || "{{", this.suffix = l ? Fm(l) : c || "}}", this.formatSeparator = h || ",", this.unescapePrefix = m ? "" : g || "-", this.unescapeSuffix = this.unescapePrefix ? "" : m || "", this.nestingPrefix = v ? Fm(v) : x || Fm("$t("), this.nestingSuffix = S ? Fm(S) : E || Fm(")"), this.nestingOptionsSeparator = T || ",", this.maxReplaces = b || 1e3, this.alwaysFormat = w !== void 0 ? w : !1, this.resetRegExp()
   }
   reset() {
      this.options && this.init(this.options)
   }
   resetRegExp() {
      const e = (t, i) => (t == null ? void 0 : t.source) === i ? (t.lastIndex = 0, t) : new RegExp(i, "g");
      this.regexp = e(this.regexp, `${this.prefix}(.+?)${this.suffix}`), this.regexpUnescape = e(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`), this.nestingRegexp = e(this.nestingRegexp, `${this.nestingPrefix}(.+?)${this.nestingSuffix}`)
   }
   interpolate(e, t, i, s) {
      var x;
      let r, a, l;
      const c = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {},
         h = S => {
            if (S.indexOf(this.formatSeparator) < 0) {
               const w = cP(t, c, S, this.options.keySeparator, this.options.ignoreJSONStructure);
               return this.alwaysFormat ? this.format(w, void 0, i, {
                  ...s,
                  ...t,
                  interpolationkey: S
               }) : w
            }
            const E = S.split(this.formatSeparator),
               T = E.shift().trim(),
               b = E.join(this.formatSeparator).trim();
            return this.format(cP(t, c, T, this.options.keySeparator, this.options.ignoreJSONStructure), b, i, {
               ...s,
               ...t,
               interpolationkey: T
            })
         };
      this.resetRegExp();
      const m = (s == null ? void 0 : s.missingInterpolationHandler) || this.options.missingInterpolationHandler,
         g = ((x = s == null ? void 0 : s.interpolation) == null ? void 0 : x.skipOnVariables) !== void 0 ? s.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
      return [{
         regex: this.regexpUnescape,
         safeValue: S => LA(S)
      }, {
         regex: this.regexp,
         safeValue: S => this.escapeValue ? LA(this.escape(S)) : LA(S)
      }].forEach(S => {
         for (l = 0; r = S.regex.exec(e);) {
            const E = r[1].trim();
            if (a = h(E), a === void 0)
               if (typeof m == "function") {
                  const b = m(e, r, s);
                  a = $t(b) ? b : ""
               } else if (s && Object.prototype.hasOwnProperty.call(s, E)) a = "";
            else if (g) {
               a = r[0];
               continue
            } else this.logger.warn(`missed to pass in variable ${E} for interpolating ${e}`), a = "";
            else !$t(a) && !this.useRawValueToEscape && (a = eP(a));
            const T = S.safeValue(a);
            if (e = e.replace(r[0], T), g ? (S.regex.lastIndex += a.length, S.regex.lastIndex -= r[0].length) : S.regex.lastIndex = 0, l++, l >= this.maxReplaces) break
         }
      }), e
   }
   nest(e, t, i = {}) {
      let s, r, a;
      const l = (c, h) => {
         const m = this.nestingOptionsSeparator;
         if (c.indexOf(m) < 0) return c;
         const g = c.split(new RegExp(`${m}[ ]*{`));
         let v = `{${g[1]}`;
         c = g[0], v = this.interpolate(v, a);
         const x = v.match(/'/g),
            S = v.match(/"/g);
         (((x == null ? void 0 : x.length) ?? 0) % 2 === 0 && !S || S.length % 2 !== 0) && (v = v.replace(/'/g, '"'));
         try {
            a = JSON.parse(v), h && (a = {
               ...h,
               ...a
            })
         } catch (E) {
            return this.logger.warn(`failed parsing options string in nesting for key ${c}`, E), `${c}${m}${v}`
         }
         return a.defaultValue && a.defaultValue.indexOf(this.prefix) > -1 && delete a.defaultValue, c
      };
      for (; s = this.nestingRegexp.exec(e);) {
         let c = [];
         a = {
            ...i
         }, a = a.replace && !$t(a.replace) ? a.replace : a, a.applyPostProcessor = !1, delete a.defaultValue;
         const h = /{.*}/.test(s[1]) ? s[1].lastIndexOf("}") + 1 : s[1].indexOf(this.formatSeparator);
         if (h !== -1 && (c = s[1].slice(h).split(this.formatSeparator).map(m => m.trim()).filter(Boolean), s[1] = s[1].slice(0, h)), r = t(l.call(this, s[1].trim(), a), a), r && s[0] === e && !$t(r)) return r;
         $t(r) || (r = eP(r)), r || (this.logger.warn(`missed to resolve ${s[1]} for nesting ${e}`), r = ""), c.length && (r = c.reduce((m, g) => this.format(m, g, i.lng, {
            ...i,
            interpolationkey: s[1].trim()
         }), r.trim())), e = e.replace(s[0], r), this.regexp.lastIndex = 0
      }
      return e
   }
}
const ase = n => {
      let e = n.toLowerCase().trim();
      const t = {};
      if (n.indexOf("(") > -1) {
         const i = n.split("(");
         e = i[0].toLowerCase().trim();
         const s = i[1].substring(0, i[1].length - 1);
         e === "currency" && s.indexOf(":") < 0 ? t.currency || (t.currency = s.trim()) : e === "relativetime" && s.indexOf(":") < 0 ? t.range || (t.range = s.trim()) : s.split(";").forEach(a => {
            if (a) {
               const [l, ...c] = a.split(":"), h = c.join(":").trim().replace(/^'+|'+$/g, ""), m = l.trim();
               t[m] || (t[m] = h), h === "false" && (t[m] = !1), h === "true" && (t[m] = !0), isNaN(h) || (t[m] = parseInt(h, 10))
            }
         })
      }
      return {
         formatName: e,
         formatOptions: t
      }
   },
   fP = n => {
      const e = {};
      return (t, i, s) => {
         let r = s;
         s && s.interpolationkey && s.formatParams && s.formatParams[s.interpolationkey] && s[s.interpolationkey] && (r = {
            ...r,
            [s.interpolationkey]: void 0
         });
         const a = i + JSON.stringify(r);
         let l = e[a];
         return l || (l = n(ax(i), s), e[a] = l), l(t)
      }
   },
   ose = n => (e, t, i) => n(ax(t), i)(e);
class lse {
   constructor(e = {}) {
      this.logger = Uu.create("formatter"), this.options = e, this.init(e)
   }
   init(e, t = {
      interpolation: {}
   }) {
      this.formatSeparator = t.interpolation.formatSeparator || ",";
      const i = t.cacheInBuiltFormats ? fP : ose;
      this.formats = {
         number: i((s, r) => {
            const a = new Intl.NumberFormat(s, {
               ...r
            });
            return l => a.format(l)
         }),
         currency: i((s, r) => {
            const a = new Intl.NumberFormat(s, {
               ...r,
               style: "currency"
            });
            return l => a.format(l)
         }),
         datetime: i((s, r) => {
            const a = new Intl.DateTimeFormat(s, {
               ...r
            });
            return l => a.format(l)
         }),
         relativetime: i((s, r) => {
            const a = new Intl.RelativeTimeFormat(s, {
               ...r
            });
            return l => a.format(l, r.range || "day")
         }),
         list: i((s, r) => {
            const a = new Intl.ListFormat(s, {
               ...r
            });
            return l => a.format(l)
         })
      }
   }
   add(e, t) {
      this.formats[e.toLowerCase().trim()] = t
   }
   addCached(e, t) {
      this.formats[e.toLowerCase().trim()] = fP(t)
   }
   format(e, t, i, s = {}) {
      const r = t.split(this.formatSeparator);
      if (r.length > 1 && r[0].indexOf("(") > 1 && r[0].indexOf(")") < 0 && r.find(l => l.indexOf(")") > -1)) {
         const l = r.findIndex(c => c.indexOf(")") > -1);
         r[0] = [r[0], ...r.splice(1, l)].join(this.formatSeparator)
      }
      return r.reduce((l, c) => {
         var g;
         const {
            formatName: h,
            formatOptions: m
         } = ase(c);
         if (this.formats[h]) {
            let v = l;
            try {
               const x = ((g = s == null ? void 0 : s.formatParams) == null ? void 0 : g[s.interpolationkey]) || {},
                  S = x.locale || x.lng || s.locale || s.lng || i;
               v = this.formats[h](l, S, {
                  ...m,
                  ...s,
                  ...x
               })
            } catch (x) {
               this.logger.warn(x)
            }
            return v
         } else this.logger.warn(`there was no format function for ${h}`);
         return l
      }, e)
   }
}
const use = (n, e) => {
   n.pending[e] !== void 0 && (delete n.pending[e], n.pendingCount--)
};
class cse extends nE {
   constructor(e, t, i, s = {}) {
      var r, a;
      super(), this.backend = e, this.store = t, this.services = i, this.languageUtils = i.languageUtils, this.options = s, this.logger = Uu.create("backendConnector"), this.waitingReads = [], this.maxParallelReads = s.maxParallelReads || 10, this.readingCalls = 0, this.maxRetries = s.maxRetries >= 0 ? s.maxRetries : 5, this.retryTimeout = s.retryTimeout >= 1 ? s.retryTimeout : 350, this.state = {}, this.queue = [], (a = (r = this.backend) == null ? void 0 : r.init) == null || a.call(r, i, s.backend, s)
   }
   queueLoad(e, t, i, s) {
      const r = {},
         a = {},
         l = {},
         c = {};
      return e.forEach(h => {
         let m = !0;
         t.forEach(g => {
            const v = `${h}|${g}`;
            !i.reload && this.store.hasResourceBundle(h, g) ? this.state[v] = 2 : this.state[v] < 0 || (this.state[v] === 1 ? a[v] === void 0 && (a[v] = !0) : (this.state[v] = 1, m = !1, a[v] === void 0 && (a[v] = !0), r[v] === void 0 && (r[v] = !0), c[g] === void 0 && (c[g] = !0)))
         }), m || (l[h] = !0)
      }), (Object.keys(r).length || Object.keys(a).length) && this.queue.push({
         pending: a,
         pendingCount: Object.keys(a).length,
         loaded: {},
         errors: [],
         callback: s
      }), {
         toLoad: Object.keys(r),
         pending: Object.keys(a),
         toLoadLanguages: Object.keys(l),
         toLoadNamespaces: Object.keys(c)
      }
   }
   loaded(e, t, i) {
      const s = e.split("|"),
         r = s[0],
         a = s[1];
      t && this.emit("failedLoading", r, a, t), !t && i && this.store.addResourceBundle(r, a, i, void 0, void 0, {
         skipCopy: !0
      }), this.state[e] = t ? -1 : 2, t && i && (this.state[e] = 0);
      const l = {};
      this.queue.forEach(c => {
         Kie(c.loaded, [r], a), use(c, e), t && c.errors.push(t), c.pendingCount === 0 && !c.done && (Object.keys(c.loaded).forEach(h => {
            l[h] || (l[h] = {});
            const m = c.loaded[h];
            m.length && m.forEach(g => {
               l[h][g] === void 0 && (l[h][g] = !0)
            })
         }), c.done = !0, c.errors.length ? c.callback(c.errors) : c.callback())
      }), this.emit("loaded", l), this.queue = this.queue.filter(c => !c.done)
   }
   read(e, t, i, s = 0, r = this.retryTimeout, a) {
      if (!e.length) return a(null, {});
      if (this.readingCalls >= this.maxParallelReads) {
         this.waitingReads.push({
            lng: e,
            ns: t,
            fcName: i,
            tried: s,
            wait: r,
            callback: a
         });
         return
      }
      this.readingCalls++;
      const l = (h, m) => {
            if (this.readingCalls--, this.waitingReads.length > 0) {
               const g = this.waitingReads.shift();
               this.read(g.lng, g.ns, g.fcName, g.tried, g.wait, g.callback)
            }
            if (h && m && s < this.maxRetries) {
               setTimeout(() => {
                  this.read.call(this, e, t, i, s + 1, r * 2, a)
               }, r);
               return
            }
            a(h, m)
         },
         c = this.backend[i].bind(this.backend);
      if (c.length === 2) {
         try {
            const h = c(e, t);
            h && typeof h.then == "function" ? h.then(m => l(null, m)).catch(l) : l(null, h)
         } catch (h) {
            l(h)
         }
         return
      }
      return c(e, t, l)
   }
   prepareLoading(e, t, i = {}, s) {
      if (!this.backend) return this.logger.warn("No backend was added via i18next.use. Will not load resources."), s && s();
      $t(e) && (e = this.languageUtils.toResolveHierarchy(e)), $t(t) && (t = [t]);
      const r = this.queueLoad(e, t, i, s);
      if (!r.toLoad.length) return r.pending.length || s(), null;
      r.toLoad.forEach(a => {
         this.loadOne(a)
      })
   }
   load(e, t, i) {
      this.prepareLoading(e, t, {}, i)
   }
   reload(e, t, i) {
      this.prepareLoading(e, t, {
         reload: !0
      }, i)
   }
   loadOne(e, t = "") {
      const i = e.split("|"),
         s = i[0],
         r = i[1];
      this.read(s, r, "read", void 0, void 0, (a, l) => {
         a && this.logger.warn(`${t}loading namespace ${r} for language ${s} failed`, a), !a && l && this.logger.log(`${t}loaded namespace ${r} for language ${s}`, l), this.loaded(e, a, l)
      })
   }
   saveMissing(e, t, i, s, r, a = {}, l = () => {}) {
      var c, h, m, g, v;
      if ((h = (c = this.services) == null ? void 0 : c.utils) != null && h.hasLoadedNamespace && !((g = (m = this.services) == null ? void 0 : m.utils) != null && g.hasLoadedNamespace(t))) {
         this.logger.warn(`did not save key "${i}" as the namespace "${t}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
         return
      }
      if (!(i == null || i === "")) {
         if ((v = this.backend) != null && v.create) {
            const x = {
                  ...a,
                  isUpdate: r
               },
               S = this.backend.create.bind(this.backend);
            if (S.length < 6) try {
               let E;
               S.length === 5 ? E = S(e, t, i, s, x) : E = S(e, t, i, s), E && typeof E.then == "function" ? E.then(T => l(null, T)).catch(l) : l(null, E)
            } catch (E) {
               l(E)
            } else S(e, t, i, s, l, x)
         }!e || !e[0] || this.store.addResource(e[0], t, i, s)
      }
   }
}
const hP = () => ({
      debug: !1,
      initAsync: !0,
      ns: ["translation"],
      defaultNS: ["translation"],
      fallbackLng: ["dev"],
      fallbackNS: !1,
      supportedLngs: !1,
      nonExplicitSupportedLngs: !1,
      load: "all",
      preload: !1,
      simplifyPluralSuffix: !0,
      keySeparator: ".",
      nsSeparator: ":",
      pluralSeparator: "_",
      contextSeparator: "_",
      partialBundledLanguages: !1,
      saveMissing: !1,
      updateMissing: !1,
      saveMissingTo: "fallback",
      saveMissingPlurals: !0,
      missingKeyHandler: !1,
      missingInterpolationHandler: !1,
      postProcess: !1,
      postProcessPassResolved: !1,
      returnNull: !1,
      returnEmptyString: !0,
      returnObjects: !1,
      joinArrays: !1,
      returnedObjectHandler: !1,
      parseMissingKeyHandler: !1,
      appendNamespaceToMissingKey: !1,
      appendNamespaceToCIMode: !1,
      overloadTranslationOptionHandler: n => {
         let e = {};
         if (typeof n[1] == "object" && (e = n[1]), $t(n[1]) && (e.defaultValue = n[1]), $t(n[2]) && (e.tDescription = n[2]), typeof n[2] == "object" || typeof n[3] == "object") {
            const t = n[3] || n[2];
            Object.keys(t).forEach(i => {
               e[i] = t[i]
            })
         }
         return e
      },
      interpolation: {
         escapeValue: !0,
         format: n => n,
         prefix: "{{",
         suffix: "}}",
         formatSeparator: ",",
         unescapePrefix: "-",
         nestingPrefix: "$t(",
         nestingSuffix: ")",
         nestingOptionsSeparator: ",",
         maxReplaces: 1e3,
         skipOnVariables: !0
      },
      cacheInBuiltFormats: !0
   }),
   dP = n => {
      var e, t;
      return $t(n.ns) && (n.ns = [n.ns]), $t(n.fallbackLng) && (n.fallbackLng = [n.fallbackLng]), $t(n.fallbackNS) && (n.fallbackNS = [n.fallbackNS]), ((t = (e = n.supportedLngs) == null ? void 0 : e.indexOf) == null ? void 0 : t.call(e, "cimode")) < 0 && (n.supportedLngs = n.supportedLngs.concat(["cimode"])), typeof n.initImmediate == "boolean" && (n.initAsync = n.initImmediate), n
   },
   gb = () => {},
   fse = n => {
      Object.getOwnPropertyNames(Object.getPrototypeOf(n)).forEach(t => {
         typeof n[t] == "function" && (n[t] = n[t].bind(n))
      })
   };
class ox extends nE {
   constructor(e = {}, t) {
      if (super(), this.options = dP(e), this.services = {}, this.logger = Uu, this.modules = {
            external: []
         }, fse(this), t && !this.isInitialized && !e.isClone) {
         if (!this.options.initAsync) return this.init(e, t), this;
         setTimeout(() => {
            this.init(e, t)
         }, 0)
      }
   }
   init(e = {}, t) {
      this.isInitializing = !0, typeof e == "function" && (t = e, e = {}), e.defaultNS == null && e.ns && ($t(e.ns) ? e.defaultNS = e.ns : e.ns.indexOf("translation") < 0 && (e.defaultNS = e.ns[0]));
      const i = hP();
      this.options = {
         ...i,
         ...this.options,
         ...dP(e)
      }, this.options.interpolation = {
         ...i.interpolation,
         ...this.options.interpolation
      }, e.keySeparator !== void 0 && (this.options.userDefinedKeySeparator = e.keySeparator), e.nsSeparator !== void 0 && (this.options.userDefinedNsSeparator = e.nsSeparator);
      const s = h => h ? typeof h == "function" ? new h : h : null;
      if (!this.options.isClone) {
         this.modules.logger ? Uu.init(s(this.modules.logger), this.options) : Uu.init(null, this.options);
         let h;
         this.modules.formatter ? h = this.modules.formatter : h = lse;
         const m = new oP(this.options);
         this.store = new sP(this.options.resources, this.options);
         const g = this.services;
         g.logger = Uu, g.resourceStore = this.store, g.languageUtils = m, g.pluralResolver = new sse(m, {
            prepend: this.options.pluralSeparator,
            simplifyPluralSuffix: this.options.simplifyPluralSuffix
         }), this.options.interpolation.format && this.options.interpolation.format !== i.interpolation.format && this.logger.warn("init: you are still using the legacy format function, please use the new approach: https://www.i18next.com/translation-function/formatting"), h && (!this.options.interpolation.format || this.options.interpolation.format === i.interpolation.format) && (g.formatter = s(h), g.formatter.init && g.formatter.init(g, this.options), this.options.interpolation.format = g.formatter.format.bind(g.formatter)), g.interpolator = new rse(this.options), g.utils = {
            hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
         }, g.backendConnector = new cse(s(this.modules.backend), g.resourceStore, g, this.options), g.backendConnector.on("*", (x, ...S) => {
            this.emit(x, ...S)
         }), this.modules.languageDetector && (g.languageDetector = s(this.modules.languageDetector), g.languageDetector.init && g.languageDetector.init(g, this.options.detection, this.options)), this.modules.i18nFormat && (g.i18nFormat = s(this.modules.i18nFormat), g.i18nFormat.init && g.i18nFormat.init(this)), this.translator = new Q1(this.services, this.options), this.translator.on("*", (x, ...S) => {
            this.emit(x, ...S)
         }), this.modules.external.forEach(x => {
            x.init && x.init(this)
         })
      }
      if (this.format = this.options.interpolation.format, t || (t = gb), this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
         const h = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
         h.length > 0 && h[0] !== "dev" && (this.options.lng = h[0])
      }!this.services.languageDetector && !this.options.lng && this.logger.warn("init: no languageDetector is used and no lng is defined"), ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"].forEach(h => {
         this[h] = (...m) => this.store[h](...m)
      }), ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"].forEach(h => {
         this[h] = (...m) => (this.store[h](...m), this)
      });
      const l = A0(),
         c = () => {
            const h = (m, g) => {
               this.isInitializing = !1, this.isInitialized && !this.initializedStoreOnce && this.logger.warn("init: i18next is already initialized. You should call init just once!"), this.isInitialized = !0, this.options.isClone || this.logger.log("initialized", this.options), this.emit("initialized", this.options), l.resolve(g), t(m, g)
            };
            if (this.languages && !this.isInitialized) return h(null, this.t.bind(this));
            this.changeLanguage(this.options.lng, h)
         };
      return this.options.resources || !this.options.initAsync ? c() : setTimeout(c, 0), l
   }
   loadResources(e, t = gb) {
      var r, a;
      let i = t;
      const s = $t(e) ? e : this.language;
      if (typeof e == "function" && (i = e), !this.options.resources || this.options.partialBundledLanguages) {
         if ((s == null ? void 0 : s.toLowerCase()) === "cimode" && (!this.options.preload || this.options.preload.length === 0)) return i();
         const l = [],
            c = h => {
               if (!h || h === "cimode") return;
               this.services.languageUtils.toResolveHierarchy(h).forEach(g => {
                  g !== "cimode" && l.indexOf(g) < 0 && l.push(g)
               })
            };
         s ? c(s) : this.services.languageUtils.getFallbackCodes(this.options.fallbackLng).forEach(m => c(m)), (a = (r = this.options.preload) == null ? void 0 : r.forEach) == null || a.call(r, h => c(h)), this.services.backendConnector.load(l, this.options.ns, h => {
            !h && !this.resolvedLanguage && this.language && this.setResolvedLanguage(this.language), i(h)
         })
      } else i(null)
   }
   reloadResources(e, t, i) {
      const s = A0();
      return typeof e == "function" && (i = e, e = void 0), typeof t == "function" && (i = t, t = void 0), e || (e = this.languages), t || (t = this.options.ns), i || (i = gb), this.services.backendConnector.reload(e, t, r => {
         s.resolve(), i(r)
      }), s
   }
   use(e) {
      if (!e) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
      if (!e.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
      return e.type === "backend" && (this.modules.backend = e), (e.type === "logger" || e.log && e.warn && e.error) && (this.modules.logger = e), e.type === "languageDetector" && (this.modules.languageDetector = e), e.type === "i18nFormat" && (this.modules.i18nFormat = e), e.type === "postProcessor" && WF.addPostProcessor(e), e.type === "formatter" && (this.modules.formatter = e), e.type === "3rdParty" && this.modules.external.push(e), this
   }
   setResolvedLanguage(e) {
      if (!(!e || !this.languages) && !(["cimode", "dev"].indexOf(e) > -1)) {
         for (let t = 0; t < this.languages.length; t++) {
            const i = this.languages[t];
            if (!(["cimode", "dev"].indexOf(i) > -1) && this.store.hasLanguageSomeTranslations(i)) {
               this.resolvedLanguage = i;
               break
            }
         }!this.resolvedLanguage && this.languages.indexOf(e) < 0 && this.store.hasLanguageSomeTranslations(e) && (this.resolvedLanguage = e, this.languages.unshift(e))
      }
   }
   changeLanguage(e, t) {
      this.isLanguageChangingTo = e;
      const i = A0();
      this.emit("languageChanging", e);
      const s = l => {
            this.language = l, this.languages = this.services.languageUtils.toResolveHierarchy(l), this.resolvedLanguage = void 0, this.setResolvedLanguage(l)
         },
         r = (l, c) => {
            c ? this.isLanguageChangingTo === e && (s(c), this.translator.changeLanguage(c), this.isLanguageChangingTo = void 0, this.emit("languageChanged", c), this.logger.log("languageChanged", c)) : this.isLanguageChangingTo = void 0, i.resolve((...h) => this.t(...h)), t && t(l, (...h) => this.t(...h))
         },
         a = l => {
            var m, g;
            !e && !l && this.services.languageDetector && (l = []);
            const c = $t(l) ? l : l && l[0],
               h = this.store.hasLanguageSomeTranslations(c) ? c : this.services.languageUtils.getBestMatchFromCodes($t(l) ? [l] : l);
            h && (this.language || s(h), this.translator.language || this.translator.changeLanguage(h), (g = (m = this.services.languageDetector) == null ? void 0 : m.cacheUserLanguage) == null || g.call(m, h)), this.loadResources(h, v => {
               r(v, h)
            })
         };
      return !e && this.services.languageDetector && !this.services.languageDetector.async ? a(this.services.languageDetector.detect()) : !e && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect.length === 0 ? this.services.languageDetector.detect().then(a) : this.services.languageDetector.detect(a) : a(e), i
   }
   getFixedT(e, t, i) {
      const s = (r, a, ...l) => {
         let c;
         typeof a != "object" ? c = this.options.overloadTranslationOptionHandler([r, a].concat(l)) : c = {
            ...a
         }, c.lng = c.lng || s.lng, c.lngs = c.lngs || s.lngs, c.ns = c.ns || s.ns, c.keyPrefix !== "" && (c.keyPrefix = c.keyPrefix || i || s.keyPrefix);
         const h = this.options.keySeparator || ".";
         let m;
         return c.keyPrefix && Array.isArray(r) ? m = r.map(g => `${c.keyPrefix}${h}${g}`) : m = c.keyPrefix ? `${c.keyPrefix}${h}${r}` : r, this.t(m, c)
      };
      return $t(e) ? s.lng = e : s.lngs = e, s.ns = t, s.keyPrefix = i, s
   }
   t(...e) {
      var t;
      return (t = this.translator) == null ? void 0 : t.translate(...e)
   }
   exists(...e) {
      var t;
      return (t = this.translator) == null ? void 0 : t.exists(...e)
   }
   setDefaultNamespace(e) {
      this.options.defaultNS = e
   }
   hasLoadedNamespace(e, t = {}) {
      if (!this.isInitialized) return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages), !1;
      if (!this.languages || !this.languages.length) return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages), !1;
      const i = t.lng || this.resolvedLanguage || this.languages[0],
         s = this.options ? this.options.fallbackLng : !1,
         r = this.languages[this.languages.length - 1];
      if (i.toLowerCase() === "cimode") return !0;
      const a = (l, c) => {
         const h = this.services.backendConnector.state[`${l}|${c}`];
         return h === -1 || h === 0 || h === 2
      };
      if (t.precheck) {
         const l = t.precheck(this, a);
         if (l !== void 0) return l
      }
      return !!(this.hasResourceBundle(i, e) || !this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages || a(i, e) && (!s || a(r, e)))
   }
   loadNamespaces(e, t) {
      const i = A0();
      return this.options.ns ? ($t(e) && (e = [e]), e.forEach(s => {
         this.options.ns.indexOf(s) < 0 && this.options.ns.push(s)
      }), this.loadResources(s => {
         i.resolve(), t && t(s)
      }), i) : (t && t(), Promise.resolve())
   }
   loadLanguages(e, t) {
      const i = A0();
      $t(e) && (e = [e]);
      const s = this.options.preload || [],
         r = e.filter(a => s.indexOf(a) < 0 && this.services.languageUtils.isSupportedCode(a));
      return r.length ? (this.options.preload = s.concat(r), this.loadResources(a => {
         i.resolve(), t && t(a)
      }), i) : (t && t(), Promise.resolve())
   }
   dir(e) {
      var s, r;
      if (e || (e = this.resolvedLanguage || (((s = this.languages) == null ? void 0 : s.length) > 0 ? this.languages[0] : this.language)), !e) return "rtl";
      if (Intl.Locale) {
         const a = new Intl.Locale(e);
         if (a && a.getTextInfo) {
            const l = a.getTextInfo();
            if (l && l.direction) return l.direction
         }
      }
      const t = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"],
         i = ((r = this.services) == null ? void 0 : r.languageUtils) || new oP(hP());
      return e.toLowerCase().indexOf("-latn") > 1 ? "ltr" : t.indexOf(i.getLanguagePartFromCode(e)) > -1 || e.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr"
   }
   static createInstance(e = {}, t) {
      return new ox(e, t)
   }
   cloneInstance(e = {}, t = gb) {
      const i = e.forkResourceStore;
      i && delete e.forkResourceStore;
      const s = {
            ...this.options,
            ...e,
            isClone: !0
         },
         r = new ox(s);
      if ((e.debug !== void 0 || e.prefix !== void 0) && (r.logger = r.logger.clone(e)), ["store", "services", "language"].forEach(l => {
            r[l] = this[l]
         }), r.services = {
            ...this.services
         }, r.services.utils = {
            hasLoadedNamespace: r.hasLoadedNamespace.bind(r)
         }, i) {
         const l = Object.keys(this.store.data).reduce((c, h) => (c[h] = {
            ...this.store.data[h]
         }, c[h] = Object.keys(c[h]).reduce((m, g) => (m[g] = {
            ...c[h][g]
         }, m), c[h]), c), {});
         r.store = new sP(l, s), r.services.resourceStore = r.store
      }
      return r.translator = new Q1(r.services, s), r.translator.on("*", (l, ...c) => {
         r.emit(l, ...c)
      }), r.init(s, t), r.translator.options = s, r.translator.backendConnector.services.utils = {
         hasLoadedNamespace: r.hasLoadedNamespace.bind(r)
      }, r
   }
   toJSON() {
      return {
         options: this.options,
         store: this.store,
         language: this.language,
         languages: this.languages,
         resolvedLanguage: this.resolvedLanguage
      }
   }
}
const Fr = ox.createInstance();
Fr.createInstance = ox.createInstance;
Fr.createInstance;
Fr.dir;
Fr.init;
Fr.loadResources;
Fr.reloadResources;
Fr.use;
Fr.changeLanguage;
Fr.getFixedT;
Fr.t;
Fr.exists;
Fr.setDefaultNamespace;
Fr.hasLoadedNamespace;
Fr.loadNamespaces;
Fr.loadLanguages;
const hse = {
      home: {
         title: "MYSTERIUM - Luxury Coffee with Edible Gold & Progressive Giving",
         description: "Discover MYSTERIUM: premium coffee infused with 24k edible gold. Every purchase supports La Fontana Della Fortuna NGO through our progressive cashback program. Luxury that gives back."
      },
      projects: {
         title: "MYSTERIUM - Our Coffee Collections",
         description: "Explore our exclusive coffee collections crafted with edible gold. Each blend supports charitable causes through our progressive donation program with La Fontana Della Fortuna."
      },
      privacy: {
         title: "MYSTERIUM - Privacy Policy",
         description: "Learn how MYSTERIUM protects your personal data and handles your information in accordance with global privacy standards (GDPR, CCPA)."
      }
   },
   dse = "OUR STORY",
   fxe = "VIDEO",
   pse = "IMPACT",
   mse = "CONTACT",
   gse = "MENU",
   vse = "SOUND ON",
   yse = "SOUND OFF",
   xse = "MAIN",
   _se = "LUXURY COFFEE<br/>THAT GIVES BACK.",
   Sse = "SCROLL TO EXPLORE",
   bse = "PREMIUM COFFEE<br/>WITH EDIBLE GOLD.",
   Tse = "BACKGROUND IMAGE BY<br/>NASA",
   Ese = "At MYSTERIUM, we believe luxury and compassion can coexist. Each cup of our premium coffee is infused with 24k edible gold and crafted with exceptional quality.<br/><br/>Through our partnership with La Fontana Della Fortuna NGO, every purchase contributes to meaningful causes. Our progressive cashback system ensures that the more you enjoy, the more you give back to communities in need.",
   Mse = "SUPPORTING COMMUNITIES<br/>AROUND THE WORLD.",
   Ase = "DISCOVER OUR COLLECTIONS",
   wse = "PROGRESSIVE<br/>CASHBACK SYSTEM.",
   Rse = "Our innovative cashback program rewards your loyalty while amplifying your impact. With each purchase, earn progressive rewards that can be used for future orders or donated directly to La Fontana Della Fortuna NGO, supporting education, healthcare, and community development worldwide.",
   Cse = "24K EDIBLE GOLD<br/>INFUSION.",
   Dse = "Each blend is carefully crafted with premium Arabica beans and infused with 24k edible gold particles. This unique process creates a luxurious coffee experience that delights the senses while maintaining the rich, complex flavors of our expertly sourced beans.",
   Nse = "TRANSPARENT<br/>GIVING MODEL.",
   Ose = "We believe in complete transparency. Track exactly how your purchases support La Fontana Della Fortuna's initiatives through our blockchain-verified donation system. Every transaction is recorded, ensuring your contribution reaches those who need it most.",
   Use = "A LUXURY BRAND CREATED TO DELIGHT, INSPIRE, AND MAKE A LASTING DIFFERENCE IN THE WORLD.",
   Pse = "JOIN OUR MISSION.",
   Lse = "Whether you're interested in our premium coffee collections, partnership opportunities, or learning more about our charitable impact, we'd love to hear from you.",
   Bse = "Experience luxury coffee that makes a difference.",
   zse = "SUBMIT",
   Ise = "BACK TO TOP",
   Fse = "PRIVACY POLICY",
   Hse = "MYSTERIUM COFFEE. ALL RIGHTS RESERVED.",
   Vse = "Last updated: June 17, 2025.",
   Gse = "At MYSTERIUM, a luxury coffee brand supporting La Fontana Della Fortuna NGO, we value your privacy and are committed to protecting the personal information you share with us. This Privacy Policy describes how we collect, use, and handle your personal data when you interact with our website and make purchases.",
   kse = "1. Information We Collect",
   jse = "When you use our website or make a purchase, you voluntarily provide us with the following information:",
   qse = "Full Name: To personalize your experience and process orders.",
   Xse = "Email Address: To send order confirmations, updates, and charitable impact reports.",
   Wse = "Shipping Address: To deliver your premium coffee products.",
   Yse = "Payment Information: Securely processed through encrypted payment gateways.",
   Kse = "We collect minimal data necessary for transactions and charitable donation tracking. We use cookies only for essential website functionality and to improve your browsing experience.",
   Zse = "2. How We Use the Information Collected",
   Qse = "The information you provide is used for the following purposes:",
   Jse = "Order Processing: To fulfill your coffee purchases and deliver products to your address.",
   $se = "Donation Tracking: To calculate and allocate your progressive cashback contributions to La Fontana Della Fortuna NGO.",
   ere = "At MYSTERIUM, we respect your privacy. We will never sell, rent, or share your personal information with third parties for marketing purposes. Your data is used solely for order fulfillment and charitable impact reporting.",
   tre = "3. Data Storage and Retention",
   nre = "Your information is stored securely using industry-standard encryption. Order details and donation records are maintained for tax and transparency purposes in accordance with applicable laws.",
   ire = "We retain your purchase history to provide you with accurate cashback calculations and charitable impact reports. You can request deletion of your data at any time, subject to legal retention requirements for financial transactions.",
   sre = "4. Your Rights",
   rre = "In accordance with international privacy laws (GDPR, CCPA), you have the following rights:",
   are = "Access: The right to know what information we hold about you.",
   ore = "Rectification: The right to correct any inaccurate information.",
   lre = "Erasure: The right to request deletion of your personal data.",
   ure = "To exercise any of these rights, please contact us at privacy@mysterium.coffee. We will respond to your request within 30 days.",
   cre = "5. Data Security",
   fre = "We implement robust security measures including SSL encryption, secure payment processing, and regular security audits. While we take every precaution to protect your data, no internet transmission is 100% secure. We recommend using strong passwords and keeping your account credentials confidential.",
   hre = "6. Third-Party Services",
   dre = "We work with trusted partners for payment processing and shipping. These partners are contractually obligated to protect your data and use it only for providing their services. We do not share your information with third parties for their marketing purposes.",
   pre = "7. Changes to Our Privacy Policy",
   mre = 'We may update this Privacy Policy to reflect changes in our practices or legal requirements. We will notify you of significant changes via email and update the "Last updated" date. Please review this policy periodically.',
   gre = "8. Contact",
   vre = "If you have any questions about this Privacy Policy, your data, or our charitable giving program, please contact us:",
   yre = "Email: privacy@mysterium.coffee",
   xre = "NEXT COLLECTION",
   _re = "ALL COLLECTIONS",
   Sre = "Collection Details",
   bre = "FEATURED COLLECTIONS",
   Cere = {
      home: {
         title: "MYSTERIUM - Cafea de Lux cu Aur Comestibil i Donaii Progressive",
         description: "Descoper MYSTERIUM: cafea premium infuzat cu aur comestibil de 24k. Fiecare achiziie susine ONG-ul La Fontana Della Fortuna prin programul nostru de cashback progresiv. Lux care ofer napoi."
      },
      projects: {
         title: "MYSTERIUM - Coleciile Noastre de Cafea",
         description: "Exploreaz coleciile noastre exclusive de cafea realizate cu aur comestibil. Fiecare blend susine cauze caritabile prin programul nostru de donaii progresive cu La Fontana Della Fortuna."
      },
      privacy: {
         title: "MYSTERIUM - Politica de Confidenialitate",
         description: "Afl cum MYSTERIUM i protejeaz datele personale i gestioneaz informaiile tale n conformitate cu standardele globale de confidenialitate (GDPR, CCPA)."
      }
   },
   Dere = "POVESTEA NOASTR",
   fxro = "VIDEO",
   Nere = "IMPACT",
   Oere = "CONTACT",
   Uere = "MENIU",
   Pere = "SUNET PORNIT",
   Lere = "SUNET OPRIT",
   Bere = "PRINCIPAL",
   zere = "CAFEA DE LUX<br/>CARE OFER NAPOI.",
   Iere = "DERULEAZ PENTRU A EXPLORA",
   Fere = "CAFEA PREMIUM<br/>CU AUR COMESTIBIL.",
   Here = "FUNDAIA NASA",
   Vere = "La MYSTERIUM, credem c luxul i compasiunea pot coexista. Fiecare ceac din cafeaua noastr premium este infuzat cu aur comestibil de 24k i realizat cu calitate excepional.<br/><br/>Prin parteneriatul nostru cu ONG-ul La Fontana Della Fortuna, fiecare achiziie contribuie la cauze semnificative. Sistemul nostru de cashback progresiv asigur c, cu ct te bucuri mai mult, cu att oferi mai mult napoi comunitilor n nevoie.",
   Gere = "SUSINEREA COMUNITILOR<br/>DIN NTREAGA LUME.",
   kere = "DESCOPER COLECIILE NOASTRE",
   jere = "SISTEM DE CASHBACK<br/>PROGRESIV.",
   qere = "Programul nostru inovator de cashback i rspltete loialitatea n timp ce amplific impactul tu. Cu fiecare achiziie, ctigi recompense progresive care pot fi folosite pentru comenzi viitoare sau donate direct ctre La Fontana Della Fortuna, susinnd educaia, sntatea i dezvoltarea comunitar la nivel global.",
   Xere = "INFUZIE CU AUR<br/>COMESTIBIL 24K.",
   Were = "Fiecare blend este realizat cu grij din boabe Arabica premium i infuzat cu particule de aur comestibil de 24k. Acest proces unic creeaz o experien de cafea luxoas care ncnt simurile, pstrnd n acelai timp aromele bogate i complexe ale boabelor noastre selectate cu expertiz.",
   Yere = "MODEL TRANSPARENT<br/>DE DONAII.",
   Kere = "Credem n transparen complet. Urmrete exact cum achiziiile tale susin iniiativele La Fontana Della Fortuna prin sistemul nostru de donaii verificat blockchain. Fiecare tranzacie este nregistrat, asigurndu-te c contribuia ta ajunge la cei care au cea mai mare nevoie.",
   Zere = "O MARC DE LUX CREAT PENTRU A NCNTA, A INSPIRA I A FACE O DIFEREN DE DURAT N LUME.",
   Qere = "ALTUR-TE MISIUNII NOASTRE.",
   Jere = "Fie c eti interesat de coleciile noastre premium de cafea, oportuniti de parteneriat sau s afli mai multe despre impactul nostru caritabil, ne-ar plcea s auzim de la tine.",
   $ere = "Experimenteaz cafeaua de lux care face diferena.",
   Vene = "TRIMITE",
   Gene = "NAPOI SUS",
   kene = "POLITICA DE CONFIDENIALITATE",
   jene = "MYSTERIUM COFFEE. TOATE DREPTURILE REZERVATE.",
   qene = "Ultima actualizare: 17 iunie 2025.",
   Xene = "La MYSTERIUM, o marc de cafea de lux care susine ONG-ul La Fontana Della Fortuna, apreciem confidenialitatea ta i ne angajm s protejm informaiile personale pe care le mprteti cu noi. Aceast Politic de Confidenialitate descrie cum colectm, folosim i gestionm datele tale personale atunci cnd interacionezi cu site-ul nostru i faci achiziii.",
   Wene = "1. Informaii pe care le colectm",
   Yene = "Cnd foloseti site-ul nostru sau faci o achiziie, ne furnizezi voluntar urmtoarele informaii:",
   Kene = "Nume complet: Pentru a-i personaliza experiena i a procesa comenzile.",
   Zene = "Adres de email: Pentru a trimite confirmri de comand, actualizri i rapoarte de impact caritabil.",
   Qene = "Adres de livrare: Pentru a livra produsele tale premium de cafea.",
   Jene = "Informaii de plat: Procesate securizat prin gateway-uri de plat criptate.",
   $ene = "Colectm doar datele minime necesare pentru tranzacii i urmrirea donaiilor caritabile. Folosim cookie-uri doar pentru funcionaliti eseniale ale site-ului i pentru a mbunti experiena ta de navigare.",
   etne = "2. Cum folosim informaiile colectate",
   ttne = "Informaiile pe care le furnizezi sunt folosite pentru urmtoarele scopuri:",
   ntne = "Procesarea comenzilor: Pentru a procesa achiziiile tale de cafea i a livra produsele la adresa ta.",
   itne = "Urmrirea donaiilor: Pentru a calcula i aloca contribuiile tale de cashback progresiv ctre La Fontana Della Fortuna.",
   stne = "La MYSTERIUM, respectm confidenialitatea ta. Nu vom vinde, nchiria sau mprti niciodat informaiile tale personale cu teri n scopuri de marketing. Datele tale sunt folosite exclusiv pentru procesarea comenzilor i raportarea impactului caritabil.",
   rtne = "3. Stocare i pstrare date",
   atne = "Informaiile tale sunt stocate securizat folosind criptare standard n industrie. Detaliile comenzilor i nregistrrile donaiilor sunt pstrate pentru scopuri fiscale i de transparen conform legilor aplicabile.",
   otne = "Pstrm istoricul achiziiilor tale pentru a-i oferi calcule precise de cashback i rapoarte de impact caritabil. Poi solicita tergerea datelor tale oricnd, sub rezerva cerinelor legale de pstrare pentru tranzacii financiare.",
   ltne = "4. Drepturile tale",
   utne = "n conformitate cu legile internaionale de confidenialitate (GDPR, CCPA), ai urmtoarele drepturi:",
   ctne = "Acces: Dreptul de a ti ce informaii deinem despre tine.",
   ftne = "Rectificare: Dreptul de a corecta orice informaie inexact.",
   htne = "tergere: Dreptul de a solicita tergerea datelor tale personale.",
   dtne = "Pentru a exercita oricare din aceste drepturi, te rugm s ne contactezi la privacy@mysterium.coffee. Vom rspunde solicitrii tale n termen de 30 de zile.",
   ptne = "5. Securitatea datelor",
   mtne = "Implementm msuri de securitate robuste incluznd criptare SSL, procesare securizat a plilor i audituri de securitate regulate. Dei lum toate precauiile pentru a-i proteja datele, nicio transmisie pe internet nu este 100% sigur. Recomandm folosirea parolelor puternice i pstrarea confidenial a credenialelor contului.",
   gtne = "6. Servicii tere",
   vtne = "Lucrm cu parteneri de ncredere pentru procesarea plilor i livrare. Aceti parteneri sunt obligai contractual s-i protejeze datele i s le foloseasc doar pentru furnizarea serviciilor lor. Nu mprtim informaiile tale cu teri pentru scopurile lor de marketing.",
   ytne = "7. Modificri ale Politicii de Confidenialitate",
   xtne = 'Putem actualiza aceast Politic de Confidenialitate pentru a reflecta schimbrile n practicile noastre sau cerinele legale. Te vom notifica despre modificrile semnificative prin email i vom actualiza data "Ultima actualizare". Te rugm s revizuieti periodic aceast politic.',
   _tne = "8. Contact",
   Stne = "Dac ai ntrebri despre aceast Politic de Confidenialitate, datele tale sau programul nostru de donaii caritabile, te rugm s ne contactezi:",
   btne = "Email: privacy@mysterium.coffee",
   Ttne = "URMTOAREA COLECIE",
   Etne = "TOATE COLECIILE",
   Mtne = "Detalii Colecie",
   Atne = "COLECII RECOMANDATE",
   wene = {
      seo: Cere,
      aboutUs: Dere,
      videoBtn: fxro,
      services: Nere,
      contact: Oere,
      menu: Uere,
      soundOn: Pere,
      soundOff: Lere,
      main: Bere,
      mainTitle: zere,
      step1: Iere,
      aboutTitle: Fere,
      founded: Here,
      aboutText: Vere,
      aboutClient: Gere,
      step2: kere,
      servicesTitle1: jere,
      servicesText1: qere,
      servicesTitle2: Xere,
      servicesText2: Were,
      servicesTitle3: Yere,
      servicesText3: Kere,
      footerText: Zere,
      contactTitle: Qere,
      contactText1: Jere,
      contactText2: $ere,
      submit: Vene,
      backTop: Gene,
      privacyPolicy: kene,
      rightsReserved: jene,
      lastUpdated: qene,
      introParagraph: Xene,
      section1Title: Wene,
      section1Paragraph1: Yene,
      section1Bullet1: Kene,
      section1Bullet2: Zene,
      section1Bullet3: Qene,
      section1Bullet4: Jene,
      section1Paragraph2: $ene,
      section2Title: etne,
      section2Paragraph1: ttne,
      section2Bullet1: ntne,
      section2Bullet2: itne,
      section2Paragraph2: stne,
      section3Title: rtne,
      section3Paragraph1: atne,
      section3Paragraph2: otne,
      section4Title: ltne,
      section4Paragraph1: utne,
      section4Bullet1: ctne,
      section4Bullet2: ftne,
      section4Bullet3: htne,
      section4Paragraph2: dtne,
      section5Title: ptne,
      section5Paragraph1: mtne,
      section6Title: gtne,
      section6Paragraph1: vtne,
      section7Title: ytne,
      section7Paragraph1: xtne,
      section8Title: _tne,
      section8Paragraph1: Stne,
      section8Email: btne,
      nextProject: Ttne,
      portfolio: Etne,
      projectDetails: Mtne,
      selectedWork: Atne
   },
   Tre = {
      seo: hse,
      aboutUs: dse,
      videoBtn: fxe,
      services: pse,
      contact: mse,
      menu: gse,
      soundOn: vse,
      soundOff: yse,
      main: xse,
      mainTitle: _se,
      step1: Sse,
      aboutTitle: bse,
      founded: Tse,
      aboutText: Ese,
      aboutClient: Mse,
      step2: Ase,
      servicesTitle1: wse,
      servicesText1: Rse,
      servicesTitle2: Cse,
      servicesText2: Dse,
      servicesTitle3: Nse,
      servicesText3: Ose,
      footerText: Use,
      contactTitle: Pse,
      contactText1: Lse,
      contactText2: Bse,
      submit: zse,
      backTop: Ise,
      privacyPolicy: Fse,
      rightsReserved: Hse,
      lastUpdated: Vse,
      introParagraph: Gse,
      section1Title: kse,
      section1Paragraph1: jse,
      section1Bullet1: qse,
      section1Bullet2: Xse,
      section1Bullet3: Wse,
      section1Bullet4: Yse,
      section1Paragraph2: Kse,
      section2Title: Zse,
      section2Paragraph1: Qse,
      section2Bullet1: Jse,
      section2Bullet2: $se,
      section2Paragraph2: ere,
      section3Title: tre,
      section3Paragraph1: nre,
      section3Paragraph2: ire,
      section4Title: sre,
      section4Paragraph1: rre,
      section4Bullet1: are,
      section4Bullet2: ore,
      section4Bullet3: lre,
      section4Paragraph2: ure,
      section5Title: cre,
      section5Paragraph1: fre,
      section6Title: hre,
      section6Paragraph1: dre,
      section7Title: pre,
      section7Paragraph1: mre,
      section8Title: gre,
      section8Paragraph1: vre,
      section8Email: yre,
      nextProject: xre,
      portfolio: _re,
      projectDetails: Sre,
      selectedWork: bre
   },
   Ere = {
      home: {
         title: "MYSTERIUM - Caf de Lujo con Oro Comestible y Donaciones Progresivas",
         description: "Descubre MYSTERIUM: caf premium infusionado con oro comestible de 24k. Cada compra apoya a la ONG La Fontana Della Fortuna a travs de nuestro programa de cashback progresivo. Lujo que devuelve."
      },
      projects: {
         title: "MYSTERIUM - Nuestras Colecciones de Caf",
         description: "Explora nuestras colecciones exclusivas de caf elaboradas con oro comestible. Cada mezcla apoya causas benficas a travs de nuestro programa de donacin progresiva con La Fontana Della Fortuna."
      },
      privacy: {
         title: "MYSTERIUM - Poltica de Privacidad",
         description: "Conoce cmo MYSTERIUM protege tus datos personales segn los estndares globales de privacidad (GDPR, CCPA)."
      }
   },
   Mre = "NUESTRA HISTORIA",
   fxes = "VIDEO",
   Are = "IMPACTO",
   wre = "CONTACTO",
   Rre = "MEN",
   Cre = "SONIDO ACTIVADO",
   Dre = "SONIDO DESACTIVADO",
   Nre = "INICIO",
   Ore = "CAF DE LUJO<br/>QUE DEVUELVE.",
   Ure = "SCROLL PARA EXPLORAR",
   Pre = "CAF PREMIUM<br/>CON ORO COMESTIBLE.",
   Lre = "APOYANDO COMUNIDADES<br/>EN TODO EL MUNDO.",
   Bre = "En MYSTERIUM, creemos que el lujo y la compasin pueden coexistir. Cada taza de nuestro caf premium est infusionada con oro comestible de 24k y elaborada con calidad excepcional.<br/><br/>A travs de nuestra asociacin con la ONG La Fontana Della Fortuna, cada compra contribuye a causas significativas. Nuestro sistema de cashback progresivo asegura que mientras ms disfrutas, ms devuelves a comunidades necesitadas.",
   zre = "APOYANDO COMUNIDADES<br/>EN TODO EL MUNDO.",
   Ire = "DESCUBRE NUESTRAS COLECCIONES",
   Fre = "SISTEMA DE CASHBACK<br/>PROGRESIVO.",
   Hre = "Nuestro innovador programa de cashback recompensa tu lealtad mientras amplifica tu impacto. Con cada compra, ganas recompensas progresivas que puedes usar en futuros pedidos o donar directamente a La Fontana Della Fortuna, apoyando educacin, salud y desarrollo comunitario mundial.",
   Vre = "INFUSIN CON<br/>ORO COMESTIBLE 24K.",
   Gre = "Cada mezcla est cuidadosamente elaborada con granos Arbica premium e infusionada con partculas de oro comestible de 24k. Este proceso nico crea una experiencia de caf lujosa que deleita los sentidos mientras mantiene los ricos y complejos sabores de nuestros granos expertamente seleccionados.",
   kre = "MODELO DE DONACIN<br/>TRANSPARENTE.",
   jre = "Creemos en la transparencia total. Rastrea exactamente cmo tus compras apoyan las iniciativas de La Fontana Della Fortuna a travs de nuestro sistema de donacin verificado por blockchain. Cada transaccin se registra, asegurando que tu contribucin llegue a quienes ms lo necesitan.",
   qre = "UNA MARCA DE LUJO CREADA PARA DELEITAR, INSPIRAR Y HACER UNA DIFERENCIA DURADERA EN EL MUNDO.",
   Xre = "NETE A NUESTRA MISIN.",
   Wre = "Si ests interesado en nuestras colecciones de caf premium, oportunidades de asociacin, o aprender ms sobre nuestro impacto benfico, nos encantara saber de ti.",
   Yre = "Experimenta caf de lujo que hace la diferencia.",
   Kre = "ENVIAR",
   Zre = "VOLVER ARRIBA",
   Qre = "POLTICA DE PRIVACIDAD",
   Jre = "MYSTERIUM COFFEE. TODOS LOS DERECHOS RESERVADOS.",
   $re = "ltima actualizacin: 17 de junio de 2025.",
   eae = "En MYSTERIUM, una marca de caf de lujo que apoya a la ONG La Fontana Della Fortuna, valoramos tu privacidad y estamos comprometidos con la proteccin de la informacin personal que compartes con nosotros. Esta Poltica de Privacidad describe cmo recopilamos, usamos y gestionamos tus datos personales cuando interactas con nuestro sitio web y realizas compras.",
   tae = "1. Informacin que recopilamos",
   nae = "Cuando usas nuestro sitio web o realizas una compra, nos proporcionas voluntariamente la siguiente informacin:",
   iae = "Nombre completo: Para personalizar tu experiencia y procesar pedidos.",
   sae = "Correo electrnico: Para enviar confirmaciones de pedido, actualizaciones y reportes de impacto benfico.",
   rae = "Direccin de envo: Para entregar tus productos de caf premium.",
   aae = "Informacin de pago: Procesada de forma segura a travs de pasarelas de pago encriptadas.",
   oae = "Recopilamos los datos mnimos necesarios para transacciones y seguimiento de donaciones benficas. Usamos cookies solo para funcionalidades esenciales del sitio web y para mejorar tu experiencia de navegacin.",
   lae = "2. Cmo usamos la informacin recopilada",
   uae = "La informacin que proporcionas se utiliza para los siguientes fines:",
   cae = "Procesamiento de pedidos: Para procesar tus compras de caf y entregar productos a tu direccin.",
   fae = "Seguimiento de donaciones: Para calcular y asignar tus contribuciones de cashback progresivo a La Fontana Della Fortuna.",
   hae = "En MYSTERIUM respetamos tu privacidad. Nunca venderemos, alquilaremos ni compartiremos tu informacin personal con terceros con fines de marketing. Tus datos se utilizan nicamente para el procesamiento de pedidos y reportes de impacto benfico.",
   dae = "3. Almacenamiento y retencin de datos",
   pae = "Tu informacin se almacena de forma segura utilizando encriptacin estndar de la industria. Los detalles de pedidos y registros de donaciones se mantienen para fines fiscales y de transparencia de acuerdo con las leyes aplicables.",
   mae = "Conservamos tu historial de compras para proporcionarte clculos precisos de cashback y reportes de impacto benfico. Puedes solicitar la eliminacin de tus datos en cualquier momento, sujeto a requisitos legales de retencin para transacciones financieras.",
   gae = "4. Tus derechos",
   vae = "De acuerdo con las leyes internacionales de privacidad (GDPR, CCPA), tienes los siguientes derechos:",
   yae = "Acceso: El derecho a saber qu informacin tenemos sobre ti.",
   xae = "Rectificacin: El derecho a corregir cualquier informacin inexacta.",
   _ae = "Supresin: El derecho a solicitar la eliminacin de tus datos personales.",
   Sae = "Para ejercer cualquiera de estos derechos, por favor contctanos en privacy@mysterium.coffee. Responderemos a tu solicitud dentro de 30 das.",
   bae = "5. Seguridad de los datos",
   Tae = "Implementamos medidas de seguridad robustas incluyendo encriptacin SSL, procesamiento seguro de pagos y auditoras de seguridad regulares. Aunque tomamos todas las precauciones para proteger tus datos, ninguna transmisin por internet es 100% segura. Recomendamos usar contraseas fuertes y mantener tus credenciales confidenciales.",
   Eae = "6. Servicios de terceros",
   Mae = "Trabajamos con socios de confianza para procesamiento de pagos y envos. Estos socios estn contractualmente obligados a proteger tus datos y usarlos solo para proporcionar sus servicios. No compartimos tu informacin con terceros para sus propsitos de marketing.",
   Aae = "7. Cambios en nuestra Poltica de Privacidad",
   wae = 'Podemos actualizar esta Poltica de Privacidad para reflejar cambios en nuestras prcticas o requisitos legales. Te notificaremos de cambios significativos por correo electrnico y actualizaremos la "ltima actualizacin". Por favor revisa esta poltica peridicamente.',
   Rae = "8. Contacto",
   Cae = "Si tienes alguna pregunta sobre esta Poltica de Privacidad, tus datos o nuestro programa de donaciones benficas, por favor contctanos:",
   Dae = "Correo electrnico: privacy@mysterium.coffee",
   Nae = "SIGUIENTE COLECCIN",
   Oae = "TODAS LAS COLECCIONES",
   Uae = "Detalles de la Coleccin",
   Pae = "COLECCIONES DESTACADAS",
   Lae = {
      seo: Ere,
      aboutUs: Mre,
      videoBtn: fxes,
      services: Are,
      contact: wre,
      menu: Rre,
      soundOn: Cre,
      soundOff: Dre,
      main: Nre,
      mainTitle: Ore,
      step1: Ure,
      aboutTitle: Pre,
      founded: Lre,
      aboutText: Bre,
      aboutClient: zre,
      step2: Ire,
      servicesTitle1: Fre,
      servicesText1: Hre,
      servicesTitle2: Vre,
      servicesText2: Gre,
      servicesTitle3: kre,
      servicesText3: jre,
      footerText: qre,
      contactTitle: Xre,
      contactText1: Wre,
      contactText2: Yre,
      submit: Kre,
      backTop: Zre,
      privacyPolicy: Qre,
      rightsReserved: Jre,
      lastUpdated: $re,
      introParagraph: eae,
      section1Title: tae,
      section1Paragraph1: nae,
      section1Bullet1: iae,
      section1Bullet2: sae,
      section1Bullet3: rae,
      section1Bullet4: aae,
      section1Paragraph2: oae,
      section2Title: lae,
      section2Paragraph1: uae,
      section2Bullet1: cae,
      section2Bullet2: fae,
      section2Paragraph2: hae,
      section3Title: dae,
      section3Paragraph1: pae,
      section3Paragraph2: mae,
      section4Title: gae,
      section4Paragraph1: vae,
      section4Bullet1: yae,
      section4Bullet2: xae,
      section4Bullet3: _ae,
      section4Paragraph2: Sae,
      section5Title: bae,
      section5Paragraph1: Tae,
      section6Title: Eae,
      section6Paragraph1: Mae,
      section7Title: Aae,
      section7Paragraph1: wae,
      section8Title: Rae,
      section8Paragraph1: Cae,
      section8Email: Dae,
      nextProject: Nae,
      portfolio: Oae,
      projectDetails: Uae,
      selectedWork: Pae
   },
   Bae = {
      home: {
         title: "MYSTERIUM - Caf de Luxe avec Or Comestible et Dons Progressifs",
         description: "Dcouvrez MYSTERIUM : caf premium infus avec de l'or comestible 24 carats. Chaque achat soutient l'ONG La Fontana Della Fortuna grce  notre programme de cashback progressif. Le luxe qui redonne."
      },
      projects: {
         title: "MYSTERIUM - Nos Collections de Caf",
         description: "Explorez nos collections exclusives de caf labores avec de l'or comestible. Chaque mlange soutient des causes caritatives grce  notre programme de don progressif avec La Fontana Della Fortuna."
      },
      privacy: {
         title: "MYSTERIUM - Politique de Confidentialit",
         description: "Dcouvrez comment MYSTERIUM protge vos donnes personnelles conformment aux normes mondiales de confidentialit (RGPD, CCPA)."
      }
   },
   zae = "NOTRE HISTOIRE",
   fxfr = "VIDO",
   Iae = "IMPACT",
   Fae = "CONTACT",
   Hae = "MENU",
   Vae = "SON ACTIV",
   Gae = "SON DSACTIV",
   kae = "ACCUEIL",
   jae = "CAF DE LUXE<br/>QUI REDONNE.",
   qae = "FAITES DFILER POUR EXPLORER",
   Xae = "CAF PREMIUM<br/>AVEC OR COMESTIBLE.",
   Wae = "SOUTIEN AUX COMMUNAUTS<br/> TRAVERS LE MONDE.",
   Yae = "Chez MYSTERIUM, nous croyons que le luxe et la compassion peuvent coexister. Chaque tasse de notre caf premium est infuse avec de l'or comestible 24 carats et labore avec une qualit exceptionnelle.<br/><br/>Grce  notre partenariat avec l'ONG La Fontana Della Fortuna, chaque achat contribue  des causes significatives. Notre systme de cashback progressif garantit que plus vous apprciez, plus vous redonnez aux communauts dans le besoin.",
   Kae = "SOUTIEN AUX COMMUNAUTS<br/> TRAVERS LE MONDE.",
   Zae = "DCOUVREZ NOS COLLECTIONS",
   Qae = "SYSTME DE CASHBACK<br/>PROGRESSIF.",
   Jae = "Notre programme innovant de cashback rcompense votre fidlit tout en amplifiant votre impact.  chaque achat, gagnez des rcompenses progressives utilisables pour vos futures commandes ou  donner directement  La Fontana Della Fortuna, soutenant l'ducation, la sant et le dveloppement communautaire mondial.",
   $ae = "INFUSION D'OR<br/>COMESTIBLE 24 CARATS.",
   eoe = "Chaque mlange est soigneusement labor avec des grains Arabica premium et infus avec des particules d'or comestible 24 carats. Ce processus unique cre une exprience caf luxueuse qui ravit les sens tout en prservant les saveurs riches et complexes de nos grains expertement slectionns.",
   toe = "MODLE DE DON<br/>TRANSPARENT.",
   noe = "Nous croyons en la transparence totale. Suivez exactement comment vos achats soutiennent les initiatives de La Fontana Della Fortuna grce  notre systme de don vrifi par blockchain. Chaque transaction est enregistre, garantissant que votre contribution atteint ceux qui en ont le plus besoin.",
   ioe = "UNE MARQUE DE LUXE CRE POUR RAVIR, INSPIRER ET FAIRE UNE DIFFRENCE DURABLE DANS LE MONDE.",
   soe = "REJOIGNEZ NOTRE MISSION.",
   roe = "Que vous soyez intress par nos collections de caf premium, des opportunits de partenariat, ou en apprendre davantage sur notre impact caritatif, nous serions ravis de vous entendre.",
   aoe = "Dcouvrez un caf de luxe qui fait la diffrence.",
   ooe = "ENVOYER",
   loe = "RETOUR EN HAUT",
   uoe = "POLITIQUE DE CONFIDENTIALIT",
   coe = "MYSTERIUM COFFEE. TOUS DROITS RSERVS.",
   foe = "Dernire mise  jour : 17 juin 2025.",
   hoe = "Chez MYSTERIUM, une marque de caf de luxe soutenant l'ONG La Fontana Della Fortuna, nous valorisons votre vie prive et nous nous engageons  protger les informations personnelles que vous partagez avec nous. Cette Politique de Confidentialit dcrit comment nous collectons, utilisons et grons vos donnes personnelles lorsque vous interagissez avec notre site web et effectuez des achats.",
   doe = "1. Informations que nous collectons",
   poe = "Lorsque vous utilisez notre site web ou effectuez un achat, vous nous fournissez volontairement les informations suivantes :",
   moe = "Nom complet : Pour personnaliser votre exprience et traiter les commandes.",
   goe = "Adresse e-mail : Pour envoyer les confirmations de commande, les mises  jour et les rapports d'impact caritatif.",
   voe = "Adresse de livraison : Pour livrer vos produits de caf premium.",
   yoe = "Informations de paiement : Traites en toute scurit via des passerelles de paiement cryptes.",
   xoe = "Nous collectons le minimum de donnes ncessaires pour les transactions et le suivi des dons caritatifs. Nous utilisons des cookies uniquement pour les fonctionnalits essentielles du site et pour amliorer votre exprience de navigation.",
   _oe = "2. Comment nous utilisons les informations collectes",
   Soe = "Les informations que vous fournissez sont utilises aux fins suivantes :",
   boe = "Traitement des commandes : Pour traiter vos achats de caf et livrer les produits  votre adresse.",
   Toe = "Suivi des dons : Pour calculer et allouer vos contributions de cashback progressif  l'ONG La Fontana Della Fortuna.",
   Eoe = "Chez MYSTERIUM, nous respectons votre vie prive. Nous ne vendrons, ne louerons ni ne partagerons jamais vos informations personnelles avec des tiers  des fins de marketing. Vos donnes sont utilises uniquement pour le traitement des commandes et les rapports d'impact caritatif.",
   Moe = "3. Stockage et conservation des donnes",
   Aoe = "Vos informations sont stockes en toute scurit grce au cryptage standard de l'industrie. Les dtails des commandes et les dossiers de dons sont conservs  des fins fiscales et de transparence conformment aux lois applicables.",
   woe = "Nous conservons votre historique d'achats pour vous fournir des calculs prcis de cashback et des rapports d'impact caritatif. Vous pouvez demander la suppression de vos donnes  tout moment, sous rserve des exigences lgales de conservation pour les transactions financires.",
   Roe = "4. Vos droits",
   Coe = "Conformment aux lois internationales sur la protection de la vie prive (RGPD, CCPA), vous disposez des droits suivants :",
   Doe = "Accs : Le droit de savoir quelles informations nous dtenons sur vous.",
   Noe = "Rectification : Le droit de corriger toute information inexacte.",
   Ooe = "Suppression : Le droit de demander la suppression de vos donnes personnelles.",
   Uoe = "Pour exercer l'un de ces droits, veuillez nous contacter  privacy@mysterium.coffee. Nous rpondrons  votre demande dans les 30 jours.",
   Poe = "5. Scurit des donnes",
   Loe = "Nous mettons en uvre des mesures de scurit robustes incluant le cryptage SSL, le traitement scuris des paiements et des audits de scurit rguliers. Bien que nous prenions toutes les prcautions pour protger vos donnes, aucune transmission sur Internet n'est scurise  100%. Nous vous recommandons d'utiliser des mots de passe forts et de garder vos identifiants confidentiels.",
   Boe = "6. Services tiers",
   zoe = "Nous travaillons avec des partenaires de confiance pour le traitement des paiements et la livraison. Ces partenaires sont contractuellement tenus de protger vos donnes et de les utiliser uniquement pour fournir leurs services. Nous ne partageons pas vos informations avec des tiers  des fins de marketing.",
   Ioe = "7. Modifications de notre Politique de Confidentialit",
   Foe = 'Nous pouvons mettre  jour cette Politique de Confidentialit pour reflter les changements dans nos pratiques ou les exigences lgales. Nous vous informerons des changements importants par e-mail et mettrons  jour la "Dernire mise  jour". Veuillez consulter cette politique priodiquement.',
   Hoe = "8. Contact",
   Voe = "Si vous avez des questions concernant cette Politique de Confidentialit, vos donnes ou notre programme de dons caritatifs, veuillez nous contacter :",
   Goe = "Adresse e-mail : privacy@mysterium.coffee",
   koe = "COLLECTION SUIVANTE",
   joe = "TOUTES LES COLLECTIONS",
   qoe = "Dtails de la Collection",
   Xoe = "COLLECTIONS EN VEDETTE",
   Woe = {
      seo: Bae,
      aboutUs: zae,
      videoBtn: fxfr,
      services: Iae,
      contact: Fae,
      menu: Hae,
      soundOn: Vae,
      soundOff: Gae,
      main: kae,
      mainTitle: jae,
      step1: qae,
      aboutTitle: Xae,
      founded: Wae,
      aboutText: Yae,
      aboutClient: Kae,
      step2: Zae,
      servicesTitle1: Qae,
      servicesText1: Jae,
      servicesTitle2: $ae,
      servicesText2: eoe,
      servicesTitle3: toe,
      servicesText3: noe,
      footerText: ioe,
      contactTitle: soe,
      contactText1: roe,
      contactText2: aoe,
      submit: ooe,
      backTop: loe,
      privacyPolicy: uoe,
      rightsReserved: coe,
      lastUpdated: foe,
      introParagraph: hoe,
      section1Title: doe,
      section1Paragraph1: poe,
      section1Bullet1: moe,
      section1Bullet2: goe,
      section1Bullet3: voe,
      section1Bullet4: yoe,
      section1Paragraph2: xoe,
      section2Title: _oe,
      section2Paragraph1: Soe,
      section2Bullet1: boe,
      section2Bullet2: Toe,
      section2Paragraph2: Eoe,
      section3Title: Moe,
      section3Paragraph1: Aoe,
      section3Paragraph2: woe,
      section4Title: Roe,
      section4Paragraph1: Coe,
      section4Bullet1: Doe,
      section4Bullet2: Noe,
      section4Bullet3: Ooe,
      section4Paragraph2: Uoe,
      section5Title: Poe,
      section5Paragraph1: Loe,
      section6Title: Boe,
      section6Paragraph1: zoe,
      section7Title: Ioe,
      section7Paragraph1: Foe,
      section8Title: Hoe,
      section8Paragraph1: Voe,
      section8Email: Goe,
      nextProject: koe,
      portfolio: joe,
      projectDetails: qoe,
      selectedWork: Xoe
   },
   Yoe = {
      home: {
         title: "MYSTERIUM - Luxuskaffee mit essbarem Gold und progressiven Spenden",
         description: "Entdecken Sie MYSTERIUM: Premium-Kaffee mit 24-kartigem essbarem Gold. Jeder Kauf untersttzt die NGO La Fontana Della Fortuna durch unser progressives Cashback-Programm. Luxus, der zurckgibt."
      },
      projects: {
         title: "MYSTERIUM - Unsere Kaffeekollektionen",
         description: "Entdecken Sie unsere exklusiven Kaffeekollektionen mit essbarem Gold. Jede Mischung untersttzt wohlttige Zwecke durch unser progressives Spendenprogramm mit La Fontana Della Fortuna."
      },
      privacy: {
         title: "MYSTERIUM - Datenschutzrichtlinie",
         description: "Erfahren Sie, wie MYSTERIUM Ihre personenbezogenen Daten gem den globalen Datenschutzstandards (DSGVO, CCPA) schtzt."
      }
   },
   Koe = "UNSERE GESCHICHTE",
   fxde = "VIDEO",
   Zoe = "IMPACT",
   Qoe = "KONTAKT",
   Joe = "MEN",
   $oe = "TON EIN",
   ele = "TON AUS",
   tle = "STARTSEITE",
   nele = "LUXUSKAFFEE<br/>DER ZURCKGIBT.",
   ile = "SCROLLEN, UM ZU ENTDECKEN",
   sle = "PREMIUM-KAFFEE<br/>MIT ESSBAREM GOLD.",
   rle = "UNTERSTTZUNG VON GEMEINSCHAFTEN<br/>AUF DER GANZEN WELT.",
   ale = "Bei MYSTERIUM glauben wir, dass Luxus und Mitgefhl koexistieren knnen. Jede Tasse unseres Premium-Kaffees ist mit 24-kartigem essbarem Gold veredelt und mit auergewhnlicher Qualitt hergestellt.<br/><br/>Durch unsere Partnerschaft mit der NGO La Fontana Della Fortuna trgt jeder Kauf zu bedeutungsvollen Zwecken bei. Unser progressives Cashback-System stellt sicher, dass Sie umso mehr zurckgeben, je mehr Sie genieen  an bedrftige Gemeinschaften.",
   ole = "UNTERSTTZUNG VON GEMEINSCHAFTEN<br/>AUF DER GANZEN WELT.",
   lle = "ENTDECKEN SIE UNSERE KOLLEKTIONEN",
   ule = "PROGRESSIVES<br/>CASHBACK-SYSTEM.",
   cle = "Unser innovatives Cashback-Programm belohnt Ihre Treue und verstrkt Ihre Wirkung. Mit jedem Kauf verdienen Sie progressive Prmien, die Sie fr zuknftige Bestellungen verwenden oder direkt an La Fontana Della Fortuna spenden knnen  zur Untersttzung von Bildung, Gesundheit und Gemeindeentwicklung weltweit.",
   fle = "24-KARTIGES<br/>ESSBARES GOLD.",
   hle = "Jede Mischung wird sorgfltig mit Premium-Arabica-Bohnen hergestellt und mit 24-kartigem essbarem Gold veredelt. Dieser einzigartige Prozess schafft ein luxurises Kaffeeerlebnis, das die Sinne erfreut und gleichzeitig die reichen, komplexen Aromen unserer fachmnnisch ausgewhlten Bohnen bewahrt.",
   dle = "TRANSPARENTES<br/>SPENDENMODELL.",
   nle = "Wir glauben an vollstndige Transparenz. Verfolgen Sie genau, wie Ihre Einkufe die Initiativen von La Fontana Della Fortuna durch unser blockchain-verifiziertes Spendensystem untersttzen. Jede Transaktion wird aufgezeichnet und stellt sicher, dass Ihr Beitrag diejenigen erreicht, die ihn am meisten brauchen.",
   mle = "EINE LUXUSMARKE, GESCHAFFEN UM ZU ERFREUEN, ZU INSPIRIEREN UND EINEN BLEIBENDEN UNTERSCHIED IN DER WELT ZU MACHEN.",
   gle = "SCHLIESSEN SIE SICH UNSERER MISSION AN.",
   vle = "Ob Sie sich fr unsere Premium-Kaffeekollektionen interessieren, Partnerschaftsmglichkeiten suchen oder mehr ber unsere wohlttige Wirkung erfahren mchten  wir wrden uns freuen, von Ihnen zu hren.",
   yle = "Erleben Sie Luxuskaffee, der einen Unterschied macht.",
   xle = "ABSENDEN",
   _le = "ZURCK NACH OBEN",
   Sle = "DATENSCHUTZERKLRUNG",
   ble = "MYSTERIUM COFFEE. ALLE RECHTE VORBEHALTEN.",
   Tle = "Letzte Aktualisierung: 17. Juni 2025.",
   Ele = "Bei MYSTERIUM, einer Luxus-Kaffeemarke, die die NGO La Fontana Della Fortuna untersttzt, legen wir groen Wert auf Ihre Privatsphre und verpflichten uns, Ihre persnlichen Daten zu schtzen. Diese Datenschutzrichtlinie beschreibt, wie wir Ihre personenbezogenen Daten erfassen, verwenden und verarbeiten, wenn Sie mit unserer Website interagieren und Kufe ttigen.",
   Mle = "1. Welche Informationen wir erfassen",
   Ale = "Wenn Sie unsere Website nutzen oder einen Kauf ttigen, stellen Sie uns freiwillig die folgenden Informationen zur Verfgung:",
   wle = "Vollstndiger Name: Um Ihr Erlebnis zu personalisieren und Bestellungen zu bearbeiten.",
   Rle = "E-Mail-Adresse: Um Bestellbesttigungen, Updates und Berichte ber wohlttige Wirkung zu senden.",
   Cle = "Lieferadresse: Um Ihre Premium-Kaffeeprodukte zu liefern.",
   Dle = "Zahlungsinformationen: Sicher verarbeitet durch verschlsselte Zahlungsgateways.",
   Nle = "Wir erfassen nur die minimal notwendigen Daten fr Transaktionen und die Verfolgung wohlttiger Spenden. Wir verwenden Cookies nur fr wesentliche Website-Funktionen und zur Verbesserung Ihres Surferlebnisses.",
   Ole = "2. Wie wir die erfassten Informationen verwenden",
   Ule = "Die von Ihnen bereitgestellten Informationen werden fr folgende Zwecke verwendet:",
   Ple = "Auftragsbearbeitung: Um Ihre Kaffeekufe zu verarbeiten und Produkte an Ihre Adresse zu liefern.",
   Lle = "Spendenverfolgung: Um Ihre progressiven Cashback-Beitrge an La Fontana Della Fortuna zu berechnen und zuzuweisen.",
   Ble = "Bei MYSTERIUM respektieren wir Ihre Privatsphre. Wir werden Ihre persnlichen Daten niemals zu Marketingzwecken an Dritte verkaufen, vermieten oder weitergeben. Ihre Daten werden ausschlielich fr die Auftragsabwicklung und Berichte ber wohlttige Wirkung verwendet.",
   zle = "3. Speicherung und Aufbewahrung von Daten",
   Ile = "Wenn Sie uns ber das Kontaktformular eine Nachricht senden, wird diese Information direkt per NodeMailer an unser E-Mail-Postfach bermittelt. Wir speichern diese Information nicht in der Datenbank unserer Website oder in CRM-Systemen.",
   Fle = "Wir bewahren Ihre Anfrage nur so lange auf, wie es unbedingt erforderlich ist, um Ihre Mitteilung zu bearbeiten und zu beantworten, sowie fr jede direkte Folgekommunikation. Sobald der Kontakt abgeschlossen ist und kein legitimer Grund mehr besteht, die Nachricht aufzubewahren (z.B. die Anfrage wurde vollstndig beantwortet und es besteht kein laufendes Projekt), wird sie aus unserem Posteingang gelscht.",
   Hle = "4. Ihre Rechte",
   Vle = "Gem den internationalen Datenschutzgesetzen (DSGVO, CCPA) haben Sie folgende Rechte:",
   Gle = "Auskunft: Das Recht zu erfahren, welche Informationen wir ber Sie speichern.",
   kle = "Berichtigung: Das Recht, unrichtige Informationen zu korrigieren.",
   jle = "Lschung: Das Recht, die Lschung Ihrer personenbezogenen Daten zu verlangen.",
   qle = "Um eines dieser Rechte auszuben, kontaktieren Sie uns bitte unter privacy@mysterium.coffee. Wir werden Ihre Anfrage innerhalb von 30 Tagen beantworten.",
   Xle = "5. Datensicherheit",
   Wle = "Wir implementieren robuste Sicherheitsmanahmen einschlielich SSL-Verschlsselung, sicherer Zahlungsabwicklung und regelmiger Sicherheitsaudits. Obwohl wir alle Vorsichtsmanahmen zum Schutz Ihrer Daten treffen, kann keine Internetbertragung zu 100% sicher sein. Wir empfehlen die Verwendung starker Passwrter und die Geheimhaltung Ihrer Zugangsdaten.",
   Yle = "6. Drittanbieter-Dienste",
   Kle = "Wir arbeiten mit vertrauenswrdigen Partnern fr Zahlungsabwicklung und Versand zusammen. Diese Partner sind vertraglich verpflichtet, Ihre Daten zu schtzen und nur zur Erbringung ihrer Dienste zu verwenden. Wir geben Ihre Informationen nicht zu Marketingzwecken an Dritte weiter.",
   Zle = "7. nderungen an unserer Datenschutzrichtlinie",
   Qle = "Wir knnen diese Datenschutzrichtlinie aktualisieren, um nderungen in unseren Praktiken oder gesetzlichen Anforderungen widerzuspiegeln. Wir werden Sie ber wesentliche nderungen per E-Mail informieren und das Datum der Letzten Aktualisierung\" aktualisieren. Bitte berprfen Sie diese Richtlinie regelmig.",
   Jle = "8. Kontakt",
   $le = "Wenn Sie Fragen zu dieser Datenschutzrichtlinie, Ihren Daten oder unserem wohlttigen Spendenprogramm haben, kontaktieren Sie uns bitte:",
   eue = "E-Mail: privacy@mysterium.coffee",
   tue = "NCHSTE KOLLEKTION",
   nue = "ALLE KOLLEKTIONEN",
   iue = "Kollektionsdetails",
   sue = "AUSGEWHLTE KOLLEKTIONEN",
   rue = {
      seo: Yoe,
      aboutUs: Koe,
      videoBtn: fxde,
      services: Zoe,
      contact: Qoe,
      menu: Joe,
      soundOn: $oe,
      soundOff: ele,
      main: tle,
      mainTitle: nle,
      step1: ile,
      aboutTitle: sle,
      founded: rle,
      aboutText: ale,
      aboutClient: ole,
      step2: lle,
      servicesTitle1: ule,
      servicesText1: cle,
      servicesTitle2: fle,
      servicesText2: hle,
      servicesTitle3: dle,
      servicesText3: Ple,
      footerText: mle,
      contactTitle: gle,
      contactText1: vle,
      contactText2: yle,
      submit: xle,
      backTop: _le,
      privacyPolicy: Sle,
      rightsReserved: ble,
      lastUpdated: Tle,
      introParagraph: Ele,
      section1Title: Mle,
      section1Paragraph1: Ale,
      section1Bullet1: wle,
      section1Bullet2: Rle,
      section1Bullet3: Cle,
      section1Bullet4: Dle,
      section1Paragraph2: Nle,
      section2Title: Ole,
      section2Paragraph1: Ule,
      section2Bullet1: Ple,
      section2Bullet2: Lle,
      section2Paragraph2: Ble,
      section3Title: zle,
      section3Paragraph1: Ile,
      section3Paragraph2: Fle,
      section4Title: Hle,
      section4Paragraph1: Vle,
      section4Bullet1: Gle,
      section4Bullet2: kle,
      section4Bullet3: jle,
      section4Paragraph2: qle,
      section5Title: Xle,
      section5Paragraph1: Wle,
      section6Title: Yle,
      section6Paragraph1: Kle,
      section7Title: Zle,
      section7Paragraph1: Qle,
      section8Title: Jle,
      section8Paragraph1: $le,
      section8Email: eue,
      nextProject: tue,
      portfolio: nue,
      projectDetails: iue,
      selectedWork: sue
   },
   Kue = {
      home: {
         title: "MYSTERIUM - Caff di Lusso con Oro Commestibile e Donazioni Progressive",
         description: "Scopri MYSTERIUM: caff premium infuso con oro commestibile 24k. Ogni acquisto sostiene l'ONG La Fontana Della Fortuna attraverso il nostro programma di cashback progressivo. Lusso che restituisce."
      },
      projects: {
         title: "MYSTERIUM - Le Nostre Collezioni di Caff",
         description: "Esplora le nostre collezioni esclusive di caff realizzate con oro commestibile. Ogni miscela sostiene cause benefiche attraverso il nostro programma di donazione progressiva con La Fontana Della Fortuna."
      },
      privacy: {
         title: "MYSTERIUM - Informativa sulla Privacy",
         description: "Scopri come MYSTERIUM protegge i tuoi dati personali in conformit con gli standard globali sulla privacy (GDPR, CCPA)."
      }
   },
   Zue = "LA NOSTRA STORIA",
   fxit = "VIDEO",
   Que = "IMPATTO",
   Jue = "CONTATTO",
   $ue = "MENU",
   eve = "AUDIO ATTIVO",
   tve = "AUDIO DISATTIVATO",
   nve = "PRINCIPALE",
   ive = "CAFF DI LUSSO<br/>CHE RESTITUISCE.",
   sve = "SCORRI PER ESPLORARE",
   rve = "CAFF PREMIUM<br/>CON ORO COMMESTIBILE.",
   ave = "IMMAGINE DI SFONDO<br/>DELLA NASA",
   ove = "In MYSTERIUM, crediamo che lusso e compassione possano coesistere. Ogni tazza del nostro caff premium  infusa con oro commestibile 24k e realizzata con qualit eccezionale.<br/><br/>Attraverso la nostra partnership con l'ONG La Fontana Della Fortuna, ogni acquisto contribuisce a cause significative. Il nostro sistema di cashback progressivo garantisce che pi ti godi il caff, pi restituisci alle comunit bisognose.",
   lve = "SOSTENERE LE COMUNIT<br/>IN TUTTO IL MONDO.",
   uve = "SCOPRI LE NOSTRE COLLEZIONI",
   cve = "SISTEMA DI CASHBACK<br/>PROGRESSIVO.",
   fve = "Il nostro innovativo programma di cashback premia la tua fedelt amplificando il tuo impatto. Con ogni acquisto, guadagni premi progressivi che possono essere utilizzati per ordini futuri o donati direttamente a La Fontana Della Fortuna, sostenendo istruzione, assistenza sanitaria e sviluppo comunitario in tutto il mondo.",
   hve = "INFUSIONE DI ORO<br/>COMMESTIBILE 24K.",
   dve = "Ogni miscela  accuratamente realizzata con chicchi Arabica premium e infusa con particelle d'oro commestibile 24k. Questo processo unico crea un'esperienza di caff lussuosa che delizia i sensi mantenendo i sapori ricchi e complessi dei nostri chicchi selezionati con esperienza.",
   pve = "MODELLO DI DONAZIONE<br/>TRASPARENTE.",
   mve = "Crediamo nella completa trasparenza. Traccia esattamente come i tuoi acquisti sostengono le iniziative di La Fontana Della Fortuna attraverso il nostro sistema di donazione verificato blockchain. Ogni transazione  registrata, garantendo che il tuo contributo raggiunga coloro che ne hanno pi bisogno.",
   gve = "UN MARCHIO DI LUSSO CREATO PER DELIZIARE, ISPIRARE E FARE UNA DIFFERENZA DURATURA NEL MONDO.",
   vve = "UNISCITI ALLA NOSTRA MISSIONE.",
   yve = "Che tu sia interessato alle nostre collezioni di caff premium, opportunit di partnership o per saperne di pi sul nostro impatto benefico, ci piacerebbe sentirti.",
   xve = "Vivi il caff di lusso che fa la differenza.",
   _ve = "INVIA",
   Sve = "TORNA SU",
   bve = "INFORMATIVA SULLA PRIVACY",
   Tve = "MYSTERIUM COFFEE. TUTTI I DIRITTI RISERVATI.",
   Eve = "Ultimo aggiornamento: 17 giugno 2025.",
   Mve = "In MYSTERIUM, un marchio di caff di lusso che sostiene l'ONG La Fontana Della Fortuna, apprezziamo la tua privacy e ci impegniamo a proteggere le informazioni personali che condividi con noi. Questa Informativa sulla Privacy descrive come raccogliamo, utilizziamo e gestiamo i tuoi dati personali quando interagisci con il nostro sito web e effettui acquisti.",
   Ave = "1. Informazioni che Raccogliamo",
   wve = "Quando utilizzi il nostro sito web o effettui un acquisto, ci fornisci volontariamente le seguenti informazioni:",
   Rve = "Nome Completo: Per personalizzare la tua esperienza e processare gli ordini.",
   Cve = "Indirizzo Email: Per inviare conferme d'ordine, aggiornamenti e report sull'impatto benefico.",
   Dve = "Indirizzo di Spedizione: Per consegnare i tuoi prodotti di caff premium.",
   Nve = "Informazioni di Pagamento: Elaborate in modo sicuro attraverso gateway di pagamento crittografati.",
   Ove = "Raccogliamo solo i dati minimi necessari per le transazioni e il monitoraggio delle donazioni benefiche. Utilizziamo i cookie solo per funzionalit essenziali del sito web e per migliorare la tua esperienza di navigazione.",
   Uve = "2. Come Utilizziamo le Informazioni Raccolte",
   Pve = "Le informazioni che fornisci vengono utilizzate per i seguenti scopi:",
   Lve = "Elaborazione Ordini: Per elaborare i tuoi acquisti di caff e consegnare i prodotti al tuo indirizzo.",
   Bve = "Tracciamento Donazioni: Per calcolare e allocare i tuoi contributi di cashback progressivo a La Fontana Della Fortuna.",
   zve = "In MYSTERIUM, rispettiamo la tua privacy. Non venderemo, affitteremo o condivideremo mai le tue informazioni personali con terze parti per scopi di marketing. I tuoi dati sono utilizzati esclusivamente per l'elaborazione degli ordini e i report sull'impatto benefico.",
   Ive = "3. Archiviazione e Conservazione dei Dati",
   Fve = "Le tue informazioni sono archiviate in modo sicuro utilizzando crittografia standard del settore. I dettagli degli ordini e i registri delle donazioni sono mantenuti per scopi fiscali e di trasparenza in conformit con le leggi applicabili.",
   Hve = "Conserviamo la cronologia dei tuoi acquisti per fornirti calcoli di cashback accurati e report sull'impatto benefico. Puoi richiedere la cancellazione dei tuoi dati in qualsiasi momento, soggetto ai requisiti legali di conservazione per le transazioni finanziarie.",
   Vve = "4. I Tuoi Diritti",
   Gve = "In conformit con le leggi internazionali sulla privacy (GDPR, CCPA), hai i seguenti diritti:",
   kve = "Accesso: Il diritto di sapere quali informazioni deteniamo su di te.",
   jve = "Rettifica: Il diritto di correggere qualsiasi informazione inesatta.",
   qve = "Cancellazione: Il diritto di richiedere la cancellazione dei tuoi dati personali.",
   Xve = "Per esercitare uno qualsiasi di questi diritti, ti preghiamo di contattarci a privacy@mysterium.coffee. Risponderemo alla tua richiesta entro 30 giorni.",
   Wve = "5. Sicurezza dei Dati",
   Yve = "Implementiamo misure di sicurezza robuste tra cui crittografia SSL, elaborazione sicura dei pagamenti e audit di sicurezza regolari. Sebbene prendiamo tutte le precauzioni per proteggere i tuoi dati, nessuna trasmissione internet  sicura al 100%. Raccomandiamo l'uso di password forti e di mantenere riservate le credenziali del tuo account.",
   Kve = "6. Servizi di Terze Parti",
   Zve = "Lavoriamo con partner affidabili per l'elaborazione dei pagamenti e la spedizione. Questi partner sono contrattualmente obbligati a proteggere i tuoi dati e a utilizzarli solo per fornire i loro servizi. Non condividiamo le tue informazioni con terze parti per i loro scopi di marketing.",
   Qve = "7. Modifiche alla Nostra Informativa sulla Privacy",
   Jve = 'Potremmo aggiornare questa Informativa sulla Privacy per riflettere cambiamenti nelle nostre pratiche o requisiti legali. Ti informeremo di modifiche significative via email e aggiorneremo la data "Ultimo aggiornamento". Ti preghiamo di rivedere periodicamente questa informativa.',
   $ve = "8. Contatto",
   eye = "Se hai domande su questa Informativa sulla Privacy, sui tuoi dati o sul nostro programma di donazioni benefiche, ti preghiamo di contattarci:",
   tye = "Email: privacy@mysterium.coffee",
   nye = "PROSSIMA COLLEZIONE",
   iye = "TUTTE LE COLLEZIONI",
   sye = "Dettagli Collezione",
   rye = "COLLEZIONI IN EVIDENZA",
   aye = {
      seo: Kue,
      aboutUs: Zue,
      videoBtn: fxit,
      services: Que,
      contact: Jue,
      menu: $ue,
      soundOn: eve,
      soundOff: tve,
      main: nve,
      mainTitle: ive,
      step1: sve,
      aboutTitle: rve,
      founded: ave,
      aboutText: ove,
      aboutClient: lve,
      step2: uve,
      servicesTitle1: cve,
      servicesText1: fve,
      servicesTitle2: hve,
      servicesText2: dve,
      servicesTitle3: pve,
      servicesText3: mve,
      footerText: gve,
      contactTitle: vve,
      contactText1: yve,
      contactText2: xve,
      submit: _ve,
      backTop: Sve,
      privacyPolicy: bve,
      rightsReserved: Tve,
      lastUpdated: Eve,
      introParagraph: Mve,
      section1Title: Ave,
      section1Paragraph1: wve,
      section1Bullet1: Rve,
      section1Bullet2: Cve,
      section1Bullet3: Dve,
      section1Bullet4: Nve,
      section1Paragraph2: Ove,
      section2Title: Uve,
      section2Paragraph1: Pve,
      section2Bullet1: Lve,
      section2Bullet2: Bve,
      section2Paragraph2: zve,
      section3Title: Ive,
      section3Paragraph1: Fve,
      section3Paragraph2: Hve,
      section4Title: Vve,
      section4Paragraph1: Gve,
      section4Bullet1: kve,
      section4Bullet2: jve,
      section4Bullet3: qve,
      section4Paragraph2: Xve,
      section5Title: Wve,
      section5Paragraph1: Yve,
      section6Title: Kve,
      section6Paragraph1: Zve,
      section7Title: Qve,
      section7Paragraph1: Jve,
      section8Title: $ve,
      section8Paragraph1: eye,
      section8Email: tye,
      nextProject: nye,
      portfolio: iye,
      projectDetails: sye,
      selectedWork: rye
   };
Fr.use(_W).init({
   resources: {
      en: {
         translation: Tre
      },
      ro: {
         translation: wene
      },
      es: {
         translation: Lae
      },
      fr: {
         translation: Woe
      },
      de: {
         translation: rue
      },
      it: {
         translation: aye
      }
   },
   lng: "ro",
   fallbackLng: "ro",
   interpolation: {
      escapeValue: !1
   }
});

function aue() {
   const [n, e] = j.useState(!1), t = {
      shouldPlay: n,
      setShouldPlay: e
   };
   return H.jsxs(H.Fragment, {
      children: [H.jsx(Xie, {}), H.jsx(jie, {
         ...t
      }), H.jsx(Vie, {
         ...t
      }), H.jsxs(L5, {
         children: [H.jsx(jo, {
            path: "/",
            element: H.jsx(M0, {
               children: H.jsx(xU, {
                  ...t
               })
            })
         }), H.jsx(jo, {
            path: "/:lang",
            element: H.jsx(M0, {
               children: H.jsx(xU, {
                  ...t
               })
            })
         }), H.jsx(jo, {
            path: "/portfolio",
            element: H.jsx(QU, {
               ...t
            })
         }), H.jsx(jo, {
            path: "/:lang/portfolio",
            element: H.jsx(M0, {
               children: H.jsx(QU, {
                  ...t
               })
            })
         }), H.jsx(jo, {
            path: "/portfolio/:id",
            element: H.jsx($U, {
               ...t,
               lang: "ro"
            })
         }), H.jsx(jo, {
            path: "/:lang/portfolio/:id",
            element: H.jsx(M0, {
               children: H.jsx($U, {
                  ...t
               })
            })
         }), H.jsx(jo, {
            path: "/privacy",
            element: H.jsx(JU, {
               ...t
            })
         }), H.jsx(jo, {
            path: "/:lang/privacy",
            element: H.jsx(M0, {
               children: H.jsx(JU, {
                  ...t
               })
            })
         }), H.jsx(jo, {
            path: "/login",
            element: H.jsx(Fie, {})
         }), H.jsx(jo, {
            path: "/admin/projects",
            element: H.jsx(Hie, {})
         }), H.jsx(jo, {
            path: "*",
            element: H.jsx(zA, {
               to: "/",
               replace: !0
            })
         })]
      })]
   })
}
jH.createRoot(document.getElementById("root")).render(H.jsx($o.StrictMode, {
   children: H.jsx(_V, {
      children: H.jsx(rV, {
         children: H.jsx(aue, {})
      })
   })
}));